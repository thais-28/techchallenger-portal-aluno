"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/methods/index.js
var require_methods = __commonJS({
  "node_modules/methods/index.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    module2.exports = getCurrentNodeMethods() || getBasicNodeMethods();
    function getCurrentNodeMethods() {
      return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
        return method.toLowerCase();
      });
    }
    function getBasicNodeMethods() {
      return [
        "get",
        "post",
        "put",
        "head",
        "delete",
        "options",
        "trace",
        "copy",
        "lock",
        "mkcol",
        "move",
        "purge",
        "propfind",
        "proppatch",
        "unlock",
        "report",
        "mkactivity",
        "checkout",
        "merge",
        "m-search",
        "notify",
        "subscribe",
        "unsubscribe",
        "patch",
        "search",
        "connect"
      ];
    }
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS({
  "node_modules/object-inspect/util.inspect.js"(exports2, module2) {
    "use strict";
    module2.exports = require("util").inspect;
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports2, module2) {
    "use strict";
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util_inspect();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    var quotes = {
      __proto__: null,
      "double": '"',
      single: "'"
    };
    var quoteREs = {
      __proto__: null,
      "double": /(["\\])/g,
      single: /(['\\])/g
    };
    module2.exports = function inspect_(obj, options2, depth, seen) {
      var opts = options2 || {};
      if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var style = opts.quoteStyle || defaultStyle;
      var quoteChar = quotes[style];
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function canTrustToString(obj) {
      return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && canTrustToString(obj);
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && canTrustToString(obj);
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && canTrustToString(obj);
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && canTrustToString(obj);
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && canTrustToString(obj);
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var quoteRE = quoteREs[opts.quoteStyle || "single"];
      quoteRE.lastIndex = 0;
      var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel-list/index.js
var require_side_channel_list = __commonJS({
  "node_modules/side-channel-list/index.js"(exports2, module2) {
    "use strict";
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var listGetNode = function(list, key, isDelete) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) != null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          if (!isDelete) {
            curr.next = /** @type {NonNullable<typeof list.next>} */
            list.next;
            list.next = curr;
          }
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      if (!objects) {
        return void 0;
      }
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      if (!objects) {
        return false;
      }
      return !!listGetNode(objects, key);
    };
    var listDelete = function(objects, key) {
      if (objects) {
        return listGetNode(objects, key, true);
      }
    };
    module2.exports = function getSideChannelList() {
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          var root = $o && $o.next;
          var deletedNode = listDelete($o, key);
          if (deletedNode && root && root === deletedNode) {
            $o = void 0;
          }
          return !!deletedNode;
        },
        get: function(key) {
          return listGet($o, key);
        },
        has: function(key) {
          return listHas($o, key);
        },
        set: function(key, value) {
          if (!$o) {
            $o = {
              next: void 0
            };
          }
          listSet(
            /** @type {NonNullable<typeof $o>} */
            $o,
            key,
            value
          );
        }
      };
      return channel;
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor2 = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor2,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "node_modules/call-bound/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// node_modules/side-channel-map/index.js
var require_side_channel_map = __commonJS({
  "node_modules/side-channel-map/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $Map = GetIntrinsic("%Map%", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var $mapDelete = callBound("Map.prototype.delete", true);
    var $mapSize = callBound("Map.prototype.size", true);
    module2.exports = !!$Map && /** @type {Exclude<import('.'), false>} */
    function getSideChannelMap() {
      var $m;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          if ($m) {
            var result = $mapDelete($m, key);
            if ($mapSize($m) === 0) {
              $m = void 0;
            }
            return result;
          }
          return false;
        },
        get: function(key) {
          if ($m) {
            return $mapGet($m, key);
          }
        },
        has: function(key) {
          if ($m) {
            return $mapHas($m, key);
          }
          return false;
        },
        set: function(key, value) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        }
      };
      return channel;
    };
  }
});

// node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = __commonJS({
  "node_modules/side-channel-weakmap/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var getSideChannelMap = require_side_channel_map();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
    module2.exports = $WeakMap ? (
      /** @type {Exclude<import('.'), false>} */
      function getSideChannelWeakMap() {
        var $wm;
        var $m;
        var channel = {
          assert: function(key) {
            if (!channel.has(key)) {
              throw new $TypeError("Side channel does not contain " + inspect(key));
            }
          },
          "delete": function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapDelete($wm, key);
              }
            } else if (getSideChannelMap) {
              if ($m) {
                return $m["delete"](key);
              }
            }
            return false;
          },
          get: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key);
              }
            }
            return $m && $m.get(key);
          },
          has: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key);
              }
            }
            return !!$m && $m.has(key);
          },
          set: function(key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key, value);
            } else if (getSideChannelMap) {
              if (!$m) {
                $m = getSideChannelMap();
              }
              $m.set(key, value);
            }
          }
        };
        return channel;
      }
    ) : getSideChannelMap;
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var getSideChannelList = require_side_channel_list();
    var getSideChannelMap = require_side_channel_map();
    var getSideChannelWeakMap = require_side_channel_weakmap();
    var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
    module2.exports = function getSideChannel() {
      var $channelData;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          return !!$channelData && $channelData["delete"](key);
        },
        get: function(key) {
          return $channelData && $channelData.get(key);
        },
        has: function(key) {
          return !!$channelData && $channelData.has(key);
        },
        set: function(key, value) {
          if (!$channelData) {
            $channelData = makeChannel();
          }
          $channelData.set(key, value);
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options2) {
      var obj = options2 && options2.plainObjects ? { __proto__: null } : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options2) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object" && typeof source !== "function") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options2 && (options2.plainObjects || options2.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options2);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options2);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options2);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode2 = function(str, defaultDecoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var limit = 1024;
    var encode2 = function encode3(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c = segment.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hexTable[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode: decode2,
      encode: encode2,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      commaRoundTrip: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      filter: void 0,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options2 = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options2.filter === "function") {
        filter = options2.filter;
        obj = filter("", obj);
      } else if (isArray(options2.filter)) {
        filter = options2.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options2.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options2.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options2.sort) {
        objKeys.sort(options2.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = obj[key];
        if (options2.skipNulls && value === null) {
          continue;
        }
        pushToArray(keys, stringify(
          value,
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options2.allowEmptyArrays,
          options2.strictNullHandling,
          options2.skipNulls,
          options2.encodeDotInKeys,
          options2.encode ? options2.encoder : null,
          options2.filter,
          options2.sort,
          options2.allowDots,
          options2.serializeDate,
          options2.format,
          options2.formatter,
          options2.encodeValuesOnly,
          options2.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options2.delimiter);
      var prefix = options2.addQueryPrefix === true ? "?" : "";
      if (options2.charsetSentinel) {
        if (options2.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false,
      throwOnLimitExceeded: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options2, currentArrayLength) {
      if (val && typeof val === "string" && options2.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      if (options2.throwOnLimitExceeded && currentArrayLength >= options2.arrayLimit) {
        throw new RangeError("Array limit exceeded. Only " + options2.arrayLimit + " element" + (options2.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options2) {
      var obj = { __proto__: null };
      var cleanStr = options2.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options2.parameterLimit === Infinity ? void 0 : options2.parameterLimit;
      var parts = cleanStr.split(
        options2.delimiter,
        options2.throwOnLimitExceeded ? limit + 1 : limit
      );
      if (options2.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
      }
      var skipIndex = -1;
      var i;
      var charset = options2.charset;
      if (options2.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key;
        var val;
        if (pos === -1) {
          key = options2.decoder(part, defaults.decoder, charset, "key");
          val = options2.strictNullHandling ? null : "";
        } else {
          key = options2.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(
              part.slice(pos + 1),
              options2,
              isArray(obj[key]) ? obj[key].length : 0
            ),
            function(encodedVal) {
              return options2.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options2.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(String(val));
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options2.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options2.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options2, valuesParsed) {
      var currentArrayLength = 0;
      if (chain.length > 0 && chain[chain.length - 1] === "[]") {
        var parentKey = chain.slice(0, -1).join("");
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
      }
      var leaf = valuesParsed ? val : parseArrayValue(val, options2, currentArrayLength);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options2.parseArrays) {
          obj = options2.allowEmptyArrays && (leaf === "" || options2.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf);
        } else {
          obj = options2.plainObjects ? { __proto__: null } : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var decodedRoot = options2.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          if (!options2.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options2.parseArrays && index <= options2.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options2, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options2.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options2.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options2.plainObjects && has.call(Object.prototype, parent)) {
          if (!options2.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options2.depth > 0 && (segment = child.exec(key)) !== null && i < options2.depth) {
        i += 1;
        if (!options2.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options2.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        if (options2.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options2.depth + " and strictDepth is true");
        }
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options2, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
        throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
      };
    };
    module2.exports = function(str, opts) {
      var options2 = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options2.plainObjects ? { __proto__: null } : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options2) : str;
      var obj = options2.plainObjects ? { __proto__: null } : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options2, typeof str === "string");
        obj = utils.merge(obj, newObj, options2);
      }
      if (options2.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var parse = require_parse();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "node_modules/mime/Mime.js"(exports2, module2) {
    "use strict";
    function Mime() {
      this._types = /* @__PURE__ */ Object.create(null);
      this._extensions = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < arguments.length; i++) {
        this.define(arguments[i]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t) {
          return t.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i = 0; i < extensions.length; i++) {
          const ext = extensions[i];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error(
              'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
            );
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime.prototype.getType = function(path) {
      path = String(path);
      let last = path.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last.replace(/^.*\./, "").toLowerCase();
      let hasPath = last.length < path.length;
      let hasDot = ext.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module2.exports = Mime;
  }
});

// node_modules/mime/types/standard.js
var require_standard = __commonJS({
  "node_modules/mime/types/standard.js"(exports2, module2) {
    "use strict";
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// node_modules/mime/types/other.js
var require_other = __commonJS({
  "node_modules/mime/types/other.js"(exports2, module2) {
    "use strict";
    module2.exports = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// node_modules/mime/index.js
var require_mime = __commonJS({
  "node_modules/mime/index.js"(exports2, module2) {
    "use strict";
    var Mime = require_Mime();
    module2.exports = new Mime(require_standard(), require_other());
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options2) {
      var delayedStream = new this();
      options2 = options2 || {};
      for (var option in options2) {
        delayedStream[option] = options2[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options2) {
      var combinedStream = new this();
      options2 = options2 || {};
      for (var option in options2) {
        combinedStream[option] = options2[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options2) {
      Stream.prototype.pipe.call(this, dest, options2);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self = this;
      stream.on("error", function(err) {
        self._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/form-data/node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/form-data/node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/form-data/node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/form-data/node_modules/mime-db/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_db();
  }
});

// node_modules/form-data/node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/form-data/node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports2, module2) {
    "use strict";
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports2, module2) {
    "use strict";
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports2, module2) {
    "use strict";
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    "use strict";
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error2, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error2) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error2, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports2, module2) {
    "use strict";
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    "use strict";
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports2, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error2, result) {
          if (error2) {
            callback(error2, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error2, result) {
        if (error2) {
          callback(error2, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports2, module2) {
    "use strict";
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "node_modules/es-set-tostringtag/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
    module2.exports = function setToStringTag(object, value) {
      var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
      var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
      if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
        throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
      }
      if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
        if ($defineProperty) {
          $defineProperty(object, toStringTag, {
            configurable: !nonConfigurable,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object[toStringTag] = value;
        }
      }
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports2, module2) {
    "use strict";
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports2, module2) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var Stream = require("stream").Stream;
    var crypto = require("crypto");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var setToStringTag = require_es_set_tostringtag();
    var hasOwn = require_hasown();
    var populate = require_populate();
    function FormData(options2) {
      if (!(this instanceof FormData)) {
        return new FormData(options2);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options2 = options2 || {};
      for (var option in options2) {
        this[option] = options2[option];
      }
    }
    util.inherits(FormData, CombinedStream);
    FormData.LINE_BREAK = "\r\n";
    FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData.prototype.append = function(field, value, options2) {
      options2 = options2 || {};
      if (typeof options2 === "string") {
        options2 = { filename: options2 };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value === "number" || value == null) {
        value = String(value);
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options2);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options2);
    };
    FormData.prototype._trackLength = function(header, value, options2) {
      var valueLength = 0;
      if (options2.knownLength != null) {
        valueLength += Number(options2.knownLength);
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options2.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData.prototype._lengthRetriever = function(value, callback) {
      if (hasOwn(value, "fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            if (err) {
              callback(err);
              return;
            }
            var fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (hasOwn(value, "httpVersion")) {
        callback(null, Number(value.headers["content-length"]));
      } else if (hasOwn(value, "httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, Number(response.headers["content-length"]));
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData.prototype._multiPartHeader = function(field, value, options2) {
      if (typeof options2.header === "string") {
        return options2.header;
      }
      var contentDisposition = this._getContentDisposition(value, options2);
      var contentType = this._getContentType(value, options2);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options2.header === "object") {
        populate(headers, options2.header);
      }
      var header;
      for (var prop in headers) {
        if (hasOwn(headers, prop)) {
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData.LINE_BREAK;
          }
        }
      }
      return "--" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
    };
    FormData.prototype._getContentDisposition = function(value, options2) {
      var filename;
      if (typeof options2.filepath === "string") {
        filename = path.normalize(options2.filepath).replace(/\\/g, "/");
      } else if (options2.filename || value && (value.name || value.path)) {
        filename = path.basename(options2.filename || value && (value.name || value.path));
      } else if (value && value.readable && hasOwn(value, "httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        return 'filename="' + filename + '"';
      }
    };
    FormData.prototype._getContentType = function(value, options2) {
      var contentType = options2.contentType;
      if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options2.filepath || options2.filename)) {
        contentType = mime.lookup(options2.filepath || options2.filename);
      }
      if (!contentType && value && typeof value === "object") {
        contentType = FormData.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
    };
    FormData.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (hasOwn(userHeaders, header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData.prototype.setBoundary = function(boundary) {
      if (typeof boundary !== "string") {
        throw new TypeError("FormData boundary must be a string");
      }
      this._boundary = boundary;
    };
    FormData.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData.prototype._generateBoundary = function() {
      this._boundary = "--------------------------" + crypto.randomBytes(12).toString("hex");
    };
    FormData.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData.prototype.submit = function(params, cb) {
      var request2;
      var options2;
      var defaults = { method: "post" };
      if (typeof params === "string") {
        params = parseUrl(params);
        options2 = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options2 = populate(params, defaults);
        if (!options2.port) {
          options2.port = options2.protocol === "https:" ? 443 : 80;
        }
      }
      options2.headers = this.getHeaders(params.headers);
      if (options2.protocol === "https:") {
        request2 = https.request(options2);
      } else {
        request2 = http.request(options2);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request2.setHeader("Content-Length", length);
        }
        this.pipe(request2);
        if (cb) {
          var onResponse;
          var callback = function(error2, responce) {
            request2.removeListener("error", callback);
            request2.removeListener("response", onResponse);
            return cb.call(this, error2, responce);
          };
          onResponse = callback.bind(this, null);
          request2.on("error", callback);
          request2.on("response", onResponse);
        }
      }.bind(this));
      return request2;
    };
    FormData.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData.prototype.toString = function() {
      return "[object FormData]";
    };
    setToStringTag(FormData, "FormData");
    module2.exports = FormData;
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toBig = exports2.shrSL = exports2.shrSH = exports2.rotrSL = exports2.rotrSH = exports2.rotrBL = exports2.rotrBH = exports2.rotr32L = exports2.rotr32H = exports2.rotlSL = exports2.rotlSH = exports2.rotlBL = exports2.rotlBH = exports2.add5L = exports2.add5H = exports2.add4L = exports2.add4H = exports2.add3L = exports2.add3H = void 0;
    exports2.add = add;
    exports2.fromBig = fromBig;
    exports2.split = split;
    var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    var _32n = /* @__PURE__ */ BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    function split(lst, le = false) {
      const len = lst.length;
      let Ah = new Uint32Array(len);
      let Al = new Uint32Array(len);
      for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports2.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports2.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports2.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports2.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports2.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports2.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports2.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports2.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports2.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports2.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports2.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports2.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports2.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports2.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports2.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports2.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports2.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports2.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports2.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports2.default = u64;
  }
});

// node_modules/@noble/hashes/cryptoNode.js
var require_cryptoNode = __commonJS({
  "node_modules/@noble/hashes/cryptoNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.crypto = void 0;
    var nc = require("crypto");
    exports2.crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : nc && typeof nc === "object" && "randomBytes" in nc ? nc : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils2 = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.Hash = exports2.nextTick = exports2.swap32IfBE = exports2.byteSwapIfBE = exports2.swap8IfBE = exports2.isLE = void 0;
    exports2.isBytes = isBytes;
    exports2.anumber = anumber;
    exports2.abytes = abytes;
    exports2.ahash = ahash;
    exports2.aexists = aexists;
    exports2.aoutput = aoutput;
    exports2.u8 = u8;
    exports2.u32 = u32;
    exports2.clean = clean;
    exports2.createView = createView;
    exports2.rotr = rotr;
    exports2.rotl = rotl;
    exports2.byteSwap = byteSwap;
    exports2.byteSwap32 = byteSwap32;
    exports2.bytesToHex = bytesToHex;
    exports2.hexToBytes = hexToBytes;
    exports2.asyncLoop = asyncLoop;
    exports2.utf8ToBytes = utf8ToBytes;
    exports2.bytesToUtf8 = bytesToUtf8;
    exports2.toBytes = toBytes;
    exports2.kdfInputToBytes = kdfInputToBytes;
    exports2.concatBytes = concatBytes;
    exports2.checkOpts = checkOpts;
    exports2.createHasher = createHasher;
    exports2.createOptHasher = createOptHasher;
    exports2.createXOFer = createXOFer;
    exports2.randomBytes = randomBytes;
    var crypto_1 = require_cryptoNode();
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports2.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports2.swap8IfBE = exports2.isLE ? (n) => n : (n) => byteSwap(n);
    exports2.byteSwapIfBE = exports2.swap8IfBE;
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
      return arr;
    }
    exports2.swap32IfBE = exports2.isLE ? (u) => u : byteSwap32;
    var hasHexBuiltin = /* @__PURE__ */ (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      if (hasHexBuiltin)
        return bytes.toHex();
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    var nextTick = async () => {
    };
    exports2.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports2.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function kdfInputToBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      abytes(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    var Hash = class {
    };
    exports2.Hash = Hash;
    function createHasher(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function createXOFer(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports2.wrapConstructor = createHasher;
    exports2.wrapConstructorWithOpts = createOptHasher;
    exports2.wrapXOFConstructorWithOpts = createXOFer;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/@noble/hashes/sha3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shake256 = exports2.shake128 = exports2.keccak_512 = exports2.keccak_384 = exports2.keccak_256 = exports2.keccak_224 = exports2.sha3_512 = exports2.sha3_384 = exports2.sha3_256 = exports2.sha3_224 = exports2.Keccak = void 0;
    exports2.keccakP = keccakP;
    var _u64_ts_1 = require_u64();
    var utils_ts_1 = require_utils2();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    var SHA3_PI = [];
    var SHA3_ROTL = [];
    var _SHA3_IOTA = [];
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
    var SHA3_IOTA_H = IOTAS[0];
    var SHA3_IOTA_L = IOTAS[1];
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      (0, utils_ts_1.clean)(B);
    }
    var Keccak = class _Keccak extends utils_ts_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        (0, utils_ts_1.anumber)(outputLen);
        if (!(0 < blockLen && blockLen < 200))
          throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
      }
      clone() {
        return this._cloneInto();
      }
      keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, state } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports2.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));
    exports2.sha3_224 = (() => gen(6, 144, 224 / 8))();
    exports2.sha3_256 = (() => gen(6, 136, 256 / 8))();
    exports2.sha3_384 = (() => gen(6, 104, 384 / 8))();
    exports2.sha3_512 = (() => gen(6, 72, 512 / 8))();
    exports2.keccak_224 = (() => gen(1, 144, 224 / 8))();
    exports2.keccak_256 = (() => gen(1, 136, 256 / 8))();
    exports2.keccak_384 = (() => gen(1, 104, 384 / 8))();
    exports2.keccak_512 = (() => gen(1, 72, 512 / 8))();
    var genShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports2.shake128 = (() => genShake(31, 168, 128 / 8))();
    exports2.shake256 = (() => genShake(31, 136, 256 / 8))();
  }
});

// node_modules/@paralleldrive/cuid2/src/index.js
var require_src = __commonJS({
  "node_modules/@paralleldrive/cuid2/src/index.js"(exports2, module2) {
    "use strict";
    var { sha3_512: sha3 } = require_sha3();
    var defaultLength = 24;
    var bigLength = 32;
    var createEntropy = (length = 4, random = Math.random) => {
      let entropy = "";
      while (entropy.length < length) {
        entropy = entropy + Math.floor(random() * 36).toString(36);
      }
      return entropy;
    };
    function bufToBigInt(buf) {
      let bits = 8n;
      let value = 0n;
      for (const i of buf.values()) {
        const bi = BigInt(i);
        value = (value << bits) + bi;
      }
      return value;
    }
    var hash = (input = "") => {
      return bufToBigInt(sha3(input)).toString(36).slice(1);
    };
    var alphabet = Array.from(
      { length: 26 },
      (x, i) => String.fromCharCode(i + 97)
    );
    var randomLetter = (random) => alphabet[Math.floor(random() * alphabet.length)];
    var createFingerprint = ({
      globalObj = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {},
      random = Math.random
    } = {}) => {
      const globals = Object.keys(globalObj).toString();
      const sourceString = globals.length ? globals + createEntropy(bigLength, random) : createEntropy(bigLength, random);
      return hash(sourceString).substring(0, bigLength);
    };
    var createCounter = (count) => () => {
      return count++;
    };
    var initialCountMax = 476782367;
    var init = ({
      // Fallback if the user does not pass in a CSPRNG. This should be OK
      // because we don't rely solely on the random number generator for entropy.
      // We also use the host fingerprint, current time, and a session counter.
      random = Math.random,
      counter = createCounter(Math.floor(random() * initialCountMax)),
      length = defaultLength,
      fingerprint = createFingerprint({ random })
    } = {}) => {
      return function cuid2() {
        const firstLetter = randomLetter(random);
        const time = Date.now().toString(36);
        const count = counter().toString(36);
        const salt = createEntropy(length, random);
        const hashInput = `${time + salt + count + fingerprint}`;
        return `${firstLetter + hash(hashInput).substring(1, length)}`;
      };
    };
    var createId = init();
    var isCuid = (id, { minLength = 2, maxLength = bigLength } = {}) => {
      const length = id.length;
      const regex = /^[0-9a-z]+$/;
      try {
        if (typeof id === "string" && length >= minLength && length <= maxLength && regex.test(id))
          return true;
      } finally {
      }
      return false;
    };
    module2.exports.getConstants = () => ({ defaultLength, bigLength });
    module2.exports.init = init;
    module2.exports.createId = createId;
    module2.exports.bufToBigInt = bufToBigInt;
    module2.exports.createCounter = createCounter;
    module2.exports.createFingerprint = createFingerprint;
    module2.exports.isCuid = isCuid;
  }
});

// node_modules/@paralleldrive/cuid2/index.js
var require_cuid2 = __commonJS({
  "node_modules/@paralleldrive/cuid2/index.js"(exports2, module2) {
    "use strict";
    var { createId, init, getConstants, isCuid } = require_src();
    module2.exports.createId = createId;
    module2.exports.init = init;
    module2.exports.getConstants = getConstants;
    module2.exports.isCuid = isCuid;
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    "use strict";
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb) return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/asap/raw.js
var require_raw = __commonJS({
  "node_modules/asap/raw.js"(exports2, module2) {
    "use strict";
    var domain;
    var hasSetImmediate = typeof setImmediate === "function";
    module2.exports = rawAsap;
    function rawAsap(task) {
      if (!queue.length) {
        requestFlush();
        flushing = true;
      }
      queue[queue.length] = task;
    }
    var queue = [];
    var flushing = false;
    var index = 0;
    var capacity = 1024;
    function flush() {
      while (index < queue.length) {
        var currentIndex = index;
        index = index + 1;
        queue[currentIndex].call();
        if (index > capacity) {
          for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
            queue[scan] = queue[scan + index];
          }
          queue.length -= index;
          index = 0;
        }
      }
      queue.length = 0;
      index = 0;
      flushing = false;
    }
    rawAsap.requestFlush = requestFlush;
    function requestFlush() {
      var parentDomain = process.domain;
      if (parentDomain) {
        if (!domain) {
          domain = require("domain");
        }
        domain.active = process.domain = null;
      }
      if (flushing && hasSetImmediate) {
        setImmediate(flush);
      } else {
        process.nextTick(flush);
      }
      if (parentDomain) {
        domain.active = process.domain = parentDomain;
      }
    }
  }
});

// node_modules/asap/asap.js
var require_asap = __commonJS({
  "node_modules/asap/asap.js"(exports2, module2) {
    "use strict";
    var rawAsap = require_raw();
    var freeTasks = [];
    module2.exports = asap;
    function asap(task) {
      var rawTask;
      if (freeTasks.length) {
        rawTask = freeTasks.pop();
      } else {
        rawTask = new RawTask();
      }
      rawTask.task = task;
      rawTask.domain = process.domain;
      rawAsap(rawTask);
    }
    function RawTask() {
      this.task = null;
      this.domain = null;
    }
    RawTask.prototype.call = function() {
      if (this.domain) {
        this.domain.enter();
      }
      var threw = true;
      try {
        this.task.call();
        threw = false;
        if (this.domain) {
          this.domain.exit();
        }
      } finally {
        if (threw) {
          rawAsap.requestFlush();
        }
        this.task = null;
        this.domain = null;
        freeTasks.push(this);
      }
    };
  }
});

// node_modules/dezalgo/dezalgo.js
var require_dezalgo = __commonJS({
  "node_modules/dezalgo/dezalgo.js"(exports2, module2) {
    "use strict";
    var wrappy = require_wrappy();
    module2.exports = wrappy(dezalgo);
    var asap = require_asap();
    function dezalgo(cb) {
      var sync = true;
      asap(function() {
        sync = false;
      });
      return function zalgoSafe() {
        var args = arguments;
        var me = this;
        if (sync)
          asap(function() {
            cb.apply(me, args);
          });
        else
          cb.apply(me, args);
      };
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    "use strict";
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called) return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/formidable/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/formidable/dist/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs = require("fs");
    var crypto = require("crypto");
    var node_events = require("events");
    var cuid2 = require_cuid2();
    var dezalgo = require_dezalgo();
    var fsPromises = require("fs/promises");
    var os = require("os");
    var path = require("path");
    var node_string_decoder = require("string_decoder");
    var once = require_once();
    var node_stream = require("stream");
    var PersistentFile = class extends node_events.EventEmitter {
      constructor({ filepath, newFilename, originalFilename, mimetype, hashAlgorithm }) {
        super();
        this.lastModifiedDate = null;
        Object.assign(this, { filepath, newFilename, originalFilename, mimetype, hashAlgorithm });
        this.size = 0;
        this._writeStream = null;
        if (typeof this.hashAlgorithm === "string") {
          this.hash = crypto.createHash(this.hashAlgorithm);
        } else {
          this.hash = null;
        }
      }
      open() {
        this._writeStream = fs.createWriteStream(this.filepath);
        this._writeStream.on("error", (err) => {
          this.emit("error", err);
        });
      }
      toJSON() {
        const json2 = {
          size: this.size,
          filepath: this.filepath,
          newFilename: this.newFilename,
          mimetype: this.mimetype,
          mtime: this.lastModifiedDate,
          length: this.length,
          originalFilename: this.originalFilename
        };
        if (this.hash && this.hash !== "") {
          json2.hash = this.hash;
        }
        return json2;
      }
      toString() {
        return `PersistentFile: ${this.newFilename}, Original: ${this.originalFilename}, Path: ${this.filepath}`;
      }
      write(buffer, cb) {
        if (this.hash) {
          this.hash.update(buffer);
        }
        if (this._writeStream.closed) {
          cb();
          return;
        }
        this._writeStream.write(buffer, () => {
          this.lastModifiedDate = /* @__PURE__ */ new Date();
          this.size += buffer.length;
          this.emit("progress", this.size);
          cb();
        });
      }
      end(cb) {
        if (this.hash) {
          this.hash = this.hash.digest("hex");
        }
        this._writeStream.end(() => {
          this.emit("end");
          cb();
        });
      }
      destroy() {
        this._writeStream.destroy();
        const filepath = this.filepath;
        setTimeout(function() {
          fs.unlink(filepath, () => {
          });
        }, 1);
      }
    };
    var VolatileFile = class extends node_events.EventEmitter {
      constructor({ filepath, newFilename, originalFilename, mimetype, hashAlgorithm, createFileWriteStream }) {
        super();
        this.lastModifiedDate = null;
        Object.assign(this, { filepath, newFilename, originalFilename, mimetype, hashAlgorithm, createFileWriteStream });
        this.size = 0;
        this._writeStream = null;
        if (typeof this.hashAlgorithm === "string") {
          this.hash = crypto.createHash(this.hashAlgorithm);
        } else {
          this.hash = null;
        }
      }
      open() {
        this._writeStream = this.createFileWriteStream(this);
        this._writeStream.on("error", (err) => {
          this.emit("error", err);
        });
      }
      destroy() {
        this._writeStream.destroy();
      }
      toJSON() {
        const json2 = {
          size: this.size,
          newFilename: this.newFilename,
          length: this.length,
          originalFilename: this.originalFilename,
          mimetype: this.mimetype
        };
        if (this.hash && this.hash !== "") {
          json2.hash = this.hash;
        }
        return json2;
      }
      toString() {
        return `VolatileFile: ${this.originalFilename}`;
      }
      write(buffer, cb) {
        if (this.hash) {
          this.hash.update(buffer);
        }
        if (this._writeStream.closed || this._writeStream.destroyed) {
          cb();
          return;
        }
        this._writeStream.write(buffer, () => {
          this.size += buffer.length;
          this.emit("progress", this.size);
          cb();
        });
      }
      end(cb) {
        if (this.hash) {
          this.hash = this.hash.digest("hex");
        }
        this._writeStream.end(() => {
          this.emit("end");
          cb();
        });
      }
    };
    var missingPlugin = 1e3;
    var pluginFunction = 1001;
    var aborted = 1002;
    var noParser = 1003;
    var uninitializedParser = 1004;
    var filenameNotString = 1005;
    var maxFieldsSizeExceeded = 1006;
    var maxFieldsExceeded = 1007;
    var smallerThanMinFileSize = 1008;
    var biggerThanTotalMaxFileSize = 1009;
    var noEmptyFiles = 1010;
    var missingContentType = 1011;
    var malformedMultipart = 1012;
    var missingMultipartBoundary = 1013;
    var unknownTransferEncoding = 1014;
    var maxFilesExceeded = 1015;
    var biggerThanMaxFileSize = 1016;
    var pluginFailed = 1017;
    var cannotCreateDir = 1018;
    var FormidableError = class extends Error {
      constructor(message, internalCode, httpCode = 500) {
        super(message);
        this.code = internalCode;
        this.httpCode = httpCode;
      }
    };
    var FormidableError$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      aborted,
      biggerThanMaxFileSize,
      biggerThanTotalMaxFileSize,
      cannotCreateDir,
      default: FormidableError,
      filenameNotString,
      malformedMultipart,
      maxFieldsExceeded,
      maxFieldsSizeExceeded,
      maxFilesExceeded,
      missingContentType,
      missingMultipartBoundary,
      missingPlugin,
      noEmptyFiles,
      noParser,
      pluginFailed,
      pluginFunction,
      smallerThanMinFileSize,
      uninitializedParser,
      unknownTransferEncoding
    });
    var DummyParser = class extends node_stream.Transform {
      constructor(incomingForm, options2 = {}) {
        super();
        this.globalOptions = { ...options2 };
        this.incomingForm = incomingForm;
      }
      _flush(callback) {
        this.incomingForm.ended = true;
        this.incomingForm._maybeEnd();
        callback();
      }
    };
    var s = 0;
    var STATE = {
      PARSER_UNINITIALIZED: s++,
      START: s++,
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      PART_END: s++,
      END: s++
    };
    var f = 1;
    var FBOUNDARY = { PART_BOUNDARY: f, LAST_BOUNDARY: f *= 2 };
    var LF = 10;
    var CR = 13;
    var SPACE = 32;
    var HYPHEN = 45;
    var COLON = 58;
    var A = 97;
    var Z = 122;
    function lower(c) {
      return c | 32;
    }
    var STATES = {};
    Object.keys(STATE).forEach((stateName) => {
      STATES[stateName] = STATE[stateName];
    });
    var MultipartParser = class _MultipartParser extends node_stream.Transform {
      constructor(options2 = {}) {
        super({ readableObjectMode: true });
        this.boundary = null;
        this.boundaryChars = null;
        this.lookbehind = null;
        this.bufferLength = 0;
        this.state = STATE.PARSER_UNINITIALIZED;
        this.globalOptions = { ...options2 };
        this.index = null;
        this.flags = 0;
      }
      _endUnexpected() {
        return new FormidableError(
          `MultipartParser.end(): stream ended unexpectedly: ${this.explain()}`,
          malformedMultipart,
          400
        );
      }
      _flush(done) {
        if (this.state === STATE.HEADER_FIELD_START && this.index === 0 || this.state === STATE.PART_DATA && this.index === this.boundary.length) {
          this._handleCallback("partEnd");
          this._handleCallback("end");
          done();
        } else if (this.state !== STATE.END) {
          done(this._endUnexpected());
        } else {
          done();
        }
      }
      initWithBoundary(str) {
        this.boundary = Buffer.from(`\r
--${str}`);
        this.lookbehind = Buffer.alloc(this.boundary.length + 8);
        this.state = STATE.START;
        this.boundaryChars = {};
        for (let i = 0; i < this.boundary.length; i++) {
          this.boundaryChars[this.boundary[i]] = true;
        }
      }
      // eslint-disable-next-line max-params
      _handleCallback(name, buf, start, end) {
        if (start !== void 0 && start === end) {
          return;
        }
        this.push({ name, buffer: buf, start, end });
      }
      // eslint-disable-next-line max-statements
      _transform(buffer, _, done) {
        let i = 0;
        let prevIndex = this.index;
        let { index, state, flags } = this;
        const { lookbehind, boundary, boundaryChars } = this;
        const boundaryLength = boundary.length;
        const boundaryEnd = boundaryLength - 1;
        this.bufferLength = buffer.length;
        let c = null;
        let cl = null;
        const setMark = (name, idx) => {
          this[`${name}Mark`] = typeof idx === "number" ? idx : i;
        };
        const clearMarkSymbol = (name) => {
          delete this[`${name}Mark`];
        };
        const dataCallback = (name, shouldClear) => {
          const markSymbol = `${name}Mark`;
          if (!(markSymbol in this)) {
            return;
          }
          if (!shouldClear) {
            this._handleCallback(name, buffer, this[markSymbol], buffer.length);
            setMark(name, 0);
          } else {
            this._handleCallback(name, buffer, this[markSymbol], i);
            clearMarkSymbol(name);
          }
        };
        for (i = 0; i < this.bufferLength; i++) {
          c = buffer[i];
          switch (state) {
            case STATE.PARSER_UNINITIALIZED:
              done(this._endUnexpected());
              return;
            case STATE.START:
              index = 0;
              state = STATE.START_BOUNDARY;
            case STATE.START_BOUNDARY:
              if (index === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= FBOUNDARY.LAST_BOUNDARY;
                } else if (c !== CR) {
                  done(this._endUnexpected());
                  return;
                }
                index++;
                break;
              } else if (index - 1 === boundary.length - 2) {
                if (flags & FBOUNDARY.LAST_BOUNDARY && c === HYPHEN) {
                  this._handleCallback("end");
                  state = STATE.END;
                  flags = 0;
                } else if (!(flags & FBOUNDARY.LAST_BOUNDARY) && c === LF) {
                  index = 0;
                  this._handleCallback("partBegin");
                  state = STATE.HEADER_FIELD_START;
                } else {
                  done(this._endUnexpected());
                  return;
                }
                break;
              }
              if (c !== boundary[index + 2]) {
                index = -2;
              }
              if (c === boundary[index + 2]) {
                index++;
              }
              break;
            case STATE.HEADER_FIELD_START:
              state = STATE.HEADER_FIELD;
              setMark("headerField");
              index = 0;
            case STATE.HEADER_FIELD:
              if (c === CR) {
                clearMarkSymbol("headerField");
                state = STATE.HEADERS_ALMOST_DONE;
                break;
              }
              index++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index === 1) {
                  done(this._endUnexpected());
                  return;
                }
                dataCallback("headerField", true);
                state = STATE.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                done(this._endUnexpected());
                return;
              }
              break;
            case STATE.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              setMark("headerValue");
              state = STATE.HEADER_VALUE;
            case STATE.HEADER_VALUE:
              if (c === CR) {
                dataCallback("headerValue", true);
                this._handleCallback("headerEnd");
                state = STATE.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case STATE.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                done(this._endUnexpected());
                return;
              }
              state = STATE.HEADER_FIELD_START;
              break;
            case STATE.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                done(this._endUnexpected());
                return;
              }
              this._handleCallback("headersEnd");
              state = STATE.PART_DATA_START;
              break;
            case STATE.PART_DATA_START:
              state = STATE.PART_DATA;
              setMark("partData");
            case STATE.PART_DATA:
              prevIndex = index;
              if (index === 0) {
                i += boundaryEnd;
                while (i < this.bufferLength && !(buffer[i] in boundaryChars)) {
                  i += boundaryLength;
                }
                i -= boundaryEnd;
                c = buffer[i];
              }
              if (index < boundary.length) {
                if (boundary[index] === c) {
                  if (index === 0) {
                    dataCallback("partData", true);
                  }
                  index++;
                } else {
                  index = 0;
                }
              } else if (index === boundary.length) {
                index++;
                if (c === CR) {
                  flags |= FBOUNDARY.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= FBOUNDARY.LAST_BOUNDARY;
                } else {
                  index = 0;
                }
              } else if (index - 1 === boundary.length) {
                if (flags & FBOUNDARY.PART_BOUNDARY) {
                  index = 0;
                  if (c === LF) {
                    flags &= ~FBOUNDARY.PART_BOUNDARY;
                    this._handleCallback("partEnd");
                    this._handleCallback("partBegin");
                    state = STATE.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & FBOUNDARY.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    this._handleCallback("partEnd");
                    this._handleCallback("end");
                    state = STATE.END;
                    flags = 0;
                  } else {
                    index = 0;
                  }
                } else {
                  index = 0;
                }
              }
              if (index > 0) {
                lookbehind[index - 1] = c;
              } else if (prevIndex > 0) {
                this._handleCallback("partData", lookbehind, 0, prevIndex);
                prevIndex = 0;
                setMark("partData");
                i--;
              }
              break;
            case STATE.END:
              break;
            default:
              done(this._endUnexpected());
              return;
          }
        }
        dataCallback("headerField");
        dataCallback("headerValue");
        dataCallback("partData");
        this.index = index;
        this.state = state;
        this.flags = flags;
        done();
        return this.bufferLength;
      }
      explain() {
        return `state = ${_MultipartParser.stateToString(this.state)}`;
      }
    };
    MultipartParser.stateToString = (stateNumber) => {
      for (const stateName in STATE) {
        const number = STATE[stateName];
        if (number === stateNumber) return stateName;
      }
    };
    var MultipartParser$1 = Object.assign(MultipartParser, { STATES });
    var OctetStreamParser = class extends node_stream.PassThrough {
      constructor(options2 = {}) {
        super();
        this.globalOptions = { ...options2 };
      }
    };
    var octetStreamType = "octet-stream";
    async function plugin$3(formidable2, options2) {
      const self = this || formidable2;
      if (/octet-stream/i.test(self.headers["content-type"])) {
        await init$2.call(self, self, options2);
      }
      return self;
    }
    async function init$2(_self, _opts) {
      this.type = octetStreamType;
      const originalFilename = this.headers["x-file-name"];
      const mimetype = this.headers["content-type"];
      const thisPart = {
        originalFilename,
        mimetype
      };
      const newFilename = this._getNewName(thisPart);
      const filepath = this._joinDirectoryName(newFilename);
      const file = await this._newFile({
        newFilename,
        filepath,
        originalFilename,
        mimetype
      });
      this.emit("fileBegin", originalFilename, file);
      file.open();
      this.openedFiles.push(file);
      this._flushing += 1;
      this._parser = new OctetStreamParser(this.options);
      let outstandingWrites = 0;
      this._parser.on("data", (buffer) => {
        this.pause();
        outstandingWrites += 1;
        file.write(buffer, () => {
          outstandingWrites -= 1;
          this.resume();
          if (this.ended) {
            this._parser.emit("doneWritingFile");
          }
        });
      });
      this._parser.on("end", () => {
        this._flushing -= 1;
        this.ended = true;
        const done = () => {
          file.end(() => {
            this.emit("file", "file", file);
            this._maybeEnd();
          });
        };
        if (outstandingWrites === 0) {
          done();
        } else {
          this._parser.once("doneWritingFile", done);
        }
      });
      return this;
    }
    var QuerystringParser = class extends node_stream.Transform {
      constructor(options2 = {}) {
        super({ readableObjectMode: true });
        this.globalOptions = { ...options2 };
        this.buffer = "";
        this.bufferLength = 0;
      }
      _transform(buffer, encoding, callback) {
        this.buffer += buffer.toString("ascii");
        this.bufferLength = this.buffer.length;
        callback();
      }
      _flush(callback) {
        const fields = new URLSearchParams(this.buffer);
        for (const [key, value] of fields) {
          this.push({
            key,
            value
          });
        }
        this.buffer = "";
        callback();
      }
    };
    var querystringType = "urlencoded";
    function plugin$2(formidable2, options2) {
      const self = this || formidable2;
      if (/urlencoded/i.test(self.headers["content-type"])) {
        init$1.call(self, self, options2);
      }
      return self;
    }
    function init$1(_self, _opts) {
      this.type = querystringType;
      const parser = new QuerystringParser(this.options);
      parser.on("data", ({ key, value }) => {
        this.emit("field", key, value);
      });
      parser.once("end", () => {
        this.ended = true;
        this._maybeEnd();
      });
      this._parser = parser;
      return this;
    }
    var multipartType = "multipart";
    function plugin$1(formidable2, options2) {
      const self = this || formidable2;
      const multipart = /multipart/i.test(self.headers["content-type"]);
      if (multipart) {
        const m = self.headers["content-type"].match(
          /boundary=(?:"([^"]+)"|([^;]+))/i
        );
        if (m) {
          const initMultipart = createInitMultipart(m[1] || m[2]);
          initMultipart.call(self, self, options2);
        } else {
          const err = new FormidableError(
            "bad content-type header, no multipart boundary",
            missingMultipartBoundary,
            400
          );
          self._error(err);
        }
      }
      return self;
    }
    function createInitMultipart(boundary) {
      return function initMultipart() {
        this.type = multipartType;
        const parser = new MultipartParser$1(this.options);
        let headerField;
        let headerValue;
        let part;
        parser.initWithBoundary(boundary);
        parser.on("data", async ({ name, buffer, start, end }) => {
          if (name === "partBegin") {
            part = new node_stream.Stream();
            part.readable = true;
            part.headers = {};
            part.name = null;
            part.originalFilename = null;
            part.mimetype = null;
            part.transferEncoding = this.options.encoding;
            part.transferBuffer = "";
            headerField = "";
            headerValue = "";
          } else if (name === "headerField") {
            headerField += buffer.toString(this.options.encoding, start, end);
          } else if (name === "headerValue") {
            headerValue += buffer.toString(this.options.encoding, start, end);
          } else if (name === "headerEnd") {
            headerField = headerField.toLowerCase();
            part.headers[headerField] = headerValue;
            const m = headerValue.match(
              // eslint-disable-next-line no-useless-escape
              /\bname=("([^"]*)"|([^\(\)<>@,;:\\"\/\[\]\?=\{\}\s\t/]+))/i
            );
            if (headerField === "content-disposition") {
              if (m) {
                part.name = m[2] || m[3] || "";
              }
              part.originalFilename = this._getFileName(headerValue);
            } else if (headerField === "content-type") {
              part.mimetype = headerValue;
            } else if (headerField === "content-transfer-encoding") {
              part.transferEncoding = headerValue.toLowerCase();
            }
            headerField = "";
            headerValue = "";
          } else if (name === "headersEnd") {
            switch (part.transferEncoding) {
              case "binary":
              case "7bit":
              case "8bit":
              case "utf-8": {
                const dataPropagation = (ctx) => {
                  if (ctx.name === "partData") {
                    part.emit("data", ctx.buffer.slice(ctx.start, ctx.end));
                  }
                };
                const dataStopPropagation = (ctx) => {
                  if (ctx.name === "partEnd") {
                    part.emit("end");
                    parser.off("data", dataPropagation);
                    parser.off("data", dataStopPropagation);
                  }
                };
                parser.on("data", dataPropagation);
                parser.on("data", dataStopPropagation);
                break;
              }
              case "base64": {
                const dataPropagation = (ctx) => {
                  if (ctx.name === "partData") {
                    part.transferBuffer += ctx.buffer.slice(ctx.start, ctx.end).toString("ascii");
                    const offset = parseInt(part.transferBuffer.length / 4, 10) * 4;
                    part.emit(
                      "data",
                      Buffer.from(
                        part.transferBuffer.substring(0, offset),
                        "base64"
                      )
                    );
                    part.transferBuffer = part.transferBuffer.substring(offset);
                  }
                };
                const dataStopPropagation = (ctx) => {
                  if (ctx.name === "partEnd") {
                    part.emit("data", Buffer.from(part.transferBuffer, "base64"));
                    part.emit("end");
                    parser.off("data", dataPropagation);
                    parser.off("data", dataStopPropagation);
                  }
                };
                parser.on("data", dataPropagation);
                parser.on("data", dataStopPropagation);
                break;
              }
              default:
                return this._error(
                  new FormidableError(
                    "unknown transfer-encoding",
                    unknownTransferEncoding,
                    501
                  )
                );
            }
            this._parser.pause();
            await this.onPart(part);
            this._parser.resume();
          } else if (name === "end") {
            this.ended = true;
            this._maybeEnd();
          }
        });
        this._parser = parser;
      };
    }
    var JSONParser = class extends node_stream.Transform {
      constructor(options2 = {}) {
        super({ readableObjectMode: true });
        this.chunks = [];
        this.globalOptions = { ...options2 };
      }
      _transform(chunk, encoding, callback) {
        this.chunks.push(String(chunk));
        callback();
      }
      _flush(callback) {
        try {
          const fields = JSON.parse(this.chunks.join(""));
          this.push(fields);
        } catch (e) {
          callback(e);
          return;
        }
        this.chunks = null;
        callback();
      }
    };
    var jsonType = "json";
    function plugin(formidable2, options2) {
      const self = this || formidable2;
      if (/json/i.test(self.headers["content-type"])) {
        init.call(self, self, options2);
      }
      return self;
    }
    function init(_self, _opts) {
      this.type = jsonType;
      const parser = new JSONParser(this.options);
      parser.on("data", (fields) => {
        this.fields = fields;
      });
      parser.once("end", () => {
        this.ended = true;
        this._maybeEnd();
      });
      this._parser = parser;
    }
    var CUID2_FINGERPRINT = `${process.env.NODE_ENV}-${os.platform()}-${os.hostname()}`;
    var createId = cuid2.init({ length: 25, fingerprint: CUID2_FINGERPRINT.toLowerCase() });
    var DEFAULT_OPTIONS = {
      maxFields: 1e3,
      maxFieldsSize: 20 * 1024 * 1024,
      maxFiles: Infinity,
      maxFileSize: 200 * 1024 * 1024,
      maxTotalFileSize: void 0,
      minFileSize: 1,
      allowEmptyFiles: false,
      createDirsFromUploads: false,
      keepExtensions: false,
      encoding: "utf-8",
      hashAlgorithm: false,
      uploadDir: os.tmpdir(),
      enabledPlugins: [plugin$3, plugin$2, plugin$1, plugin],
      fileWriteStreamHandler: null,
      defaultInvalidName: "invalid-name",
      filter(_part) {
        return true;
      },
      filename: void 0
    };
    function hasOwnProp(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    var decorateForceSequential = function(promiseCreator) {
      let lastPromise = Promise.resolve();
      return async function(...x) {
        const promiseWeAreWaitingFor = lastPromise;
        let currentPromise;
        let callback;
        lastPromise = new Promise(function(resolve) {
          callback = resolve;
        });
        await promiseWeAreWaitingFor;
        currentPromise = promiseCreator(...x);
        currentPromise.then(callback).catch(callback);
        return currentPromise;
      };
    };
    var createNecessaryDirectoriesAsync = decorateForceSequential(function(filePath) {
      const directoryname = path.dirname(filePath);
      return fsPromises.mkdir(directoryname, { recursive: true });
    });
    var invalidExtensionChar = (c) => {
      const code = c.charCodeAt(0);
      return !(code === 46 || // .
      code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122);
    };
    var IncomingForm = class extends node_events.EventEmitter {
      constructor(options2 = {}) {
        super();
        this.options = { ...DEFAULT_OPTIONS, ...options2 };
        if (!this.options.maxTotalFileSize) {
          this.options.maxTotalFileSize = this.options.maxFileSize;
        }
        const dir = path.resolve(
          this.options.uploadDir || this.options.uploaddir || os.tmpdir()
        );
        this.uploaddir = dir;
        this.uploadDir = dir;
        [
          "error",
          "headers",
          "type",
          "bytesExpected",
          "bytesReceived",
          "_parser",
          "req"
        ].forEach((key) => {
          this[key] = null;
        });
        this._setUpRename();
        this._flushing = 0;
        this._fieldsSize = 0;
        this._totalFileSize = 0;
        this._plugins = [];
        this.openedFiles = [];
        this.options.enabledPlugins = [].concat(this.options.enabledPlugins).filter(Boolean);
        if (this.options.enabledPlugins.length === 0) {
          throw new FormidableError(
            "expect at least 1 enabled builtin plugin, see options.enabledPlugins",
            missingPlugin
          );
        }
        this.options.enabledPlugins.forEach((plugin2) => {
          this.use(plugin2);
        });
        this._setUpMaxFields();
        this._setUpMaxFiles();
        this.ended = void 0;
        this.type = void 0;
      }
      use(plugin2) {
        if (typeof plugin2 !== "function") {
          throw new FormidableError(
            ".use: expect `plugin` to be a function",
            pluginFunction
          );
        }
        this._plugins.push(plugin2.bind(this));
        return this;
      }
      pause() {
        try {
          this.req.pause();
        } catch (err) {
          if (!this.ended) {
            this._error(err);
          }
          return false;
        }
        return true;
      }
      resume() {
        try {
          this.req.resume();
        } catch (err) {
          if (!this.ended) {
            this._error(err);
          }
          return false;
        }
        return true;
      }
      // returns a promise if no callback is provided
      async parse(req, cb) {
        this.req = req;
        let promise;
        if (!cb) {
          let resolveRef;
          let rejectRef;
          promise = new Promise((resolve, reject) => {
            resolveRef = resolve;
            rejectRef = reject;
          });
          cb = (err, fields, files2) => {
            if (err) {
              rejectRef(err);
            } else {
              resolveRef([fields, files2]);
            }
          };
        }
        const callback = once(dezalgo(cb));
        this.fields = {};
        const files = {};
        this.on("field", (name, value) => {
          if (this.type === "multipart" || this.type === "urlencoded") {
            if (!hasOwnProp(this.fields, name)) {
              this.fields[name] = [value];
            } else {
              this.fields[name].push(value);
            }
          } else {
            this.fields[name] = value;
          }
        });
        this.on("file", (name, file) => {
          if (!hasOwnProp(files, name)) {
            files[name] = [file];
          } else {
            files[name].push(file);
          }
        });
        this.on("error", (err) => {
          callback(err, this.fields, files);
        });
        this.on("end", () => {
          callback(null, this.fields, files);
        });
        await this.writeHeaders(req.headers);
        req.on("error", (err) => {
          this._error(err);
        }).on("aborted", () => {
          this.emit("aborted");
          this._error(new FormidableError("Request aborted", aborted));
        }).on("data", (buffer) => {
          try {
            this.write(buffer);
          } catch (err) {
            this._error(err);
          }
        }).on("end", () => {
          if (this.error) {
            return;
          }
          if (this._parser) {
            this._parser.end();
          }
        });
        if (promise) {
          return promise;
        }
        return this;
      }
      async writeHeaders(headers) {
        this.headers = headers;
        this._parseContentLength();
        await this._parseContentType();
        if (!this._parser) {
          this._error(
            new FormidableError(
              "no parser found",
              noParser,
              415
              // Unsupported Media Type
            )
          );
          return;
        }
        this._parser.once("error", (error2) => {
          this._error(error2);
        });
      }
      write(buffer) {
        if (this.error) {
          return null;
        }
        if (!this._parser) {
          this._error(
            new FormidableError("uninitialized parser", uninitializedParser)
          );
          return null;
        }
        this.bytesReceived += buffer.length;
        this.emit("progress", this.bytesReceived, this.bytesExpected);
        this._parser.write(buffer);
        return this.bytesReceived;
      }
      onPart(part) {
        return this._handlePart(part);
      }
      async _handlePart(part) {
        if (part.originalFilename && typeof part.originalFilename !== "string") {
          this._error(
            new FormidableError(
              `the part.originalFilename should be string when it exists`,
              filenameNotString
            )
          );
          return;
        }
        if (!part.mimetype) {
          let value = "";
          const decoder = new node_string_decoder.StringDecoder(
            part.transferEncoding || this.options.encoding
          );
          part.on("data", (buffer) => {
            this._fieldsSize += buffer.length;
            if (this._fieldsSize > this.options.maxFieldsSize) {
              this._error(
                new FormidableError(
                  `options.maxFieldsSize (${this.options.maxFieldsSize} bytes) exceeded, received ${this._fieldsSize} bytes of field data`,
                  maxFieldsSizeExceeded,
                  413
                  // Payload Too Large
                )
              );
              return;
            }
            value += decoder.write(buffer);
          });
          part.on("end", () => {
            this.emit("field", part.name, value);
          });
          return;
        }
        if (!this.options.filter(part)) {
          return;
        }
        this._flushing += 1;
        let fileSize = 0;
        const newFilename = this._getNewName(part);
        const filepath = this._joinDirectoryName(newFilename);
        const file = await this._newFile({
          newFilename,
          filepath,
          originalFilename: part.originalFilename,
          mimetype: part.mimetype
        });
        file.on("error", (err) => {
          this._error(err);
        });
        this.emit("fileBegin", part.name, file);
        file.open();
        this.openedFiles.push(file);
        part.on("data", (buffer) => {
          this._totalFileSize += buffer.length;
          fileSize += buffer.length;
          if (this._totalFileSize > this.options.maxTotalFileSize) {
            this._error(
              new FormidableError(
                `options.maxTotalFileSize (${this.options.maxTotalFileSize} bytes) exceeded, received ${this._totalFileSize} bytes of file data`,
                biggerThanTotalMaxFileSize,
                413
              )
            );
            return;
          }
          if (buffer.length === 0) {
            return;
          }
          this.pause();
          file.write(buffer, () => {
            this.resume();
          });
        });
        part.on("end", () => {
          if (!this.options.allowEmptyFiles && fileSize === 0) {
            this._error(
              new FormidableError(
                `options.allowEmptyFiles is false, file size should be greater than 0`,
                noEmptyFiles,
                400
              )
            );
            return;
          }
          if (fileSize < this.options.minFileSize) {
            this._error(
              new FormidableError(
                `options.minFileSize (${this.options.minFileSize} bytes) inferior, received ${fileSize} bytes of file data`,
                smallerThanMinFileSize,
                400
              )
            );
            return;
          }
          if (fileSize > this.options.maxFileSize) {
            this._error(
              new FormidableError(
                `options.maxFileSize (${this.options.maxFileSize} bytes), received ${fileSize} bytes of file data`,
                biggerThanMaxFileSize,
                413
              )
            );
            return;
          }
          file.end(() => {
            this._flushing -= 1;
            this.emit("file", part.name, file);
            this._maybeEnd();
          });
        });
      }
      // eslint-disable-next-line max-statements
      async _parseContentType() {
        if (this.bytesExpected === 0) {
          this._parser = new DummyParser(this, this.options);
          return;
        }
        if (!this.headers["content-type"]) {
          this._error(
            new FormidableError(
              "bad content-type header, no content-type",
              missingContentType,
              400
            )
          );
          return;
        }
        new DummyParser(this, this.options);
        const results = [];
        await Promise.all(this._plugins.map(async (plugin2, idx) => {
          let pluginReturn = null;
          try {
            pluginReturn = await plugin2(this, this.options) || this;
          } catch (err) {
            const error2 = new FormidableError(
              `plugin on index ${idx} failed with: ${err.message}`,
              pluginFailed,
              500
            );
            error2.idx = idx;
            throw error2;
          }
          Object.assign(this, pluginReturn);
          this.emit("plugin", idx, pluginReturn);
        }));
        this.emit("pluginsResults", results);
      }
      _error(err, eventName = "error") {
        if (this.error || this.ended) {
          return;
        }
        this.req = null;
        this.error = err;
        this.emit(eventName, err);
        this.openedFiles.forEach((file) => {
          file.destroy();
        });
      }
      _parseContentLength() {
        this.bytesReceived = 0;
        if (this.headers["content-length"]) {
          this.bytesExpected = parseInt(this.headers["content-length"], 10);
        } else if (this.headers["transfer-encoding"] === void 0) {
          this.bytesExpected = 0;
        }
        if (this.bytesExpected !== null) {
          this.emit("progress", this.bytesReceived, this.bytesExpected);
        }
      }
      _newParser() {
        return new MultipartParser$1(this.options);
      }
      async _newFile({ filepath, originalFilename, mimetype, newFilename }) {
        if (this.options.fileWriteStreamHandler) {
          return new VolatileFile({
            newFilename,
            filepath,
            originalFilename,
            mimetype,
            createFileWriteStream: this.options.fileWriteStreamHandler,
            hashAlgorithm: this.options.hashAlgorithm
          });
        }
        if (this.options.createDirsFromUploads) {
          try {
            await createNecessaryDirectoriesAsync(filepath);
          } catch (errorCreatingDir) {
            this._error(new FormidableError(
              `cannot create directory`,
              cannotCreateDir,
              409
            ));
          }
        }
        return new PersistentFile({
          newFilename,
          filepath,
          originalFilename,
          mimetype,
          hashAlgorithm: this.options.hashAlgorithm
        });
      }
      _getFileName(headerValue) {
        const m = headerValue.match(
          /\bfilename=("(.*?)"|([^()<>{}[\]@,;:"?=\s/\t]+))($|;\s)/i
        );
        if (!m) return null;
        const match = m[2] || m[3] || "";
        let originalFilename = match.substr(match.lastIndexOf("\\") + 1);
        originalFilename = originalFilename.replace(/%22/g, '"');
        originalFilename = originalFilename.replace(
          /&#([\d]{4});/g,
          (_, code) => String.fromCharCode(code)
        );
        return originalFilename;
      }
      // able to get composed extension with multiple dots
      // "a.b.c" -> ".b.c"
      // as opposed to path.extname -> ".c"
      _getExtension(str) {
        if (!str) {
          return "";
        }
        const basename = path.basename(str);
        const firstDot = basename.indexOf(".");
        const lastDot = basename.lastIndexOf(".");
        let rawExtname = path.extname(basename);
        if (firstDot !== lastDot) {
          rawExtname = basename.slice(firstDot);
        }
        let filtered;
        const firstInvalidIndex = Array.from(rawExtname).findIndex(invalidExtensionChar);
        if (firstInvalidIndex === -1) {
          filtered = rawExtname;
        } else {
          filtered = rawExtname.substring(0, firstInvalidIndex);
        }
        if (filtered === ".") {
          return "";
        }
        return filtered;
      }
      _joinDirectoryName(name) {
        const newPath = path.join(this.uploadDir, name);
        if (!newPath.startsWith(this.uploadDir)) {
          return path.join(this.uploadDir, this.options.defaultInvalidName);
        }
        return newPath;
      }
      _setUpRename() {
        const hasRename = typeof this.options.filename === "function";
        if (hasRename) {
          this._getNewName = (part) => {
            let ext = "";
            let name = this.options.defaultInvalidName;
            if (part.originalFilename) {
              ({ ext, name } = path.parse(part.originalFilename));
              if (this.options.keepExtensions !== true) {
                ext = "";
              }
            }
            return this.options.filename.call(this, name, ext, part, this);
          };
        } else {
          this._getNewName = (part) => {
            const name = createId();
            if (part && this.options.keepExtensions) {
              const originalFilename = typeof part === "string" ? part : part.originalFilename;
              return `${name}${this._getExtension(originalFilename)}`;
            }
            return name;
          };
        }
      }
      _setUpMaxFields() {
        if (this.options.maxFields !== Infinity) {
          let fieldsCount = 0;
          this.on("field", () => {
            fieldsCount += 1;
            if (fieldsCount > this.options.maxFields) {
              this._error(
                new FormidableError(
                  `options.maxFields (${this.options.maxFields}) exceeded`,
                  maxFieldsExceeded,
                  413
                )
              );
            }
          });
        }
      }
      _setUpMaxFiles() {
        if (this.options.maxFiles !== Infinity) {
          let fileCount = 0;
          this.on("fileBegin", () => {
            fileCount += 1;
            if (fileCount > this.options.maxFiles) {
              this._error(
                new FormidableError(
                  `options.maxFiles (${this.options.maxFiles}) exceeded`,
                  maxFilesExceeded,
                  413
                )
              );
            }
          });
        }
      }
      _maybeEnd() {
        if (!this.ended || this._flushing || this.error) {
          return;
        }
        this.req = null;
        this.emit("end");
      }
    };
    var formidable = (...args) => new IncomingForm(...args);
    var { enabledPlugins } = DEFAULT_OPTIONS;
    exports2.DummyParser = DummyParser;
    exports2.File = PersistentFile;
    exports2.Formidable = IncomingForm;
    exports2.IncomingForm = IncomingForm;
    exports2.JSONParser = JSONParser;
    exports2.MultipartParser = MultipartParser$1;
    exports2.OctetStreamParser = OctetStreamParser;
    exports2.OctetstreamParser = OctetStreamParser;
    exports2.PersistentFile = PersistentFile;
    exports2.QueryStringParser = QuerystringParser;
    exports2.QuerystringParser = QuerystringParser;
    exports2.VolatileFile = VolatileFile;
    exports2.default = formidable;
    exports2.defaultOptions = DEFAULT_OPTIONS;
    exports2.enabledPlugins = enabledPlugins;
    exports2.errors = FormidableError$1;
    exports2.formidable = formidable;
    exports2.json = plugin;
    exports2.multipart = plugin$1;
    exports2.octetstream = plugin$3;
    exports2.querystring = plugin$2;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter2) {
        const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env: env2 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/cookiejar/cookiejar.js
var require_cookiejar = __commonJS({
  "node_modules/cookiejar/cookiejar.js"(exports2) {
    "use strict";
    (function() {
      "use strict";
      function CookieAccessInfo(domain, path, secure, script) {
        if (this instanceof CookieAccessInfo) {
          this.domain = domain || void 0;
          this.path = path || "/";
          this.secure = !!secure;
          this.script = !!script;
          return this;
        }
        return new CookieAccessInfo(domain, path, secure, script);
      }
      CookieAccessInfo.All = Object.freeze(/* @__PURE__ */ Object.create(null));
      exports2.CookieAccessInfo = CookieAccessInfo;
      function Cookie(cookiestr, request_domain, request_path) {
        if (cookiestr instanceof Cookie) {
          return cookiestr;
        }
        if (this instanceof Cookie) {
          this.name = null;
          this.value = null;
          this.expiration_date = Infinity;
          this.path = String(request_path || "/");
          this.explicit_path = false;
          this.domain = request_domain || null;
          this.explicit_domain = false;
          this.secure = false;
          this.noscript = false;
          if (cookiestr) {
            this.parse(cookiestr, request_domain, request_path);
          }
          return this;
        }
        return new Cookie(cookiestr, request_domain, request_path);
      }
      exports2.Cookie = Cookie;
      Cookie.prototype.toString = function toString() {
        var str = [this.name + "=" + this.value];
        if (this.expiration_date !== Infinity) {
          str.push("expires=" + new Date(this.expiration_date).toGMTString());
        }
        if (this.domain) {
          str.push("domain=" + this.domain);
        }
        if (this.path) {
          str.push("path=" + this.path);
        }
        if (this.secure) {
          str.push("secure");
        }
        if (this.noscript) {
          str.push("httponly");
        }
        return str.join("; ");
      };
      Cookie.prototype.toValueString = function toValueString() {
        return this.name + "=" + this.value;
      };
      var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
      Cookie.prototype.parse = function parse(str, request_domain, request_path) {
        if (this instanceof Cookie) {
          if (str.length > 32768) {
            console.warn("Cookie too long for parsing (>32768 characters)");
            return;
          }
          var parts = str.split(";").filter(function(value2) {
            return !!value2;
          });
          var i;
          var pair = parts[0].match(/([^=]+)=([\s\S]*)/);
          if (!pair) {
            console.warn("Invalid cookie header encountered. Header: '" + str + "'");
            return;
          }
          var key = pair[1];
          var value = pair[2];
          if (typeof key !== "string" || key.length === 0 || typeof value !== "string") {
            console.warn("Unable to extract values from cookie header. Cookie: '" + str + "'");
            return;
          }
          this.name = key;
          this.value = value;
          for (i = 1; i < parts.length; i += 1) {
            pair = parts[i].match(/([^=]+)(?:=([\s\S]*))?/);
            key = pair[1].trim().toLowerCase();
            value = pair[2];
            switch (key) {
              case "httponly":
                this.noscript = true;
                break;
              case "expires":
                this.expiration_date = value ? Number(Date.parse(value)) : Infinity;
                break;
              case "path":
                this.path = value ? value.trim() : "";
                this.explicit_path = true;
                break;
              case "domain":
                this.domain = value ? value.trim() : "";
                this.explicit_domain = !!this.domain;
                break;
              case "secure":
                this.secure = true;
                break;
            }
          }
          if (!this.explicit_path) {
            this.path = request_path || "/";
          }
          if (!this.explicit_domain) {
            this.domain = request_domain;
          }
          return this;
        }
        return new Cookie().parse(str, request_domain, request_path);
      };
      Cookie.prototype.matches = function matches(access_info) {
        if (access_info === CookieAccessInfo.All) {
          return true;
        }
        if (this.noscript && access_info.script || this.secure && !access_info.secure || !this.collidesWith(access_info)) {
          return false;
        }
        return true;
      };
      Cookie.prototype.collidesWith = function collidesWith(access_info) {
        if (this.path && !access_info.path || this.domain && !access_info.domain) {
          return false;
        }
        if (this.path && access_info.path.indexOf(this.path) !== 0) {
          return false;
        }
        if (this.explicit_path && access_info.path.indexOf(this.path) !== 0) {
          return false;
        }
        var access_domain = access_info.domain && access_info.domain.replace(/^[\.]/, "");
        var cookie_domain = this.domain && this.domain.replace(/^[\.]/, "");
        if (cookie_domain === access_domain) {
          return true;
        }
        if (cookie_domain) {
          if (!this.explicit_domain) {
            return false;
          }
          var wildcard = access_domain.indexOf(cookie_domain);
          if (wildcard === -1 || wildcard !== access_domain.length - cookie_domain.length) {
            return false;
          }
          return true;
        }
        return true;
      };
      function CookieJar() {
        var cookies, cookies_list, collidable_cookie;
        if (this instanceof CookieJar) {
          cookies = /* @__PURE__ */ Object.create(null);
          this.setCookie = function setCookie(cookie, request_domain, request_path) {
            var remove, i;
            cookie = new Cookie(cookie, request_domain, request_path);
            remove = cookie.expiration_date <= Date.now();
            if (cookies[cookie.name] !== void 0) {
              cookies_list = cookies[cookie.name];
              for (i = 0; i < cookies_list.length; i += 1) {
                collidable_cookie = cookies_list[i];
                if (collidable_cookie.collidesWith(cookie)) {
                  if (remove) {
                    cookies_list.splice(i, 1);
                    if (cookies_list.length === 0) {
                      delete cookies[cookie.name];
                    }
                    return false;
                  }
                  cookies_list[i] = cookie;
                  return cookie;
                }
              }
              if (remove) {
                return false;
              }
              cookies_list.push(cookie);
              return cookie;
            }
            if (remove) {
              return false;
            }
            cookies[cookie.name] = [cookie];
            return cookies[cookie.name];
          };
          this.getCookie = function getCookie(cookie_name, access_info) {
            var cookie, i;
            cookies_list = cookies[cookie_name];
            if (!cookies_list) {
              return;
            }
            for (i = 0; i < cookies_list.length; i += 1) {
              cookie = cookies_list[i];
              if (cookie.expiration_date <= Date.now()) {
                if (cookies_list.length === 0) {
                  delete cookies[cookie.name];
                }
                continue;
              }
              if (cookie.matches(access_info)) {
                return cookie;
              }
            }
          };
          this.getCookies = function getCookies(access_info) {
            var matches = [], cookie_name, cookie;
            for (cookie_name in cookies) {
              cookie = this.getCookie(cookie_name, access_info);
              if (cookie) {
                matches.push(cookie);
              }
            }
            matches.toString = function toString() {
              return matches.join(":");
            };
            matches.toValueString = function toValueString() {
              return matches.map(function(c) {
                return c.toValueString();
              }).join("; ");
            };
            return matches;
          };
          return this;
        }
        return new CookieJar();
      }
      exports2.CookieJar = CookieJar;
      CookieJar.prototype.setCookies = function setCookies(cookies, request_domain, request_path) {
        cookies = Array.isArray(cookies) ? cookies : cookies.split(cookie_str_splitter);
        var successful = [], i, cookie;
        cookies = cookies.map(function(item) {
          return new Cookie(item, request_domain, request_path);
        });
        for (i = 0; i < cookies.length; i += 1) {
          cookie = cookies[i];
          if (this.setCookie(cookie, request_domain, request_path)) {
            successful.push(cookie);
          }
        }
        return successful;
      };
    })();
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports2, module2) {
    "use strict";
    module2.exports = stringify;
    stringify.default = stringify;
    stringify.stable = deterministicStringify;
    stringify.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify(obj, replacer, spacer, options2) {
      if (typeof options2 === "undefined") {
        options2 = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options2);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options2) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options2);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options2);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options2) {
      if (typeof options2 === "undefined") {
        options2 = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options2) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options2) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options2);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options2);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/superagent/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/superagent/lib/utils.js"(exports2) {
    "use strict";
    exports2.type = (string_) => string_.split(/ *; */).shift();
    exports2.params = (value) => {
      const object = {};
      for (const string_ of value.split(/ *; */)) {
        const parts = string_.split(/ *= */);
        const key = parts.shift();
        const value2 = parts.shift();
        if (key && value2) object[key] = value2;
      }
      return object;
    };
    exports2.parseLinks = (value) => {
      const object = {};
      for (const string_ of value.split(/ *, */)) {
        const parts = string_.split(/ *; */);
        const url = parts[0].slice(1, -1);
        const rel = parts[1].split(/ *= */)[1].slice(1, -1);
        object[rel] = url;
      }
      return object;
    };
    exports2.cleanHeader = (header, changesOrigin) => {
      delete header["content-type"];
      delete header["content-length"];
      delete header["transfer-encoding"];
      delete header.host;
      if (changesOrigin) {
        delete header.authorization;
        delete header.cookie;
      }
      return header;
    };
    exports2.normalizeHostname = (hostname) => {
      const [, normalized] = hostname.match(/^\[([^\]]+)\]$/) || [];
      return normalized || hostname;
    };
    exports2.isObject = (object) => {
      return object !== null && typeof object === "object";
    };
    exports2.hasOwn = Object.hasOwn || function(object, property) {
      if (object == null) {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      return Object.prototype.hasOwnProperty.call(new Object(object), property);
    };
    exports2.mixin = (target, source) => {
      for (const key in source) {
        if (exports2.hasOwn(source, key)) {
          target[key] = source[key];
        }
      }
    };
    exports2.isGzipOrDeflateEncoding = (res) => {
      return new RegExp(/^\s*(?:deflate|gzip)\s*$/).test(res.headers["content-encoding"]);
    };
    exports2.isBrotliEncoding = (res) => {
      return new RegExp(/^\s*(?:br)\s*$/).test(res.headers["content-encoding"]);
    };
  }
});

// node_modules/superagent/lib/request-base.js
var require_request_base = __commonJS({
  "node_modules/superagent/lib/request-base.js"(exports2, module2) {
    "use strict";
    var {
      isObject,
      hasOwn
    } = require_utils3();
    module2.exports = RequestBase;
    function RequestBase() {
    }
    RequestBase.prototype.clearTimeout = function() {
      clearTimeout(this._timer);
      clearTimeout(this._responseTimeoutTimer);
      clearTimeout(this._uploadTimeoutTimer);
      delete this._timer;
      delete this._responseTimeoutTimer;
      delete this._uploadTimeoutTimer;
      return this;
    };
    RequestBase.prototype.parse = function(fn) {
      this._parser = fn;
      return this;
    };
    RequestBase.prototype.responseType = function(value) {
      this._responseType = value;
      return this;
    };
    RequestBase.prototype.serialize = function(fn) {
      this._serializer = fn;
      return this;
    };
    RequestBase.prototype.timeout = function(options2) {
      if (!options2 || typeof options2 !== "object") {
        this._timeout = options2;
        this._responseTimeout = 0;
        this._uploadTimeout = 0;
        return this;
      }
      for (const option in options2) {
        if (hasOwn(options2, option)) {
          switch (option) {
            case "deadline":
              this._timeout = options2.deadline;
              break;
            case "response":
              this._responseTimeout = options2.response;
              break;
            case "upload":
              this._uploadTimeout = options2.upload;
              break;
            default:
              console.warn("Unknown timeout option", option);
          }
        }
      }
      return this;
    };
    RequestBase.prototype.retry = function(count, fn) {
      if (arguments.length === 0 || count === true) count = 1;
      if (count <= 0) count = 0;
      this._maxRetries = count;
      this._retries = 0;
      this._retryCallback = fn;
      return this;
    };
    var ERROR_CODES = /* @__PURE__ */ new Set(["ETIMEDOUT", "ECONNRESET", "EADDRINUSE", "ECONNREFUSED", "EPIPE", "ENOTFOUND", "ENETUNREACH", "EAI_AGAIN"]);
    var STATUS_CODES = /* @__PURE__ */ new Set([408, 413, 429, 500, 502, 503, 504, 521, 522, 524]);
    RequestBase.prototype._shouldRetry = function(error2, res) {
      if (!this._maxRetries || this._retries++ >= this._maxRetries) {
        return false;
      }
      if (this._retryCallback) {
        try {
          const override = this._retryCallback(error2, res);
          if (override === true) return true;
          if (override === false) return false;
        } catch (err) {
          console.error(err);
        }
      }
      if (res && res.status && STATUS_CODES.has(res.status)) return true;
      if (error2) {
        if (error2.code && ERROR_CODES.has(error2.code)) return true;
        if (error2.timeout && error2.code === "ECONNABORTED") return true;
        if (error2.crossDomain) return true;
      }
      return false;
    };
    RequestBase.prototype._retry = function() {
      this.clearTimeout();
      if (this.req) {
        this.req = null;
        this.req = this.request();
      }
      this._aborted = false;
      this.timedout = false;
      this.timedoutError = null;
      return this._end();
    };
    RequestBase.prototype.then = function(resolve, reject) {
      if (!this._fullfilledPromise) {
        const self = this;
        if (this._endCalled) {
          console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
        }
        this._fullfilledPromise = new Promise((resolve2, reject2) => {
          self.on("abort", () => {
            if (this._maxRetries && this._maxRetries > this._retries) {
              return;
            }
            if (this.timedout && this.timedoutError) {
              reject2(this.timedoutError);
              return;
            }
            const error2 = new Error("Aborted");
            error2.code = "ABORTED";
            error2.status = this.status;
            error2.method = this.method;
            error2.url = this.url;
            reject2(error2);
          });
          self.end((error2, res) => {
            if (error2) reject2(error2);
            else resolve2(res);
          });
        });
      }
      return this._fullfilledPromise.then(resolve, reject);
    };
    RequestBase.prototype.catch = function(callback) {
      return this.then(void 0, callback);
    };
    RequestBase.prototype.use = function(fn) {
      fn(this);
      return this;
    };
    RequestBase.prototype.ok = function(callback) {
      if (typeof callback !== "function") throw new Error("Callback required");
      this._okCallback = callback;
      return this;
    };
    RequestBase.prototype._isResponseOK = function(res) {
      if (!res) {
        return false;
      }
      if (this._okCallback) {
        return this._okCallback(res);
      }
      return res.status >= 200 && res.status < 300;
    };
    RequestBase.prototype.get = function(field) {
      return this._header[field.toLowerCase()];
    };
    RequestBase.prototype.getHeader = RequestBase.prototype.get;
    RequestBase.prototype.set = function(field, value) {
      if (isObject(field)) {
        for (const key in field) {
          if (hasOwn(field, key)) this.set(key, field[key]);
        }
        return this;
      }
      this._header[field.toLowerCase()] = value;
      this.header[field] = value;
      return this;
    };
    RequestBase.prototype.unset = function(field) {
      delete this._header[field.toLowerCase()];
      delete this.header[field];
      return this;
    };
    RequestBase.prototype.field = function(name, value, options2) {
      if (name === null || void 0 === name) {
        throw new Error(".field(name, val) name can not be empty");
      }
      if (this._data) {
        throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
      }
      if (isObject(name)) {
        for (const key in name) {
          if (hasOwn(name, key)) this.field(key, name[key]);
        }
        return this;
      }
      if (Array.isArray(value)) {
        for (const i in value) {
          if (hasOwn(value, i)) this.field(name, value[i]);
        }
        return this;
      }
      if (value === null || void 0 === value) {
        throw new Error(".field(name, val) val can not be empty");
      }
      if (typeof value === "boolean") {
        value = String(value);
      }
      if (options2) this._getFormData().append(name, value, options2);
      else this._getFormData().append(name, value);
      return this;
    };
    RequestBase.prototype.abort = function() {
      if (this._aborted) {
        return this;
      }
      this._aborted = true;
      if (this.xhr) this.xhr.abort();
      if (this.req) {
        this.req.abort();
      }
      this.clearTimeout();
      this.emit("abort");
      return this;
    };
    RequestBase.prototype._auth = function(user, pass, options2, base64Encoder) {
      switch (options2.type) {
        case "basic":
          this.set("Authorization", `Basic ${base64Encoder(`${user}:${pass}`)}`);
          break;
        case "auto":
          this.username = user;
          this.password = pass;
          break;
        case "bearer":
          this.set("Authorization", `Bearer ${user}`);
          break;
        default:
          break;
      }
      return this;
    };
    RequestBase.prototype.withCredentials = function(on) {
      if (on === void 0) on = true;
      this._withCredentials = on;
      return this;
    };
    RequestBase.prototype.redirects = function(n) {
      this._maxRedirects = n;
      return this;
    };
    RequestBase.prototype.maxResponseSize = function(n) {
      if (typeof n !== "number") {
        throw new TypeError("Invalid argument");
      }
      this._maxResponseSize = n;
      return this;
    };
    RequestBase.prototype.toJSON = function() {
      return {
        method: this.method,
        url: this.url,
        data: this._data,
        headers: this._header
      };
    };
    RequestBase.prototype.send = function(data) {
      const isObject_ = isObject(data);
      let type = this._header["content-type"];
      if (this._formData) {
        throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
      }
      if (isObject_ && !this._data) {
        if (Array.isArray(data)) {
          this._data = [];
        } else if (!this._isHost(data)) {
          this._data = {};
        }
      } else if (data && this._data && this._isHost(this._data)) {
        throw new Error("Can't merge these send calls");
      }
      if (isObject_ && isObject(this._data)) {
        for (const key in data) {
          if (typeof data[key] == "bigint" && !data[key].toJSON) throw new Error("Cannot serialize BigInt value to json");
          if (hasOwn(data, key)) this._data[key] = data[key];
        }
      } else if (typeof data === "bigint") throw new Error("Cannot send value of type BigInt");
      else if (typeof data === "string") {
        if (!type) this.type("form");
        type = this._header["content-type"];
        if (type) type = type.toLowerCase().trim();
        if (type === "application/x-www-form-urlencoded") {
          this._data = this._data ? `${this._data}&${data}` : data;
        } else {
          this._data = (this._data || "") + data;
        }
      } else {
        this._data = data;
      }
      if (!isObject_ || this._isHost(data)) {
        return this;
      }
      if (!type) this.type("json");
      return this;
    };
    RequestBase.prototype.sortQuery = function(sort) {
      this._sort = typeof sort === "undefined" ? true : sort;
      return this;
    };
    RequestBase.prototype._finalizeQueryString = function() {
      const query = this._query.join("&");
      if (query) {
        this.url += (this.url.includes("?") ? "&" : "?") + query;
      }
      this._query.length = 0;
      if (this._sort) {
        const index = this.url.indexOf("?");
        if (index >= 0) {
          const queryArray = this.url.slice(index + 1).split("&");
          if (typeof this._sort === "function") {
            queryArray.sort(this._sort);
          } else {
            queryArray.sort();
          }
          this.url = this.url.slice(0, index) + "?" + queryArray.join("&");
        }
      }
    };
    RequestBase.prototype._appendQueryString = () => {
      console.warn("Unsupported");
    };
    RequestBase.prototype._timeoutError = function(reason, timeout, errno) {
      if (this._aborted) {
        return;
      }
      const error2 = new Error(`${reason + timeout}ms exceeded`);
      error2.timeout = timeout;
      error2.code = "ECONNABORTED";
      error2.errno = errno;
      this.timedout = true;
      this.timedoutError = error2;
      this.abort();
      this.callback(error2);
    };
    RequestBase.prototype._setTimeouts = function() {
      const self = this;
      if (this._timeout && !this._timer) {
        this._timer = setTimeout(() => {
          self._timeoutError("Timeout of ", self._timeout, "ETIME");
        }, this._timeout);
      }
      if (this._responseTimeout && !this._responseTimeoutTimer) {
        this._responseTimeoutTimer = setTimeout(() => {
          self._timeoutError("Response timeout of ", self._responseTimeout, "ETIMEDOUT");
        }, this._responseTimeout);
      }
    };
  }
});

// node_modules/superagent/lib/node/http2wrapper.js
var require_http2wrapper = __commonJS({
  "node_modules/superagent/lib/node/http2wrapper.js"(exports2) {
    "use strict";
    var http2 = require("http2");
    var Stream = require("stream");
    var net = require("net");
    var tls = require("tls");
    var {
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_STATUS,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_AUTHORITY,
      HTTP2_HEADER_HOST,
      HTTP2_HEADER_SET_COOKIE,
      NGHTTP2_CANCEL
    } = http2.constants;
    function setProtocol(protocol) {
      return {
        request(options2) {
          return new Request2(protocol, options2);
        }
      };
    }
    function normalizeIpv6Host(host) {
      return net.isIP(host) === 6 ? `[${host}]` : host;
    }
    var Request2 = class extends Stream {
      constructor(protocol, options2) {
        super();
        const defaultPort = protocol === "https:" ? 443 : 80;
        const defaultHost = "localhost";
        const port = options2.port || defaultPort;
        const host = options2.host || defaultHost;
        delete options2.port;
        delete options2.host;
        this.method = options2.method;
        this.path = options2.path;
        this.protocol = protocol;
        this.host = host;
        delete options2.method;
        delete options2.path;
        const sessionOptions = {
          ...options2
        };
        if (options2.socketPath) {
          sessionOptions.socketPath = options2.socketPath;
          sessionOptions.createConnection = this.createUnixConnection.bind(this);
        }
        this._headers = {};
        const normalizedHost = normalizeIpv6Host(host);
        const session = http2.connect(`${protocol}//${normalizedHost}:${port}`, sessionOptions);
        this.setHeader("host", `${normalizedHost}:${port}`);
        session.on("error", (error2) => this.emit("error", error2));
        this.session = session;
      }
      createUnixConnection(authority, options2) {
        switch (this.protocol) {
          case "http:":
            return net.connect(options2.socketPath);
          case "https:":
            options2.ALPNProtocols = ["h2"];
            options2.servername = this.host;
            options2.allowHalfOpen = true;
            return tls.connect(options2.socketPath, options2);
          default:
            throw new Error("Unsupported protocol", this.protocol);
        }
      }
      setNoDelay(bool) {
      }
      getFrame() {
        if (this.frame) {
          return this.frame;
        }
        const method = {
          [HTTP2_HEADER_PATH]: this.path,
          [HTTP2_HEADER_METHOD]: this.method
        };
        let headers = this.mapToHttp2Header(this._headers);
        headers = Object.assign(headers, method);
        const frame = this.session.request(headers);
        frame.once("response", (headers2, flags) => {
          headers2 = this.mapToHttpHeader(headers2);
          frame.headers = headers2;
          frame.statusCode = headers2[HTTP2_HEADER_STATUS];
          frame.status = frame.statusCode;
          this.emit("response", frame);
        });
        this._headerSent = true;
        frame.once("drain", () => this.emit("drain"));
        frame.on("error", (error2) => this.emit("error", error2));
        frame.on("close", () => this.session.close());
        this.frame = frame;
        return frame;
      }
      mapToHttpHeader(headers) {
        const keys = Object.keys(headers);
        const http2Headers = {};
        for (let key of keys) {
          let value = headers[key];
          key = key.toLowerCase();
          switch (key) {
            case HTTP2_HEADER_SET_COOKIE:
              value = Array.isArray(value) ? value : [value];
              break;
            default:
              break;
          }
          http2Headers[key] = value;
        }
        return http2Headers;
      }
      mapToHttp2Header(headers) {
        const keys = Object.keys(headers);
        const http2Headers = {};
        for (let key of keys) {
          let value = headers[key];
          key = key.toLowerCase();
          switch (key) {
            case HTTP2_HEADER_HOST:
              key = HTTP2_HEADER_AUTHORITY;
              value = /^http:\/\/|^https:\/\//.test(value) ? new URL(value).host : value;
              break;
            default:
              break;
          }
          http2Headers[key] = value;
        }
        return http2Headers;
      }
      setHeader(name, value) {
        this._headers[name.toLowerCase()] = value;
      }
      getHeader(name) {
        return this._headers[name.toLowerCase()];
      }
      write(data, encoding) {
        const frame = this.getFrame();
        return frame.write(data, encoding);
      }
      pipe(stream, options2) {
        const frame = this.getFrame();
        return frame.pipe(stream, options2);
      }
      end(data) {
        const frame = this.getFrame();
        frame.end(data);
      }
      abort(data) {
        const frame = this.getFrame();
        frame.close(NGHTTP2_CANCEL);
        this.session.destroy();
      }
    };
    exports2.setProtocol = setProtocol;
  }
});

// node_modules/superagent/lib/node/decompress.js
var require_decompress = __commonJS({
  "node_modules/superagent/lib/node/decompress.js"(exports2) {
    "use strict";
    var zlib = require("zlib");
    var utils = require_utils3();
    var {
      isGzipOrDeflateEncoding,
      isBrotliEncoding
    } = utils;
    exports2.chooseDecompresser = (res) => {
      let decompresser;
      if (isGzipOrDeflateEncoding(res)) {
        decompresser = zlib.createUnzip();
      } else if (isBrotliEncoding(res)) {
        decompresser = zlib.createBrotliDecompress();
      } else {
        throw new Error("unknown content-encoding");
      }
      return decompresser;
    };
  }
});

// node_modules/superagent/lib/node/unzip.js
var require_unzip = __commonJS({
  "node_modules/superagent/lib/node/unzip.js"(exports2) {
    "use strict";
    var {
      StringDecoder
    } = require("string_decoder");
    var Stream = require("stream");
    var {
      chooseDecompresser
    } = require_decompress();
    exports2.decompress = (request2, res) => {
      let decompresser = chooseDecompresser(res);
      const stream = new Stream();
      let decoder;
      stream.req = request2;
      decompresser.on("error", (error2) => {
        if (error2 && error2.code === "Z_BUF_ERROR") {
          stream.emit("end");
          return;
        }
        stream.emit("error", error2);
      });
      res.pipe(decompresser);
      res.setEncoding = (type) => {
        decoder = new StringDecoder(type);
      };
      decompresser.on("data", (buf) => {
        if (decoder) {
          const string_ = decoder.write(buf);
          if (string_.length > 0) stream.emit("data", string_);
        } else {
          stream.emit("data", buf);
        }
      });
      decompresser.on("end", () => {
        stream.emit("end");
      });
      const _on = res.on;
      res.on = function(type, fn) {
        if (type === "data" || type === "end") {
          stream.on(type, fn.bind(res));
        } else if (type === "error") {
          stream.on(type, fn.bind(res));
          _on.call(res, type, fn);
        } else {
          _on.call(res, type, fn);
        }
        return this;
      };
    };
  }
});

// node_modules/superagent/lib/response-base.js
var require_response_base = __commonJS({
  "node_modules/superagent/lib/response-base.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = ResponseBase;
    function ResponseBase() {
    }
    ResponseBase.prototype.get = function(field) {
      return this.header[field.toLowerCase()];
    };
    ResponseBase.prototype._setHeaderProperties = function(header) {
      const ct = header["content-type"] || "";
      this.type = utils.type(ct);
      const parameters = utils.params(ct);
      for (const key in parameters) {
        if (Object.prototype.hasOwnProperty.call(parameters, key)) this[key] = parameters[key];
      }
      this.links = {};
      try {
        if (header.link) {
          this.links = utils.parseLinks(header.link);
        }
      } catch (err) {
      }
    };
    ResponseBase.prototype._setStatusProperties = function(status) {
      const type = Math.trunc(status / 100);
      this.statusCode = status;
      this.status = this.statusCode;
      this.statusType = type;
      this.info = type === 1;
      this.ok = type === 2;
      this.redirect = type === 3;
      this.clientError = type === 4;
      this.serverError = type === 5;
      this.error = type === 4 || type === 5 ? this.toError() : false;
      this.created = status === 201;
      this.accepted = status === 202;
      this.noContent = status === 204;
      this.badRequest = status === 400;
      this.unauthorized = status === 401;
      this.notAcceptable = status === 406;
      this.forbidden = status === 403;
      this.notFound = status === 404;
      this.unprocessableEntity = status === 422;
    };
  }
});

// node_modules/superagent/lib/node/response.js
var require_response = __commonJS({
  "node_modules/superagent/lib/node/response.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream");
    var ResponseBase = require_response_base();
    var {
      mixin
    } = require_utils3();
    module2.exports = Response2;
    function Response2(request2) {
      Stream.call(this);
      this.res = request2.res;
      const {
        res
      } = this;
      this.request = request2;
      this.req = request2.req;
      this.text = res.text;
      this.files = res.files || {};
      this.buffered = request2._resBuffered;
      this.headers = res.headers;
      this.header = this.headers;
      this._setStatusProperties(res.statusCode);
      this._setHeaderProperties(this.header);
      this.setEncoding = res.setEncoding.bind(res);
      res.on("data", this.emit.bind(this, "data"));
      res.on("end", this.emit.bind(this, "end"));
      res.on("close", this.emit.bind(this, "close"));
      res.on("error", this.emit.bind(this, "error"));
    }
    Object.defineProperty(Response2.prototype, "body", {
      get() {
        return this._body !== void 0 ? this._body : this.res.body !== void 0 ? this.res.body : {};
      },
      set(value) {
        this._body = value;
      }
    });
    util.inherits(Response2, Stream);
    mixin(Response2.prototype, ResponseBase.prototype);
    Response2.prototype.destroy = function(error2) {
      this.res.destroy(error2);
    };
    Response2.prototype.pause = function() {
      this.res.pause();
    };
    Response2.prototype.resume = function() {
      this.res.resume();
    };
    Response2.prototype.toError = function() {
      const {
        req
      } = this;
      const {
        method
      } = req;
      const {
        path
      } = req;
      const message = `cannot ${method} ${path} (${this.status})`;
      const error2 = new Error(message);
      error2.status = this.status;
      error2.text = this.text;
      error2.method = method;
      error2.path = path;
      return error2;
    };
    Response2.prototype.setStatusProperties = function(status) {
      console.warn("In superagent 2.x setStatusProperties is a private method");
      return this._setStatusProperties(status);
    };
    Response2.prototype.toJSON = function() {
      return {
        req: this.request.toJSON(),
        header: this.header,
        status: this.status,
        text: this.text
      };
    };
  }
});

// node_modules/superagent/lib/agent-base.js
var require_agent_base = __commonJS({
  "node_modules/superagent/lib/agent-base.js"(exports2, module2) {
    "use strict";
    var defaults = ["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert", "disableTLSCerts"];
    var Agent = class {
      constructor() {
        this._defaults = [];
      }
      _setDefaults(request2) {
        for (const def of this._defaults) {
          request2[def.fn](...def.args);
        }
      }
    };
    for (const fn of defaults) {
      Agent.prototype[fn] = function(...args) {
        this._defaults.push({
          fn,
          args
        });
        return this;
      };
    }
    module2.exports = Agent;
  }
});

// node_modules/superagent/lib/node/agent.js
var require_agent = __commonJS({
  "node_modules/superagent/lib/node/agent.js"(exports2, module2) {
    "use strict";
    var {
      CookieJar
    } = require_cookiejar();
    var {
      CookieAccessInfo
    } = require_cookiejar();
    var methods = require_methods();
    var request2 = require_node2();
    var AgentBase = require_agent_base();
    var Agent = class extends AgentBase {
      constructor(options2) {
        super();
        this.jar = new CookieJar();
        if (options2) {
          if (options2.ca) {
            this.ca(options2.ca);
          }
          if (options2.key) {
            this.key(options2.key);
          }
          if (options2.pfx) {
            this.pfx(options2.pfx);
          }
          if (options2.cert) {
            this.cert(options2.cert);
          }
          if (options2.rejectUnauthorized === false) {
            this.disableTLSCerts();
          }
        }
      }
      /**
       * Save the cookies in the given `res` to
       * the agent's cookie jar for persistence.
       *
       * @param {Response} res
       * @api private
       */
      _saveCookies(res) {
        const cookies = res.headers["set-cookie"];
        if (cookies) {
          var _res$request;
          const url = new URL(((_res$request = res.request) === null || _res$request === void 0 ? void 0 : _res$request.url) || "");
          this.jar.setCookies(cookies, url.hostname, url.pathname);
        }
      }
      /**
       * Attach cookies when available to the given `req`.
       *
       * @param {Request} req
       * @api private
       */
      _attachCookies(request_) {
        const url = new URL(request_.url);
        const access = new CookieAccessInfo(url.hostname, url.pathname, url.protocol === "https:");
        const cookies = this.jar.getCookies(access).toValueString();
        request_.cookies = cookies;
      }
    };
    for (const name of methods) {
      const method = name.toUpperCase();
      if (method === "QUERY") continue;
      Agent.prototype[name] = function(url, fn) {
        const request_ = new request2.Request(method, url);
        request_.on("response", this._saveCookies.bind(this));
        request_.on("redirect", this._saveCookies.bind(this));
        request_.on("redirect", this._attachCookies.bind(this, request_));
        this._setDefaults(request_);
        this._attachCookies(request_);
        if (fn) {
          request_.end(fn);
        }
        return request_;
      };
    }
    Agent.prototype.del = Agent.prototype.delete;
    var proxyAgent = new Proxy(Agent, {
      apply(target, thisArg, argumentsList) {
        return new target(...argumentsList);
      }
    });
    module2.exports = proxyAgent;
  }
});

// node_modules/superagent/lib/node/parsers/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/superagent/lib/node/parsers/urlencoded.js"(exports2, module2) {
    "use strict";
    var qs = require_lib();
    module2.exports = (res, fn) => {
      res.text = "";
      res.setEncoding("ascii");
      res.on("data", (chunk) => {
        res.text += chunk;
      });
      res.on("end", () => {
        try {
          fn(null, qs.parse(res.text));
        } catch (err) {
          fn(err);
        }
      });
    };
  }
});

// node_modules/superagent/lib/node/parsers/json.js
var require_json = __commonJS({
  "node_modules/superagent/lib/node/parsers/json.js"(exports2, module2) {
    "use strict";
    module2.exports = function(res, fn) {
      res.text = "";
      res.setEncoding("utf8");
      res.on("data", (chunk) => {
        res.text += chunk;
      });
      res.on("end", () => {
        let body;
        let error2;
        try {
          body = res.text && JSON.parse(res.text);
        } catch (err) {
          error2 = err;
          error2.rawResponse = res.text || null;
          error2.statusCode = res.statusCode;
        } finally {
          fn(error2, body);
        }
      });
    };
  }
});

// node_modules/superagent/lib/node/parsers/text.js
var require_text = __commonJS({
  "node_modules/superagent/lib/node/parsers/text.js"(exports2, module2) {
    "use strict";
    module2.exports = (res, fn) => {
      res.text = "";
      res.setEncoding("utf8");
      res.on("data", (chunk) => {
        res.text += chunk;
      });
      res.on("end", fn);
    };
  }
});

// node_modules/superagent/lib/node/parsers/image.js
var require_image = __commonJS({
  "node_modules/superagent/lib/node/parsers/image.js"(exports2, module2) {
    "use strict";
    module2.exports = (res, fn) => {
      const data = [];
      res.on("data", (chunk) => {
        data.push(chunk);
      });
      res.on("end", () => {
        fn(null, Buffer.concat(data));
      });
    };
  }
});

// node_modules/superagent/lib/node/parsers/index.js
var require_parsers = __commonJS({
  "node_modules/superagent/lib/node/parsers/index.js"(exports2) {
    "use strict";
    exports2["application/x-www-form-urlencoded"] = require_urlencoded();
    exports2["application/json"] = require_json();
    exports2.text = require_text();
    exports2["application/json-seq"] = exports2.text;
    var binary = require_image();
    exports2["application/octet-stream"] = binary;
    exports2["application/pdf"] = binary;
    exports2.image = binary;
  }
});

// node_modules/superagent/lib/node/index.js
var require_node2 = __commonJS({
  "node_modules/superagent/lib/node/index.js"(exports2, module2) {
    "use strict";
    var {
      format
    } = require("url");
    var Stream = require("stream");
    var https = require("https");
    var http = require("http");
    var fs = require("fs");
    var zlib = require("zlib");
    var util = require("util");
    var qs = require_lib();
    var mime = require_mime();
    var methods = require_methods();
    var FormData = require_form_data();
    var formidable = require_dist();
    var debug = require_src2()("superagent");
    var CookieJar = require_cookiejar();
    var safeStringify = require_fast_safe_stringify();
    var utils = require_utils3();
    var RequestBase = require_request_base();
    var http2 = require_http2wrapper();
    var {
      decompress
    } = require_unzip();
    var Response2 = require_response();
    var {
      mixin,
      hasOwn,
      isBrotliEncoding,
      isGzipOrDeflateEncoding
    } = utils;
    var {
      chooseDecompresser
    } = require_decompress();
    function request2(method, url) {
      if (typeof url === "function") {
        return new exports2.Request("GET", method).end(url);
      }
      if (arguments.length === 1) {
        return new exports2.Request("GET", method);
      }
      return new exports2.Request(method, url);
    }
    module2.exports = request2;
    exports2 = module2.exports;
    exports2.Request = Request2;
    exports2.agent = require_agent();
    function noop() {
    }
    exports2.Response = Response2;
    mime.define({
      "application/x-www-form-urlencoded": ["form", "urlencoded", "form-data"]
    }, true);
    exports2.protocols = {
      "http:": http,
      "https:": https,
      "http2:": http2
    };
    exports2.serialize = {
      "application/x-www-form-urlencoded": (obj) => {
        return qs.stringify(obj, {
          indices: false,
          strictNullHandling: true
        });
      },
      "application/json": safeStringify
    };
    exports2.parse = require_parsers();
    exports2.buffer = {};
    function _initHeaders(request_) {
      request_._header = {
        // coerces header names to lowercase
      };
      request_.header = {
        // preserves header name case
      };
    }
    function Request2(method, url) {
      Stream.call(this);
      if (typeof url !== "string") url = format(url);
      this._enableHttp2 = Boolean(process.env.HTTP2_TEST);
      this._agent = false;
      this._formData = null;
      this.method = method;
      this.url = url;
      _initHeaders(this);
      this.writable = true;
      this._redirects = 0;
      this.redirects(method === "HEAD" ? 0 : 5);
      this.cookies = "";
      this.qs = {};
      this._query = [];
      this.qsRaw = this._query;
      this._redirectList = [];
      this._streamRequest = false;
      this._lookup = void 0;
      this.once("end", this.clearTimeout.bind(this));
    }
    util.inherits(Request2, Stream);
    mixin(Request2.prototype, RequestBase.prototype);
    Request2.prototype.http2 = function(bool) {
      if (exports2.protocols["http2:"] === void 0) {
        throw new Error("superagent: this version of Node.js does not support http2");
      }
      this._enableHttp2 = bool === void 0 ? true : bool;
      return this;
    };
    Request2.prototype.attach = function(field, file, options2) {
      if (file) {
        if (this._data) {
          throw new Error("superagent can't mix .send() and .attach()");
        }
        let o = options2 || {};
        if (typeof options2 === "string") {
          o = {
            filename: options2
          };
        }
        if (typeof file === "string") {
          if (!o.filename) o.filename = file;
          debug("creating `fs.ReadStream` instance for file: %s", file);
          file = fs.createReadStream(file);
          file.on("error", (error2) => {
            const formData = this._getFormData();
            formData.emit("error", error2);
          });
        } else if (!o.filename && file.path) {
          o.filename = file.path;
        }
        this._getFormData().append(field, file, o);
      }
      return this;
    };
    Request2.prototype._getFormData = function() {
      if (!this._formData) {
        this._formData = new FormData();
        this._formData.on("error", (error2) => {
          debug("FormData error", error2);
          if (this.called) {
            return;
          }
          this.callback(error2);
          this.abort();
        });
      }
      return this._formData;
    };
    Request2.prototype.agent = function(agent) {
      if (arguments.length === 0) return this._agent;
      this._agent = agent;
      return this;
    };
    Request2.prototype.lookup = function(lookup) {
      if (arguments.length === 0) return this._lookup;
      this._lookup = lookup;
      return this;
    };
    Request2.prototype.type = function(type) {
      return this.set("Content-Type", type.includes("/") ? type : mime.getType(type));
    };
    Request2.prototype.accept = function(type) {
      return this.set("Accept", type.includes("/") ? type : mime.getType(type));
    };
    Request2.prototype.query = function(value) {
      if (typeof value === "string") {
        this._query.push(value);
      } else {
        Object.assign(this.qs, value);
      }
      return this;
    };
    Request2.prototype.write = function(data, encoding) {
      const request_ = this.request();
      if (!this._streamRequest) {
        this._streamRequest = true;
      }
      return request_.write(data, encoding);
    };
    Request2.prototype.pipe = function(stream, options2) {
      this.piped = true;
      this.buffer(false);
      this.end();
      return this._pipeContinue(stream, options2);
    };
    Request2.prototype._pipeContinue = function(stream, options2) {
      this.req.once("response", (res) => {
        if (isRedirect(res.statusCode) && this._redirects++ !== this._maxRedirects) {
          return this._redirect(res) === this ? this._pipeContinue(stream, options2) : void 0;
        }
        this.res = res;
        this._emitResponse();
        if (this._aborted) return;
        if (this._shouldDecompress(res)) {
          let decompresser = chooseDecompresser(res);
          decompresser.on("error", (error2) => {
            if (error2 && error2.code === "Z_BUF_ERROR") {
              stream.emit("end");
              return;
            }
            stream.emit("error", error2);
          });
          res.pipe(decompresser).pipe(stream, options2);
          decompresser.once("end", () => this.emit("end"));
        } else {
          res.pipe(stream, options2);
          res.once("end", () => this.emit("end"));
        }
      });
      return stream;
    };
    Request2.prototype.buffer = function(value) {
      this._buffer = value !== false;
      return this;
    };
    Request2.prototype._redirect = function(res) {
      let url = res.headers.location;
      if (!url) {
        return this.callback(new Error("No location header for redirect"), res);
      }
      debug("redirect %s -> %s", this.url, url);
      url = new URL(url, this.url).href;
      res.resume();
      let headers = this.req.getHeaders ? this.req.getHeaders() : this.req._headers;
      const changesOrigin = new URL(url).host !== new URL(this.url).host;
      if (res.statusCode === 301 || res.statusCode === 302) {
        headers = utils.cleanHeader(headers, changesOrigin);
        this.method = this.method === "HEAD" ? "HEAD" : "GET";
        this._data = null;
      }
      if (res.statusCode === 303) {
        headers = utils.cleanHeader(headers, changesOrigin);
        this.method = "GET";
        this._data = null;
      }
      delete headers.host;
      delete this.req;
      delete this._formData;
      _initHeaders(this);
      this.res = res;
      this._endCalled = false;
      this.url = url;
      this.qs = {};
      this._query.length = 0;
      this.set(headers);
      this._emitRedirect();
      this._redirectList.push(this.url);
      this.end(this._callback);
      return this;
    };
    Request2.prototype.auth = function(user, pass, options2) {
      if (arguments.length === 1) pass = "";
      if (typeof pass === "object" && pass !== null) {
        options2 = pass;
        pass = "";
      }
      if (!options2) {
        options2 = {
          type: "basic"
        };
      }
      const encoder = (string) => Buffer.from(string).toString("base64");
      return this._auth(user, pass, options2, encoder);
    };
    Request2.prototype.ca = function(cert) {
      this._ca = cert;
      return this;
    };
    Request2.prototype.key = function(cert) {
      this._key = cert;
      return this;
    };
    Request2.prototype.pfx = function(cert) {
      if (typeof cert === "object" && !Buffer.isBuffer(cert)) {
        this._pfx = cert.pfx;
        this._passphrase = cert.passphrase;
      } else {
        this._pfx = cert;
      }
      return this;
    };
    Request2.prototype.cert = function(cert) {
      this._cert = cert;
      return this;
    };
    Request2.prototype.disableTLSCerts = function() {
      this._disableTLSCerts = true;
      return this;
    };
    Request2.prototype.request = function() {
      if (this.req) return this.req;
      const options2 = {};
      try {
        const query = qs.stringify(this.qs, {
          indices: false,
          strictNullHandling: true
        });
        if (query) {
          this.qs = {};
          this._query.push(query);
        }
        this._finalizeQueryString();
      } catch (err) {
        return this.emit("error", err);
      }
      let {
        url: urlString
      } = this;
      const retries = this._retries;
      if (urlString.indexOf("http") !== 0) urlString = `http://${urlString}`;
      const url = new URL(urlString);
      let {
        protocol
      } = url;
      let path = `${url.pathname}${url.search}`;
      if (/^https?\+unix:/.test(protocol) === true) {
        protocol = `${protocol.split("+")[0]}:`;
        options2.socketPath = url.hostname.replace(/%2F/g, "/");
        url.host = "";
        url.hostname = "";
      }
      if (this._connectOverride) {
        const {
          hostname
        } = url;
        const match = hostname in this._connectOverride ? this._connectOverride[hostname] : this._connectOverride["*"];
        if (match) {
          if (!this._header.host) {
            this.set("host", url.host);
          }
          let newHost;
          let newPort;
          if (typeof match === "object") {
            newHost = match.host;
            newPort = match.port;
          } else {
            newHost = match;
            newPort = url.port;
          }
          url.host = /:/.test(newHost) ? `[${newHost}]` : newHost;
          if (newPort) {
            url.host += `:${newPort}`;
            url.port = newPort;
          }
          url.hostname = newHost;
        }
      }
      options2.method = this.method;
      options2.port = url.port;
      options2.path = path;
      options2.host = utils.normalizeHostname(url.hostname);
      options2.ca = this._ca;
      options2.key = this._key;
      options2.pfx = this._pfx;
      options2.cert = this._cert;
      options2.passphrase = this._passphrase;
      options2.agent = this._agent;
      options2.lookup = this._lookup;
      options2.rejectUnauthorized = typeof this._disableTLSCerts === "boolean" ? !this._disableTLSCerts : process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0";
      if (this._header.host) {
        options2.servername = this._header.host.replace(/:\d+$/, "");
      }
      if (this._trustLocalhost && /^(?:localhost|127\.0\.0\.\d+|(0*:)+:0*1)$/.test(url.hostname)) {
        options2.rejectUnauthorized = false;
      }
      const module_ = this._enableHttp2 ? exports2.protocols["http2:"].setProtocol(protocol) : exports2.protocols[protocol];
      this.req = module_.request(options2);
      const {
        req
      } = this;
      req.setNoDelay(true);
      if (options2.method !== "HEAD") {
        req.setHeader("Accept-Encoding", "gzip, deflate");
      }
      this.protocol = protocol;
      this.host = url.host;
      req.once("drain", () => {
        this.emit("drain");
      });
      req.on("error", (error2) => {
        if (this._aborted) return;
        if (this._retries !== retries) return;
        if (this.response) return;
        this.callback(error2);
      });
      if (url.username || url.password) {
        this.auth(url.username, url.password);
      }
      if (this.username && this.password) {
        this.auth(this.username, this.password);
      }
      for (const key in this.header) {
        if (hasOwn(this.header, key)) req.setHeader(key, this.header[key]);
      }
      if (this.cookies) {
        if (hasOwn(this._header, "cookie")) {
          const temporaryJar = new CookieJar.CookieJar();
          temporaryJar.setCookies(this._header.cookie.split("; "));
          temporaryJar.setCookies(this.cookies.split("; "));
          req.setHeader("Cookie", temporaryJar.getCookies(CookieJar.CookieAccessInfo.All).toValueString());
        } else {
          req.setHeader("Cookie", this.cookies);
        }
      }
      return req;
    };
    Request2.prototype.callback = function(error2, res) {
      if (this._shouldRetry(error2, res)) {
        return this._retry();
      }
      const fn = this._callback || noop;
      this.clearTimeout();
      if (this.called) return console.warn("superagent: double callback bug");
      this.called = true;
      if (!error2) {
        try {
          if (!this._isResponseOK(res)) {
            let message = "Unsuccessful HTTP response";
            if (res) {
              message = http.STATUS_CODES[res.status] || message;
            }
            error2 = new Error(message);
            error2.status = res ? res.status : void 0;
          }
        } catch (err) {
          error2 = err;
          error2.status = error2.status || (res ? res.status : void 0);
        }
      }
      if (!error2) {
        return fn(null, res);
      }
      error2.response = res;
      if (this._maxRetries) error2.retries = this._retries - 1;
      if (error2 && this.listeners("error").length > 0) {
        this.emit("error", error2);
      }
      fn(error2, res);
    };
    Request2.prototype._isHost = function(object) {
      return Buffer.isBuffer(object) || object instanceof Stream || object instanceof FormData;
    };
    Request2.prototype._emitResponse = function(body, files) {
      const response = new Response2(this);
      this.response = response;
      response.redirects = this._redirectList;
      if (void 0 !== body) {
        response.body = body;
      }
      response.files = files;
      if (this._endCalled) {
        response.pipe = function() {
          throw new Error("end() has already been called, so it's too late to start piping");
        };
      }
      this.emit("response", response);
      return response;
    };
    Request2.prototype._emitRedirect = function() {
      const response = new Response2(this);
      response.redirects = this._redirectList;
      this.emit("redirect", response);
    };
    Request2.prototype.end = function(fn) {
      this.request();
      debug("%s %s", this.method, this.url);
      if (this._endCalled) {
        throw new Error(".end() was called twice. This is not supported in superagent");
      }
      this._endCalled = true;
      this._callback = fn || noop;
      this._end();
    };
    Request2.prototype._end = function() {
      if (this._aborted) return this.callback(new Error("The request has been aborted even before .end() was called"));
      let data = this._data;
      const {
        req
      } = this;
      const {
        method
      } = this;
      this._setTimeouts();
      if (method !== "HEAD" && !req._headerSent) {
        if (typeof data !== "string") {
          let contentType = req.getHeader("Content-Type");
          if (contentType) contentType = contentType.split(";")[0];
          let serialize = this._serializer || exports2.serialize[contentType];
          if (!serialize && isJSON(contentType)) {
            serialize = exports2.serialize["application/json"];
          }
          if (serialize) data = serialize(data);
        }
        if (data && !req.getHeader("Content-Length")) {
          req.setHeader("Content-Length", Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data));
        }
      }
      req.once("response", (res) => {
        debug("%s %s -> %s", this.method, this.url, res.statusCode);
        if (this._responseTimeoutTimer) {
          clearTimeout(this._responseTimeoutTimer);
        }
        if (this.piped) {
          return;
        }
        const max = this._maxRedirects;
        const mime2 = utils.type(res.headers["content-type"] || "") || "text/plain";
        let type = mime2.split("/")[0];
        if (type) type = type.toLowerCase().trim();
        const multipart = type === "multipart";
        const redirect = isRedirect(res.statusCode);
        const responseType = this._responseType;
        this.res = res;
        if (redirect && this._redirects++ !== max) {
          return this._redirect(res);
        }
        if (this.method === "HEAD") {
          this.emit("end");
          this.callback(null, this._emitResponse());
          return;
        }
        if (this._shouldDecompress(res)) {
          decompress(req, res);
        }
        let buffer = this._buffer;
        if (buffer === void 0 && mime2 in exports2.buffer) {
          buffer = Boolean(exports2.buffer[mime2]);
        }
        let parser = this._parser;
        if (void 0 === buffer && parser) {
          console.warn("A custom superagent parser has been set, but buffering strategy for the parser hasn't been configured. Call `req.buffer(true or false)` or set `superagent.buffer[mime] = true or false`");
          buffer = true;
        }
        if (!parser) {
          if (responseType) {
            parser = exports2.parse.image;
            buffer = true;
          } else if (multipart) {
            const form = formidable.formidable();
            parser = (res2, callback) => {
              const bridgeStream = new Stream.PassThrough();
              bridgeStream.method = this.method || "POST";
              bridgeStream.url = this.url || "/";
              bridgeStream.httpVersion = res2.httpVersion || "1.1";
              bridgeStream.headers = res2.headers || {};
              bridgeStream.socket = res2.socket || {
                readable: true
              };
              res2.pipe(bridgeStream);
              form.parse(bridgeStream, (err, fields, files) => {
                if (err) return callback(err);
                const flattenedFields = {};
                if (fields) {
                  for (const key in fields) {
                    const value = fields[key];
                    flattenedFields[key] = Array.isArray(value) && value.length === 1 ? value[0] : value;
                  }
                }
                const flattenedFiles = {};
                if (files) {
                  for (const key in files) {
                    const value = files[key];
                    flattenedFiles[key] = Array.isArray(value) && value.length === 1 ? value[0] : value;
                  }
                }
                callback(null, flattenedFields, flattenedFiles);
              });
            };
            buffer = true;
          } else if (isBinary(mime2)) {
            parser = exports2.parse.image;
            buffer = true;
          } else if (exports2.parse[mime2]) {
            parser = exports2.parse[mime2];
          } else if (type === "text") {
            parser = exports2.parse.text;
            buffer = buffer !== false;
          } else if (isJSON(mime2)) {
            parser = exports2.parse["application/json"];
            buffer = buffer !== false;
          } else if (buffer) {
            parser = exports2.parse.text;
          } else if (void 0 === buffer) {
            parser = exports2.parse.image;
            buffer = true;
          }
        }
        if (void 0 === buffer && isText(mime2) || isJSON(mime2)) {
          buffer = true;
        }
        this._resBuffered = buffer;
        let parserHandlesEnd = false;
        if (buffer) {
          let responseBytesLeft = this._maxResponseSize || 2e8;
          res.on("data", (buf) => {
            responseBytesLeft -= buf.byteLength || buf.length > 0 ? buf.length : 0;
            if (responseBytesLeft < 0) {
              const error2 = new Error("Maximum response size reached");
              error2.code = "ETOOLARGE";
              parserHandlesEnd = false;
              res.destroy(error2);
              this.callback(error2, null);
            }
          });
        }
        if (parser) {
          try {
            parserHandlesEnd = buffer;
            parser(res, (error2, object, files) => {
              if (this.timedout) {
                return;
              }
              if (error2 && !this._aborted) {
                return this.callback(error2);
              }
              if (parserHandlesEnd) {
                this.emit("end");
                this.callback(null, this._emitResponse(object, files));
              }
            });
          } catch (err) {
            this.callback(err);
            return;
          }
        }
        this.res = res;
        if (!buffer) {
          debug("unbuffered %s %s", this.method, this.url);
          this.callback(null, this._emitResponse());
          if (multipart) return;
          res.once("end", () => {
            debug("end %s %s", this.method, this.url);
            this.emit("end");
          });
          return;
        }
        res.once("error", (error2) => {
          parserHandlesEnd = false;
          this.callback(error2, null);
        });
        if (!parserHandlesEnd) res.once("end", () => {
          debug("end %s %s", this.method, this.url);
          this.emit("end");
          this.callback(null, this._emitResponse());
        });
      });
      this.emit("request", this);
      const getProgressMonitor = () => {
        const lengthComputable = true;
        const total = req.getHeader("Content-Length");
        let loaded = 0;
        const progress = new Stream.Transform();
        progress._transform = (chunk, encoding, callback) => {
          loaded += chunk.length;
          this.emit("progress", {
            direction: "upload",
            lengthComputable,
            loaded,
            total
          });
          callback(null, chunk);
        };
        return progress;
      };
      const bufferToChunks = (buffer) => {
        const chunkSize = 16 * 1024;
        const chunking = new Stream.Readable();
        const totalLength = buffer.length;
        const remainder = totalLength % chunkSize;
        const cutoff = totalLength - remainder;
        for (let i = 0; i < cutoff; i += chunkSize) {
          const chunk = buffer.slice(i, i + chunkSize);
          chunking.push(chunk);
        }
        if (remainder > 0) {
          const remainderBuffer = buffer.slice(-remainder);
          chunking.push(remainderBuffer);
        }
        chunking.push(null);
        return chunking;
      };
      const formData = this._formData;
      if (formData) {
        const headers = formData.getHeaders();
        for (const i in headers) {
          if (hasOwn(headers, i)) {
            debug('setting FormData header: "%s: %s"', i, headers[i]);
            req.setHeader(i, headers[i]);
          }
        }
        formData.getLength((error2, length) => {
          if (error2) debug("formData.getLength had error", error2, length);
          debug("got FormData Content-Length: %s", length);
          if (typeof length === "number") {
            req.setHeader("Content-Length", length);
          }
          formData.pipe(getProgressMonitor()).pipe(req);
        });
      } else if (Buffer.isBuffer(data)) {
        bufferToChunks(data).pipe(getProgressMonitor()).pipe(req);
      } else {
        req.end(data);
      }
    };
    Request2.prototype._shouldDecompress = (res) => {
      return hasNonEmptyResponseContent(res) && (isGzipOrDeflateEncoding(res) || isBrotliEncoding(res));
    };
    Request2.prototype.connect = function(connectOverride) {
      if (typeof connectOverride === "string") {
        this._connectOverride = {
          "*": connectOverride
        };
      } else if (typeof connectOverride === "object") {
        this._connectOverride = connectOverride;
      } else {
        this._connectOverride = void 0;
      }
      return this;
    };
    Request2.prototype.trustLocalhost = function(toggle) {
      this._trustLocalhost = toggle === void 0 ? true : toggle;
      return this;
    };
    if (!methods.includes("del")) {
      methods = [...methods];
      methods.push("del");
    }
    for (let method of methods) {
      const name = method;
      method = method === "del" ? "delete" : method;
      method = method.toUpperCase();
      request2[name] = (url, data, fn) => {
        const request_ = request2(method, url);
        if (typeof data === "function") {
          fn = data;
          data = null;
        }
        if (data) {
          if (method === "GET" || method === "HEAD") {
            request_.query(data);
          } else {
            request_.send(data);
          }
        }
        if (fn) request_.end(fn);
        return request_;
      };
    }
    function isText(mime2) {
      const parts = mime2.split("/");
      let type = parts[0];
      if (type) type = type.toLowerCase().trim();
      let subtype = parts[1];
      if (subtype) subtype = subtype.toLowerCase().trim();
      return type === "text" || subtype === "x-www-form-urlencoded";
    }
    function isBinary(mime2) {
      let [registry, name] = mime2.split("/");
      if (registry) registry = registry.toLowerCase().trim();
      if (name) name = name.toLowerCase().trim();
      return ["audio", "font", "image", "video"].includes(registry) || ["gz", "gzip"].includes(name);
    }
    function isJSON(mime2) {
      return /[/+]json($|[^-\w])/i.test(mime2);
    }
    function isRedirect(code) {
      return [301, 302, 303, 305, 307, 308].includes(code);
    }
    function hasNonEmptyResponseContent(res) {
      if (res.statusCode === 204 || res.statusCode === 304) {
        return false;
      }
      if (res.headers["content-length"] === "0") {
        return false;
      }
      return true;
    }
  }
});

// node_modules/supertest/lib/test.js
var require_test = __commonJS({
  "node_modules/supertest/lib/test.js"(exports2, module2) {
    "use strict";
    var { inspect } = require("util");
    var http = require("http");
    var { STATUS_CODES } = require("http");
    var { Server } = require("tls");
    var { deepStrictEqual } = require("assert");
    var { Request: Request2 } = require_node2();
    var http2;
    try {
      http2 = require("http2");
    } catch (_) {
    }
    var Test = class extends Request2 {
      /**
       * Initialize a new `Test` with the given `app`,
       * request `method` and `path`.
       *
       * @param {Server} app
       * @param {String} method
       * @param {String} path
       * @api public
       */
      constructor(app, method, path, optHttp2) {
        super(method.toUpperCase(), path);
        if (typeof app === "function") {
          if (optHttp2) {
            app = http2.createServer(app);
          } else {
            app = http.createServer(app);
          }
        }
        this.redirects(0);
        this.buffer();
        this.app = app;
        this._asserts = [];
        this.url = typeof app === "string" ? app + path : this.serverAddress(app, path);
      }
      /**
       * Returns a URL, extracted from a server.
       *
       * @param {Server} app
       * @param {String} path
       * @returns {String} URL address
       * @api private
       */
      serverAddress(app, path) {
        const addr = app.address();
        if (!addr) this._server = app.listen(0);
        const port = app.address().port;
        const protocol = app instanceof Server ? "https" : "http";
        return protocol + "://127.0.0.1:" + port + path;
      }
      /**
       * Expectations:
       *
       *   .expect(200)
       *   .expect(200, fn)
       *   .expect(200, body)
       *   .expect('Some body')
       *   .expect('Some body', fn)
       *   .expect(['json array body', { key: 'val' }])
       *   .expect('Content-Type', 'application/json')
       *   .expect('Content-Type', 'application/json', fn)
       *   .expect(fn)
       *   .expect([200, 404])
       *
       * @return {Test}
       * @api public
       */
      expect(a, b, c) {
        if (typeof a === "function") {
          this._asserts.push(wrapAssertFn(a));
          return this;
        }
        if (typeof b === "function") this.end(b);
        if (typeof c === "function") this.end(c);
        if (typeof a === "number") {
          this._asserts.push(wrapAssertFn(this._assertStatus.bind(this, a)));
          if (typeof b !== "function" && arguments.length > 1) {
            this._asserts.push(wrapAssertFn(this._assertBody.bind(this, b)));
          }
          return this;
        }
        if (Array.isArray(a) && a.length > 0 && a.every((val) => typeof val === "number")) {
          this._asserts.push(wrapAssertFn(this._assertStatusArray.bind(this, a)));
          return this;
        }
        if (typeof b === "string" || typeof b === "number" || b instanceof RegExp) {
          this._asserts.push(wrapAssertFn(this._assertHeader.bind(this, { name: "" + a, value: b })));
          return this;
        }
        this._asserts.push(wrapAssertFn(this._assertBody.bind(this, a)));
        return this;
      }
      /**
       * Defer invoking superagent's `.end()` until
       * the server is listening.
       *
       * @param {?Function} fn
       * @api public
       */
      end(fn) {
        const server = this._server;
        super.end((err, res) => {
          const localAssert = () => {
            this.assert(err, res, fn);
          };
          if (server && server._handle) {
            return server.close((closeError) => {
              if (closeError && closeError.code === "ERR_SERVER_NOT_RUNNING") {
                return localAssert();
              }
              if (closeError) {
                return localAssert();
              }
              localAssert();
            });
          }
          localAssert();
        });
        return this;
      }
      /**
       * Perform assertions and invoke `fn(err, res)`.
       *
       * @param {?Error} resError
       * @param {Response} res
       * @param {Function} fn
       * @api private
       */
      assert(resError, res, fn) {
        let errorObj;
        const sysErrors = {
          ECONNREFUSED: "Connection refused",
          ECONNRESET: "Connection reset by peer",
          EPIPE: "Broken pipe",
          ETIMEDOUT: "Operation timed out"
        };
        if (!res && resError) {
          if (resError instanceof Error && resError.syscall === "connect" && Object.getOwnPropertyNames(sysErrors).indexOf(resError.code) >= 0) {
            errorObj = new Error(resError.code + ": " + sysErrors[resError.code]);
          } else {
            errorObj = resError;
          }
        }
        for (let i = 0; i < this._asserts.length && !errorObj; i += 1) {
          errorObj = this._assertFunction(this._asserts[i], res);
        }
        if (!errorObj && resError instanceof Error && (!res || resError.status !== res.status)) {
          errorObj = resError;
        }
        if (fn) {
          fn.call(this, errorObj || null, res);
        }
      }
      /*
        * Adds a set Authorization Bearer
        *
        * @param {Bearer} Bearer Token
        * Shortcut for .set('Authorization', `Bearer ${token}`)
        */
      bearer(token) {
        this.set("Authorization", `Bearer ${token}`);
        return this;
      }
      /*
        * Adds a set Authorization Bearer
        *
        * @param {Bearer} Bearer Token
        * Shortcut for .set('Authorization', `Bearer ${token}`)
        */
      bearer(token) {
        this.set("Authorization", `Bearer ${token}`);
        return this;
      }
      /**
       * Perform assertions on a response body and return an Error upon failure.
       *
       * @param {Mixed} body
       * @param {Response} res
       * @return {?Error}
       * @api private
       */
      // eslint-disable-next-line class-methods-use-this
      _assertBody(body, res) {
        const isRegexp = body instanceof RegExp;
        if (typeof body === "object" && !isRegexp) {
          try {
            deepStrictEqual(body, res.body);
          } catch (err) {
            const a = inspect(body);
            const b = inspect(res.body);
            return error2("expected " + a + " response body, got " + b, body, res.body);
          }
        } else if (body !== res.text) {
          const a = inspect(body);
          const b = inspect(res.text);
          if (isRegexp) {
            if (!body.test(res.text)) {
              return error2("expected body " + b + " to match " + body, body, res.body);
            }
          } else {
            return error2("expected " + a + " response body, got " + b, body, res.body);
          }
        }
      }
      /**
       * Perform assertions on a response header and return an Error upon failure.
       *
       * @param {Object} header
       * @param {Response} res
       * @return {?Error}
       * @api private
       */
      // eslint-disable-next-line class-methods-use-this
      _assertHeader(header, res) {
        const field = header.name;
        const actual = res.header[field.toLowerCase()];
        const fieldExpected = header.value;
        if (typeof actual === "undefined") return new Error('expected "' + field + '" header field');
        if (Array.isArray(actual) && actual.toString() === fieldExpected || fieldExpected === actual) {
          return;
        }
        if (fieldExpected instanceof RegExp) {
          if (!fieldExpected.test(actual)) {
            return new Error('expected "' + field + '" matching ' + fieldExpected + ', got "' + actual + '"');
          }
        } else {
          return new Error('expected "' + field + '" of "' + fieldExpected + '", got "' + actual + '"');
        }
      }
      /**
       * Perform assertions on the response status and return an Error upon failure.
       *
       * @param {Number} status
       * @param {Response} res
       * @return {?Error}
       * @api private
       */
      // eslint-disable-next-line class-methods-use-this
      _assertStatus(status, res) {
        if (res.status !== status) {
          const a = STATUS_CODES[status];
          const b = STATUS_CODES[res.status];
          return new Error("expected " + status + ' "' + a + '", got ' + res.status + ' "' + b + '"');
        }
      }
      /**
       * Perform assertions on the response status and return an Error upon failure.
       *
       * @param {Array<Number>} statusArray
       * @param {Response} res
       * @return {?Error}
       * @api private
       */
      // eslint-disable-next-line class-methods-use-this
      _assertStatusArray(statusArray, res) {
        if (!statusArray.includes(res.status)) {
          const b = STATUS_CODES[res.status];
          const expectedList = statusArray.join(", ");
          return new Error(
            'expected one of "' + expectedList + '", got ' + res.status + ' "' + b + '"'
          );
        }
      }
      /**
       * Performs an assertion by calling a function and return an Error upon failure.
       *
       * @param {Function} fn
       * @param {Response} res
       * @return {?Error}
       * @api private
       */
      // eslint-disable-next-line class-methods-use-this
      _assertFunction(fn, res) {
        let err;
        try {
          err = fn(res);
        } catch (e) {
          err = e;
        }
        if (err instanceof Error) return err;
      }
    };
    function wrapAssertFn(assertFn) {
      const savedStack = new Error().stack.split("\n").slice(3);
      return function(res) {
        let badStack;
        let err;
        try {
          err = assertFn(res);
        } catch (e) {
          err = e;
        }
        if (err instanceof Error && err.stack) {
          badStack = err.stack.replace(err.message, "").split("\n").slice(1);
          err.stack = [err.toString()].concat(savedStack).concat("----").concat(badStack).join("\n");
        }
        return err;
      };
    }
    function error2(msg, expected, actual) {
      const err = new Error(msg);
      err.expected = expected;
      err.actual = actual;
      err.showDiff = true;
      return err;
    }
    module2.exports = Test;
  }
});

// node_modules/supertest/lib/agent.js
var require_agent2 = __commonJS({
  "node_modules/supertest/lib/agent.js"(exports2, module2) {
    "use strict";
    var { agent: Agent } = require_node2();
    var methods = require_methods();
    var http = require("http");
    var http2;
    try {
      http2 = require("http2");
    } catch (_) {
    }
    var Test = require_test();
    function TestAgent(app, options2 = {}) {
      if (!(this instanceof TestAgent)) return new TestAgent(app, options2);
      const agent = new Agent(options2);
      Object.assign(this, agent);
      this._options = options2;
      if (typeof app === "function") {
        if (options2.http2) {
          if (!http2) {
            throw new Error(
              "supertest: this version of Node.js does not support http2"
            );
          }
          app = http2.createServer(app);
        } else {
          app = http.createServer(app);
        }
      }
      this.app = app;
    }
    Object.setPrototypeOf(TestAgent.prototype, Agent.prototype);
    var originalQuery = Agent.prototype.query;
    TestAgent.prototype.host = function(host) {
      this._host = host;
      return this;
    };
    methods.forEach(function(method) {
      if (method === "query") {
        return;
      }
      TestAgent.prototype[method] = function(url, fn) {
        const req = new Test(this.app, method.toUpperCase(), url);
        if (this._options.http2) {
          req.http2();
        }
        if (this._host) {
          req.set("host", this._host);
        }
        req.on("response", this._saveCookies.bind(this));
        req.on("redirect", this._saveCookies.bind(this));
        req.on("redirect", this._attachCookies.bind(this, req));
        this._setDefaults(req);
        this._attachCookies(req);
        return req;
      };
    });
    TestAgent.prototype.query = originalQuery;
    TestAgent.prototype.del = TestAgent.prototype.delete;
    module2.exports = TestAgent;
  }
});

// node_modules/supertest/index.js
var require_supertest = __commonJS({
  "node_modules/supertest/index.js"(exports2, module2) {
    "use strict";
    var methods = require_methods();
    var http2;
    try {
      http2 = require("http2");
    } catch (_) {
    }
    var Test = require_test();
    var agent = require_agent2();
    module2.exports = function(app, options2 = {}) {
      const obj = {};
      if (typeof app === "function") {
        if (options2.http2) {
          if (!http2) {
            throw new Error(
              "supertest: this version of Node.js does not support http2"
            );
          }
        }
      }
      methods.forEach(function(method) {
        obj[method] = function(url) {
          var test = new Test(app, method, url, options2.http2);
          if (options2.http2) {
            test.http2();
          }
          return test;
        };
      });
      obj.del = obj.delete;
      return obj;
    };
    module2.exports.Test = Test;
    module2.exports.agent = agent;
  }
});

// node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env2, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env2.stack.push({ value, dispose, async });
  } else if (async) {
    env2.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env2) {
  function fail(e) {
    env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
    env2.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env2.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env2.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
    if (env2.hasError) throw env2.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    "use strict";
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __esDecorate,
      __runInitializers,
      __propKey,
      __setFunctionName,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources,
      __rewriteRelativeImportExtension
    };
  }
});

// node_modules/mongodb-memory-server-core/node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/camelcase/index.js"(exports2, module2) {
    "use strict";
    var UPPERCASE = /[\p{Lu}]/u;
    var LOWERCASE = /[\p{Ll}]/u;
    var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
    var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
    var SEPARATORS = /[_.\- ]+/;
    var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
    var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
    var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
    var preserveCamelCase = (string, toLowerCase, toUpperCase) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string.length; i++) {
        const character = string[i];
        if (isLastCharLower && UPPERCASE.test(character)) {
          string = string.slice(0, i) + "-" + string.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
          string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
        }
      }
      return string;
    };
    var preserveConsecutiveUppercase = (input, toLowerCase) => {
      LEADING_CAPITAL.lastIndex = 0;
      return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
    };
    var postProcess = (input, toUpperCase) => {
      SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
      NUMBERS_AND_IDENTIFIER.lastIndex = 0;
      return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
    };
    var camelCase = (input, options2) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options2 = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options2
      };
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      const toLowerCase = options2.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options2.locale);
      const toUpperCase = options2.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options2.locale);
      if (input.length === 1) {
        return options2.pascalCase ? toUpperCase(input) : toLowerCase(input);
      }
      const hasUpperCase = input !== toLowerCase(input);
      if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase);
      }
      input = input.replace(LEADING_SEPARATORS, "");
      if (options2.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input, toLowerCase);
      } else {
        input = toLowerCase(input);
      }
      if (options2.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
      }
      return postProcess(input, toUpperCase);
    };
    module2.exports = camelCase;
    module2.exports.default = camelCase;
  }
});

// node_modules/new-find-package-json/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/new-find-package-json/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findSync = exports2.find = exports2.findAsync = void 0;
    var path = require("path");
    var fs_1 = require("fs");
    var debug = require_src2();
    var log = debug("new-find-package-json:main");
    async function* findAsync(input, base2, fileName) {
      log(`findSync: called with "${input}" and "${base2}" and "${fileName}"`);
      base2 = !!base2 ? base2 : "";
      const useFileName = !!fileName ? fileName : "package.json";
      const useBase = !!base2 || path.isAbsolute(base2) ? base2 : process.cwd();
      let testPath = path.resolve(useBase, input);
      let wasRoot = false;
      while (testPath) {
        if (testPath === path.parse(testPath).root) {
          wasRoot = true;
        }
        const testFile = path.resolve(testPath, useFileName);
        log(`findSync: testing path "${testFile}"`);
        const result = await statPathAsync(testFile);
        if (!!result && result.isFile()) {
          log(`findSync: path exists and is file "${testFile}"`);
          yield testFile;
          log(`findSync: after yield`);
        }
        if (wasRoot) {
          break;
        }
        testPath = path.resolve(testPath, "..");
      }
    }
    exports2.findAsync = findAsync;
    exports2.find = findAsync;
    function* findSync(input, base2, fileName) {
      log(`findSync: called with "${input}" and "${base2}" and "${fileName}"`);
      base2 = !!base2 ? base2 : "";
      const useFileName = !!fileName ? fileName : "package.json";
      const useBase = !!base2 || path.isAbsolute(base2) ? base2 : process.cwd();
      let testPath = path.resolve(useBase, input);
      let wasRoot = false;
      while (testPath) {
        if (testPath === path.parse(testPath).root) {
          wasRoot = true;
        }
        const testFile = path.resolve(testPath, useFileName);
        log(`findSync: testing path "${testFile}"`);
        const result = statPathSync(testFile);
        if (!!result && result.isFile()) {
          log(`findSync: path exists and is file "${testFile}"`);
          yield testFile;
          log(`findSync: after yield`);
        }
        if (wasRoot) {
          break;
        }
        testPath = path.resolve(testPath, "..");
      }
    }
    exports2.findSync = findSync;
    function statPathSync(path2) {
      var _a;
      try {
        return (0, fs_1.statSync)(path2);
      } catch (err) {
        if (err != void 0 && err != null && ((_a = err) === null || _a === void 0 ? void 0 : _a.code) === "ENOENT") {
          return void 0;
        }
        throw err;
      }
    }
    async function statPathAsync(path2) {
      return fs_1.promises.stat(path2).catch((err) => {
        if (err.code === "ENOENT") {
          return void 0;
        }
        throw err;
      });
    }
  }
});

// node_modules/mongodb-memory-server-core/lib/util/errors.js
var require_errors = __commonJS({
  "node_modules/mongodb-memory-server-core/lib/util/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GenericMMSError = exports2.UnknownLinuxDistro = exports2.DownloadError = exports2.UnknownVersionError = exports2.UnexpectedCloseError = exports2.StdoutInstanceError = exports2.KnownVersionIncompatibilityError = exports2.NoRegexMatchError = exports2.ParseArchiveRegexError = exports2.ReplsetCountLowError = exports2.AssertionFallbackError = exports2.BinaryNotFoundError = exports2.InsufficientPermissionsError = exports2.AuthNotObjectError = exports2.KeyFileMissingError = exports2.InstanceInfoError = exports2.StartBinaryFailedError = exports2.Md5CheckFailedError = exports2.WaitForPrimaryTimeoutError = exports2.UnknownArchitectureError = exports2.UnknownPlatformError = exports2.UnableToUnlockLockfileError = exports2.UnknownLockfileStatusError = exports2.StateError = void 0;
    var utils_1 = require_utils4();
    var StateError = class extends Error {
      constructor(wantedStates, gotState) {
        super(`Incorrect State for operation: "${gotState}", allowed States: "[${wantedStates.join(",")}]"
This may be because of using a v6.x way of calling functions, look at the following guide if anything applies:
https://typegoose.github.io/mongodb-memory-server/docs/guides/migration/migrate7#no-function-other-than-start-create-ensureinstance-will-be-starting-anything`);
        this.wantedStates = wantedStates;
        this.gotState = gotState;
      }
    };
    exports2.StateError = StateError;
    var UnknownLockfileStatusError = class extends Error {
      constructor(status) {
        super(`Unknown LockFile Status: "${status}"`);
        this.status = status;
      }
    };
    exports2.UnknownLockfileStatusError = UnknownLockfileStatusError;
    var UnableToUnlockLockfileError = class extends Error {
      constructor(thisInstance, file) {
        super(`Cannot unlock file "${file}", because it is not locked by this ${thisInstance ? "instance" : "process"}`);
        this.thisInstance = thisInstance;
        this.file = file;
      }
    };
    exports2.UnableToUnlockLockfileError = UnableToUnlockLockfileError;
    var UnknownPlatformError = class extends Error {
      constructor(platform) {
        super(`Unknown Platform: "${platform}"`);
        this.platform = platform;
      }
    };
    exports2.UnknownPlatformError = UnknownPlatformError;
    var UnknownArchitectureError = class extends Error {
      constructor(arch, platform) {
        super();
        this.arch = arch;
        this.platform = platform;
        if (!(0, utils_1.isNullOrUndefined)(platform)) {
          this.message = `Unsupported Architecture-Platform combination: arch: "${arch}", platform: "${platform}"`;
        } else {
          this.message = `Unsupported Architecture: "${arch}"`;
        }
      }
    };
    exports2.UnknownArchitectureError = UnknownArchitectureError;
    var WaitForPrimaryTimeoutError = class extends Error {
      constructor(timeout, where) {
        super(`Timed out after ${timeout}ms while waiting for a Primary (where: "${where}")`);
        this.timeout = timeout;
        this.where = where;
      }
    };
    exports2.WaitForPrimaryTimeoutError = WaitForPrimaryTimeoutError;
    var Md5CheckFailedError = class extends Error {
      constructor(binarymd5, checkfilemd5) {
        super(`MD5 check failed! Binary MD5 is "${binarymd5}", Checkfile MD5 is "${checkfilemd5}"`);
        this.binarymd5 = binarymd5;
        this.checkfilemd5 = checkfilemd5;
      }
    };
    exports2.Md5CheckFailedError = Md5CheckFailedError;
    var StartBinaryFailedError = class extends Error {
      constructor(binary) {
        super(`Starting the Binary Failed (PID is undefined)! Binary: "${binary}"`);
        this.binary = binary;
      }
    };
    exports2.StartBinaryFailedError = StartBinaryFailedError;
    var InstanceInfoError = class extends Error {
      constructor(where) {
        super(`"instanceInfo" was undefined when expected to be defined! (where: "${where}")`);
        this.where = where;
      }
    };
    exports2.InstanceInfoError = InstanceInfoError;
    var KeyFileMissingError = class extends Error {
      constructor() {
        super(`"keyfileLocation" was undefined when expected!`);
      }
    };
    exports2.KeyFileMissingError = KeyFileMissingError;
    var AuthNotObjectError = class extends Error {
      constructor() {
        super('"auth" was not a object when it was expected!');
      }
    };
    exports2.AuthNotObjectError = AuthNotObjectError;
    var InsufficientPermissionsError = class extends Error {
      constructor(path) {
        super(`File "${path}" does not have the required Permissions, required Permissions: "--x"`);
        this.path = path;
      }
    };
    exports2.InsufficientPermissionsError = InsufficientPermissionsError;
    var BinaryNotFoundError = class extends Error {
      constructor(path, extra = "") {
        super(`No Binary at path "${path}" was found! (ENOENT)${extra}`);
        this.path = path;
        this.extra = extra;
      }
    };
    exports2.BinaryNotFoundError = BinaryNotFoundError;
    var AssertionFallbackError = class extends Error {
      constructor() {
        super("Assert failed - no custom error");
      }
    };
    exports2.AssertionFallbackError = AssertionFallbackError;
    var ReplsetCountLowError = class extends Error {
      constructor(count) {
        super(`ReplSet Count needs to be 1 or higher! (specified count: "${count}")`);
        this.count = count;
      }
    };
    exports2.ReplsetCountLowError = ReplsetCountLowError;
    var ParseArchiveRegexError = class extends Error {
      constructor(key) {
        super(`Expected "${key}" to be found in regex groups`);
        this.key = key;
      }
    };
    exports2.ParseArchiveRegexError = ParseArchiveRegexError;
    var NoRegexMatchError = class extends Error {
      constructor(name, extra) {
        super();
        this.name = name;
        this.extra = extra;
        const addExtra = !!extra ? `(${extra})` : "";
        this.message = `Expected "${name}" to have Regex Matches${addExtra}`;
      }
    };
    exports2.NoRegexMatchError = NoRegexMatchError;
    var KnownVersionIncompatibilityError = class extends Error {
      constructor(dist, requested_version, available_versions, extra) {
        super();
        this.dist = dist;
        this.requested_version = requested_version;
        this.available_versions = available_versions;
        this.extra = extra;
        const addExtra = !!extra ? `
${extra}` : "";
        this.message = `Requested Version "${requested_version}" is not available for "${dist}"! Available Versions: "${available_versions}"${addExtra}`;
      }
    };
    exports2.KnownVersionIncompatibilityError = KnownVersionIncompatibilityError;
    var StdoutInstanceError = class extends Error {
      // not using "public variable: type", because it is a basic wrapper for "Error"
      constructor(msg) {
        super(msg);
      }
    };
    exports2.StdoutInstanceError = StdoutInstanceError;
    var UnexpectedCloseError = class extends Error {
      constructor(code, signal) {
        super();
        this.message = `Instance closed unexpectedly with code "${code}" and signal "${signal}"`;
        if (signal == "SIGILL") {
          this.message += "\nThe Process Exited with SIGILL, which mean illegal instruction, which is commonly thrown in mongodb 5.0+ when not having AVX available on the CPU";
        }
        if (process.platform === "win32" && (code ?? 0) > 1e9) {
          this.message += "\nExit Code is large, commonly meaning that vc_redist is not installed, the latest vc_redist can be found at https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170";
        }
      }
    };
    exports2.UnexpectedCloseError = UnexpectedCloseError;
    var UnknownVersionError = class extends Error {
      constructor(version) {
        super(`Could not coerce VERSION to a semver version (version: "${version}")`);
        this.version = version;
      }
    };
    exports2.UnknownVersionError = UnknownVersionError;
    var DownloadError = class extends Error {
      constructor(url, msg) {
        super(`Download failed for url "${url}", Details:
${msg}`);
        this.url = url;
        this.msg = msg;
      }
    };
    exports2.DownloadError = DownloadError;
    var UnknownLinuxDistro = class extends Error {
      constructor(distro, id_like) {
        super(`Unknown/unsupported linux "${distro}" id_like's: [${id_like?.join(", ")}]`);
        this.distro = distro;
        this.id_like = id_like;
      }
    };
    exports2.UnknownLinuxDistro = UnknownLinuxDistro;
    var GenericMMSError = class extends Error {
    };
    exports2.GenericMMSError = GenericMMSError;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options2) => {
      if (!options2) {
        return emptyOpts;
      }
      if (typeof options2 !== "object") {
        return looseOption;
      }
      return options2;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options2) {
        options2 = parseOptions(options2);
        if (version instanceof _SemVer) {
          if (version.loose === !!options2.loose && version.includePrerelease === !!options2.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        const m = version.trim().match(options2.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base2 = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base2];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base2);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base2];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/parse.js
var require_parse2 = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = (version, options2, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options2);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse = require_parse2();
    var valid = (version, options2) => {
      const v = parse(version, options2);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse = require_parse2();
    var clean = (version, options2) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options2);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version, release, options2, identifier, identifierBase) => {
      if (typeof options2 === "string") {
        identifierBase = identifier;
        identifier = options2;
        options2 = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options2
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse = require_parse2();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse = require_parse2();
    var prerelease = (version, options2) => {
      const parsed = parse(version, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = require_parse2();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options2) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options2 = options2 || {};
      let match = null;
      if (!options2.rtl) {
        match = version.match(options2.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options2.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options2.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options2.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options2);
    };
    module2.exports = coerce;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/internal/lrucache.js"(exports2, module2) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/classes/range.js
var require_range2 = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options2) {
        options2 = parseOptions(options2);
        if (range instanceof _Range) {
          if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options2);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options2) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options2) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options2);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options2) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options2);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options2) => {
      debug("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug("caret", comp);
      comp = replaceTildes(comp, options2);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug("xrange", comp);
      comp = replaceStars(comp, options2);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options2) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options2)).join(" ");
    };
    var replaceTilde = (comp, options2) => {
      const r = options2.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options2) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options2)).join(" ");
    };
    var replaceCaret = (comp, options2) => {
      debug("caret", comp, options2);
      const r = options2.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z3 = options2.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z3} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z3} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z3} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z3} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z3} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options2) => {
      debug("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options2)).join(" ");
    };
    var replaceXRange = (comp, options2) => {
      comp = comp.trim();
      const r = options2.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options2.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options2) => {
      debug("replaceStars", comp, options2);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options2) => {
      debug("replaceGTE0", comp, options2);
      return comp.trim().replace(re[options2.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options2) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options2.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options2) {
        options2 = parseOptions(options2);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options2.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options2) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options2).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options2).test(comp.semver);
        }
        options2 = parseOptions(options2);
        if (options2.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options2.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options2) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options2) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range2();
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var satisfies = (version, range, options2) => {
      try {
        range = new Range(range, options2);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var toComparators = (range, options2) => new Range(range, options2).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range2();
    var maxSatisfying = (versions, range, options2) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options2);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range2();
    var minSatisfying = (versions, range, options2) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options2);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range2();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var validRange = (range, options2) => {
      try {
        return new Range(range, options2).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range2();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options2) => {
      version = new SemVer(version, options2);
      range = new Range(range, options2);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options2)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options2)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options2)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version, range, options2) => outside(version, range, ">", options2);
    module2.exports = gtr;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version, range, options2) => outside(version, range, "<", options2);
    module2.exports = ltr;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var intersects = (r1, r2, options2) => {
      r1 = new Range(r1, options2);
      r2 = new Range(r2, options2);
      return r1.intersects(r2, options2);
    };
    module2.exports = intersects;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options2) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options2));
      for (const version of v) {
        const included = satisfies(version, range, options2);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range2();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options2 = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options2);
      dom = new Range(dom, options2);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options2);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options2) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options2.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options2.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options2);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options2);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options2);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options2)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options2)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options2)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options2.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options2.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options2);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options2)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options2);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options2)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options2) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options2);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options2) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options2);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/mongodb-memory-server-core/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/mongodb-memory-server-core/node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse2();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range2();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/mongodb-memory-server-core/lib/util/utils.js
var require_utils4 = __commonJS({
  "node_modules/mongodb-memory-server-core/lib/util/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getStorageEngine = exports2.lockfilePath = exports2.md5FromFile = exports2.md5 = exports2.uuidv4 = exports2.removeDir = exports2.createTmpDir = exports2.mkdir = exports2.checkBinaryPermissions = exports2.ManagerAdvanced = exports2.ManagerBase = exports2.tryReleaseFile = exports2.pathExists = exports2.statPath = exports2.authDefault = exports2.ensureAsync = exports2.isAlive = exports2.killProcess = exports2.assertion = exports2.isNullOrUndefined = exports2.uriTemplate = exports2.getHost = exports2.generateDbName = exports2.errorWithCode = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var debug_1 = tslib_1.__importDefault(require_src2());
    var fs_1 = require("fs");
    var errors_1 = require_errors();
    var os_1 = require("os");
    var path = tslib_1.__importStar(require("path"));
    var crypto_1 = require("crypto");
    var semver = tslib_1.__importStar(require_semver2());
    var log = (0, debug_1.default)("MongoMS:utils");
    function errorWithCode(err) {
      return err instanceof Error && "code" in err;
    }
    exports2.errorWithCode = errorWithCode;
    function generateDbName(dbName) {
      return dbName || "";
    }
    exports2.generateDbName = generateDbName;
    function getHost(uri) {
      return uri.replace(/(?:^mongodb:\/{2})|(?:\/.*$)|(?:.*@)/gim, "");
    }
    exports2.getHost = getHost;
    function uriTemplate(host, port, dbName, query) {
      const hosts = !isNullOrUndefined(port) ? `${host}:${port}` : host;
      return `mongodb://${hosts}/${dbName}` + (!isNullOrUndefined(query) ? `?${query.join("&")}` : "");
    }
    exports2.uriTemplate = uriTemplate;
    function isNullOrUndefined(val) {
      return val === null || val === void 0;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function assertion(cond, error2) {
      if (!cond) {
        throw error2 ?? new errors_1.AssertionFallbackError();
      }
    }
    exports2.assertion = assertion;
    async function killProcess(childprocess, name, mongodPort) {
      function ilog(msg) {
        log(`Mongo[${mongodPort || "unknown"}] killProcess: ${msg}`);
      }
      if (isNullOrUndefined(childprocess)) {
        ilog("childprocess was somehow undefined");
        return;
      }
      if (!isAlive(childprocess.pid)) {
        ilog("given childProcess's PID was not alive anymore");
        return;
      }
      const timeoutTime = 1e3 * 10;
      await new Promise((res, rej) => {
        let timeout = setTimeout(() => {
          ilog("timeout triggered, trying SIGKILL");
          if (!debug_1.default.enabled("MongoMS:utils")) {
            console.warn('An Process didnt exit with signal "SIGINT" within 10 seconds, using "SIGKILL"!\nEnable debug logs for more information');
          }
          childprocess.kill("SIGKILL");
          timeout = setTimeout(() => {
            ilog("timeout triggered again, rejecting");
            rej(new Error(`Process "${name}" didnt exit, enable debug for more information.`));
          }, timeoutTime);
        }, timeoutTime);
        childprocess.once(`exit`, (code, signal) => {
          ilog(`${name}: got exit signal, Code: ${code}, Signal: ${signal}`);
          clearTimeout(timeout);
          res();
        });
        ilog(`${name}: sending "SIGINT"`);
        childprocess.kill("SIGINT");
      });
    }
    exports2.killProcess = killProcess;
    function isAlive(pid) {
      if (isNullOrUndefined(pid)) {
        return false;
      }
      try {
        process.kill(pid, 0);
        return true;
      } catch (err) {
        return false;
      }
    }
    exports2.isAlive = isAlive;
    async function ensureAsync() {
      return new Promise((res) => process.nextTick(res));
    }
    exports2.ensureAsync = ensureAsync;
    function authDefault(opts) {
      return {
        force: false,
        enable: true,
        customRootName: "mongodb-memory-server-root",
        customRootPwd: "rootuser",
        extraUsers: [],
        keyfileContent: "0123456789",
        ...opts
      };
    }
    exports2.authDefault = authDefault;
    async function statPath(path2) {
      return fs_1.promises.stat(path2).catch((err) => {
        if (["ENOENT", "EACCES"].includes(err.code)) {
          return void 0;
        }
        throw err;
      });
    }
    exports2.statPath = statPath;
    async function pathExists(path2) {
      return !isNullOrUndefined(await statPath(path2));
    }
    exports2.pathExists = pathExists;
    async function tryReleaseFile(path2, parser) {
      try {
        const output = await fs_1.promises.readFile(path2);
        return parser(output.toString());
      } catch (err) {
        if (errorWithCode(err) && !["ENOENT", "EACCES"].includes(err.code)) {
          throw err;
        }
        log(`tryReleaseFile: "${path2}" does not exist`);
        return void 0;
      }
    }
    exports2.tryReleaseFile = tryReleaseFile;
    var ManagerBase = class {
    };
    exports2.ManagerBase = ManagerBase;
    var ManagerAdvanced = class extends ManagerBase {
    };
    exports2.ManagerAdvanced = ManagerAdvanced;
    async function checkBinaryPermissions(path2) {
      try {
        await fs_1.promises.access(path2, fs_1.constants.X_OK);
      } catch (err) {
        if (errorWithCode(err)) {
          if (err.code === "EACCES") {
            throw new errors_1.InsufficientPermissionsError(path2);
          }
          if (err.code === "ENOENT") {
            throw new errors_1.BinaryNotFoundError(path2);
          }
        }
        throw err;
      }
    }
    exports2.checkBinaryPermissions = checkBinaryPermissions;
    async function mkdir(path2) {
      await fs_1.promises.mkdir(path2, { recursive: true });
    }
    exports2.mkdir = mkdir;
    async function createTmpDir(prefix, atPath) {
      const tmpPath = atPath ?? (0, os_1.tmpdir)();
      return fs_1.promises.mkdtemp(path.join(tmpPath, prefix));
    }
    exports2.createTmpDir = createTmpDir;
    async function removeDir(dirPath) {
      const stat = await statPath(dirPath);
      if (isNullOrUndefined(stat)) {
        return;
      }
      if (!stat.isDirectory()) {
        throw new Error(`Given Path is not a directory! (Path: "${dirPath}")`);
      }
      await fs_1.promises.rm(dirPath, { force: true, recursive: true });
    }
    exports2.removeDir = removeDir;
    function uuidv4() {
      return (0, crypto_1.randomUUID)();
    }
    exports2.uuidv4 = uuidv4;
    function md5(content) {
      return (0, crypto_1.createHash)("md5").update(content).digest("hex");
    }
    exports2.md5 = md5;
    async function md5FromFile(file) {
      return md5(await fs_1.promises.readFile(file));
    }
    exports2.md5FromFile = md5FromFile;
    function lockfilePath(downloadDir, version) {
      return path.resolve(downloadDir, `${version}.lock`);
    }
    exports2.lockfilePath = lockfilePath;
    function getStorageEngine(storageEngine, coercedVersion) {
      if (storageEngine === "ephemeralForTest" && semver.gte(coercedVersion, "7.0.0")) {
        console.warn('Storage Engine "ephemeralForTest" is removed since mongodb 7.0.0, automatically using "wiredTiger"!\nThis warning is because the mentioned storage engine is explicitly used and mongodb version is 7.0.0 or higher');
        return "wiredTiger";
      }
      if (isNullOrUndefined(storageEngine)) {
        if (semver.gte(coercedVersion, "7.0.0")) {
          return "wiredTiger";
        }
        return "ephemeralForTest";
      }
      return storageEngine;
    }
    exports2.getStorageEngine = getStorageEngine;
  }
});

// node_modules/mongodb-memory-server-core/lib/util/resolveConfig.js
var require_resolveConfig = __commonJS({
  "node_modules/mongodb-memory-server-core/lib/util/resolveConfig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.envToBool = exports2.envName = exports2.packageJsonPath = exports2.resolveConfig = exports2.processConfigOption = exports2.findPackageJson = exports2.setDefaultValue = exports2.defaultValues = exports2.DEFAULT_VERSION = exports2.ENV_CONFIG_PREFIX = exports2.ResolveConfigVariables = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var camelcase_1 = tslib_1.__importDefault(require_camelcase());
    var new_find_package_json_1 = require_lib2();
    var debug_1 = tslib_1.__importDefault(require_src2());
    var path = tslib_1.__importStar(require("path"));
    var fs_1 = require("fs");
    var utils_1 = require_utils4();
    Symbol.dispose ??= Symbol("Symbol.dispose");
    Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
    var log = (0, debug_1.default)("MongoMS:ResolveConfig");
    var ResolveConfigVariables;
    (function(ResolveConfigVariables2) {
      ResolveConfigVariables2["DOWNLOAD_DIR"] = "DOWNLOAD_DIR";
      ResolveConfigVariables2["PLATFORM"] = "PLATFORM";
      ResolveConfigVariables2["ARCH"] = "ARCH";
      ResolveConfigVariables2["VERSION"] = "VERSION";
      ResolveConfigVariables2["DEBUG"] = "DEBUG";
      ResolveConfigVariables2["DOWNLOAD_MIRROR"] = "DOWNLOAD_MIRROR";
      ResolveConfigVariables2["DOWNLOAD_URL"] = "DOWNLOAD_URL";
      ResolveConfigVariables2["DOWNLOAD_IGNORE_MISSING_HEADER"] = "DOWNLOAD_IGNORE_MISSING_HEADER";
      ResolveConfigVariables2["PREFER_GLOBAL_PATH"] = "PREFER_GLOBAL_PATH";
      ResolveConfigVariables2["DISABLE_POSTINSTALL"] = "DISABLE_POSTINSTALL";
      ResolveConfigVariables2["SYSTEM_BINARY"] = "SYSTEM_BINARY";
      ResolveConfigVariables2["MD5_CHECK"] = "MD5_CHECK";
      ResolveConfigVariables2["ARCHIVE_NAME"] = "ARCHIVE_NAME";
      ResolveConfigVariables2["RUNTIME_DOWNLOAD"] = "RUNTIME_DOWNLOAD";
      ResolveConfigVariables2["USE_HTTP"] = "USE_HTTP";
      ResolveConfigVariables2["SYSTEM_BINARY_VERSION_CHECK"] = "SYSTEM_BINARY_VERSION_CHECK";
      ResolveConfigVariables2["USE_ARCHIVE_NAME_FOR_BINARY_NAME"] = "USE_ARCHIVE_NAME_FOR_BINARY_NAME";
      ResolveConfigVariables2["MAX_REDIRECTS"] = "MAX_REDIRECTS";
      ResolveConfigVariables2["DISTRO"] = "DISTRO";
    })(ResolveConfigVariables || (exports2.ResolveConfigVariables = ResolveConfigVariables = {}));
    exports2.ENV_CONFIG_PREFIX = "MONGOMS_";
    exports2.DEFAULT_VERSION = "7.0.14";
    exports2.defaultValues = /* @__PURE__ */ new Map([
      // apply app-default values here
      [ResolveConfigVariables.VERSION, exports2.DEFAULT_VERSION],
      [ResolveConfigVariables.PREFER_GLOBAL_PATH, "true"],
      [ResolveConfigVariables.RUNTIME_DOWNLOAD, "true"],
      [ResolveConfigVariables.USE_HTTP, "false"],
      [ResolveConfigVariables.SYSTEM_BINARY_VERSION_CHECK, "true"],
      [ResolveConfigVariables.USE_ARCHIVE_NAME_FOR_BINARY_NAME, "false"],
      [ResolveConfigVariables.MD5_CHECK, "true"],
      [ResolveConfigVariables.MAX_REDIRECTS, "2"]
    ]);
    function setDefaultValue(key, value) {
      exports2.defaultValues.set(key, value);
    }
    exports2.setDefaultValue = setDefaultValue;
    var packagejson = void 0;
    function findPackageJson(directory) {
      for (const filename of (0, new_find_package_json_1.findSync)(directory || process.cwd())) {
        log(`findPackageJson: Found package.json at "${filename}"`);
        const readout = JSON.parse((0, fs_1.readFileSync)(filename).toString());
        const config = readout?.config?.mongodbMemoryServer;
        if (!(0, utils_1.isNullOrUndefined)(config) && Object.keys(config ?? {}).length > 0) {
          log(`findPackageJson: Found package with non-empty config field at "${filename}"`);
          const filepath = path.dirname(filename);
          packagejson = {
            filePath: filepath,
            config: processConfigOption(config, filepath)
          };
          break;
        }
      }
      return packagejson;
    }
    exports2.findPackageJson = findPackageJson;
    function processConfigOption(input, filepath) {
      log("processConfigOption", input, filepath);
      if (typeof input !== "object") {
        log("processConfigOptions: input was not a object");
        return {};
      }
      const returnobj = input;
      const ccDownloadDir = (0, camelcase_1.default)(ResolveConfigVariables.DOWNLOAD_DIR);
      const ccSystemBinary = (0, camelcase_1.default)(ResolveConfigVariables.SYSTEM_BINARY);
      if (ccDownloadDir in returnobj) {
        returnobj[ccDownloadDir] = path.resolve(filepath, returnobj[ccDownloadDir]);
      }
      if (ccSystemBinary in returnobj) {
        returnobj[ccSystemBinary] = path.resolve(filepath, returnobj[ccSystemBinary]);
      }
      return returnobj;
    }
    exports2.processConfigOption = processConfigOption;
    function resolveConfig(variableName) {
      return (process.env[envName(variableName)] ?? packagejson?.config[(0, camelcase_1.default)(variableName)] ?? exports2.defaultValues.get(variableName))?.toString();
    }
    exports2.resolveConfig = resolveConfig;
    function packageJsonPath() {
      return packagejson?.filePath;
    }
    exports2.packageJsonPath = packageJsonPath;
    exports2.default = resolveConfig;
    function envName(variableName) {
      return `${exports2.ENV_CONFIG_PREFIX}${variableName}`;
    }
    exports2.envName = envName;
    function envToBool(env2 = "") {
      if (typeof env2 !== "string") {
        log("envToBool: input was not a string!");
        return false;
      }
      return ["1", "on", "yes", "true"].indexOf(env2.toLowerCase()) !== -1;
    }
    exports2.envToBool = envToBool;
    var debug_enabled = false;
    if (envToBool(resolveConfig(ResolveConfigVariables.DEBUG))) {
      debug_1.default.enable("MongoMS:*");
      log("Debug Mode Enabled, through Environment Variable");
      debug_enabled = true;
    }
    findPackageJson();
    if (envToBool(resolveConfig(ResolveConfigVariables.DEBUG)) && !debug_enabled) {
      debug_1.default.enable("MongoMS:*");
      log("Debug Mode Enabled, through package.json");
      debug_enabled = true;
    }
  }
});

// node_modules/mongodb-memory-server-core/lib/util/getport/index.js
var require_getport = __commonJS({
  "node_modules/mongodb-memory-server-core/lib/util/getport/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resetPortsCache = exports2.tryPort = exports2.validPort = exports2.getFreePort = exports2.MAX_PORT = exports2.MIN_PORT = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var net = tslib_1.__importStar(require("net"));
    var debug_1 = tslib_1.__importDefault(require_src2());
    var log = (0, debug_1.default)("MongoMS:GetPort");
    exports2.MIN_PORT = 1024;
    exports2.MAX_PORT = 65535;
    var PORTS_CACHE_CLEAN_TIME = 1e3 * 10;
    var PORTS_CACHE = {
      timeSet: void 0,
      ports: /* @__PURE__ */ new Set()
    };
    var MAX_DEFAULT_TRIES = 10;
    async function getFreePort(firstPort, max_tries = MAX_DEFAULT_TRIES) {
      firstPort = firstPort || 0;
      if (PORTS_CACHE.timeSet && Date.now() - PORTS_CACHE.timeSet > PORTS_CACHE_CLEAN_TIME) {
        PORTS_CACHE.ports.clear();
        PORTS_CACHE.timeSet = Date.now();
      } else if (!PORTS_CACHE.timeSet) {
        PORTS_CACHE.timeSet = Date.now();
      }
      let tries = 0;
      while (tries <= max_tries) {
        tries += 1;
        const nextPort = tries === 1 ? firstPort : 0;
        if (PORTS_CACHE.ports.has(nextPort) && nextPort !== 0) {
          continue;
        }
        PORTS_CACHE.ports.add(nextPort);
        const triedPort = await tryPort(nextPort);
        if (triedPort > 0) {
          const inCacheAndNotSame = PORTS_CACHE.ports.has(triedPort) && nextPort !== triedPort;
          log(`getFreePort: found free port ${triedPort}, in cache and not custom: ${inCacheAndNotSame}`);
          PORTS_CACHE.ports.add(nextPort);
          if (inCacheAndNotSame) {
            continue;
          }
          PORTS_CACHE.timeSet = Date.now();
          return triedPort;
        }
      }
      throw new Error("Max port tries exceeded");
    }
    exports2.getFreePort = getFreePort;
    exports2.default = getFreePort;
    function validPort(port) {
      const mod = port % exports2.MAX_PORT;
      return mod < exports2.MIN_PORT ? exports2.MIN_PORT : mod;
    }
    exports2.validPort = validPort;
    function tryPort(port) {
      return new Promise((res, rej) => {
        const server = net.createServer();
        if (typeof server.unref === "function") {
          server.unref();
        }
        server.on("error", (err) => {
          if (err?.code !== "EADDRINUSE") {
            rej(err);
          }
          res(-1);
        });
        server.listen(port, () => {
          const address = server.address();
          const port2 = address.port;
          server.close();
          res(port2);
        });
      });
    }
    exports2.tryPort = tryPort;
    function resetPortsCache() {
      PORTS_CACHE.timeSet = void 0;
      PORTS_CACHE.ports.clear();
    }
    exports2.resetPortsCache = resetPortsCache;
  }
});

// node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    "use strict";
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src2()("follow-redirects");
        } catch (error2) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var URL2 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug2();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== "undefined";
      var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var looksLikeV8 = isFunction(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
      }
    })();
    var useNativeURL = false;
    try {
      assert(new URL2(""));
    } catch (error2) {
      useNativeURL = error2.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop;
    function RedirectableRequest(options2, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options2);
      this._options = options2;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self = this;
      this._onNativeResponse = function(response) {
        try {
          self._processResponse(response);
        } catch (cause) {
          self.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error2) {
      destroyRequest(this._currentRequest, error2);
      destroy.call(this, error2);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self._timeout) {
          clearTimeout(self._timeout);
        }
        self._timeout = setTimeout(function() {
          self.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self._timeout) {
          clearTimeout(self._timeout);
          self._timeout = null;
        }
        self.removeListener("abort", clearTimer);
        self.removeListener("error", clearTimer);
        self.removeListener("response", clearTimer);
        self.removeListener("close", clearTimer);
        if (callback) {
          self.removeListener("timeout", callback);
        }
        if (!self.socket) {
          self._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options2) {
      if (!options2.headers) {
        options2.headers = {};
      }
      if (options2.host) {
        if (!options2.hostname) {
          options2.hostname = options2.host;
        }
        delete options2.host;
      }
      if (!options2.pathname && options2.path) {
        var searchPos = options2.path.indexOf("?");
        if (searchPos < 0) {
          options2.pathname = options2.path;
        } else {
          options2.pathname = options2.path.substring(0, searchPos);
          options2.search = options2.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request2._redirectable = this;
      for (var event of events) {
        request2.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, […]
        // a client MUST send the target URI in absolute-form […].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error2) {
          if (request2 === self._currentRequest) {
            if (error2) {
              self.emit("error", error2);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request2.finished) {
                request2.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self._ended) {
              request2.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request2(input, options2, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options2;
            options2 = validateUrl(input);
            input = { protocol };
          }
          if (isFunction(options2)) {
            callback = options2;
            options2 = null;
          }
          options2 = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options2);
          options2.nativeProtocols = nativeProtocols;
          if (!isString(options2.host) && !isString(options2.hostname)) {
            options2.hostname = "::1";
          }
          assert.equal(options2.protocol, protocol, "protocol mismatch");
          debug("options", options2);
          return new RedirectableRequest(options2, callback);
        }
        function get(input, options2, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options2, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request2, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL2(input);
      } else {
        parsed = validateUrl(url.parse(input));
        if (!isString(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base2) {
      return useNativeURL ? new URL2(relative, base2) : parseUrl(url.resolve(base2, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread = target || {};
      for (var key of preservedUrlFields) {
        spread[key] = urlObject[key];
      }
      if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
      }
      if (spread.port !== "") {
        spread.port = Number(spread.port);
      }
      spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
      return spread;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        if (isFunction(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request2, error2) {
      for (var event of events) {
        request2.removeListener(event, eventHandlers[event]);
      }
      request2.on("error", noop);
      request2.destroy(error2);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString(subdomain) && isString(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL2 && value instanceof URL2;
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// node_modules/fast-fifo/fixed-size.js
var require_fixed_size = __commonJS({
  "node_modules/fast-fifo/fixed-size.js"(exports2, module2) {
    "use strict";
    module2.exports = class FixedFIFO {
      constructor(hwm) {
        if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) throw new Error("Max size for a FixedFIFO should be a power of two");
        this.buffer = new Array(hwm);
        this.mask = hwm - 1;
        this.top = 0;
        this.btm = 0;
        this.next = null;
      }
      clear() {
        this.top = this.btm = 0;
        this.next = null;
        this.buffer.fill(void 0);
      }
      push(data) {
        if (this.buffer[this.top] !== void 0) return false;
        this.buffer[this.top] = data;
        this.top = this.top + 1 & this.mask;
        return true;
      }
      shift() {
        const last = this.buffer[this.btm];
        if (last === void 0) return void 0;
        this.buffer[this.btm] = void 0;
        this.btm = this.btm + 1 & this.mask;
        return last;
      }
      peek() {
        return this.buffer[this.btm];
      }
      isEmpty() {
        return this.buffer[this.btm] === void 0;
      }
    };
  }
});

// node_modules/fast-fifo/index.js
var require_fast_fifo = __commonJS({
  "node_modules/fast-fifo/index.js"(exports2, module2) {
    "use strict";
    var FixedFIFO = require_fixed_size();
    module2.exports = class FastFIFO {
      constructor(hwm) {
        this.hwm = hwm || 16;
        this.head = new FixedFIFO(this.hwm);
        this.tail = this.head;
        this.length = 0;
      }
      clear() {
        this.head = this.tail;
        this.head.clear();
        this.length = 0;
      }
      push(val) {
        this.length++;
        if (!this.head.push(val)) {
          const prev = this.head;
          this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
          this.head.push(val);
        }
      }
      shift() {
        if (this.length !== 0) this.length--;
        const val = this.tail.shift();
        if (val === void 0 && this.tail.next) {
          const next = this.tail.next;
          this.tail.next = null;
          this.tail = next;
          return this.tail.shift();
        }
        return val;
      }
      peek() {
        const val = this.tail.peek();
        if (val === void 0 && this.tail.next) return this.tail.next.peek();
        return val;
      }
      isEmpty() {
        return this.length === 0;
      }
    };
  }
});

// node_modules/b4a/index.js
var require_b4a = __commonJS({
  "node_modules/b4a/index.js"(exports2, module2) {
    "use strict";
    function isBuffer(value) {
      return Buffer.isBuffer(value) || value instanceof Uint8Array;
    }
    function isEncoding(encoding) {
      return Buffer.isEncoding(encoding);
    }
    function alloc(size, fill2, encoding) {
      return Buffer.alloc(size, fill2, encoding);
    }
    function allocUnsafe(size) {
      return Buffer.allocUnsafe(size);
    }
    function allocUnsafeSlow(size) {
      return Buffer.allocUnsafeSlow(size);
    }
    function byteLength(string, encoding) {
      return Buffer.byteLength(string, encoding);
    }
    function compare(a, b) {
      return Buffer.compare(a, b);
    }
    function concat(buffers, totalLength) {
      return Buffer.concat(buffers, totalLength);
    }
    function copy(source, target, targetStart, start, end) {
      return toBuffer(source).copy(target, targetStart, start, end);
    }
    function equals(a, b) {
      return toBuffer(a).equals(b);
    }
    function fill(buffer, value, offset, end, encoding) {
      return toBuffer(buffer).fill(value, offset, end, encoding);
    }
    function from(value, encodingOrOffset, length) {
      return Buffer.from(value, encodingOrOffset, length);
    }
    function includes(buffer, value, byteOffset, encoding) {
      return toBuffer(buffer).includes(value, byteOffset, encoding);
    }
    function indexOf(buffer, value, byfeOffset, encoding) {
      return toBuffer(buffer).indexOf(value, byfeOffset, encoding);
    }
    function lastIndexOf(buffer, value, byteOffset, encoding) {
      return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding);
    }
    function swap16(buffer) {
      return toBuffer(buffer).swap16();
    }
    function swap32(buffer) {
      return toBuffer(buffer).swap32();
    }
    function swap64(buffer) {
      return toBuffer(buffer).swap64();
    }
    function toBuffer(buffer) {
      if (Buffer.isBuffer(buffer)) return buffer;
      return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    }
    function toString(buffer, encoding, start, end) {
      return toBuffer(buffer).toString(encoding, start, end);
    }
    function write(buffer, string, offset, length, encoding) {
      return toBuffer(buffer).write(string, offset, length, encoding);
    }
    function writeDoubleLE(buffer, value, offset) {
      return toBuffer(buffer).writeDoubleLE(value, offset);
    }
    function writeFloatLE(buffer, value, offset) {
      return toBuffer(buffer).writeFloatLE(value, offset);
    }
    function writeUInt32LE(buffer, value, offset) {
      return toBuffer(buffer).writeUInt32LE(value, offset);
    }
    function writeInt32LE(buffer, value, offset) {
      return toBuffer(buffer).writeInt32LE(value, offset);
    }
    function readDoubleLE(buffer, offset) {
      return toBuffer(buffer).readDoubleLE(offset);
    }
    function readFloatLE(buffer, offset) {
      return toBuffer(buffer).readFloatLE(offset);
    }
    function readUInt32LE(buffer, offset) {
      return toBuffer(buffer).readUInt32LE(offset);
    }
    function readInt32LE(buffer, offset) {
      return toBuffer(buffer).readInt32LE(offset);
    }
    function writeDoubleBE(buffer, value, offset) {
      return toBuffer(buffer).writeDoubleBE(value, offset);
    }
    function writeFloatBE(buffer, value, offset) {
      return toBuffer(buffer).writeFloatBE(value, offset);
    }
    function writeUInt32BE(buffer, value, offset) {
      return toBuffer(buffer).writeUInt32BE(value, offset);
    }
    function writeInt32BE(buffer, value, offset) {
      return toBuffer(buffer).writeInt32BE(value, offset);
    }
    function readDoubleBE(buffer, offset) {
      return toBuffer(buffer).readDoubleBE(offset);
    }
    function readFloatBE(buffer, offset) {
      return toBuffer(buffer).readFloatBE(offset);
    }
    function readUInt32BE(buffer, offset) {
      return toBuffer(buffer).readUInt32BE(offset);
    }
    function readInt32BE(buffer, offset) {
      return toBuffer(buffer).readInt32BE(offset);
    }
    module2.exports = {
      isBuffer,
      isEncoding,
      alloc,
      allocUnsafe,
      allocUnsafeSlow,
      byteLength,
      compare,
      concat,
      copy,
      equals,
      fill,
      from,
      includes,
      indexOf,
      lastIndexOf,
      swap16,
      swap32,
      swap64,
      toBuffer,
      toString,
      write,
      writeDoubleLE,
      writeFloatLE,
      writeUInt32LE,
      writeInt32LE,
      readDoubleLE,
      readFloatLE,
      readUInt32LE,
      readInt32LE,
      writeDoubleBE,
      writeFloatBE,
      writeUInt32BE,
      writeInt32BE,
      readDoubleBE,
      readFloatBE,
      readUInt32BE,
      readInt32BE
    };
  }
});

// node_modules/text-decoder/lib/pass-through-decoder.js
var require_pass_through_decoder = __commonJS({
  "node_modules/text-decoder/lib/pass-through-decoder.js"(exports2, module2) {
    "use strict";
    var b4a = require_b4a();
    module2.exports = class PassThroughDecoder {
      constructor(encoding) {
        this.encoding = encoding;
      }
      get remaining() {
        return 0;
      }
      decode(tail) {
        return b4a.toString(tail, this.encoding);
      }
      flush() {
        return "";
      }
    };
  }
});

// node_modules/text-decoder/lib/utf8-decoder.js
var require_utf8_decoder = __commonJS({
  "node_modules/text-decoder/lib/utf8-decoder.js"(exports2, module2) {
    "use strict";
    var b4a = require_b4a();
    module2.exports = class UTF8Decoder {
      constructor() {
        this.codePoint = 0;
        this.bytesSeen = 0;
        this.bytesNeeded = 0;
        this.lowerBoundary = 128;
        this.upperBoundary = 191;
      }
      get remaining() {
        return this.bytesSeen;
      }
      decode(data) {
        if (this.bytesNeeded === 0) {
          let isBoundary = true;
          for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength; i < n && isBoundary; i++) {
            isBoundary = data[i] <= 127;
          }
          if (isBoundary) return b4a.toString(data, "utf8");
        }
        let result = "";
        for (let i = 0, n = data.byteLength; i < n; i++) {
          const byte = data[i];
          if (this.bytesNeeded === 0) {
            if (byte <= 127) {
              result += String.fromCharCode(byte);
            } else {
              this.bytesSeen = 1;
              if (byte >= 194 && byte <= 223) {
                this.bytesNeeded = 2;
                this.codePoint = byte & 31;
              } else if (byte >= 224 && byte <= 239) {
                if (byte === 224) this.lowerBoundary = 160;
                else if (byte === 237) this.upperBoundary = 159;
                this.bytesNeeded = 3;
                this.codePoint = byte & 15;
              } else if (byte >= 240 && byte <= 244) {
                if (byte === 240) this.lowerBoundary = 144;
                if (byte === 244) this.upperBoundary = 143;
                this.bytesNeeded = 4;
                this.codePoint = byte & 7;
              } else {
                result += "\uFFFD";
              }
            }
            continue;
          }
          if (byte < this.lowerBoundary || byte > this.upperBoundary) {
            this.codePoint = 0;
            this.bytesNeeded = 0;
            this.bytesSeen = 0;
            this.lowerBoundary = 128;
            this.upperBoundary = 191;
            result += "\uFFFD";
            continue;
          }
          this.lowerBoundary = 128;
          this.upperBoundary = 191;
          this.codePoint = this.codePoint << 6 | byte & 63;
          this.bytesSeen++;
          if (this.bytesSeen !== this.bytesNeeded) continue;
          result += String.fromCodePoint(this.codePoint);
          this.codePoint = 0;
          this.bytesNeeded = 0;
          this.bytesSeen = 0;
        }
        return result;
      }
      flush() {
        const result = this.bytesNeeded > 0 ? "\uFFFD" : "";
        this.codePoint = 0;
        this.bytesNeeded = 0;
        this.bytesSeen = 0;
        this.lowerBoundary = 128;
        this.upperBoundary = 191;
        return result;
      }
    };
  }
});

// node_modules/text-decoder/index.js
var require_text_decoder = __commonJS({
  "node_modules/text-decoder/index.js"(exports2, module2) {
    "use strict";
    var PassThroughDecoder = require_pass_through_decoder();
    var UTF8Decoder = require_utf8_decoder();
    module2.exports = class TextDecoder {
      constructor(encoding = "utf8") {
        this.encoding = normalizeEncoding(encoding);
        switch (this.encoding) {
          case "utf8":
            this.decoder = new UTF8Decoder();
            break;
          case "utf16le":
          case "base64":
            throw new Error("Unsupported encoding: " + this.encoding);
          default:
            this.decoder = new PassThroughDecoder(this.encoding);
        }
      }
      get remaining() {
        return this.decoder.remaining;
      }
      push(data) {
        if (typeof data === "string") return data;
        return this.decoder.decode(data);
      }
      // For Node.js compatibility
      write(data) {
        return this.push(data);
      }
      end(data) {
        let result = "";
        if (data) result = this.push(data);
        result += this.decoder.flush();
        return result;
      }
    };
    function normalizeEncoding(encoding) {
      encoding = encoding.toLowerCase();
      switch (encoding) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return encoding;
        default:
          throw new Error("Unknown encoding: " + encoding);
      }
    }
  }
});

// node_modules/streamx/index.js
var require_streamx = __commonJS({
  "node_modules/streamx/index.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = require("events");
    var STREAM_DESTROYED = new Error("Stream was destroyed");
    var PREMATURE_CLOSE = new Error("Premature close");
    var FIFO = require_fast_fifo();
    var TextDecoder2 = require_text_decoder();
    var qmt = typeof queueMicrotask === "undefined" ? (fn) => global.process.nextTick(fn) : queueMicrotask;
    var MAX = (1 << 29) - 1;
    var OPENING = 1;
    var PREDESTROYING = 2;
    var DESTROYING = 4;
    var DESTROYED = 8;
    var NOT_OPENING = MAX ^ OPENING;
    var NOT_PREDESTROYING = MAX ^ PREDESTROYING;
    var READ_ACTIVE = 1 << 4;
    var READ_UPDATING = 2 << 4;
    var READ_PRIMARY = 4 << 4;
    var READ_QUEUED = 8 << 4;
    var READ_RESUMED = 16 << 4;
    var READ_PIPE_DRAINED = 32 << 4;
    var READ_ENDING = 64 << 4;
    var READ_EMIT_DATA = 128 << 4;
    var READ_EMIT_READABLE = 256 << 4;
    var READ_EMITTED_READABLE = 512 << 4;
    var READ_DONE = 1024 << 4;
    var READ_NEXT_TICK = 2048 << 4;
    var READ_NEEDS_PUSH = 4096 << 4;
    var READ_READ_AHEAD = 8192 << 4;
    var READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
    var READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH;
    var READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
    var READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
    var READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD;
    var READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
    var READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
    var READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
    var READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
    var READ_PAUSED = MAX ^ READ_RESUMED;
    var READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
    var READ_NOT_ENDING = MAX ^ READ_ENDING;
    var READ_PIPE_NOT_DRAINED = MAX ^ READ_FLOWING;
    var READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;
    var READ_NOT_UPDATING = MAX ^ READ_UPDATING;
    var READ_NO_READ_AHEAD = MAX ^ READ_READ_AHEAD;
    var READ_PAUSED_NO_READ_AHEAD = MAX ^ READ_RESUMED_READ_AHEAD;
    var WRITE_ACTIVE = 1 << 18;
    var WRITE_UPDATING = 2 << 18;
    var WRITE_PRIMARY = 4 << 18;
    var WRITE_QUEUED = 8 << 18;
    var WRITE_UNDRAINED = 16 << 18;
    var WRITE_DONE = 32 << 18;
    var WRITE_EMIT_DRAIN = 64 << 18;
    var WRITE_NEXT_TICK = 128 << 18;
    var WRITE_WRITING = 256 << 18;
    var WRITE_FINISHING = 512 << 18;
    var WRITE_CORKED = 1024 << 18;
    var WRITE_NOT_ACTIVE = MAX ^ (WRITE_ACTIVE | WRITE_WRITING);
    var WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
    var WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING);
    var WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
    var WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
    var WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;
    var WRITE_NOT_UPDATING = MAX ^ WRITE_UPDATING;
    var WRITE_NOT_CORKED = MAX ^ WRITE_CORKED;
    var ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
    var NOT_ACTIVE = MAX ^ ACTIVE;
    var DONE = READ_DONE | WRITE_DONE;
    var DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING;
    var OPEN_STATUS = DESTROY_STATUS | OPENING;
    var AUTO_DESTROY = DESTROY_STATUS | DONE;
    var NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
    var ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK;
    var TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE;
    var IS_OPENING = OPEN_STATUS | TICKING;
    var READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
    var READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
    var READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
    var READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
    var SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD;
    var READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;
    var READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY;
    var READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING;
    var WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
    var WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
    var WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
    var WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
    var WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED;
    var WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
    var WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING;
    var WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;
    var WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
    var WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY;
    var WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS;
    var asyncIterator = Symbol.asyncIterator || Symbol("asyncIterator");
    var WritableState = class {
      constructor(stream, { highWaterMark = 16384, map: map2 = null, mapWritable, byteLength, byteLengthWritable } = {}) {
        this.stream = stream;
        this.queue = new FIFO();
        this.highWaterMark = highWaterMark;
        this.buffered = 0;
        this.error = null;
        this.pipeline = null;
        this.drains = null;
        this.byteLength = byteLengthWritable || byteLength || defaultByteLength;
        this.map = mapWritable || map2;
        this.afterWrite = afterWrite.bind(this);
        this.afterUpdateNextTick = updateWriteNT.bind(this);
      }
      get ended() {
        return (this.stream._duplexState & WRITE_DONE) !== 0;
      }
      push(data) {
        if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false;
        if (this.map !== null) data = this.map(data);
        this.buffered += this.byteLength(data);
        this.queue.push(data);
        if (this.buffered < this.highWaterMark) {
          this.stream._duplexState |= WRITE_QUEUED;
          return true;
        }
        this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
        return false;
      }
      shift() {
        const data = this.queue.shift();
        this.buffered -= this.byteLength(data);
        if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED;
        return data;
      }
      end(data) {
        if (typeof data === "function") this.stream.once("finish", data);
        else if (data !== void 0 && data !== null) this.push(data);
        this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
      }
      autoBatch(data, cb) {
        const buffer = [];
        const stream = this.stream;
        buffer.push(data);
        while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {
          buffer.push(stream._writableState.shift());
        }
        if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null);
        stream._writev(buffer, cb);
      }
      update() {
        const stream = this.stream;
        stream._duplexState |= WRITE_UPDATING;
        do {
          while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
            const data = this.shift();
            stream._duplexState |= WRITE_ACTIVE_AND_WRITING;
            stream._write(data, this.afterWrite);
          }
          if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
        } while (this.continueUpdate() === true);
        stream._duplexState &= WRITE_NOT_UPDATING;
      }
      updateNonPrimary() {
        const stream = this.stream;
        if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
          stream._duplexState = stream._duplexState | WRITE_ACTIVE;
          stream._final(afterFinal.bind(this));
          return;
        }
        if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
          if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
            stream._duplexState |= ACTIVE;
            stream._destroy(afterDestroy.bind(this));
          }
          return;
        }
        if ((stream._duplexState & IS_OPENING) === OPENING) {
          stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
          stream._open(afterOpen.bind(this));
        }
      }
      continueUpdate() {
        if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false;
        this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
        return true;
      }
      updateCallback() {
        if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update();
        else this.updateNextTick();
      }
      updateNextTick() {
        if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return;
        this.stream._duplexState |= WRITE_NEXT_TICK;
        if ((this.stream._duplexState & WRITE_UPDATING) === 0) qmt(this.afterUpdateNextTick);
      }
    };
    var ReadableState = class {
      constructor(stream, { highWaterMark = 16384, map: map2 = null, mapReadable, byteLength, byteLengthReadable } = {}) {
        this.stream = stream;
        this.queue = new FIFO();
        this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark;
        this.buffered = 0;
        this.readAhead = highWaterMark > 0;
        this.error = null;
        this.pipeline = null;
        this.byteLength = byteLengthReadable || byteLength || defaultByteLength;
        this.map = mapReadable || map2;
        this.pipeTo = null;
        this.afterRead = afterRead.bind(this);
        this.afterUpdateNextTick = updateReadNT.bind(this);
      }
      get ended() {
        return (this.stream._duplexState & READ_DONE) !== 0;
      }
      pipe(pipeTo, cb) {
        if (this.pipeTo !== null) throw new Error("Can only pipe to one destination");
        if (typeof cb !== "function") cb = null;
        this.stream._duplexState |= READ_PIPE_DRAINED;
        this.pipeTo = pipeTo;
        this.pipeline = new Pipeline(this.stream, pipeTo, cb);
        if (cb) this.stream.on("error", noop);
        if (isStreamx(pipeTo)) {
          pipeTo._writableState.pipeline = this.pipeline;
          if (cb) pipeTo.on("error", noop);
          pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
        } else {
          const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
          const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null);
          pipeTo.on("error", onerror);
          pipeTo.on("close", onclose);
          pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
        }
        pipeTo.on("drain", afterDrain.bind(this));
        this.stream.emit("piping", pipeTo);
        pipeTo.emit("pipe", this.stream);
      }
      push(data) {
        const stream = this.stream;
        if (data === null) {
          this.highWaterMark = 0;
          stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
          return false;
        }
        if (this.map !== null) {
          data = this.map(data);
          if (data === null) {
            stream._duplexState &= READ_PUSHED;
            return this.buffered < this.highWaterMark;
          }
        }
        this.buffered += this.byteLength(data);
        this.queue.push(data);
        stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;
        return this.buffered < this.highWaterMark;
      }
      shift() {
        const data = this.queue.shift();
        this.buffered -= this.byteLength(data);
        if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED;
        return data;
      }
      unshift(data) {
        const pending = [this.map !== null ? this.map(data) : data];
        while (this.buffered > 0) pending.push(this.shift());
        for (let i = 0; i < pending.length - 1; i++) {
          const data2 = pending[i];
          this.buffered += this.byteLength(data2);
          this.queue.push(data2);
        }
        this.push(pending[pending.length - 1]);
      }
      read() {
        const stream = this.stream;
        if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
          const data = this.shift();
          if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
          if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit("data", data);
          return data;
        }
        if (this.readAhead === false) {
          stream._duplexState |= READ_READ_AHEAD;
          this.updateNextTick();
        }
        return null;
      }
      drain() {
        const stream = this.stream;
        while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
          const data = this.shift();
          if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
          if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit("data", data);
        }
      }
      update() {
        const stream = this.stream;
        stream._duplexState |= READ_UPDATING;
        do {
          this.drain();
          while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {
            stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH;
            stream._read(this.afterRead);
            this.drain();
          }
          if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
            stream._duplexState |= READ_EMITTED_READABLE;
            stream.emit("readable");
          }
          if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
        } while (this.continueUpdate() === true);
        stream._duplexState &= READ_NOT_UPDATING;
      }
      updateNonPrimary() {
        const stream = this.stream;
        if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
          stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
          stream.emit("end");
          if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING;
          if (this.pipeTo !== null) this.pipeTo.end();
        }
        if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
          if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
            stream._duplexState |= ACTIVE;
            stream._destroy(afterDestroy.bind(this));
          }
          return;
        }
        if ((stream._duplexState & IS_OPENING) === OPENING) {
          stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
          stream._open(afterOpen.bind(this));
        }
      }
      continueUpdate() {
        if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false;
        this.stream._duplexState &= READ_NOT_NEXT_TICK;
        return true;
      }
      updateCallback() {
        if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update();
        else this.updateNextTick();
      }
      updateNextTickIfOpen() {
        if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return;
        this.stream._duplexState |= READ_NEXT_TICK;
        if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick);
      }
      updateNextTick() {
        if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return;
        this.stream._duplexState |= READ_NEXT_TICK;
        if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick);
      }
    };
    var TransformState = class {
      constructor(stream) {
        this.data = null;
        this.afterTransform = afterTransform.bind(stream);
        this.afterFinal = null;
      }
    };
    var Pipeline = class {
      constructor(src, dst, cb) {
        this.from = src;
        this.to = dst;
        this.afterPipe = cb;
        this.error = null;
        this.pipeToFinished = false;
      }
      finished() {
        this.pipeToFinished = true;
      }
      done(stream, err) {
        if (err) this.error = err;
        if (stream === this.to) {
          this.to = null;
          if (this.from !== null) {
            if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
              this.from.destroy(this.error || new Error("Writable stream closed prematurely"));
            }
            return;
          }
        }
        if (stream === this.from) {
          this.from = null;
          if (this.to !== null) {
            if ((stream._duplexState & READ_DONE) === 0) {
              this.to.destroy(this.error || new Error("Readable stream closed before ending"));
            }
            return;
          }
        }
        if (this.afterPipe !== null) this.afterPipe(this.error);
        this.to = this.from = this.afterPipe = null;
      }
    };
    function afterDrain() {
      this.stream._duplexState |= READ_PIPE_DRAINED;
      this.updateCallback();
    }
    function afterFinal(err) {
      const stream = this.stream;
      if (err) stream.destroy(err);
      if ((stream._duplexState & DESTROY_STATUS) === 0) {
        stream._duplexState |= WRITE_DONE;
        stream.emit("finish");
      }
      if ((stream._duplexState & AUTO_DESTROY) === DONE) {
        stream._duplexState |= DESTROYING;
      }
      stream._duplexState &= WRITE_NOT_FINISHING;
      if ((stream._duplexState & WRITE_UPDATING) === 0) this.update();
      else this.updateNextTick();
    }
    function afterDestroy(err) {
      const stream = this.stream;
      if (!err && this.error !== STREAM_DESTROYED) err = this.error;
      if (err) stream.emit("error", err);
      stream._duplexState |= DESTROYED;
      stream.emit("close");
      const rs = stream._readableState;
      const ws = stream._writableState;
      if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err);
      if (ws !== null) {
        while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false);
        if (ws.pipeline !== null) ws.pipeline.done(stream, err);
      }
    }
    function afterWrite(err) {
      const stream = this.stream;
      if (err) stream.destroy(err);
      stream._duplexState &= WRITE_NOT_ACTIVE;
      if (this.drains !== null) tickDrains(this.drains);
      if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
        stream._duplexState &= WRITE_DRAINED;
        if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
          stream.emit("drain");
        }
      }
      this.updateCallback();
    }
    function afterRead(err) {
      if (err) this.stream.destroy(err);
      this.stream._duplexState &= READ_NOT_ACTIVE;
      if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD;
      this.updateCallback();
    }
    function updateReadNT() {
      if ((this.stream._duplexState & READ_UPDATING) === 0) {
        this.stream._duplexState &= READ_NOT_NEXT_TICK;
        this.update();
      }
    }
    function updateWriteNT() {
      if ((this.stream._duplexState & WRITE_UPDATING) === 0) {
        this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
        this.update();
      }
    }
    function tickDrains(drains) {
      for (let i = 0; i < drains.length; i++) {
        if (--drains[i].writes === 0) {
          drains.shift().resolve(true);
          i--;
        }
      }
    }
    function afterOpen(err) {
      const stream = this.stream;
      if (err) stream.destroy(err);
      if ((stream._duplexState & DESTROYING) === 0) {
        if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY;
        if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY;
        stream.emit("open");
      }
      stream._duplexState &= NOT_ACTIVE;
      if (stream._writableState !== null) {
        stream._writableState.updateCallback();
      }
      if (stream._readableState !== null) {
        stream._readableState.updateCallback();
      }
    }
    function afterTransform(err, data) {
      if (data !== void 0 && data !== null) this.push(data);
      this._writableState.afterWrite(err);
    }
    function newListener(name) {
      if (this._readableState !== null) {
        if (name === "data") {
          this._duplexState |= READ_EMIT_DATA | READ_RESUMED_READ_AHEAD;
          this._readableState.updateNextTick();
        }
        if (name === "readable") {
          this._duplexState |= READ_EMIT_READABLE;
          this._readableState.updateNextTick();
        }
      }
      if (this._writableState !== null) {
        if (name === "drain") {
          this._duplexState |= WRITE_EMIT_DRAIN;
          this._writableState.updateNextTick();
        }
      }
    }
    var Stream = class extends EventEmitter {
      constructor(opts) {
        super();
        this._duplexState = 0;
        this._readableState = null;
        this._writableState = null;
        if (opts) {
          if (opts.open) this._open = opts.open;
          if (opts.destroy) this._destroy = opts.destroy;
          if (opts.predestroy) this._predestroy = opts.predestroy;
          if (opts.signal) {
            opts.signal.addEventListener("abort", abort.bind(this));
          }
        }
        this.on("newListener", newListener);
      }
      _open(cb) {
        cb(null);
      }
      _destroy(cb) {
        cb(null);
      }
      _predestroy() {
      }
      get readable() {
        return this._readableState !== null ? true : void 0;
      }
      get writable() {
        return this._writableState !== null ? true : void 0;
      }
      get destroyed() {
        return (this._duplexState & DESTROYED) !== 0;
      }
      get destroying() {
        return (this._duplexState & DESTROY_STATUS) !== 0;
      }
      destroy(err) {
        if ((this._duplexState & DESTROY_STATUS) === 0) {
          if (!err) err = STREAM_DESTROYED;
          this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;
          if (this._readableState !== null) {
            this._readableState.highWaterMark = 0;
            this._readableState.error = err;
          }
          if (this._writableState !== null) {
            this._writableState.highWaterMark = 0;
            this._writableState.error = err;
          }
          this._duplexState |= PREDESTROYING;
          this._predestroy();
          this._duplexState &= NOT_PREDESTROYING;
          if (this._readableState !== null) this._readableState.updateNextTick();
          if (this._writableState !== null) this._writableState.updateNextTick();
        }
      }
    };
    var Readable = class _Readable extends Stream {
      constructor(opts) {
        super(opts);
        this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD;
        this._readableState = new ReadableState(this, opts);
        if (opts) {
          if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD;
          if (opts.read) this._read = opts.read;
          if (opts.eagerOpen) this._readableState.updateNextTick();
          if (opts.encoding) this.setEncoding(opts.encoding);
        }
      }
      setEncoding(encoding) {
        const dec = new TextDecoder2(encoding);
        const map2 = this._readableState.map || echo;
        this._readableState.map = mapOrSkip;
        return this;
        function mapOrSkip(data) {
          const next = dec.push(data);
          return next === "" && (data.byteLength !== 0 || dec.remaining > 0) ? null : map2(next);
        }
      }
      _read(cb) {
        cb(null);
      }
      pipe(dest, cb) {
        this._readableState.updateNextTick();
        this._readableState.pipe(dest, cb);
        return dest;
      }
      read() {
        this._readableState.updateNextTick();
        return this._readableState.read();
      }
      push(data) {
        this._readableState.updateNextTickIfOpen();
        return this._readableState.push(data);
      }
      unshift(data) {
        this._readableState.updateNextTickIfOpen();
        return this._readableState.unshift(data);
      }
      resume() {
        this._duplexState |= READ_RESUMED_READ_AHEAD;
        this._readableState.updateNextTick();
        return this;
      }
      pause() {
        this._duplexState &= this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED;
        return this;
      }
      static _fromAsyncIterator(ite, opts) {
        let destroy;
        const rs = new _Readable({
          ...opts,
          read(cb) {
            ite.next().then(push).then(cb.bind(null, null)).catch(cb);
          },
          predestroy() {
            destroy = ite.return();
          },
          destroy(cb) {
            if (!destroy) return cb(null);
            destroy.then(cb.bind(null, null)).catch(cb);
          }
        });
        return rs;
        function push(data) {
          if (data.done) rs.push(null);
          else rs.push(data.value);
        }
      }
      static from(data, opts) {
        if (isReadStreamx(data)) return data;
        if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts);
        if (!Array.isArray(data)) data = data === void 0 ? [] : [data];
        let i = 0;
        return new _Readable({
          ...opts,
          read(cb) {
            this.push(i === data.length ? null : data[i++]);
            cb(null);
          }
        });
      }
      static isBackpressured(rs) {
        return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
      }
      static isPaused(rs) {
        return (rs._duplexState & READ_RESUMED) === 0;
      }
      [asyncIterator]() {
        const stream = this;
        let error2 = null;
        let promiseResolve = null;
        let promiseReject = null;
        this.on("error", (err) => {
          error2 = err;
        });
        this.on("readable", onreadable);
        this.on("close", onclose);
        return {
          [asyncIterator]() {
            return this;
          },
          next() {
            return new Promise(function(resolve, reject) {
              promiseResolve = resolve;
              promiseReject = reject;
              const data = stream.read();
              if (data !== null) ondata(data);
              else if ((stream._duplexState & DESTROYED) !== 0) ondata(null);
            });
          },
          return() {
            return destroy(null);
          },
          throw(err) {
            return destroy(err);
          }
        };
        function onreadable() {
          if (promiseResolve !== null) ondata(stream.read());
        }
        function onclose() {
          if (promiseResolve !== null) ondata(null);
        }
        function ondata(data) {
          if (promiseReject === null) return;
          if (error2) promiseReject(error2);
          else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED);
          else promiseResolve({ value: data, done: data === null });
          promiseReject = promiseResolve = null;
        }
        function destroy(err) {
          stream.destroy(err);
          return new Promise((resolve, reject) => {
            if (stream._duplexState & DESTROYED) return resolve({ value: void 0, done: true });
            stream.once("close", function() {
              if (err) reject(err);
              else resolve({ value: void 0, done: true });
            });
          });
        }
      }
    };
    var Writable = class extends Stream {
      constructor(opts) {
        super(opts);
        this._duplexState |= OPENING | READ_DONE;
        this._writableState = new WritableState(this, opts);
        if (opts) {
          if (opts.writev) this._writev = opts.writev;
          if (opts.write) this._write = opts.write;
          if (opts.final) this._final = opts.final;
          if (opts.eagerOpen) this._writableState.updateNextTick();
        }
      }
      cork() {
        this._duplexState |= WRITE_CORKED;
      }
      uncork() {
        this._duplexState &= WRITE_NOT_CORKED;
        this._writableState.updateNextTick();
      }
      _writev(batch, cb) {
        cb(null);
      }
      _write(data, cb) {
        this._writableState.autoBatch(data, cb);
      }
      _final(cb) {
        cb(null);
      }
      static isBackpressured(ws) {
        return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
      }
      static drained(ws) {
        if (ws.destroyed) return Promise.resolve(false);
        const state = ws._writableState;
        const pending = isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length;
        const writes = pending + (ws._duplexState & WRITE_WRITING ? 1 : 0);
        if (writes === 0) return Promise.resolve(true);
        if (state.drains === null) state.drains = [];
        return new Promise((resolve) => {
          state.drains.push({ writes, resolve });
        });
      }
      write(data) {
        this._writableState.updateNextTick();
        return this._writableState.push(data);
      }
      end(data) {
        this._writableState.updateNextTick();
        this._writableState.end(data);
        return this;
      }
    };
    var Duplex = class extends Readable {
      // and Writable
      constructor(opts) {
        super(opts);
        this._duplexState = OPENING | this._duplexState & READ_READ_AHEAD;
        this._writableState = new WritableState(this, opts);
        if (opts) {
          if (opts.writev) this._writev = opts.writev;
          if (opts.write) this._write = opts.write;
          if (opts.final) this._final = opts.final;
        }
      }
      cork() {
        this._duplexState |= WRITE_CORKED;
      }
      uncork() {
        this._duplexState &= WRITE_NOT_CORKED;
        this._writableState.updateNextTick();
      }
      _writev(batch, cb) {
        cb(null);
      }
      _write(data, cb) {
        this._writableState.autoBatch(data, cb);
      }
      _final(cb) {
        cb(null);
      }
      write(data) {
        this._writableState.updateNextTick();
        return this._writableState.push(data);
      }
      end(data) {
        this._writableState.updateNextTick();
        this._writableState.end(data);
        return this;
      }
    };
    var Transform = class extends Duplex {
      constructor(opts) {
        super(opts);
        this._transformState = new TransformState(this);
        if (opts) {
          if (opts.transform) this._transform = opts.transform;
          if (opts.flush) this._flush = opts.flush;
        }
      }
      _write(data, cb) {
        if (this._readableState.buffered >= this._readableState.highWaterMark) {
          this._transformState.data = data;
        } else {
          this._transform(data, this._transformState.afterTransform);
        }
      }
      _read(cb) {
        if (this._transformState.data !== null) {
          const data = this._transformState.data;
          this._transformState.data = null;
          cb(null);
          this._transform(data, this._transformState.afterTransform);
        } else {
          cb(null);
        }
      }
      destroy(err) {
        super.destroy(err);
        if (this._transformState.data !== null) {
          this._transformState.data = null;
          this._transformState.afterTransform();
        }
      }
      _transform(data, cb) {
        cb(null, data);
      }
      _flush(cb) {
        cb(null);
      }
      _final(cb) {
        this._transformState.afterFinal = cb;
        this._flush(transformAfterFlush.bind(this));
      }
    };
    var PassThrough = class extends Transform {
    };
    function transformAfterFlush(err, data) {
      const cb = this._transformState.afterFinal;
      if (err) return cb(err);
      if (data !== null && data !== void 0) this.push(data);
      this.push(null);
      cb(null);
    }
    function pipelinePromise(...streams) {
      return new Promise((resolve, reject) => {
        return pipeline(...streams, (err) => {
          if (err) return reject(err);
          resolve();
        });
      });
    }
    function pipeline(stream, ...streams) {
      const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];
      const done = all.length && typeof all[all.length - 1] === "function" ? all.pop() : null;
      if (all.length < 2) throw new Error("Pipeline requires at least 2 streams");
      let src = all[0];
      let dest = null;
      let error2 = null;
      for (let i = 1; i < all.length; i++) {
        dest = all[i];
        if (isStreamx(src)) {
          src.pipe(dest, onerror);
        } else {
          errorHandle(src, true, i > 1, onerror);
          src.pipe(dest);
        }
        src = dest;
      }
      if (done) {
        let fin = false;
        const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);
        dest.on("error", (err) => {
          if (error2 === null) error2 = err;
        });
        dest.on("finish", () => {
          fin = true;
          if (!autoDestroy) done(error2);
        });
        if (autoDestroy) {
          dest.on("close", () => done(error2 || (fin ? null : PREMATURE_CLOSE)));
        }
      }
      return dest;
      function errorHandle(s, rd, wr, onerror2) {
        s.on("error", onerror2);
        s.on("close", onclose);
        function onclose() {
          if (rd && s._readableState && !s._readableState.ended) return onerror2(PREMATURE_CLOSE);
          if (wr && s._writableState && !s._writableState.ended) return onerror2(PREMATURE_CLOSE);
        }
      }
      function onerror(err) {
        if (!err || error2) return;
        error2 = err;
        for (const s of all) {
          s.destroy(err);
        }
      }
    }
    function echo(s) {
      return s;
    }
    function isStream(stream) {
      return !!stream._readableState || !!stream._writableState;
    }
    function isStreamx(stream) {
      return typeof stream._duplexState === "number" && isStream(stream);
    }
    function isEnded(stream) {
      return !!stream._readableState && stream._readableState.ended;
    }
    function isFinished(stream) {
      return !!stream._writableState && stream._writableState.ended;
    }
    function getStreamError(stream, opts = {}) {
      const err = stream._readableState && stream._readableState.error || stream._writableState && stream._writableState.error;
      return !opts.all && err === STREAM_DESTROYED ? null : err;
    }
    function isReadStreamx(stream) {
      return isStreamx(stream) && stream.readable;
    }
    function isDisturbed(stream) {
      return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0;
    }
    function isTypedArray(data) {
      return typeof data === "object" && data !== null && typeof data.byteLength === "number";
    }
    function defaultByteLength(data) {
      return isTypedArray(data) ? data.byteLength : 1024;
    }
    function noop() {
    }
    function abort() {
      this.destroy(new Error("Stream aborted."));
    }
    function isWritev(s) {
      return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev;
    }
    module2.exports = {
      pipeline,
      pipelinePromise,
      isStream,
      isStreamx,
      isEnded,
      isFinished,
      isDisturbed,
      getStreamError,
      Stream,
      Writable,
      Readable,
      Duplex,
      Transform,
      // Export PassThrough for compatibility with Node.js core's stream module
      PassThrough
    };
  }
});

// node_modules/tar-stream/headers.js
var require_headers = __commonJS({
  "node_modules/tar-stream/headers.js"(exports2) {
    "use strict";
    var b4a = require_b4a();
    var ZEROS = "0000000000000000000";
    var SEVENS = "7777777777777777777";
    var ZERO_OFFSET = "0".charCodeAt(0);
    var USTAR_MAGIC = b4a.from([117, 115, 116, 97, 114, 0]);
    var USTAR_VER = b4a.from([ZERO_OFFSET, ZERO_OFFSET]);
    var GNU_MAGIC = b4a.from([117, 115, 116, 97, 114, 32]);
    var GNU_VER = b4a.from([32, 0]);
    var MASK = 4095;
    var MAGIC_OFFSET = 257;
    var VERSION_OFFSET = 263;
    exports2.decodeLongPath = function decodeLongPath(buf, encoding) {
      return decodeStr(buf, 0, buf.length, encoding);
    };
    exports2.encodePax = function encodePax(opts) {
      let result = "";
      if (opts.name) result += addLength(" path=" + opts.name + "\n");
      if (opts.linkname) result += addLength(" linkpath=" + opts.linkname + "\n");
      const pax = opts.pax;
      if (pax) {
        for (const key in pax) {
          result += addLength(" " + key + "=" + pax[key] + "\n");
        }
      }
      return b4a.from(result);
    };
    exports2.decodePax = function decodePax(buf) {
      const result = {};
      while (buf.length) {
        let i = 0;
        while (i < buf.length && buf[i] !== 32) i++;
        const len = parseInt(b4a.toString(buf.subarray(0, i)), 10);
        if (!len) return result;
        const b = b4a.toString(buf.subarray(i + 1, len - 1));
        const keyIndex = b.indexOf("=");
        if (keyIndex === -1) return result;
        result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
        buf = buf.subarray(len);
      }
      return result;
    };
    exports2.encode = function encode2(opts) {
      const buf = b4a.alloc(512);
      let name = opts.name;
      let prefix = "";
      if (opts.typeflag === 5 && name[name.length - 1] !== "/") name += "/";
      if (b4a.byteLength(name) !== name.length) return null;
      while (b4a.byteLength(name) > 100) {
        const i = name.indexOf("/");
        if (i === -1) return null;
        prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
        name = name.slice(i + 1);
      }
      if (b4a.byteLength(name) > 100 || b4a.byteLength(prefix) > 155) return null;
      if (opts.linkname && b4a.byteLength(opts.linkname) > 100) return null;
      b4a.write(buf, name);
      b4a.write(buf, encodeOct(opts.mode & MASK, 6), 100);
      b4a.write(buf, encodeOct(opts.uid, 6), 108);
      b4a.write(buf, encodeOct(opts.gid, 6), 116);
      encodeSize(opts.size, buf, 124);
      b4a.write(buf, encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
      buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
      if (opts.linkname) b4a.write(buf, opts.linkname, 157);
      b4a.copy(USTAR_MAGIC, buf, MAGIC_OFFSET);
      b4a.copy(USTAR_VER, buf, VERSION_OFFSET);
      if (opts.uname) b4a.write(buf, opts.uname, 265);
      if (opts.gname) b4a.write(buf, opts.gname, 297);
      b4a.write(buf, encodeOct(opts.devmajor || 0, 6), 329);
      b4a.write(buf, encodeOct(opts.devminor || 0, 6), 337);
      if (prefix) b4a.write(buf, prefix, 345);
      b4a.write(buf, encodeOct(cksum(buf), 6), 148);
      return buf;
    };
    exports2.decode = function decode2(buf, filenameEncoding, allowUnknownFormat) {
      let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
      let name = decodeStr(buf, 0, 100, filenameEncoding);
      const mode = decodeOct(buf, 100, 8);
      const uid = decodeOct(buf, 108, 8);
      const gid = decodeOct(buf, 116, 8);
      const size = decodeOct(buf, 124, 12);
      const mtime = decodeOct(buf, 136, 12);
      const type = toType(typeflag);
      const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
      const uname = decodeStr(buf, 265, 32);
      const gname = decodeStr(buf, 297, 32);
      const devmajor = decodeOct(buf, 329, 8);
      const devminor = decodeOct(buf, 337, 8);
      const c = cksum(buf);
      if (c === 8 * 32) return null;
      if (c !== decodeOct(buf, 148, 8)) throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
      if (isUSTAR(buf)) {
        if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
      } else if (isGNU(buf)) {
      } else {
        if (!allowUnknownFormat) {
          throw new Error("Invalid tar header: unknown format.");
        }
      }
      if (typeflag === 0 && name && name[name.length - 1] === "/") typeflag = 5;
      return {
        name,
        mode,
        uid,
        gid,
        size,
        mtime: new Date(1e3 * mtime),
        type,
        linkname,
        uname,
        gname,
        devmajor,
        devminor,
        pax: null
      };
    };
    function isUSTAR(buf) {
      return b4a.equals(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6));
    }
    function isGNU(buf) {
      return b4a.equals(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) && b4a.equals(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2));
    }
    function clamp(index, len, defaultValue) {
      if (typeof index !== "number") return defaultValue;
      index = ~~index;
      if (index >= len) return len;
      if (index >= 0) return index;
      index += len;
      if (index >= 0) return index;
      return 0;
    }
    function toType(flag) {
      switch (flag) {
        case 0:
          return "file";
        case 1:
          return "link";
        case 2:
          return "symlink";
        case 3:
          return "character-device";
        case 4:
          return "block-device";
        case 5:
          return "directory";
        case 6:
          return "fifo";
        case 7:
          return "contiguous-file";
        case 72:
          return "pax-header";
        case 55:
          return "pax-global-header";
        case 27:
          return "gnu-long-link-path";
        case 28:
        case 30:
          return "gnu-long-path";
      }
      return null;
    }
    function toTypeflag(flag) {
      switch (flag) {
        case "file":
          return 0;
        case "link":
          return 1;
        case "symlink":
          return 2;
        case "character-device":
          return 3;
        case "block-device":
          return 4;
        case "directory":
          return 5;
        case "fifo":
          return 6;
        case "contiguous-file":
          return 7;
        case "pax-header":
          return 72;
      }
      return 0;
    }
    function indexOf(block, num, offset, end) {
      for (; offset < end; offset++) {
        if (block[offset] === num) return offset;
      }
      return end;
    }
    function cksum(block) {
      let sum = 8 * 32;
      for (let i = 0; i < 148; i++) sum += block[i];
      for (let j = 156; j < 512; j++) sum += block[j];
      return sum;
    }
    function encodeOct(val, n) {
      val = val.toString(8);
      if (val.length > n) return SEVENS.slice(0, n) + " ";
      return ZEROS.slice(0, n - val.length) + val + " ";
    }
    function encodeSizeBin(num, buf, off) {
      buf[off] = 128;
      for (let i = 11; i > 0; i--) {
        buf[off + i] = num & 255;
        num = Math.floor(num / 256);
      }
    }
    function encodeSize(num, buf, off) {
      if (num.toString(8).length > 11) {
        encodeSizeBin(num, buf, off);
      } else {
        b4a.write(buf, encodeOct(num, 11), off);
      }
    }
    function parse256(buf) {
      let positive;
      if (buf[0] === 128) positive = true;
      else if (buf[0] === 255) positive = false;
      else return null;
      const tuple = [];
      let i;
      for (i = buf.length - 1; i > 0; i--) {
        const byte = buf[i];
        if (positive) tuple.push(byte);
        else tuple.push(255 - byte);
      }
      let sum = 0;
      const l = tuple.length;
      for (i = 0; i < l; i++) {
        sum += tuple[i] * Math.pow(256, i);
      }
      return positive ? sum : -1 * sum;
    }
    function decodeOct(val, offset, length) {
      val = val.subarray(offset, offset + length);
      offset = 0;
      if (val[offset] & 128) {
        return parse256(val);
      } else {
        while (offset < val.length && val[offset] === 32) offset++;
        const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
        while (offset < end && val[offset] === 0) offset++;
        if (end === offset) return 0;
        return parseInt(b4a.toString(val.subarray(offset, end)), 8);
      }
    }
    function decodeStr(val, offset, length, encoding) {
      return b4a.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding);
    }
    function addLength(str) {
      const len = b4a.byteLength(str);
      let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
      if (len + digits >= Math.pow(10, digits)) digits++;
      return len + digits + str;
    }
  }
});

// node_modules/tar-stream/extract.js
var require_extract = __commonJS({
  "node_modules/tar-stream/extract.js"(exports2, module2) {
    "use strict";
    var { Writable, Readable, getStreamError } = require_streamx();
    var FIFO = require_fast_fifo();
    var b4a = require_b4a();
    var headers = require_headers();
    var EMPTY = b4a.alloc(0);
    var BufferList = class {
      constructor() {
        this.buffered = 0;
        this.shifted = 0;
        this.queue = new FIFO();
        this._offset = 0;
      }
      push(buffer) {
        this.buffered += buffer.byteLength;
        this.queue.push(buffer);
      }
      shiftFirst(size) {
        return this._buffered === 0 ? null : this._next(size);
      }
      shift(size) {
        if (size > this.buffered) return null;
        if (size === 0) return EMPTY;
        let chunk = this._next(size);
        if (size === chunk.byteLength) return chunk;
        const chunks = [chunk];
        while ((size -= chunk.byteLength) > 0) {
          chunk = this._next(size);
          chunks.push(chunk);
        }
        return b4a.concat(chunks);
      }
      _next(size) {
        const buf = this.queue.peek();
        const rem = buf.byteLength - this._offset;
        if (size >= rem) {
          const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf;
          this.queue.shift();
          this._offset = 0;
          this.buffered -= rem;
          this.shifted += rem;
          return sub;
        }
        this.buffered -= size;
        this.shifted += size;
        return buf.subarray(this._offset, this._offset += size);
      }
    };
    var Source = class extends Readable {
      constructor(self, header, offset) {
        super();
        this.header = header;
        this.offset = offset;
        this._parent = self;
      }
      _read(cb) {
        if (this.header.size === 0) {
          this.push(null);
        }
        if (this._parent._stream === this) {
          this._parent._update();
        }
        cb(null);
      }
      _predestroy() {
        this._parent.destroy(getStreamError(this));
      }
      _detach() {
        if (this._parent._stream === this) {
          this._parent._stream = null;
          this._parent._missing = overflow(this.header.size);
          this._parent._update();
        }
      }
      _destroy(cb) {
        this._detach();
        cb(null);
      }
    };
    var Extract = class extends Writable {
      constructor(opts) {
        super(opts);
        if (!opts) opts = {};
        this._buffer = new BufferList();
        this._offset = 0;
        this._header = null;
        this._stream = null;
        this._missing = 0;
        this._longHeader = false;
        this._callback = noop;
        this._locked = false;
        this._finished = false;
        this._pax = null;
        this._paxGlobal = null;
        this._gnuLongPath = null;
        this._gnuLongLinkPath = null;
        this._filenameEncoding = opts.filenameEncoding || "utf-8";
        this._allowUnknownFormat = !!opts.allowUnknownFormat;
        this._unlockBound = this._unlock.bind(this);
      }
      _unlock(err) {
        this._locked = false;
        if (err) {
          this.destroy(err);
          this._continueWrite(err);
          return;
        }
        this._update();
      }
      _consumeHeader() {
        if (this._locked) return false;
        this._offset = this._buffer.shifted;
        try {
          this._header = headers.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat);
        } catch (err) {
          this._continueWrite(err);
          return false;
        }
        if (!this._header) return true;
        switch (this._header.type) {
          case "gnu-long-path":
          case "gnu-long-link-path":
          case "pax-global-header":
          case "pax-header":
            this._longHeader = true;
            this._missing = this._header.size;
            return true;
        }
        this._locked = true;
        this._applyLongHeaders();
        if (this._header.size === 0 || this._header.type === "directory") {
          this.emit("entry", this._header, this._createStream(), this._unlockBound);
          return true;
        }
        this._stream = this._createStream();
        this._missing = this._header.size;
        this.emit("entry", this._header, this._stream, this._unlockBound);
        return true;
      }
      _applyLongHeaders() {
        if (this._gnuLongPath) {
          this._header.name = this._gnuLongPath;
          this._gnuLongPath = null;
        }
        if (this._gnuLongLinkPath) {
          this._header.linkname = this._gnuLongLinkPath;
          this._gnuLongLinkPath = null;
        }
        if (this._pax) {
          if (this._pax.path) this._header.name = this._pax.path;
          if (this._pax.linkpath) this._header.linkname = this._pax.linkpath;
          if (this._pax.size) this._header.size = parseInt(this._pax.size, 10);
          this._header.pax = this._pax;
          this._pax = null;
        }
      }
      _decodeLongHeader(buf) {
        switch (this._header.type) {
          case "gnu-long-path":
            this._gnuLongPath = headers.decodeLongPath(buf, this._filenameEncoding);
            break;
          case "gnu-long-link-path":
            this._gnuLongLinkPath = headers.decodeLongPath(buf, this._filenameEncoding);
            break;
          case "pax-global-header":
            this._paxGlobal = headers.decodePax(buf);
            break;
          case "pax-header":
            this._pax = this._paxGlobal === null ? headers.decodePax(buf) : Object.assign({}, this._paxGlobal, headers.decodePax(buf));
            break;
        }
      }
      _consumeLongHeader() {
        this._longHeader = false;
        this._missing = overflow(this._header.size);
        const buf = this._buffer.shift(this._header.size);
        try {
          this._decodeLongHeader(buf);
        } catch (err) {
          this._continueWrite(err);
          return false;
        }
        return true;
      }
      _consumeStream() {
        const buf = this._buffer.shiftFirst(this._missing);
        if (buf === null) return false;
        this._missing -= buf.byteLength;
        const drained = this._stream.push(buf);
        if (this._missing === 0) {
          this._stream.push(null);
          if (drained) this._stream._detach();
          return drained && this._locked === false;
        }
        return drained;
      }
      _createStream() {
        return new Source(this, this._header, this._offset);
      }
      _update() {
        while (this._buffer.buffered > 0 && !this.destroying) {
          if (this._missing > 0) {
            if (this._stream !== null) {
              if (this._consumeStream() === false) return;
              continue;
            }
            if (this._longHeader === true) {
              if (this._missing > this._buffer.buffered) break;
              if (this._consumeLongHeader() === false) return false;
              continue;
            }
            const ignore = this._buffer.shiftFirst(this._missing);
            if (ignore !== null) this._missing -= ignore.byteLength;
            continue;
          }
          if (this._buffer.buffered < 512) break;
          if (this._stream !== null || this._consumeHeader() === false) return;
        }
        this._continueWrite(null);
      }
      _continueWrite(err) {
        const cb = this._callback;
        this._callback = noop;
        cb(err);
      }
      _write(data, cb) {
        this._callback = cb;
        this._buffer.push(data);
        this._update();
      }
      _final(cb) {
        this._finished = this._missing === 0 && this._buffer.buffered === 0;
        cb(this._finished ? null : new Error("Unexpected end of data"));
      }
      _predestroy() {
        this._continueWrite(null);
      }
      _destroy(cb) {
        if (this._stream) this._stream.destroy(getStreamError(this));
        cb(null);
      }
      [Symbol.asyncIterator]() {
        let error2 = null;
        let promiseResolve = null;
        let promiseReject = null;
        let entryStream = null;
        let entryCallback = null;
        const extract = this;
        this.on("entry", onentry);
        this.on("error", (err) => {
          error2 = err;
        });
        this.on("close", onclose);
        return {
          [Symbol.asyncIterator]() {
            return this;
          },
          next() {
            return new Promise(onnext);
          },
          return() {
            return destroy(null);
          },
          throw(err) {
            return destroy(err);
          }
        };
        function consumeCallback(err) {
          if (!entryCallback) return;
          const cb = entryCallback;
          entryCallback = null;
          cb(err);
        }
        function onnext(resolve, reject) {
          if (error2) {
            return reject(error2);
          }
          if (entryStream) {
            resolve({ value: entryStream, done: false });
            entryStream = null;
            return;
          }
          promiseResolve = resolve;
          promiseReject = reject;
          consumeCallback(null);
          if (extract._finished && promiseResolve) {
            promiseResolve({ value: void 0, done: true });
            promiseResolve = promiseReject = null;
          }
        }
        function onentry(header, stream, callback) {
          entryCallback = callback;
          stream.on("error", noop);
          if (promiseResolve) {
            promiseResolve({ value: stream, done: false });
            promiseResolve = promiseReject = null;
          } else {
            entryStream = stream;
          }
        }
        function onclose() {
          consumeCallback(error2);
          if (!promiseResolve) return;
          if (error2) promiseReject(error2);
          else promiseResolve({ value: void 0, done: true });
          promiseResolve = promiseReject = null;
        }
        function destroy(err) {
          extract.destroy(err);
          consumeCallback(err);
          return new Promise((resolve, reject) => {
            if (extract.destroyed) return resolve({ value: void 0, done: true });
            extract.once("close", function() {
              if (err) reject(err);
              else resolve({ value: void 0, done: true });
            });
          });
        }
      }
    };
    module2.exports = function extract(opts) {
      return new Extract(opts);
    };
    function noop() {
    }
    function overflow(size) {
      size &= 511;
      return size && 512 - size;
    }
  }
});

// node_modules/tar-stream/constants.js
var require_constants2 = __commonJS({
  "node_modules/tar-stream/constants.js"(exports2, module2) {
    "use strict";
    var constants = {
      // just for envs without fs
      S_IFMT: 61440,
      S_IFDIR: 16384,
      S_IFCHR: 8192,
      S_IFBLK: 24576,
      S_IFIFO: 4096,
      S_IFLNK: 40960
    };
    try {
      module2.exports = require("fs").constants || constants;
    } catch {
      module2.exports = constants;
    }
  }
});

// node_modules/tar-stream/pack.js
var require_pack = __commonJS({
  "node_modules/tar-stream/pack.js"(exports2, module2) {
    "use strict";
    var { Readable, Writable, getStreamError } = require_streamx();
    var b4a = require_b4a();
    var constants = require_constants2();
    var headers = require_headers();
    var DMODE = 493;
    var FMODE = 420;
    var END_OF_TAR = b4a.alloc(1024);
    var Sink = class extends Writable {
      constructor(pack, header, callback) {
        super({ mapWritable, eagerOpen: true });
        this.written = 0;
        this.header = header;
        this._callback = callback;
        this._linkname = null;
        this._isLinkname = header.type === "symlink" && !header.linkname;
        this._isVoid = header.type !== "file" && header.type !== "contiguous-file";
        this._finished = false;
        this._pack = pack;
        this._openCallback = null;
        if (this._pack._stream === null) this._pack._stream = this;
        else this._pack._pending.push(this);
      }
      _open(cb) {
        this._openCallback = cb;
        if (this._pack._stream === this) this._continueOpen();
      }
      _continuePack(err) {
        if (this._callback === null) return;
        const callback = this._callback;
        this._callback = null;
        callback(err);
      }
      _continueOpen() {
        if (this._pack._stream === null) this._pack._stream = this;
        const cb = this._openCallback;
        this._openCallback = null;
        if (cb === null) return;
        if (this._pack.destroying) return cb(new Error("pack stream destroyed"));
        if (this._pack._finalized) return cb(new Error("pack stream is already finalized"));
        this._pack._stream = this;
        if (!this._isLinkname) {
          this._pack._encode(this.header);
        }
        if (this._isVoid) {
          this._finish();
          this._continuePack(null);
        }
        cb(null);
      }
      _write(data, cb) {
        if (this._isLinkname) {
          this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data;
          return cb(null);
        }
        if (this._isVoid) {
          if (data.byteLength > 0) {
            return cb(new Error("No body allowed for this entry"));
          }
          return cb();
        }
        this.written += data.byteLength;
        if (this._pack.push(data)) return cb();
        this._pack._drain = cb;
      }
      _finish() {
        if (this._finished) return;
        this._finished = true;
        if (this._isLinkname) {
          this.header.linkname = this._linkname ? b4a.toString(this._linkname, "utf-8") : "";
          this._pack._encode(this.header);
        }
        overflow(this._pack, this.header.size);
        this._pack._done(this);
      }
      _final(cb) {
        if (this.written !== this.header.size) {
          return cb(new Error("Size mismatch"));
        }
        this._finish();
        cb(null);
      }
      _getError() {
        return getStreamError(this) || new Error("tar entry destroyed");
      }
      _predestroy() {
        this._pack.destroy(this._getError());
      }
      _destroy(cb) {
        this._pack._done(this);
        this._continuePack(this._finished ? null : this._getError());
        cb();
      }
    };
    var Pack = class extends Readable {
      constructor(opts) {
        super(opts);
        this._drain = noop;
        this._finalized = false;
        this._finalizing = false;
        this._pending = [];
        this._stream = null;
      }
      entry(header, buffer, callback) {
        if (this._finalized || this.destroying) throw new Error("already finalized or destroyed");
        if (typeof buffer === "function") {
          callback = buffer;
          buffer = null;
        }
        if (!callback) callback = noop;
        if (!header.size || header.type === "symlink") header.size = 0;
        if (!header.type) header.type = modeToType(header.mode);
        if (!header.mode) header.mode = header.type === "directory" ? DMODE : FMODE;
        if (!header.uid) header.uid = 0;
        if (!header.gid) header.gid = 0;
        if (!header.mtime) header.mtime = /* @__PURE__ */ new Date();
        if (typeof buffer === "string") buffer = b4a.from(buffer);
        const sink = new Sink(this, header, callback);
        if (b4a.isBuffer(buffer)) {
          header.size = buffer.byteLength;
          sink.write(buffer);
          sink.end();
          return sink;
        }
        if (sink._isVoid) {
          return sink;
        }
        return sink;
      }
      finalize() {
        if (this._stream || this._pending.length > 0) {
          this._finalizing = true;
          return;
        }
        if (this._finalized) return;
        this._finalized = true;
        this.push(END_OF_TAR);
        this.push(null);
      }
      _done(stream) {
        if (stream !== this._stream) return;
        this._stream = null;
        if (this._finalizing) this.finalize();
        if (this._pending.length) this._pending.shift()._continueOpen();
      }
      _encode(header) {
        if (!header.pax) {
          const buf = headers.encode(header);
          if (buf) {
            this.push(buf);
            return;
          }
        }
        this._encodePax(header);
      }
      _encodePax(header) {
        const paxHeader = headers.encodePax({
          name: header.name,
          linkname: header.linkname,
          pax: header.pax
        });
        const newHeader = {
          name: "PaxHeader",
          mode: header.mode,
          uid: header.uid,
          gid: header.gid,
          size: paxHeader.byteLength,
          mtime: header.mtime,
          type: "pax-header",
          linkname: header.linkname && "PaxHeader",
          uname: header.uname,
          gname: header.gname,
          devmajor: header.devmajor,
          devminor: header.devminor
        };
        this.push(headers.encode(newHeader));
        this.push(paxHeader);
        overflow(this, paxHeader.byteLength);
        newHeader.size = header.size;
        newHeader.type = header.type;
        this.push(headers.encode(newHeader));
      }
      _doDrain() {
        const drain = this._drain;
        this._drain = noop;
        drain();
      }
      _predestroy() {
        const err = getStreamError(this);
        if (this._stream) this._stream.destroy(err);
        while (this._pending.length) {
          const stream = this._pending.shift();
          stream.destroy(err);
          stream._continueOpen();
        }
        this._doDrain();
      }
      _read(cb) {
        this._doDrain();
        cb();
      }
    };
    module2.exports = function pack(opts) {
      return new Pack(opts);
    };
    function modeToType(mode) {
      switch (mode & constants.S_IFMT) {
        case constants.S_IFBLK:
          return "block-device";
        case constants.S_IFCHR:
          return "character-device";
        case constants.S_IFDIR:
          return "directory";
        case constants.S_IFIFO:
          return "fifo";
        case constants.S_IFLNK:
          return "symlink";
      }
      return "file";
    }
    function noop() {
    }
    function overflow(self, size) {
      size &= 511;
      if (size) self.push(END_OF_TAR.subarray(0, 512 - size));
    }
    function mapWritable(buf) {
      return b4a.isBuffer(buf) ? buf : b4a.from(buf);
    }
  }
});

// node_modules/tar-stream/index.js
var require_tar_stream = __commonJS({
  "node_modules/tar-stream/index.js"(exports2) {
    "use strict";
    exports2.extract = require_extract();
    exports2.pack = require_pack();
  }
});

// node_modules/pend/index.js
var require_pend = __commonJS({
  "node_modules/pend/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    Pend.prototype.go = function(fn) {
      if (this.pending < this.max) {
        pendGo(this, fn);
      } else {
        this.waiting.push(fn);
      }
    };
    Pend.prototype.wait = function(cb) {
      if (this.pending === 0) {
        cb(this.error);
      } else {
        this.listeners.push(cb);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self) {
      self.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called) throw new Error("callback called twice");
        called = true;
        self.error = self.error || err;
        self.pending -= 1;
        if (self.waiting.length > 0 && self.pending < self.max) {
          pendGo(self, self.waiting.shift());
        } else if (self.pending === 0) {
          var listeners = self.listeners;
          self.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      function cbListener(listener) {
        listener(self.error);
      }
    }
    function pendGo(self, fn) {
      fn(pendHold(self));
    }
  }
});

// node_modules/yauzl/fd-slicer.js
var require_fd_slicer = __commonJS({
  "node_modules/yauzl/fd-slicer.js"(exports2) {
    "use strict";
    var fs = require("fs");
    var util = require("util");
    var stream = require("stream");
    var Readable = stream.Readable;
    var Writable = stream.Writable;
    var PassThrough = stream.PassThrough;
    var Pend = require_pend();
    var EventEmitter = require("events").EventEmitter;
    exports2.createFromBuffer = createFromBuffer;
    exports2.createFromFd = createFromFd;
    exports2.BufferSlicer = BufferSlicer;
    exports2.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options2) {
      options2 = options2 || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options2.autoClose;
    }
    FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var self = this;
      self.pend.go(function(cb) {
        fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          cb();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      var self = this;
      self.pend.go(function(cb) {
        fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer2) {
          cb();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options2) {
      return new ReadStream(this, options2);
    };
    FdSlicer.prototype.createWriteStream = function(options2) {
      return new WriteStream(this, options2);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self = this;
      self.refCount -= 1;
      if (self.refCount > 0) return;
      if (self.refCount < 0) throw new Error("invalid unref");
      if (self.autoClose) {
        fs.close(self.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self.emit("error", err);
        } else {
          self.emit("close");
        }
      }
    };
    util.inherits(ReadStream, Readable);
    function ReadStream(context, options2) {
      options2 = options2 || {};
      Readable.call(this, options2);
      this.context = context;
      this.context.ref();
      this.start = options2.start || 0;
      this.endOffset = options2.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    ReadStream.prototype._read = function(n) {
      var self = this;
      if (self.destroyed) return;
      var toRead = Math.min(self._readableState.highWaterMark, n);
      if (self.endOffset != null) {
        toRead = Math.min(toRead, self.endOffset - self.pos);
      }
      if (toRead <= 0) {
        self.destroyed = true;
        self.push(null);
        self.context.unref();
        return;
      }
      self.context.pend.go(function(cb) {
        if (self.destroyed) return cb();
        var buffer = Buffer.allocUnsafe(toRead);
        fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {
          if (err) {
            self.destroy(err);
          } else if (bytesRead === 0) {
            self.destroyed = true;
            self.push(null);
            self.context.unref();
          } else {
            self.pos += bytesRead;
            self.push(buffer.slice(0, bytesRead));
          }
          cb();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed) return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable);
    function WriteStream(context, options2) {
      options2 = options2 || {};
      Writable.call(this, options2);
      this.context = context;
      this.context.ref();
      this.start = options2.start || 0;
      this.endOffset = options2.end == null ? Infinity : +options2.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self = this;
      if (self.destroyed) return;
      if (self.pos + buffer.length > self.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self.destroy();
        callback(err);
        return;
      }
      self.context.pend.go(function(cb) {
        if (self.destroyed) return cb();
        fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err2, bytes) {
          if (err2) {
            self.destroy();
            cb();
            callback(err2);
          } else {
            self.bytesWritten += bytes;
            self.pos += bytes;
            self.emit("progress");
            cb();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed) return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options2) {
      EventEmitter.call(this);
      options2 = options2 || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options2.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      if (!(0 <= offset && offset <= buffer.length)) throw new RangeError("offset outside buffer: 0 <= " + offset + " <= " + buffer.length);
      if (position < 0) throw new RangeError("position is negative: " + position);
      if (offset + length > buffer.length) {
        length = buffer.length - offset;
      }
      if (position + length > this.buffer.length) {
        length = this.buffer.length - position;
      }
      if (length <= 0) {
        setImmediate(function() {
          callback(null, 0);
        });
        return;
      }
      this.buffer.copy(buffer, offset, position, position + length);
      setImmediate(function() {
        callback(null, length);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      buffer.copy(this.buffer, position, offset, offset + length);
      setImmediate(function() {
        callback(null, length, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options2) {
      options2 = options2 || {};
      var readStream = new PassThrough(options2);
      readStream.destroyed = false;
      readStream.start = options2.start || 0;
      readStream.endOffset = options2.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options2) {
      var bufferSlicer = this;
      options2 = options2 || {};
      var writeStream = new Writable(options2);
      writeStream.start = options2.start || 0;
      writeStream.endOffset = options2.end == null ? this.buffer.length : +options2.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed) return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options2) {
      return new BufferSlicer(buffer, options2);
    }
    function createFromFd(fd, options2) {
      return new FdSlicer(fd, options2);
    }
  }
});

// node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "node_modules/buffer-crc32/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "node_modules/yauzl/index.js"(exports2) {
    "use strict";
    var fs = require("fs");
    var zlib = require("zlib");
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var Writable = require("stream").Writable;
    exports2.open = open;
    exports2.fromFd = fromFd;
    exports2.fromBuffer = fromBuffer;
    exports2.fromRandomAccessReader = fromRandomAccessReader;
    exports2.dosDateTimeToDate = dosDateTimeToDate;
    exports2.getFileNameLowLevel = getFileNameLowLevel;
    exports2.validateFileName = validateFileName;
    exports2.parseExtraFields = parseExtraFields;
    exports2.ZipFile = ZipFile;
    exports2.Entry = Entry;
    exports2.LocalFileHeader = LocalFileHeader;
    exports2.RandomAccessReader = RandomAccessReader;
    function open(path, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      if (options2.autoClose == null) options2.autoClose = true;
      if (options2.lazyEntries == null) options2.lazyEntries = false;
      if (options2.decodeStrings == null) options2.decodeStrings = true;
      if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
      if (options2.strictFileNames == null) options2.strictFileNames = false;
      if (callback == null) callback = defaultCallback;
      fs.open(path, "r", function(err, fd) {
        if (err) return callback(err);
        fromFd(fd, options2, function(err2, zipfile) {
          if (err2) fs.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    function fromFd(fd, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      if (options2.autoClose == null) options2.autoClose = false;
      if (options2.lazyEntries == null) options2.lazyEntries = false;
      if (options2.decodeStrings == null) options2.decodeStrings = true;
      if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
      if (options2.strictFileNames == null) options2.strictFileNames = false;
      if (callback == null) callback = defaultCallback;
      fs.fstat(fd, function(err, stats) {
        if (err) return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options2, callback);
      });
    }
    function fromBuffer(buffer, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      options2.autoClose = false;
      if (options2.lazyEntries == null) options2.lazyEntries = false;
      if (options2.decodeStrings == null) options2.decodeStrings = true;
      if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
      if (options2.strictFileNames == null) options2.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options2, callback);
    }
    function fromRandomAccessReader(reader, totalSize, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      if (options2.autoClose == null) options2.autoClose = true;
      if (options2.lazyEntries == null) options2.lazyEntries = false;
      if (options2.decodeStrings == null) options2.decodeStrings = true;
      var decodeStrings = !!options2.decodeStrings;
      if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
      if (options2.strictFileNames == null) options2.strictFileNames = false;
      if (callback == null) callback = defaultCallback;
      if (typeof totalSize !== "number") throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var zip64EocdlSize = 20;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(zip64EocdlSize + eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err) return callback(err);
        for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
          if (buffer.readUInt32LE(i) !== 101010256) continue;
          var eocdrBuffer = buffer.subarray(i);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("Invalid comment length. Expected: " + expectedCommentLength + ". Found: " + commentLength + ". Are there extra bytes at the end of the file? Or is the end of central dir signature `PK\u263A\u263B` in the comment?"));
          }
          var comment = decodeStrings ? decodeBuffer(eocdrBuffer.subarray(22), false) : eocdrBuffer.subarray(22);
          if (i - zip64EocdlSize >= 0 && buffer.readUInt32LE(i - zip64EocdlSize) === 117853008) {
            var zip64EocdlBuffer = buffer.subarray(i - zip64EocdlSize, i - zip64EocdlSize + zip64EocdlSize);
            var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            return readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err2) {
              if (err2) return callback(err2);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              diskNumber = zip64EocdrBuffer.readUInt32LE(16);
              if (diskNumber !== 0) {
                return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
              }
              entryCount = readUInt64LE(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options2.autoClose, options2.lazyEntries, decodeStrings, options2.validateEntrySizes, options2.strictFileNames));
            });
          }
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options2.autoClose, options2.lazyEntries, decodeStrings, options2.validateEntrySizes, options2.strictFileNames));
        }
        callback(new Error("End of central directory record signature not found. Either not a zip file, or file is truncated."));
      });
    }
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self = this;
      EventEmitter.call(self);
      self.reader = reader;
      self.reader.on("error", function(err) {
        emitError(self, err);
      });
      self.reader.once("close", function() {
        self.emit("close");
      });
      self.readEntryCursor = centralDirectoryOffset;
      self.fileSize = fileSize;
      self.entryCount = entryCount;
      self.comment = comment;
      self.entriesRead = 0;
      self.autoClose = !!autoClose;
      self.lazyEntries = !!lazyEntries;
      self.decodeStrings = !!decodeStrings;
      self.validateEntrySizes = !!validateEntrySizes;
      self.strictFileNames = !!strictFileNames;
      self.isOpen = true;
      self.emittedError = false;
      if (!self.lazyEntries) self._readEntry();
    }
    ZipFile.prototype.close = function() {
      if (!this.isOpen) return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self, err) {
      if (self.autoClose) self.close();
      emitError(self, err);
    }
    function emitError(self, err) {
      if (self.emittedError) return;
      self.emittedError = true;
      self.emit("error", err);
    }
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self = this;
      if (self.entryCount === self.entriesRead) {
        setImmediate(function() {
          if (self.autoClose) self.close();
          if (self.emittedError) return;
          self.emit("end");
        });
        return;
      }
      if (self.emittedError) return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
        if (err) return emitErrorAndAutoClose(self, err);
        if (self.emittedError) return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248) return emitErrorAndAutoClose(self, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64) return emitErrorAndAutoClose(self, new Error("strong encryption is not supported"));
        self.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err2) {
          if (err2) return emitErrorAndAutoClose(self, err2);
          if (self.emittedError) return;
          entry.fileNameRaw = buffer.subarray(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          entry.extraFieldRaw = buffer.subarray(entry.fileNameLength, fileCommentStart);
          entry.fileCommentRaw = buffer.subarray(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          try {
            entry.extraFields = parseExtraFields(entry.extraFieldRaw);
          } catch (err3) {
            return emitErrorAndAutoClose(self, err3);
          }
          if (self.decodeStrings) {
            var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
            entry.fileComment = decodeBuffer(entry.fileCommentRaw, isUtf8);
            entry.fileName = getFileNameLowLevel(entry.generalPurposeBitFlag, entry.fileNameRaw, entry.extraFields, self.strictFileNames);
            var errorMessage = validateFileName(entry.fileName);
            if (errorMessage != null) return emitErrorAndAutoClose(self, new Error(errorMessage));
          } else {
            entry.fileComment = entry.fileCommentRaw;
            entry.fileName = entry.fileNameRaw;
          }
          entry.comment = entry.fileComment;
          self.readEntryCursor += buffer.length;
          self.entriesRead += 1;
          for (var i = 0; i < entry.extraFields.length; i++) {
            var extraField = entry.extraFields[i];
            if (extraField.id !== 1) continue;
            var zip64EiefBuffer = extraField.data;
            var index = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            break;
          }
          if (self.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self, new Error(msg));
            }
          }
          self.emit("entry", entry);
          if (!self.lazyEntries) self._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options2, callback) {
      var self = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) {
        options2 = {};
      } else {
        if (options2.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options2.decrypt !== false) throw new Error("invalid options.decrypt value: " + options2.decrypt);
          if (entry.isCompressed()) {
            if (options2.decompress !== false) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options2.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options2.decompress === false || options2.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options2.decompress);
          }
        }
        if (options2.start != null || options2.end != null) {
          if (entry.isCompressed() && options2.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options2.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options2.start != null) {
          relativeStart = options2.start;
          if (relativeStart < 0) throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
        }
        if (options2.end != null) {
          relativeEnd = options2.end;
          if (relativeEnd < 0) throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
        }
      }
      if (!self.isOpen) return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options2.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      var decompress;
      if (entry.compressionMethod === 0) {
        decompress = false;
      } else if (entry.compressionMethod === 8) {
        decompress = options2.decompress != null ? options2.decompress : true;
      } else {
        return callback(new Error("unsupported compression method: " + entry.compressionMethod));
      }
      self.readLocalFileHeader(entry, { minimal: true }, function(err, localFileHeader) {
        if (err) return callback(err);
        self.openReadStreamLowLevel(
          localFileHeader.fileDataStart,
          entry.compressedSize,
          relativeStart,
          relativeEnd,
          decompress,
          entry.uncompressedSize,
          callback
        );
      });
    };
    ZipFile.prototype.openReadStreamLowLevel = function(fileDataStart, compressedSize, relativeStart, relativeEnd, decompress, uncompressedSize, callback) {
      var self = this;
      var fileDataEnd = fileDataStart + compressedSize;
      var readStream = self.reader.createReadStream({
        start: fileDataStart + relativeStart,
        end: fileDataStart + relativeEnd
      });
      var endpointStream = readStream;
      if (decompress) {
        var destroyed = false;
        var inflateFilter = zlib.createInflateRaw();
        readStream.on("error", function(err) {
          setImmediate(function() {
            if (!destroyed) inflateFilter.emit("error", err);
          });
        });
        readStream.pipe(inflateFilter);
        if (self.validateEntrySizes) {
          endpointStream = new AssertByteCountStream(uncompressedSize);
          inflateFilter.on("error", function(err) {
            setImmediate(function() {
              if (!destroyed) endpointStream.emit("error", err);
            });
          });
          inflateFilter.pipe(endpointStream);
        } else {
          endpointStream = inflateFilter;
        }
        installDestroyFn(endpointStream, function() {
          destroyed = true;
          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
          readStream.unpipe(inflateFilter);
          readStream.destroy();
        });
      }
      callback(null, endpointStream);
    };
    ZipFile.prototype.readLocalFileHeader = function(entry, options2, callback) {
      var self = this;
      if (callback == null) {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      self.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err) return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var fileDataStart = entry.relativeOffsetOfLocalHeader + 30 + fileNameLength + extraFieldLength;
          if (fileDataStart + entry.compressedSize > self.fileSize) {
            return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self.fileSize));
          }
          if (options2.minimal) {
            return callback(null, { fileDataStart });
          }
          var localFileHeader = new LocalFileHeader();
          localFileHeader.fileDataStart = fileDataStart;
          localFileHeader.versionNeededToExtract = buffer.readUInt16LE(4);
          localFileHeader.generalPurposeBitFlag = buffer.readUInt16LE(6);
          localFileHeader.compressionMethod = buffer.readUInt16LE(8);
          localFileHeader.lastModFileTime = buffer.readUInt16LE(10);
          localFileHeader.lastModFileDate = buffer.readUInt16LE(12);
          localFileHeader.crc32 = buffer.readUInt32LE(14);
          localFileHeader.compressedSize = buffer.readUInt32LE(18);
          localFileHeader.uncompressedSize = buffer.readUInt32LE(22);
          localFileHeader.fileNameLength = fileNameLength;
          localFileHeader.extraFieldLength = extraFieldLength;
          buffer = newBuffer(fileNameLength + extraFieldLength);
          self.reader.ref();
          readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader + 30, function(err2) {
            try {
              if (err2) return callback(err2);
              localFileHeader.fileName = buffer.subarray(0, fileNameLength);
              localFileHeader.extraField = buffer.subarray(fileNameLength);
              return callback(null, localFileHeader);
            } finally {
              self.reader.unref();
            }
          });
        } finally {
          self.reader.unref();
        }
      });
    };
    function Entry() {
    }
    Entry.prototype.getLastModDate = function(options2) {
      if (options2 == null) options2 = {};
      if (!options2.forceDosFormat) {
        for (var i = 0; i < this.extraFields.length; i++) {
          var extraField = this.extraFields[i];
          if (extraField.id === 21589) {
            var data = extraField.data;
            if (data.length < 5) continue;
            var flags = data[0];
            var HAS_MTIME = 1;
            if (!(flags & HAS_MTIME)) continue;
            var posixTimestamp = data.readInt32LE(1);
            return new Date(posixTimestamp * 1e3);
          } else if (extraField.id === 10) {
            var data = extraField.data;
            var cursor = 4;
            while (cursor < data.length + 4) {
              var tag = data.readUInt16LE(cursor);
              cursor += 2;
              var size = data.readUInt16LE(cursor);
              cursor += 2;
              if (tag !== 1) {
                cursor += size;
                continue;
              }
              if (size < 8 || cursor + size > data.length) break;
              var hundredNanoSecondsSince1601 = 4294967296 * data.readInt32LE(cursor + 4) + data.readUInt32LE(cursor);
              var millisecondsSince1970 = hundredNanoSecondsSince1601 / 1e4 - 116444736e5;
              return new Date(millisecondsSince1970);
            }
          }
        }
      }
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime, options2.timezone);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function LocalFileHeader() {
    }
    function dosDateTimeToDate(date, time, timezone) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      if (timezone == null || timezone === "local") {
        return new Date(year, month, day, hour, minute, second, millisecond);
      } else if (timezone === "UTC") {
        return new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));
      } else {
        throw new Error("unrecognized options.timezone: " + options.timezone);
      }
    }
    function getFileNameLowLevel(generalPurposeBitFlag, fileNameBuffer, extraFields, strictFileNames) {
      var fileName = null;
      for (var i = 0; i < extraFields.length; i++) {
        var extraField = extraFields[i];
        if (extraField.id === 28789) {
          if (extraField.data.length < 6) {
            continue;
          }
          if (extraField.data.readUInt8(0) !== 1) {
            continue;
          }
          var oldNameCrc32 = extraField.data.readUInt32LE(1);
          if (crc32.unsigned(fileNameBuffer) !== oldNameCrc32) {
            continue;
          }
          fileName = decodeBuffer(extraField.data.subarray(5), true);
          break;
        }
      }
      if (fileName == null) {
        var isUtf8 = (generalPurposeBitFlag & 2048) !== 0;
        fileName = decodeBuffer(fileNameBuffer, isUtf8);
      }
      if (!strictFileNames) {
        fileName = fileName.replace(/\\/g, "/");
      }
      return fileName;
    }
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    function parseExtraFields(extraFieldBuffer) {
      var extraFields = [];
      var i = 0;
      while (i < extraFieldBuffer.length - 3) {
        var headerId = extraFieldBuffer.readUInt16LE(i + 0);
        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
        var dataStart = i + 4;
        var dataEnd = dataStart + dataSize;
        if (dataEnd > extraFieldBuffer.length) throw new Error("extra field length exceeds extra field buffer size");
        var dataBuffer = extraFieldBuffer.subarray(dataStart, dataEnd);
        extraFields.push({
          id: headerId,
          data: dataBuffer
        });
        i = dataEnd;
      }
      return extraFields;
    }
    function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
      if (length === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err) return callback(err);
        if (bytesRead < length) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    util.inherits(AssertByteCountStream, Transform);
    function AssertByteCountStream(byteCount) {
      Transform.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
      this.actualByteCount += chunk.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb(null, chunk);
    };
    AssertByteCountStream.prototype._flush = function(cb) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self = this;
      self.refCount -= 1;
      if (self.refCount > 0) return;
      if (self.refCount < 0) throw new Error("invalid unref");
      self.close(onCloseDone);
      function onCloseDone(err) {
        if (err) return self.emit("error", err);
        self.emit("close");
      }
    };
    RandomAccessReader.prototype.createReadStream = function(options2) {
      if (options2 == null) options2 = {};
      var start = options2.start;
      var end = options2.end;
      if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed) refUnrefFilter.emit("error", err);
        });
      });
      installDestroyFn(refUnrefFilter, function() {
        stream.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream.destroy();
      });
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed) byteCounter.emit("error", err);
        });
      });
      installDestroyFn(byteCounter, function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      });
      return stream.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
      var readStream = this.createReadStream({ start: position, end: position + length });
      var writeStream = new Writable();
      var written = 0;
      writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error2) {
        callback(error2);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough);
    function RefUnrefFilter(context) {
      PassThrough.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    RefUnrefFilter.prototype._flush = function(cb) {
      this.unref();
      cb();
    };
    RefUnrefFilter.prototype.unref = function(cb) {
      if (this.unreffedYet) return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    function decodeBuffer(buffer, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8");
      } else {
        var result = "";
        for (var i = 0; i < buffer.length; i++) {
          result += cp437[buffer[i]];
        }
        return result;
      }
    }
    function readUInt64LE(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
      };
    } else {
      newBuffer = function(len) {
        return new Buffer(len);
      };
    }
    function installDestroyFn(stream, fn) {
      if (typeof stream.destroy === "function") {
        stream._destroy = function(err, cb) {
          fn();
          if (cb != null) cb(err);
        };
      } else {
        stream.destroy = fn;
      }
    }
    function defaultCallback(err) {
      if (err) throw err;
    }
  }
});

// node_modules/mongodb-memory-server-core/lib/util/getos/index.js
var require_getos = __commonJS({
  "node_modules/mongodb-memory-server-core/lib/util/getos/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseOS = exports2.parseLSB = exports2.isValidOs = exports2.getOS = exports2.isLinuxOS = exports2.UNKNOWN = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var os_1 = require("os");
    var debug_1 = tslib_1.__importDefault(require_src2());
    var utils_1 = require_utils4();
    var log = (0, debug_1.default)("MongoMS:getos");
    var LSBRegex = {
      // regex format is "lsb_release" (command output) and then "lsb-release" (file output)
      name: /^(?:distributor id:|DISTRIB_ID=)\s*(.*)$/im,
      codename: /^(?:codename:|DISTRIB_CODENAME=)\s*(.*)$/im,
      release: /^(?:release:|DISTRIB_RELEASE=)\s*(.*)$/im
    };
    var OSRegex = {
      name: /^id\s*=\s*"?(\w*)"?$/im,
      codename: /^version_codename\s*=\s*(.*)$/im,
      release: /^version_id\s*=\s*"?(\d*(?:\.\d*)?)"?$/im,
      id_like: /^id_like\s*=\s*"?([\w\s]*)"?$/im
    };
    exports2.UNKNOWN = "unknown";
    function isLinuxOS(os) {
      return os.os === "linux";
    }
    exports2.isLinuxOS = isLinuxOS;
    var cachedOs;
    async function getOS() {
      if (!cachedOs) {
        const osName = (0, os_1.platform)();
        if (osName === "linux") {
          cachedOs = await getLinuxInformation();
        } else {
          cachedOs = { os: osName };
        }
      }
      return cachedOs;
    }
    exports2.getOS = getOS;
    async function getLinuxInformation() {
      const upstreamLSB = await (0, utils_1.tryReleaseFile)("/etc/upstream-release/lsb-release", parseLSB);
      if (isValidOs(upstreamLSB)) {
        log("getLinuxInformation: Using UpstreamLSB");
        return upstreamLSB;
      }
      const etcOsRelease = await (0, utils_1.tryReleaseFile)("/etc/os-release", parseOS);
      if (isValidOs(etcOsRelease)) {
        log("getLinuxInformation: Using etcOsRelease");
        return etcOsRelease;
      }
      const usrOsRelease = await (0, utils_1.tryReleaseFile)("/usr/lib/os-release", parseOS);
      if (isValidOs(usrOsRelease)) {
        log("getLinuxInformation: Using usrOsRelease");
        return usrOsRelease;
      }
      const etcLSBRelease = await (0, utils_1.tryReleaseFile)("/etc/lsb-release", parseLSB);
      if (isValidOs(etcLSBRelease)) {
        log("getLinuxInformation: Using etcLSBRelease");
        return etcLSBRelease;
      }
      console.warn("Could not find any valid Release File, using fallback information");
      return {
        os: "linux",
        dist: exports2.UNKNOWN,
        release: ""
      };
    }
    function isValidOs(os) {
      if (os && os.dist === exports2.UNKNOWN) {
        log("isValidOS: found defined os, but was unknown:", os);
      }
      return !(0, utils_1.isNullOrUndefined)(os) && os.dist !== exports2.UNKNOWN;
    }
    exports2.isValidOs = isValidOs;
    function parseLSB(input) {
      return {
        os: "linux",
        dist: input.match(LSBRegex.name)?.[1].toLocaleLowerCase() ?? exports2.UNKNOWN,
        codename: input.match(LSBRegex.codename)?.[1].toLocaleLowerCase(),
        release: input.match(LSBRegex.release)?.[1].toLocaleLowerCase() ?? ""
      };
    }
    exports2.parseLSB = parseLSB;
    function parseOS(input) {
      return {
        os: "linux",
        dist: input.match(OSRegex.name)?.[1].toLocaleLowerCase() ?? exports2.UNKNOWN,
        codename: input.match(OSRegex.codename)?.[1].toLocaleLowerCase(),
        release: input.match(OSRegex.release)?.[1].toLocaleLowerCase() ?? "",
        id_like: input.match(OSRegex.id_like)?.[1].toLocaleLowerCase().split(" ")
      };
    }
    exports2.parseOS = parseOS;
  }
});

// node_modules/mongodb-memory-server-core/lib/util/MongoBinaryDownloadUrl.js
var require_MongoBinaryDownloadUrl = __commonJS({
  "node_modules/mongodb-memory-server-core/lib/util/MongoBinaryDownloadUrl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoBinaryDownloadUrl = exports2.DEFAULT_UBUNTU_YEAR = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var getos_1 = require_getos();
    var resolveConfig_1 = require_resolveConfig();
    var debug_1 = tslib_1.__importDefault(require_src2());
    var semver = tslib_1.__importStar(require_semver2());
    var utils_1 = require_utils4();
    var url_1 = require("url");
    var errors_1 = require_errors();
    var log = (0, debug_1.default)("MongoMS:MongoBinaryDownloadUrl");
    exports2.DEFAULT_UBUNTU_YEAR = 22;
    var MongoBinaryDownloadUrl = class _MongoBinaryDownloadUrl {
      constructor(opts) {
        this.version = opts.version;
        this.platform = this.translatePlatform(opts.platform);
        this.arch = _MongoBinaryDownloadUrl.translateArch(opts.arch);
        this.os = opts.os;
      }
      /**
       * Assemble the URL to download
       * Calls all the necessary functions to determine the URL
       */
      async getDownloadUrl() {
        const downloadUrl = (0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.DOWNLOAD_URL);
        if (downloadUrl) {
          log(`Using "${downloadUrl}" as the Download-URL`);
          const url2 = new url_1.URL(downloadUrl);
          return url2.toString();
        }
        const archive = await this.getArchiveName();
        log(`Using "${archive}" as the Archive String`);
        const mirror = (0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.DOWNLOAD_MIRROR) ?? "https://fastdl.mongodb.org";
        log(`Using "${mirror}" as the mirror`);
        const url = new url_1.URL(mirror);
        if (!url.pathname.endsWith("/")) {
          url.pathname = url.pathname + "/";
        }
        url.pathname = `${url.pathname}${this.platform}/${archive}`;
        return url.toString();
      }
      /**
       * Get the archive
       */
      async getArchiveName() {
        const archive_name = (0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.ARCHIVE_NAME);
        if (!!archive_name) {
          return archive_name;
        }
        switch (this.platform) {
          case "osx":
            return this.getArchiveNameOsx();
          case "win32":
          case "windows":
            return this.getArchiveNameWin();
          case "linux":
            return this.getArchiveNameLinux();
          default:
            throw new errors_1.UnknownPlatformError(this.platform);
        }
      }
      /**
       * Get the archive for Windows
       * (from: https://www.mongodb.org/dl/win32)
       */
      getArchiveNameWin() {
        let name = `mongodb-${this.platform}-${this.arch}`;
        const coercedVersion = semver.coerce(this.version);
        if (!(0, utils_1.isNullOrUndefined)(coercedVersion)) {
          if (semver.satisfies(coercedVersion, "4.2.x")) {
            name += "-2012plus";
          } else if (semver.lt(coercedVersion, "4.1.0")) {
            name += "-2008plus-ssl";
          }
        }
        name += `-${this.version}.zip`;
        return name;
      }
      /**
       * Get the archive for OSX (Mac)
       * (from: https://www.mongodb.org/dl/osx)
       */
      getArchiveNameOsx() {
        let name = `mongodb-osx`;
        const coercedVersion = semver.coerce(this.version);
        if (!(0, utils_1.isNullOrUndefined)(coercedVersion) && semver.gte(coercedVersion, "3.2.0")) {
          name += "-ssl";
        }
        if ((0, utils_1.isNullOrUndefined)(coercedVersion) || semver.gte(coercedVersion, "4.2.0")) {
          name = `mongodb-macos`;
        }
        if (this.arch === "aarch64") {
          if (!(0, utils_1.isNullOrUndefined)(coercedVersion) && semver.lt(coercedVersion, "6.0.0")) {
            log('getArchiveNameOsx: Arch is "aarch64" and version is below 6.0.0, using x64 binary');
            this.arch = "x86_64";
          } else {
            log('getArchiveNameOsx: Arch is "aarch64" and version is above or equal to 6.0.0, using arm64 binary');
            this.arch = "arm64";
          }
        }
        name += `-${this.arch}-${this.version}.tgz`;
        return name;
      }
      /**
       * Get the archive for Linux
       * (from: https://www.mongodb.org/dl/linux)
       */
      async getArchiveNameLinux() {
        if (!this.os && (0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.DISTRO)) {
          this.os = await (0, getos_1.getOS)();
        }
        if ((0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.DISTRO)) {
          this.overwriteDistro();
        }
        const osString = this.getLinuxOSVersionString(this.os);
        let name = `mongodb-linux-${this.arch}`;
        if (!!osString) {
          name += `-${osString}`;
        }
        name += `-${this.version}.tgz`;
        return name;
      }
      /**
       * Parse and apply config option DISTRO
       */
      overwriteDistro() {
        const env2 = (0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.DISTRO);
        if ((0, utils_1.isNullOrUndefined)(env2)) {
          return;
        }
        const split = env2.split("-");
        const distro = split[0];
        const release = split[1];
        if ((0, utils_1.isNullOrUndefined)(distro)) {
          throw new errors_1.GenericMMSError('Expected DISTRO option to have a distro like "ubuntu-18.04"');
        }
        if ((0, utils_1.isNullOrUndefined)(release)) {
          throw new errors_1.GenericMMSError('Expected DISTRO option to have a release like "ubuntu-18.04" (delimited by "-")');
        }
        this.os = {
          os: "linux",
          dist: distro,
          release
        };
      }
      /**
       * Get the version string (with distro)
       * @param os LinuxOS Object
       */
      getLinuxOSVersionString(os) {
        if (regexHelper(/ubuntu/i, os)) {
          return this.getUbuntuVersionString(os);
        } else if (regexHelper(/amzn/i, os)) {
          return this.getAmazonVersionString(os);
        } else if (regexHelper(/suse/i, os)) {
          return this.getSuseVersionString(os);
        } else if (regexHelper(/(rhel|centos|scientific|^ol$)/i, os)) {
          return this.getRhelVersionString(os);
        } else if (regexHelper(/fedora/i, os)) {
          return this.getFedoraVersionString(os);
        } else if (regexHelper(/debian/i, os)) {
          return this.getDebianVersionString(os);
        } else if (regexHelper(/alpine/i, os)) {
          console.warn("There is no official build of MongoDB for Alpine!");
        } else if (regexHelper(/(arch|manjaro|arco)(?:linux)?$/i, os)) {
          console.warn(`There is no official build of MongoDB for ArchLinux (${os.dist}). Falling back to Ubuntu 22.04 release.`);
          return this.getUbuntuVersionString({
            os: "linux",
            dist: "Ubuntu Linux",
            release: "22.04"
          });
        } else if (regexHelper(/gentoo/i, os)) {
          console.warn(`There is no official build of MongoDB for Gentoo (${os.dist}). Falling back to Debian.`);
          return this.getDebianVersionString({
            os: "linux",
            dist: "Debian",
            release: "11"
          });
        } else if (regexHelper(/unknown/i, os)) {
          console.warn("Couldnt parse dist information, please report this to https://github.com/typegoose/mongodb-memory-server/issues");
        }
        throw new errors_1.UnknownLinuxDistro(os.dist, os.id_like ?? []);
      }
      /**
       * Get the version string for Debian
       * @param os LinuxOS Object
       */
      getDebianVersionString(os) {
        let name = "debian";
        const release = parseFloat(os.release);
        const coercedVersion = semver.coerce(this.version);
        if ((0, utils_1.isNullOrUndefined)(coercedVersion)) {
          throw new errors_1.UnknownVersionError(this.version);
        }
        const isTesting = ["unstable", "testing", ""].includes(os.release);
        if (isTesting || release >= 12) {
          name += "12";
        } else if (release >= 11) {
          if (semver.lt(coercedVersion, "5.0.8") && !testVersionIsLatest(this.version)) {
            log("debian11 detected, but version below 5.0.8 requested, using debian10");
            name += "10";
          } else {
            name += "11";
          }
        } else if (release >= 10) {
          name += "10";
        } else if (release >= 9) {
          name += "92";
        } else if (release >= 8.1) {
          name += "81";
        } else if (release >= 7.1) {
          name += "71";
        }
        if (isTesting || release >= 12) {
          if (semver.lt(coercedVersion, "7.0.3") && !testVersionIsLatest(this.version)) {
            throw new errors_1.KnownVersionIncompatibilityError(`Debian ${release || os.release || os.codename}`, this.version, ">=7.0.3", "Mongodb does not provide binaries for versions before 7.0.3 for Debian 12+ and also cannot be mapped to a previous Debian release");
          }
        } else if (release >= 10) {
          if (semver.lt(coercedVersion, "4.2.1") && !testVersionIsLatest(this.version)) {
            throw new errors_1.KnownVersionIncompatibilityError(`Debian ${release || os.release || os.codename}`, this.version, ">=4.2.1", "Mongodb does not provide binaries for versions before 4.2.1 for Debian 10+ and also cannot be mapped to a previous Debian release");
          }
        }
        return name;
      }
      /**
       * Get the version string for Fedora
       * @param os LinuxOS Object
       */
      getFedoraVersionString(os) {
        const fedoraVer = parseInt(os.release, 10);
        const rhelOS = {
          os: "linux",
          dist: "rhel",
          // fallback to 8.0
          release: "8.0"
        };
        if (fedoraVer >= 34) {
          rhelOS.release = "8.0";
        } else if (fedoraVer >= 19) {
          rhelOS.release = "7.0";
        } else if (fedoraVer >= 12) {
          rhelOS.release = "6.2";
        } else if (fedoraVer >= 6) {
          rhelOS.release = "5.5";
        }
        return this.getRhelVersionString(rhelOS);
      }
      /**
       * Get the version string for Red Hat Enterprise Linux
       * @param os LinuxOS Object
       */
      getRhelVersionString(os) {
        let name = "rhel";
        const { release } = os;
        const releaseAsSemver = semver.coerce(release);
        const coercedVersion = semver.coerce(this.version);
        if ((0, utils_1.isNullOrUndefined)(coercedVersion)) {
          throw new errors_1.UnknownVersionError(this.version);
        }
        if (releaseAsSemver) {
          if (this.arch === "aarch64") {
            if (semver.lt(releaseAsSemver, "8.2.0")) {
              throw new errors_1.KnownVersionIncompatibilityError(`Rhel ${release} arm64`, this.version, ">=4.4.2", "ARM64(aarch64) support for rhel is only for rhel82 or higher");
            }
            if (semver.lt(coercedVersion, "4.4.2") && !testVersionIsLatest(this.version)) {
              throw new errors_1.KnownVersionIncompatibilityError(`Rhel ${release} arm64`, this.version, ">=4.4.2");
            }
            if (semver.satisfies(releaseAsSemver, ">=9.0.0") && semver.lt(coercedVersion, "6.0.7")) {
              throw new errors_1.KnownVersionIncompatibilityError(`Rhel ${release} arm64`, this.version, ">=6.0.7");
            }
          }
          if (semver.satisfies(releaseAsSemver, ">=9.0.0")) {
            name += "90";
          } else if (semver.satisfies(releaseAsSemver, "8.2.0") && this.arch == "aarch64") {
            if (semver.satisfies(coercedVersion, "^5.0.29 || ^6.0.17 || ^7.0.13 || ^8.0.0")) {
              name += "8";
            } else {
              name += "82";
            }
          } else if (semver.satisfies(releaseAsSemver, "^8.0.0")) {
            if (semver.satisfies(coercedVersion, "^5.0.29 || ^6.0.17 || ^7.0.13 || ^8.0.0")) {
              name += "8";
            } else {
              name += "80";
            }
          } else if (semver.satisfies(releaseAsSemver, "^7.0.0")) {
            name += "70";
          } else if (semver.satisfies(releaseAsSemver, "^6.0.0")) {
            name += "62";
          } else if (semver.satisfies(releaseAsSemver, "^5.0.0")) {
            name += "55";
          } else {
            console.warn(`Unhandled RHEL version: "${release}"("${this.arch}")`);
          }
        } else {
          console.warn(`Couldnt coerce RHEL version "${release}"`);
        }
        if (name === "rhel") {
          log('getRhelVersionString: falling back to "70"');
          name += "70";
        }
        return name;
      }
      /**
       * Get the version string for Amazon Distro
       * @param os LinuxOS Object
       */
      getAmazonVersionString(os) {
        let name = "amazon";
        const release = parseInt(os.release, 10);
        if (release >= 2) {
          name += release.toString();
        }
        return name;
      }
      /**
       * Get the version string for Suse / OpenSuse
       * @param os LinuxOS Object
       */
      // TODO: add tests for getSuseVersionString
      getSuseVersionString(os) {
        const releaseMatch = os.release.match(/(^11|^12|^15)/);
        return releaseMatch ? `suse${releaseMatch[0]}` : "";
      }
      /**
       * Get the version string for Ubuntu
       * @param os LinuxOS Object
       */
      getUbuntuVersionString(os) {
        let ubuntuOS = void 0;
        const coercedVersion = semver.coerce(this.version);
        if ((0, utils_1.isNullOrUndefined)(coercedVersion)) {
          throw new errors_1.UnknownVersionError(this.version);
        }
        {
          if (/^linux\s?mint\s*$/i.test(os.dist)) {
            const mintToUbuntuRelease = {
              17: "14.04",
              18: "16.04",
              19: "18.04",
              20: "20.04",
              21: "22.04",
              22: "24.04"
            };
            ubuntuOS = {
              os: "linux",
              dist: "ubuntu",
              release: mintToUbuntuRelease[parseInt(os.release.split(".")[0])] || mintToUbuntuRelease[21]
            };
          }
          if (/^elementary(?:\s?os)?\s*$/i.test(os.dist)) {
            const elementaryToUbuntuRelease = {
              3: "14.04",
              4: "16.04",
              5: "18.04",
              6: "20.04",
              7: "22.04"
            };
            const [elementaryMajor, elementaryMinor] = os.release.split(".").map((el) => parseInt(el));
            const realMajor = elementaryMajor || elementaryMinor;
            ubuntuOS = {
              os: "linux",
              dist: "ubuntu",
              release: elementaryToUbuntuRelease[realMajor] || elementaryToUbuntuRelease[7]
            };
          }
        }
        if ((0, utils_1.isNullOrUndefined)(ubuntuOS)) {
          if (!/^ubuntu(?:| linux)\s*$/i.test(os.dist)) {
            console.warn(`Unmapped distro "${os.dist}" with ID_LIKE "ubuntu", defaulting to highest ubuntu version!
This means that your distro does not have a internal mapping in MMS or does not have a upstream release file (like "/etc/upstream-release/lsb-release"), but has set a ID_LIKE`);
            ubuntuOS = {
              os: "linux",
              dist: "ubuntu",
              release: `${exports2.DEFAULT_UBUNTU_YEAR}.04`
            };
          } else {
            ubuntuOS = os;
          }
        }
        let ubuntuYear = parseInt(ubuntuOS.release.split(".")[0], 10);
        if (Number.isNaN(ubuntuYear)) {
          console.warn(`Could not parse ubuntu year from "${ubuntuOS.release}", using default`);
          ubuntuYear = exports2.DEFAULT_UBUNTU_YEAR;
        }
        if (this.arch === "aarch64") {
          if (semver.satisfies(coercedVersion, "<4.1.10")) {
            this.arch = "arm64";
            return "ubuntu1604";
          }
          if (semver.satisfies(coercedVersion, ">=4.1.10 <4.4.0")) {
            return "ubuntu1804";
          }
        }
        if (ubuntuOS.release === "14.10") {
          return "ubuntu1410-clang";
        }
        if (ubuntuYear >= 18 && semver.satisfies(coercedVersion, "3.x.x")) {
          log(`getUbuntuVersionString: ubuntuYear is "${ubuntuYear}", which dosnt have an 3.x.x version, defaulting to "1604"`);
          return "ubuntu1604";
        }
        if (ubuntuYear > 18 && semver.satisfies(coercedVersion, "<=4.3.x")) {
          log(`getUbuntuVersionString: ubuntuYear is "${ubuntuYear}", which dosnt have an "<=4.3.x" version, defaulting to "1804"`);
          return "ubuntu1804";
        }
        if (ubuntuYear >= 21 && semver.satisfies(coercedVersion, "<6.0.4")) {
          return "ubuntu2004";
        }
        if (ubuntuYear >= 22 && semver.satisfies(coercedVersion, "<8.0.0")) {
          return "ubuntu2204";
        }
        {
          const highestUbuntuYear = 24;
          if (ubuntuYear > highestUbuntuYear) {
            log(`getUbuntuVersionString: ubuntuYear "${ubuntuYear}" is higher than the currently supported mongodb year of "${highestUbuntuYear}", using highest known`);
            return "ubuntu2404";
          }
        }
        return `ubuntu${ubuntuYear}04`;
      }
      /**
       * Translate input platform to mongodb-archive useable platform
       * @param platform The Platform to translate to a mongodb archive platform
       * @example
       * darwin -> osx
       */
      translatePlatform(platform) {
        switch (platform) {
          case "darwin":
            return "osx";
          case "win32":
            const version = semver.coerce(this.version);
            if ((0, utils_1.isNullOrUndefined)(version)) {
              return "windows";
            }
            return semver.gte(version, "4.3.0") ? "windows" : "win32";
          case "linux":
            return "linux";
          default:
            throw new errors_1.UnknownPlatformError(platform);
        }
      }
      /**
       * Translate input arch to mongodb-archive useable arch
       * @param arch The Architecture to translate to a mongodb archive architecture
       * @example
       * x64 -> x86_64
       */
      static translateArch(arch) {
        switch (arch) {
          case "x86_64":
          case "x64":
            return "x86_64";
          case "arm64":
          case "aarch64":
            return "aarch64";
          default:
            throw new errors_1.UnknownArchitectureError(arch);
        }
      }
    };
    exports2.MongoBinaryDownloadUrl = MongoBinaryDownloadUrl;
    exports2.default = MongoBinaryDownloadUrl;
    function regexHelper(regex, os) {
      return regex.test(os.dist) || (!(0, utils_1.isNullOrUndefined)(os.id_like) ? os.id_like.filter((v) => regex.test(v)).length >= 1 : false);
    }
    function testVersionIsLatest(version) {
      return /^v\d+\.\d+-latest$/.test(version);
    }
  }
});

// node_modules/agent-base/dist/helpers.js
var require_helpers = __commonJS({
  "node_modules/agent-base/dist/helpers.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.req = exports2.json = exports2.toBuffer = void 0;
    var http = __importStar2(require("http"));
    var https = __importStar2(require("https"));
    async function toBuffer(stream) {
      let length = 0;
      const chunks = [];
      for await (const chunk of stream) {
        length += chunk.length;
        chunks.push(chunk);
      }
      return Buffer.concat(chunks, length);
    }
    exports2.toBuffer = toBuffer;
    async function json2(stream) {
      const buf = await toBuffer(stream);
      const str = buf.toString("utf8");
      try {
        return JSON.parse(str);
      } catch (_err) {
        const err = _err;
        err.message += ` (input: ${str})`;
        throw err;
      }
    }
    exports2.json = json2;
    function req(url, opts = {}) {
      const href = typeof url === "string" ? url : url.href;
      const req2 = (href.startsWith("https:") ? https : http).request(url, opts);
      const promise = new Promise((resolve, reject) => {
        req2.once("response", resolve).once("error", reject).end();
      });
      req2.then = promise.then.bind(promise);
      return req2;
    }
    exports2.req = req;
  }
});

// node_modules/agent-base/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/agent-base/dist/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Agent = void 0;
    var net = __importStar2(require("net"));
    var http = __importStar2(require("http"));
    var https_1 = require("https");
    __exportStar2(require_helpers(), exports2);
    var INTERNAL = Symbol("AgentBaseInternalState");
    var Agent = class extends http.Agent {
      constructor(opts) {
        super(opts);
        this[INTERNAL] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(options2) {
        if (options2) {
          if (typeof options2.secureEndpoint === "boolean") {
            return options2.secureEndpoint;
          }
          if (typeof options2.protocol === "string") {
            return options2.protocol === "https:";
          }
        }
        const { stack } = new Error();
        if (typeof stack !== "string")
          return false;
        return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(name) {
        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
          return null;
        }
        if (!this.sockets[name]) {
          this.sockets[name] = [];
        }
        const fakeSocket = new net.Socket({ writable: false });
        this.sockets[name].push(fakeSocket);
        this.totalSocketCount++;
        return fakeSocket;
      }
      decrementSockets(name, socket) {
        if (!this.sockets[name] || socket === null) {
          return;
        }
        const sockets = this.sockets[name];
        const index = sockets.indexOf(socket);
        if (index !== -1) {
          sockets.splice(index, 1);
          this.totalSocketCount--;
          if (sockets.length === 0) {
            delete this.sockets[name];
          }
        }
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(options2) {
        const secureEndpoint = this.isSecureEndpoint(options2);
        if (secureEndpoint) {
          return https_1.Agent.prototype.getName.call(this, options2);
        }
        return super.getName(options2);
      }
      createSocket(req, options2, cb) {
        const connectOpts = {
          ...options2,
          secureEndpoint: this.isSecureEndpoint(options2)
        };
        const name = this.getName(connectOpts);
        const fakeSocket = this.incrementSockets(name);
        Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
          this.decrementSockets(name, fakeSocket);
          if (socket instanceof http.Agent) {
            try {
              return socket.addRequest(req, connectOpts);
            } catch (err) {
              return cb(err);
            }
          }
          this[INTERNAL].currentSocket = socket;
          super.createSocket(req, options2, cb);
        }, (err) => {
          this.decrementSockets(name, fakeSocket);
          cb(err);
        });
      }
      createConnection() {
        const socket = this[INTERNAL].currentSocket;
        this[INTERNAL].currentSocket = void 0;
        if (!socket) {
          throw new Error("No socket was returned in the `connect()` function");
        }
        return socket;
      }
      get defaultPort() {
        return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
      }
      set defaultPort(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].defaultPort = v;
        }
      }
      get protocol() {
        return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
      }
      set protocol(v) {
        if (this[INTERNAL]) {
          this[INTERNAL].protocol = v;
        }
      }
    };
    exports2.Agent = Agent;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseProxyResponse = void 0;
    var debug_1 = __importDefault2(require_src2());
    var debug = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("readable", read);
        }
        function onend() {
          cleanup();
          debug("onend");
          reject(new Error("Proxy connection ended before receiving CONNECT response"));
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
          const firstLine = headerParts.shift();
          if (!firstLine) {
            socket.destroy();
            return reject(new Error("No header received from proxy CONNECT response"));
          }
          const firstLineParts = firstLine.split(" ");
          const statusCode = +firstLineParts[1];
          const statusText = firstLineParts.slice(2).join(" ");
          const headers = {};
          for (const header of headerParts) {
            if (!header)
              continue;
            const firstColon = header.indexOf(":");
            if (firstColon === -1) {
              socket.destroy();
              return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
            }
            const key = header.slice(0, firstColon).toLowerCase();
            const value = header.slice(firstColon + 1).trimStart();
            const current = headers[key];
            if (typeof current === "string") {
              headers[key] = [current, value];
            } else if (Array.isArray(current)) {
              current.push(value);
            } else {
              headers[key] = value;
            }
          }
          debug("got proxy server response: %o %o", firstLine, headers);
          cleanup();
          resolve({
            connect: {
              statusCode,
              statusText,
              headers
            },
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("end", onend);
        read();
      });
    }
    exports2.parseProxyResponse = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpsProxyAgent = void 0;
    var net = __importStar2(require("net"));
    var tls = __importStar2(require("tls"));
    var assert_1 = __importDefault2(require("assert"));
    var debug_1 = __importDefault2(require_src2());
    var agent_base_1 = require_dist2();
    var url_1 = require("url");
    var parse_proxy_response_1 = require_parse_proxy_response();
    var debug = (0, debug_1.default)("https-proxy-agent");
    var setServernameFromNonIpHost = (options2) => {
      if (options2.servername === void 0 && options2.host && !net.isIP(options2.host)) {
        return {
          ...options2,
          servername: options2.host
        };
      }
      return options2;
    };
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(proxy, opts) {
        super(opts);
        this.options = { path: void 0 };
        this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = opts?.headers ?? {};
        debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = {
          // Attempt to negotiate http/1.1 for proxy servers that support http/2
          ALPNProtocols: ["http/1.1"],
          ...opts ? omit(opts, "headers") : null,
          host,
          port
        };
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       */
      async connect(req, opts) {
        const { proxy } = this;
        if (!opts.host) {
          throw new TypeError('No "host" provided');
        }
        let socket;
        if (proxy.protocol === "https:") {
          debug("Creating `tls.Socket`: %o", this.connectOpts);
          socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
        } else {
          debug("Creating `net.Socket`: %o", this.connectOpts);
          socket = net.connect(this.connectOpts);
        }
        const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
        if (proxy.username || proxy.password) {
          const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
        }
        headers.Host = `${host}:${opts.port}`;
        if (!headers["Proxy-Connection"]) {
          headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
        }
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
        socket.write(`${payload}\r
`);
        const { connect, buffered } = await proxyResponsePromise;
        req.emit("proxyConnect", connect);
        this.emit("proxyConnect", connect, req);
        if (connect.statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            debug("Upgrading socket connection to TLS");
            return tls.connect({
              ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
              socket
            });
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net.Socket({ writable: false });
        fakeSocket.readable = true;
        req.once("socket", (s) => {
          debug("Replaying proxy buffer for failed request");
          (0, assert_1.default)(s.listenerCount("data") > 0);
          s.push(buffered);
          s.push(null);
        });
        return fakeSocket;
      }
    };
    HttpsProxyAgent.protocols = ["http", "https"];
    exports2.HttpsProxyAgent = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/commondir/index.js
var require_commondir = __commonJS({
  "node_modules/commondir/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    module2.exports = function(basedir, relfiles) {
      if (relfiles) {
        var files = relfiles.map(function(r) {
          return path.resolve(basedir, r);
        });
      } else {
        var files = basedir;
      }
      var res = files.slice(1).reduce(function(ps, file) {
        if (!file.match(/^([A-Za-z]:)?\/|\\/)) {
          throw new Error("relative path without a basedir");
        }
        var xs = file.split(/\/+|\\+/);
        for (var i = 0; ps[i] === xs[i] && i < Math.min(ps.length, xs.length); i++) ;
        return ps.slice(0, i);
      }, files[0].split(/\/+|\\+/));
      return res.length > 1 ? res.join("/") : "/";
    };
  }
});

// node_modules/p-try/index.js
var require_p_try = __commonJS({
  "node_modules/p-try/index.js"(exports2, module2) {
    "use strict";
    var pTry = (fn, ...arguments_) => new Promise((resolve) => {
      resolve(fn(...arguments_));
    });
    module2.exports = pTry;
    module2.exports.default = pTry;
  }
});

// node_modules/p-locate/node_modules/p-limit/index.js
var require_p_limit = __commonJS({
  "node_modules/p-locate/node_modules/p-limit/index.js"(exports2, module2) {
    "use strict";
    var pTry = require_p_try();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
      }
      const queue = [];
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.length > 0) {
          queue.shift()();
        }
      };
      const run = (fn, resolve, ...args) => {
        activeCount++;
        const result = pTry(fn, ...args);
        resolve(result);
        result.then(next, next);
      };
      const enqueue = (fn, resolve, ...args) => {
        if (activeCount < concurrency) {
          run(fn, resolve, ...args);
        } else {
          queue.push(run.bind(null, fn, resolve, ...args));
        }
      };
      const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.length
        },
        clearQueue: {
          value: () => {
            queue.length = 0;
          }
        }
      });
      return generator;
    };
    module2.exports = pLimit;
    module2.exports.default = pLimit;
  }
});

// node_modules/p-locate/index.js
var require_p_locate = __commonJS({
  "node_modules/p-locate/index.js"(exports2, module2) {
    "use strict";
    var pLimit = require_p_limit();
    var EndError = class extends Error {
      constructor(value) {
        super();
        this.value = value;
      }
    };
    var testElement = async (element, tester) => tester(await element);
    var finder = async (element) => {
      const values = await Promise.all(element);
      if (values[1] === true) {
        throw new EndError(values[0]);
      }
      return false;
    };
    var pLocate = async (iterable, tester, options2) => {
      options2 = {
        concurrency: Infinity,
        preserveOrder: true,
        ...options2
      };
      const limit = pLimit(options2.concurrency);
      const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
      const checkLimit = pLimit(options2.preserveOrder ? 1 : Infinity);
      try {
        await Promise.all(items.map((element) => checkLimit(finder, element)));
      } catch (error2) {
        if (error2 instanceof EndError) {
          return error2.value;
        }
        throw error2;
      }
    };
    module2.exports = pLocate;
    module2.exports.default = pLocate;
  }
});

// node_modules/locate-path/index.js
var require_locate_path = __commonJS({
  "node_modules/locate-path/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var fs = require("fs");
    var { promisify } = require("util");
    var pLocate = require_p_locate();
    var fsStat = promisify(fs.stat);
    var fsLStat = promisify(fs.lstat);
    var typeMappings = {
      directory: "isDirectory",
      file: "isFile"
    };
    function checkType({ type }) {
      if (type in typeMappings) {
        return;
      }
      throw new Error(`Invalid type specified: ${type}`);
    }
    var matchType = (type, stat) => type === void 0 || stat[typeMappings[type]]();
    module2.exports = async (paths, options2) => {
      options2 = {
        cwd: process.cwd(),
        type: "file",
        allowSymlinks: true,
        ...options2
      };
      checkType(options2);
      const statFn = options2.allowSymlinks ? fsStat : fsLStat;
      return pLocate(paths, async (path_) => {
        try {
          const stat = await statFn(path.resolve(options2.cwd, path_));
          return matchType(options2.type, stat);
        } catch (_) {
          return false;
        }
      }, options2);
    };
    module2.exports.sync = (paths, options2) => {
      options2 = {
        cwd: process.cwd(),
        allowSymlinks: true,
        type: "file",
        ...options2
      };
      checkType(options2);
      const statFn = options2.allowSymlinks ? fs.statSync : fs.lstatSync;
      for (const path_ of paths) {
        try {
          const stat = statFn(path.resolve(options2.cwd, path_));
          if (matchType(options2.type, stat)) {
            return path_;
          }
        } catch (_) {
        }
      }
    };
  }
});

// node_modules/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/path-exists/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var { promisify } = require("util");
    var pAccess = promisify(fs.access);
    module2.exports = async (path) => {
      try {
        await pAccess(path);
        return true;
      } catch (_) {
        return false;
      }
    };
    module2.exports.sync = (path) => {
      try {
        fs.accessSync(path);
        return true;
      } catch (_) {
        return false;
      }
    };
  }
});

// node_modules/find-up/index.js
var require_find_up = __commonJS({
  "node_modules/find-up/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var locatePath = require_locate_path();
    var pathExists = require_path_exists();
    var stop = Symbol("findUp.stop");
    module2.exports = async (name, options2 = {}) => {
      let directory = path.resolve(options2.cwd || "");
      const { root } = path.parse(directory);
      const paths = [].concat(name);
      const runMatcher = async (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath(paths, locateOptions);
        }
        const foundPath = await name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = await runMatcher({ ...options2, cwd: directory });
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path.dirname(directory);
      }
    };
    module2.exports.sync = (name, options2 = {}) => {
      let directory = path.resolve(options2.cwd || "");
      const { root } = path.parse(directory);
      const paths = [].concat(name);
      const runMatcher = (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath.sync(paths, locateOptions);
        }
        const foundPath = name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath.sync([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = runMatcher({ ...options2, cwd: directory });
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path.dirname(directory);
      }
    };
    module2.exports.exists = pathExists;
    module2.exports.sync.exists = pathExists.sync;
    module2.exports.stop = stop;
  }
});

// node_modules/pkg-dir/index.js
var require_pkg_dir = __commonJS({
  "node_modules/pkg-dir/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var findUp = require_find_up();
    var pkgDir = async (cwd) => {
      const filePath = await findUp("package.json", { cwd });
      return filePath && path.dirname(filePath);
    };
    module2.exports = pkgDir;
    module2.exports.default = pkgDir;
    module2.exports.sync = (cwd) => {
      const filePath = findUp.sync("package.json", { cwd });
      return filePath && path.dirname(filePath);
    };
  }
});

// node_modules/semver/semver.js
var require_semver3 = __commonJS({
  "node_modules/semver/semver.js"(exports2, module2) {
    "use strict";
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t = exports2.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max = safeRegexReplacements[i2][1];
        value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value;
    }
    tok("NUMERICIDENTIFIER");
    src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
    tok("NONNUMERICIDENTIFIER");
    src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    tok("MAINVERSION");
    src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    tok("BUILD");
    src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
    src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
    tok("LOOSE");
    src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
    safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
    tok("LONETILDE");
    src[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
    safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
    safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
    safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t.STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
        safeRe[i] = new RegExp(makeSafeRe(src[i]));
      }
    }
    var i;
    exports2.parse = parse;
    function parse(version, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options2.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options2);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options2) {
      var v = parse(version, options2);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options2) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options2);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options2.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options2);
      }
      debug("SemVer", version, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      var m = version.trim().match(options2.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(b, a, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options2.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options2);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options2) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options2);
        return satisfies(this.value, rangeTmp, options2);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options2);
        return satisfies(comp.semver, rangeTmp, options2);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options2) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options2) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options2);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options2);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options2);
      }
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, safeRe[t.COMPARATORTRIM]);
      range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options2) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options2) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options2) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options2);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options2) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options2);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports2.toComparators = toComparators;
    function toComparators(range, options2) {
      return new Range(range, options2).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options2) {
      debug("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug("caret", comp);
      comp = replaceTildes(comp, options2);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug("xrange", comp);
      comp = replaceStars(comp, options2);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options2) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options2);
      }).join(" ");
    }
    function replaceTilde(comp, options2) {
      var r = options2.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options2) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options2);
      }).join(" ");
    }
    function replaceCaret(comp, options2) {
      debug("caret", comp, options2);
      var r = options2.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options2) {
      debug("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options2);
      }).join(" ");
    }
    function replaceXRange(comp, options2) {
      comp = comp.trim();
      var r = options2.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options2.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options2) {
      debug("replaceStars", comp, options2);
      return comp.trim().replace(safeRe[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options2) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options2.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options2) {
      try {
        range = new Range(range, options2);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options2) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options2);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options2) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options2);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options2) {
      try {
        return new Range(range, options2).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options2) {
      return outside(version, range, "<", options2);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options2) {
      return outside(version, range, ">", options2);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options2) {
      version = new SemVer(version, options2);
      range = new Range(range, options2);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options2)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options2)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options2)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options2) {
      var parsed = parse(version, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options2) {
      r1 = new Range(r1, options2);
      r2 = new Range(r2, options2);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version, options2) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options2 = options2 || {};
      var match = null;
      if (!options2.rtl) {
        match = version.match(safeRe[t.COERCE]);
      } else {
        var next;
        while ((next = safeRe[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        safeRe[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options2);
    }
  }
});

// node_modules/find-cache-dir/node_modules/make-dir/index.js
var require_make_dir = __commonJS({
  "node_modules/find-cache-dir/node_modules/make-dir/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { promisify } = require("util");
    var semver = require_semver3();
    var useNativeRecursiveOption = semver.satisfies(process.version, ">=10.12.0");
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error2 = new Error(`Path contains invalid characters: ${pth}`);
          error2.code = "EINVAL";
          throw error2;
        }
      }
    };
    var processOptions = (options2) => {
      const defaults = {
        mode: 511,
        fs
      };
      return {
        ...defaults,
        ...options2
      };
    };
    var permissionError = (pth) => {
      const error2 = new Error(`operation not permitted, mkdir '${pth}'`);
      error2.code = "EPERM";
      error2.errno = -4048;
      error2.path = pth;
      error2.syscall = "mkdir";
      return error2;
    };
    var makeDir = async (input, options2) => {
      checkPath(input);
      options2 = processOptions(options2);
      const mkdir = promisify(options2.fs.mkdir);
      const stat = promisify(options2.fs.stat);
      if (useNativeRecursiveOption && options2.fs.mkdir === fs.mkdir) {
        const pth = path.resolve(input);
        await mkdir(pth, {
          mode: options2.mode,
          recursive: true
        });
        return pth;
      }
      const make = async (pth) => {
        try {
          await mkdir(pth, options2.mode);
          return pth;
        } catch (error2) {
          if (error2.code === "EPERM") {
            throw error2;
          }
          if (error2.code === "ENOENT") {
            if (path.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error2.message.includes("null bytes")) {
              throw error2;
            }
            await make(path.dirname(pth));
            return make(pth);
          }
          try {
            const stats = await stat(pth);
            if (!stats.isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_) {
            throw error2;
          }
          return pth;
        }
      };
      return make(path.resolve(input));
    };
    module2.exports = makeDir;
    module2.exports.sync = (input, options2) => {
      checkPath(input);
      options2 = processOptions(options2);
      if (useNativeRecursiveOption && options2.fs.mkdirSync === fs.mkdirSync) {
        const pth = path.resolve(input);
        fs.mkdirSync(pth, {
          mode: options2.mode,
          recursive: true
        });
        return pth;
      }
      const make = (pth) => {
        try {
          options2.fs.mkdirSync(pth, options2.mode);
        } catch (error2) {
          if (error2.code === "EPERM") {
            throw error2;
          }
          if (error2.code === "ENOENT") {
            if (path.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error2.message.includes("null bytes")) {
              throw error2;
            }
            make(path.dirname(pth));
            return make(pth);
          }
          try {
            if (!options2.fs.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_) {
            throw error2;
          }
        }
        return pth;
      };
      return make(path.resolve(input));
    };
  }
});

// node_modules/find-cache-dir/index.js
var require_find_cache_dir = __commonJS({
  "node_modules/find-cache-dir/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var fs = require("fs");
    var commonDir = require_commondir();
    var pkgDir = require_pkg_dir();
    var makeDir = require_make_dir();
    var { env: env2, cwd } = process;
    var isWritable = (path2) => {
      try {
        fs.accessSync(path2, fs.constants.W_OK);
        return true;
      } catch (_) {
        return false;
      }
    };
    function useDirectory(directory, options2) {
      if (options2.create) {
        makeDir.sync(directory);
      }
      if (options2.thunk) {
        return (...arguments_) => path.join(directory, ...arguments_);
      }
      return directory;
    }
    function getNodeModuleDirectory(directory) {
      const nodeModules = path.join(directory, "node_modules");
      if (!isWritable(nodeModules) && (fs.existsSync(nodeModules) || !isWritable(path.join(directory)))) {
        return;
      }
      return nodeModules;
    }
    module2.exports = (options2 = {}) => {
      if (env2.CACHE_DIR && !["true", "false", "1", "0"].includes(env2.CACHE_DIR)) {
        return useDirectory(path.join(env2.CACHE_DIR, options2.name), options2);
      }
      let { cwd: directory = cwd() } = options2;
      if (options2.files) {
        directory = commonDir(directory, options2.files);
      }
      directory = pkgDir.sync(directory);
      if (!directory) {
        return;
      }
      const nodeModules = getNodeModuleDirectory(directory);
      if (!nodeModules) {
        return void 0;
      }
      return useDirectory(path.join(directory, "node_modules", ".cache", options2.name), options2);
    };
  }
});

// node_modules/mongodb-memory-server-core/lib/util/DryMongoBinary.js
var require_DryMongoBinary = __commonJS({
  "node_modules/mongodb-memory-server-core/lib/util/DryMongoBinary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DryMongoBinary = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var debug_1 = tslib_1.__importDefault(require_src2());
    var resolveConfig_1 = require_resolveConfig();
    var utils_1 = require_utils4();
    var path = tslib_1.__importStar(require("path"));
    var os_1 = require("os");
    var find_cache_dir_1 = tslib_1.__importDefault(require_find_cache_dir());
    var getos_1 = require_getos();
    var errors_1 = require_errors();
    var MongoBinaryDownloadUrl_1 = require_MongoBinaryDownloadUrl();
    var log = (0, debug_1.default)("MongoMS:DryMongoBinary");
    var DryMongoBinary = class _DryMongoBinary {
      /**
       * Try to locate an existing binary
       * @returns The Path to an Binary Found, or undefined
       */
      static async locateBinary(opts) {
        log(`locateBinary: Trying to locate Binary for version "${opts.version}"`);
        const useOpts = await this.generateOptions(opts);
        if (!!useOpts.systemBinary) {
          log(`locateBinary: env "SYSTEM_BINARY" was provided with value: "${useOpts.systemBinary}"`);
          const systemReturn = await this.getSystemPath(path.resolve(useOpts.systemBinary));
          if ((0, utils_1.isNullOrUndefined)(systemReturn)) {
            throw new errors_1.BinaryNotFoundError(useOpts.systemBinary, " (systemBinary)");
          }
          return systemReturn;
        }
        if (this.binaryCache.has(opts.version)) {
          const binary = this.binaryCache.get(opts.version);
          log(`locateBinary: Requested Version found in cache: "[${opts.version}, ${binary}]"`);
          return binary;
        }
        log("locateBinary: running generateDownloadPath");
        const returnValue = await this.generateDownloadPath(useOpts);
        if (!returnValue[0]) {
          log("locateBinary: could not find a existing binary");
          return void 0;
        }
        if (returnValue[0] && await (0, utils_1.pathExists)((0, utils_1.lockfilePath)(path.dirname(returnValue[1]), useOpts.version))) {
          log("locateBinary: binary found, but also a download-lock, trying to resolve lock");
          return void 0;
        }
        log(`locateBinary: found binary at "${returnValue[1]}"`);
        this.binaryCache.set(opts.version, returnValue[1]);
        return returnValue[1];
      }
      /**
       * Ensure the given options fulfill {@link DryMongoBinaryOptions} by defaulting them
       * @param opts The options to ensure
       * @returns The ensured options
       */
      static getEnsuredOptions(opts) {
        const defaultVersion = (0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.VERSION) ?? resolveConfig_1.DEFAULT_VERSION;
        return (0, utils_1.isNullOrUndefined)(opts) ? { version: defaultVersion } : { ...opts, version: opts.version || defaultVersion };
      }
      /**
       * Generate All required options for the binary name / path generation
       */
      static async generateOptions(opts) {
        log("generateOptions");
        const ensuredOpts = _DryMongoBinary.getEnsuredOptions(opts);
        const final = {
          version: ensuredOpts.version,
          downloadDir: (0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.DOWNLOAD_DIR) || ensuredOpts.downloadDir || "",
          os: ensuredOpts.os ?? await (0, getos_1.getOS)(),
          platform: ensuredOpts.platform || (0, os_1.platform)(),
          arch: ensuredOpts.arch || (0, os_1.arch)(),
          systemBinary: (0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.SYSTEM_BINARY) || ensuredOpts.systemBinary || ""
        };
        final.downloadDir = path.dirname((await this.generateDownloadPath(final))[1]);
        if ((0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.ARCHIVE_NAME) || (0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.DOWNLOAD_URL)) {
          const input = (0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.DOWNLOAD_URL) || (0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.ARCHIVE_NAME);
          log(`generateOptions: ARCHIVE_NAME or DOWNLOAD_URL defined, generating options based on that (input: "${input}")`);
          return this.parseArchiveNameRegex(input, final);
        }
        return final;
      }
      /**
       * Parse "input" into DryMongoBinaryOptions
       * @param input The Input to be parsed with the regex
       * @param opts The Options which will be augmented with "input"
       * @returns The Augmented options
       */
      static parseArchiveNameRegex(input, opts) {
        log(`parseArchiveNameRegex (input: "${input}")`);
        const archiveMatches = /mongodb-(?<platform>linux|win32|osx|macos)(?:-ssl-|-)(?<arch>\w{4,})(?:-(?<dist>\w+)|)(?:-ssl-|-)(?:v|)(?<version>[\d.]+(?:-latest|))\./gim.exec(input);
        (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(archiveMatches), new errors_1.NoRegexMatchError("input"));
        (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(archiveMatches.groups), new errors_1.NoRegexMatchError("input", "groups"));
        const groups = archiveMatches.groups;
        (0, utils_1.assertion)(typeof groups.version === "string" && groups.version.length > 1, new errors_1.ParseArchiveRegexError("version"));
        (0, utils_1.assertion)(typeof groups.platform === "string" && groups.platform.length > 1, new errors_1.ParseArchiveRegexError("platform"));
        (0, utils_1.assertion)(typeof groups.arch === "string" && groups.arch.length >= 4, new errors_1.ParseArchiveRegexError("arch"));
        opts.version = groups.version;
        opts.arch = groups.arch;
        if (groups.platform === "linux") {
          const distMatches = !!groups.dist ? /([a-z]+)(\d*)/gim.exec(groups.dist) : null;
          opts.os = {
            os: "linux",
            dist: typeof distMatches?.[1] === "string" ? distMatches[1] : "unknown",
            // "release" should be able to be discarded in this case
            release: ""
          };
        } else {
          opts.os = { os: groups.platform };
        }
        return opts;
      }
      /**
       * Get the full path with filename
       * @returns Absoulte Path with FileName
       */
      static async getBinaryName(opts) {
        log("getBinaryName");
        let binaryName;
        if ((0, resolveConfig_1.envToBool)((0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.USE_ARCHIVE_NAME_FOR_BINARY_NAME))) {
          const archiveName = await new MongoBinaryDownloadUrl_1.MongoBinaryDownloadUrl(opts).getArchiveName();
          binaryName = path.parse(archiveName).name;
        } else {
          const addExe = opts.platform === "win32" ? ".exe" : "";
          const dist = (0, getos_1.isLinuxOS)(opts.os) ? opts.os.dist : opts.os.os;
          binaryName = `mongod-${opts.arch}-${dist}-${opts.version}${addExe}`;
        }
        return binaryName;
      }
      /**
       * Combine basePath with binaryName
       */
      static combineBinaryName(basePath, binaryName) {
        log("combineBinaryName");
        return path.resolve(basePath, binaryName);
      }
      /**
       * Probe if the provided "systemBinary" is an existing path
       * @param systemBinary The Path to probe for an System-Binary
       * @returns System Binary path or undefined
       */
      static async getSystemPath(systemBinary) {
        log("getSystempath");
        try {
          await (0, utils_1.checkBinaryPermissions)(systemBinary);
          log(`getSystemPath: found system binary path at "${systemBinary}"`);
          return systemBinary;
        } catch (err) {
          log(`getSystemPath: can't find system binary at "${systemBinary}".
${err instanceof Error ? err.message : err}`);
        }
        return void 0;
      }
      /**
       * Generate an "MongoBinaryPaths" object
       *
       * This Function should not hit the FileSystem
       * @returns an finished "MongoBinaryPaths" object
       */
      static async generatePaths(opts) {
        log("generatePaths", opts);
        const final = {
          homeCache: "",
          modulesCache: "",
          relative: "",
          resolveConfig: ""
        };
        const binaryName = await this.getBinaryName(opts);
        let nodeModulesDLDir = process.env["INIT_CWD"] || process.cwd();
        while (nodeModulesDLDir.includes(`node_modules${path.sep}mongodb-memory-server`)) {
          nodeModulesDLDir = path.resolve(nodeModulesDLDir, "..", "..");
        }
        const configPackagePath = (0, resolveConfig_1.packageJsonPath)();
        if (configPackagePath && await (0, utils_1.pathExists)(path.resolve(configPackagePath, "node_modules"))) {
          nodeModulesDLDir = configPackagePath;
        }
        const tmpModulesCache = (0, find_cache_dir_1.default)({
          name: "mongodb-memory-server",
          cwd: nodeModulesDLDir
        });
        if (!(0, utils_1.isNullOrUndefined)(tmpModulesCache)) {
          final.modulesCache = this.combineBinaryName(path.resolve(tmpModulesCache), binaryName);
        }
        const homeCache = path.resolve(this.homedir(), ".cache/mongodb-binaries");
        final.homeCache = this.combineBinaryName(homeCache, binaryName);
        const resolveConfigValue = opts.downloadDir || (0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.DOWNLOAD_DIR);
        if (!(0, utils_1.isNullOrUndefined)(resolveConfigValue) && resolveConfigValue.length > 0) {
          log(`generatePaths: resolveConfigValue is not empty`);
          final.resolveConfig = this.combineBinaryName(resolveConfigValue, binaryName);
        }
        final.relative = this.combineBinaryName(path.resolve(process.cwd(), "mongodb-binaries"), binaryName);
        return final;
      }
      /**
       * Generate the Path where an Binary will be located
       * @returns "boolean" indicating if the binary exists at the provided path, and "string" the path to use for the binary
       */
      static async generateDownloadPath(opts) {
        const preferGlobal = (0, resolveConfig_1.envToBool)((0, resolveConfig_1.resolveConfig)(resolveConfig_1.ResolveConfigVariables.PREFER_GLOBAL_PATH));
        log(`generateDownloadPath: Generating Download Path, preferGlobal: "${preferGlobal}"`);
        const paths = await this.generatePaths(opts);
        log("generateDownloadPath: Paths:", paths, opts.systemBinary);
        if (!!opts.systemBinary && await (0, utils_1.pathExists)(opts.systemBinary)) {
          const sysPath = await this.getSystemPath(opts.systemBinary);
          if (!(0, utils_1.isNullOrUndefined)(sysPath)) {
            return [true, sysPath];
          }
        }
        if (await (0, utils_1.pathExists)(paths.resolveConfig)) {
          log(`generateDownloadPath: Found binary in resolveConfig (DOWNLOAD_DIR): "${paths.resolveConfig}"`);
          return [true, paths.resolveConfig];
        }
        if (await (0, utils_1.pathExists)(paths.homeCache)) {
          log(`generateDownloadPath: Found binary in homeCache: "${paths.homeCache}"`);
          return [true, paths.homeCache];
        }
        if (await (0, utils_1.pathExists)(paths.modulesCache)) {
          log(`generateDownloadPath: Found binary in modulesCache: "${paths.modulesCache}"`);
          return [true, paths.modulesCache];
        }
        if (await (0, utils_1.pathExists)(paths.relative)) {
          log(`generateDownloadPath: Found binary in relative: "${paths.relative}"`);
          return [true, paths.relative];
        }
        log(`generateDownloadPath: no existing binary for version "${opts.version}" was found`);
        if (paths.resolveConfig.length > 0) {
          log(`generateDownloadPath: using resolveConfig (DOWNLOAD_DIR) "${paths.resolveConfig}"`);
          return [false, paths.resolveConfig];
        }
        if (preferGlobal && !!paths.homeCache) {
          log(`generateDownloadPath: using global (preferGlobal) "${paths.homeCache}"`);
          return [false, paths.homeCache];
        }
        if (paths.modulesCache.length > 0) {
          log(`generateDownloadPath: using modulesCache "${paths.modulesCache}"`);
          return [false, paths.modulesCache];
        }
        log(`generateDownloadPath: using relative "${paths.relative}"`);
        return [false, paths.relative];
      }
      /**
       * This function is used, because jest just dosnt want "os.homedir" to be mocked
       * if someone can find an way to actually mock this in an test, please change it
       */
      static homedir() {
        return (0, os_1.homedir)();
      }
    };
    exports2.DryMongoBinary = DryMongoBinary;
    DryMongoBinary.binaryCache = /* @__PURE__ */ new Map();
  }
});

// node_modules/mongodb-memory-server-core/lib/util/MongoBinaryDownload.js
var require_MongoBinaryDownload = __commonJS({
  "node_modules/mongodb-memory-server-core/lib/util/MongoBinaryDownload.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoBinaryDownload = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var os_1 = tslib_1.__importDefault(require("os"));
    var url_1 = require("url");
    var path_1 = tslib_1.__importDefault(require("path"));
    var fs_1 = require("fs");
    var follow_redirects_1 = require_follow_redirects();
    var zlib_1 = require("zlib");
    var tar_stream_1 = tslib_1.__importDefault(require_tar_stream());
    var yauzl_1 = tslib_1.__importDefault(require_yauzl());
    var MongoBinaryDownloadUrl_1 = tslib_1.__importDefault(require_MongoBinaryDownloadUrl());
    var https_proxy_agent_1 = require_dist3();
    var resolveConfig_1 = tslib_1.__importStar(require_resolveConfig());
    var debug_1 = tslib_1.__importDefault(require_src2());
    var utils_1 = require_utils4();
    var DryMongoBinary_1 = require_DryMongoBinary();
    var readline_1 = require("readline");
    var errors_1 = require_errors();
    var log = (0, debug_1.default)("MongoMS:MongoBinaryDownload");
    var MongoBinaryDownload = class {
      constructor(opts) {
        (0, utils_1.assertion)(typeof opts.downloadDir === "string", new Error("An DownloadDir must be specified!"));
        const version = opts.version ?? (0, resolveConfig_1.default)(resolveConfig_1.ResolveConfigVariables.VERSION);
        (0, utils_1.assertion)(typeof version === "string", new Error("An MongoDB Binary version must be specified!"));
        this.binaryOpts = {
          platform: opts.platform ?? os_1.default.platform(),
          arch: opts.arch ?? os_1.default.arch(),
          version,
          downloadDir: opts.downloadDir,
          checkMD5: opts.checkMD5 ?? (0, resolveConfig_1.envToBool)((0, resolveConfig_1.default)(resolveConfig_1.ResolveConfigVariables.MD5_CHECK)),
          systemBinary: opts.systemBinary ?? "",
          os: opts.os ?? { os: "unknown" }
        };
        this.dlProgress = {
          current: 0,
          length: 0,
          totalMb: 0,
          lastPrintedAt: 0
        };
      }
      /**
       * Get the full path with filename
       * @returns Absoulte Path with FileName
       */
      async getPath() {
        const opts = await DryMongoBinary_1.DryMongoBinary.generateOptions(this.binaryOpts);
        return DryMongoBinary_1.DryMongoBinary.combineBinaryName(this.binaryOpts.downloadDir, await DryMongoBinary_1.DryMongoBinary.getBinaryName(opts));
      }
      /**
       * Get the path of the already downloaded "mongod" file
       * otherwise download it and then return the path
       */
      async getMongodPath() {
        log("getMongodPath");
        const mongodPath = await this.getPath();
        if (await (0, utils_1.pathExists)(mongodPath)) {
          log(`getMongodPath: mongod path "${mongodPath}" already exists, using this`);
          return mongodPath;
        }
        const mongoDBArchive = await this.startDownload();
        await this.extract(mongoDBArchive);
        await fs_1.promises.unlink(mongoDBArchive);
        if (await (0, utils_1.pathExists)(mongodPath)) {
          return mongodPath;
        }
        throw new Error(`Cannot find downloaded mongod binary by path "${mongodPath}"`);
      }
      /**
       * Download the MongoDB Archive and check it against an MD5
       * @returns The MongoDB Archive location
       */
      async startDownload() {
        log("startDownload");
        const mbdUrl = new MongoBinaryDownloadUrl_1.default(this.binaryOpts);
        await (0, utils_1.mkdir)(this.binaryOpts.downloadDir);
        try {
          await fs_1.promises.access(this.binaryOpts.downloadDir, fs_1.constants.X_OK | fs_1.constants.W_OK);
        } catch (err) {
          console.error(`Download Directory at "${this.binaryOpts.downloadDir}" does not have sufficient permissions to be used by this process
Needed Permissions: Write & Execute (-wx)
`);
          throw err;
        }
        const downloadUrl = await mbdUrl.getDownloadUrl();
        const mongoDBArchive = await this.download(downloadUrl);
        await this.makeMD5check(`${downloadUrl}.md5`, mongoDBArchive);
        return mongoDBArchive;
      }
      /**
       * Download MD5 file and check it against the MongoDB Archive
       * @param urlForReferenceMD5 URL to download the MD5
       * @param mongoDBArchive The MongoDB Archive file location
       *
       * @returns {undefined} if "checkMD5" is falsey
       * @returns {true} if the md5 check was successful
       * @throws if the md5 check failed
       */
      async makeMD5check(urlForReferenceMD5, mongoDBArchive) {
        log("makeMD5check: Checking MD5 of downloaded binary...");
        if (!this.binaryOpts.checkMD5) {
          log("makeMD5check: checkMD5 is disabled");
          return void 0;
        }
        const archiveMD5Path = await this.download(urlForReferenceMD5);
        const signatureContent = (await fs_1.promises.readFile(archiveMD5Path)).toString("utf-8");
        const regexMatch = signatureContent.match(/^\s*([\w\d]+)\s*/i);
        const md5SigRemote = regexMatch ? regexMatch[1] : null;
        const md5SigLocal = await (0, utils_1.md5FromFile)(mongoDBArchive);
        log(`makeMD5check: Local MD5: ${md5SigLocal}, Remote MD5: ${md5SigRemote}`);
        if (md5SigRemote !== md5SigLocal) {
          throw new errors_1.Md5CheckFailedError(md5SigLocal, md5SigRemote || "unknown");
        }
        await fs_1.promises.unlink(archiveMD5Path);
        return true;
      }
      /**
       * Download file from downloadUrl
       * @param downloadUrl URL to download a File
       * @returns The Path to the downloaded archive file
       */
      async download(downloadUrl) {
        log("download");
        const proxy = process.env["yarn_https-proxy"] || process.env.yarn_proxy || process.env["npm_config_https-proxy"] || process.env.npm_config_proxy || process.env.https_proxy || process.env.http_proxy || process.env.HTTPS_PROXY || process.env.HTTP_PROXY;
        const strictSsl = process.env.npm_config_strict_ssl === "true";
        const urlObject = new url_1.URL(downloadUrl);
        urlObject.port = urlObject.port || "443";
        const requestOptions = {
          method: "GET",
          rejectUnauthorized: strictSsl,
          protocol: (0, resolveConfig_1.envToBool)((0, resolveConfig_1.default)(resolveConfig_1.ResolveConfigVariables.USE_HTTP)) ? "http:" : "https:",
          agent: proxy ? new https_proxy_agent_1.HttpsProxyAgent(proxy) : void 0
        };
        const filename = urlObject.pathname.split("/").pop();
        if (!filename) {
          throw new Error(`MongoBinaryDownload: missing filename for url "${downloadUrl}"`);
        }
        const downloadLocation = path_1.default.resolve(this.binaryOpts.downloadDir, filename);
        const tempDownloadLocation = path_1.default.resolve(this.binaryOpts.downloadDir, `${filename}.downloading`);
        log(`download: Downloading${proxy ? ` via proxy "${proxy}"` : ""}: "${downloadUrl}"`);
        if (await (0, utils_1.pathExists)(downloadLocation)) {
          log("download: Already downloaded archive found, skipping download");
          return downloadLocation;
        }
        this.assignDownloadingURL(urlObject);
        const downloadedFile = await this.httpDownload(urlObject, requestOptions, downloadLocation, tempDownloadLocation);
        return downloadedFile;
      }
      /**
       * Extract given Archive
       * @param mongoDBArchive Archive location
       * @returns extracted directory location
       */
      async extract(mongoDBArchive) {
        log("extract");
        const mongodbFullPath = await this.getPath();
        log(`extract: archive: "${mongoDBArchive}" final: "${mongodbFullPath}"`);
        await (0, utils_1.mkdir)(path_1.default.dirname(mongodbFullPath));
        const filter = (file) => /(?:bin\/(?:mongod(?:\.exe)?))$/i.test(file);
        if (/(.tar.gz|.tgz)$/.test(mongoDBArchive)) {
          await this.extractTarGz(mongoDBArchive, mongodbFullPath, filter);
        } else if (/.zip$/.test(mongoDBArchive)) {
          await this.extractZip(mongoDBArchive, mongodbFullPath, filter);
        } else {
          throw new Error(`MongoBinaryDownload: unsupported archive "${mongoDBArchive}" (downloaded from "${this._downloadingUrl ?? "unknown"}"). Broken archive from MongoDB Provider?`);
        }
        if (!await (0, utils_1.pathExists)(mongodbFullPath)) {
          throw new Error(`MongoBinaryDownload: missing mongod binary in "${mongoDBArchive}" (downloaded from "${this._downloadingUrl ?? "unknown"}"). Broken archive from MongoDB Provider?`);
        }
        return mongodbFullPath;
      }
      /**
       * Extract a .tar.gz archive
       * @param mongoDBArchive Archive location
       * @param extractPath Directory to extract to
       * @param filter Method to determine which files to extract
       */
      async extractTarGz(mongoDBArchive, extractPath, filter) {
        log("extractTarGz");
        const extract = tar_stream_1.default.extract();
        extract.on("entry", (header, stream, next) => {
          if (filter(header.name)) {
            stream.pipe((0, fs_1.createWriteStream)(extractPath, {
              mode: 509
            }));
          }
          stream.on("end", () => next());
          stream.resume();
        });
        return new Promise((res, rej) => {
          (0, fs_1.createReadStream)(mongoDBArchive).on("error", (err) => {
            rej(new errors_1.GenericMMSError("Unable to open tarball " + mongoDBArchive + ": " + err));
          }).pipe((0, zlib_1.createUnzip)()).on("error", (err) => {
            rej(new errors_1.GenericMMSError("Error during unzip for " + mongoDBArchive + ": " + err));
          }).pipe(extract).on("error", (err) => {
            rej(new errors_1.GenericMMSError("Error during untar for " + mongoDBArchive + ": " + err));
          }).on("finish", res);
        });
      }
      /**
       * Extract a .zip archive
       * @param mongoDBArchive Archive location
       * @param extractPath Directory to extract to
       * @param filter Method to determine which files to extract
       */
      async extractZip(mongoDBArchive, extractPath, filter) {
        log("extractZip");
        return new Promise((resolve, reject) => {
          yauzl_1.default.open(mongoDBArchive, { lazyEntries: true }, (err, zipfile) => {
            if (err || !zipfile) {
              return reject(err);
            }
            zipfile.readEntry();
            zipfile.on("end", () => resolve());
            zipfile.on("entry", (entry) => {
              if (!filter(entry.fileName)) {
                return zipfile.readEntry();
              }
              zipfile.openReadStream(entry, (err2, r) => {
                if (err2 || !r) {
                  return reject(err2);
                }
                r.on("end", () => zipfile.readEntry());
                r.pipe((0, fs_1.createWriteStream)(extractPath, {
                  mode: 509
                }));
              });
            });
          });
        });
      }
      /**
       * Downlaod given httpOptions to tempDownloadLocation, then move it to downloadLocation
       * @param httpOptions The httpOptions directly passed to https.get
       * @param downloadLocation The location the File should be after the download
       * @param tempDownloadLocation The location the File should be while downloading
       */
      async httpDownload(url, httpOptions, downloadLocation, tempDownloadLocation) {
        log("httpDownload");
        const downloadUrl = this.assignDownloadingURL(url);
        const maxRedirects = parseInt((0, resolveConfig_1.default)(resolveConfig_1.ResolveConfigVariables.MAX_REDIRECTS) || "");
        const useHttpsOptions = {
          maxRedirects: Number.isNaN(maxRedirects) ? 2 : maxRedirects,
          ...httpOptions
        };
        return new Promise((resolve, reject) => {
          log(`httpDownload: trying to download "${downloadUrl}"`);
          follow_redirects_1.https.get(url, useHttpsOptions, (response) => {
            if (response.statusCode != 200) {
              if (response.statusCode === 403) {
                reject(new errors_1.DownloadError(downloadUrl, "Status Code is 403 (MongoDB's 404)\nThis means that the requested version-platform combination doesn't exist\nTry to use different version 'new MongoMemoryServer({ binary: { version: 'X.Y.Z' } })'\nList of available versions can be found here: https://www.mongodb.com/download-center/community/releases/archive"));
                return;
              }
              reject(new errors_1.DownloadError(downloadUrl, `Status Code isnt 200! (it is ${response.statusCode})`));
              return;
            }
            let contentLength;
            if (typeof response.headers["content-length"] != "string") {
              log('Response header "content-lenght" is empty!');
              contentLength = 0;
            } else {
              contentLength = parseInt(response.headers["content-length"], 10);
              if (Number.isNaN(contentLength)) {
                log('Response header "content-lenght" resolved to NaN!');
                contentLength = 0;
              }
            }
            if (!(0, resolveConfig_1.envToBool)((0, resolveConfig_1.default)(resolveConfig_1.ResolveConfigVariables.DOWNLOAD_IGNORE_MISSING_HEADER)) && contentLength <= 0) {
              reject(new errors_1.DownloadError(downloadUrl, 'Response header "content-length" does not exist or resolved to NaN'));
              return;
            }
            this.dlProgress.current = 0;
            this.dlProgress.length = contentLength;
            this.dlProgress.totalMb = Math.round(this.dlProgress.length / 1048576 * 10) / 10;
            const fileStream = (0, fs_1.createWriteStream)(tempDownloadLocation);
            response.pipe(fileStream);
            fileStream.on("finish", async () => {
              if (this.dlProgress.current < this.dlProgress.length && !httpOptions.path?.endsWith(".md5")) {
                reject(new errors_1.DownloadError(downloadUrl, `Too small (${this.dlProgress.current} bytes) mongod binary downloaded.`));
                return;
              }
              this.printDownloadProgress({ length: 0 }, true);
              fileStream.close();
              await fs_1.promises.rename(tempDownloadLocation, downloadLocation);
              log(`httpDownload: moved "${tempDownloadLocation}" to "${downloadLocation}"`);
              resolve(downloadLocation);
            });
            response.on("data", (chunk) => {
              this.printDownloadProgress(chunk);
            });
          }).on("error", (err) => {
            console.error(`Couldnt download "${downloadUrl}"!`, err.message);
            reject(new errors_1.DownloadError(downloadUrl, err.message));
          });
        });
      }
      /**
       * Print the Download Progress to STDOUT
       * @param chunk A chunk to get the length
       */
      printDownloadProgress(chunk, forcePrint = false) {
        this.dlProgress.current += chunk.length;
        const now = Date.now();
        if (now - this.dlProgress.lastPrintedAt < 2e3 && !forcePrint) {
          return;
        }
        this.dlProgress.lastPrintedAt = now;
        const percentComplete = Math.round(100 * this.dlProgress.current / this.dlProgress.length * 10) / 10;
        const mbComplete = Math.round(this.dlProgress.current / 1048576 * 10) / 10;
        const crReturn = this.binaryOpts.platform === "win32" ? "\x1B[0G" : "\r";
        const message = `Downloading MongoDB "${this.binaryOpts.version}": ${percentComplete}% (${mbComplete}mb / ${this.dlProgress.totalMb}mb)${crReturn}`;
        if (process.stdout.isTTY) {
          (0, readline_1.clearLine)(process.stdout, 0);
          process.stdout.write(message);
        } else {
          console.log(message);
        }
      }
      /**
       * Helper function to de-duplicate assigning "_downloadingUrl"
       */
      assignDownloadingURL(url) {
        this._downloadingUrl = url.href;
        return this._downloadingUrl;
      }
    };
    exports2.MongoBinaryDownload = MongoBinaryDownload;
    exports2.default = MongoBinaryDownload;
  }
});

// node_modules/async-mutex/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/async-mutex/lib/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.E_CANCELED = exports2.E_ALREADY_LOCKED = exports2.E_TIMEOUT = void 0;
    exports2.E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
    exports2.E_ALREADY_LOCKED = new Error("mutex already locked");
    exports2.E_CANCELED = new Error("request for lock canceled");
  }
});

// node_modules/async-mutex/lib/Semaphore.js
var require_Semaphore = __commonJS({
  "node_modules/async-mutex/lib/Semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    var Semaphore = (
      /** @class */
      function() {
        function Semaphore2(_value, _cancelError) {
          if (_cancelError === void 0) {
            _cancelError = errors_1.E_CANCELED;
          }
          this._value = _value;
          this._cancelError = _cancelError;
          this._queue = [];
          this._weightedWaiters = [];
        }
        Semaphore2.prototype.acquire = function(weight, priority) {
          var _this = this;
          if (weight === void 0) {
            weight = 1;
          }
          if (priority === void 0) {
            priority = 0;
          }
          if (weight <= 0)
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
          return new Promise(function(resolve, reject) {
            var task = { resolve, reject, weight, priority };
            var i = findIndexFromEnd(_this._queue, function(other) {
              return priority <= other.priority;
            });
            if (i === -1 && weight <= _this._value) {
              _this._dispatchItem(task);
            } else {
              _this._queue.splice(i + 1, 0, task);
            }
          });
        };
        Semaphore2.prototype.runExclusive = function(callback_1) {
          return tslib_1.__awaiter(this, arguments, void 0, function(callback, weight, priority) {
            var _a, value, release;
            if (weight === void 0) {
              weight = 1;
            }
            if (priority === void 0) {
              priority = 0;
            }
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this.acquire(weight, priority)];
                case 1:
                  _a = _b.sent(), value = _a[0], release = _a[1];
                  _b.label = 2;
                case 2:
                  _b.trys.push([2, , 4, 5]);
                  return [4, callback(value)];
                case 3:
                  return [2, _b.sent()];
                case 4:
                  release();
                  return [
                    7
                    /*endfinally*/
                  ];
                case 5:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Semaphore2.prototype.waitForUnlock = function(weight, priority) {
          var _this = this;
          if (weight === void 0) {
            weight = 1;
          }
          if (priority === void 0) {
            priority = 0;
          }
          if (weight <= 0)
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
          if (this._couldLockImmediately(weight, priority)) {
            return Promise.resolve();
          } else {
            return new Promise(function(resolve) {
              if (!_this._weightedWaiters[weight - 1])
                _this._weightedWaiters[weight - 1] = [];
              insertSorted(_this._weightedWaiters[weight - 1], { resolve, priority });
            });
          }
        };
        Semaphore2.prototype.isLocked = function() {
          return this._value <= 0;
        };
        Semaphore2.prototype.getValue = function() {
          return this._value;
        };
        Semaphore2.prototype.setValue = function(value) {
          this._value = value;
          this._dispatchQueue();
        };
        Semaphore2.prototype.release = function(weight) {
          if (weight === void 0) {
            weight = 1;
          }
          if (weight <= 0)
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
          this._value += weight;
          this._dispatchQueue();
        };
        Semaphore2.prototype.cancel = function() {
          var _this = this;
          this._queue.forEach(function(entry) {
            return entry.reject(_this._cancelError);
          });
          this._queue = [];
        };
        Semaphore2.prototype._dispatchQueue = function() {
          this._drainUnlockWaiters();
          while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
            this._dispatchItem(this._queue.shift());
            this._drainUnlockWaiters();
          }
        };
        Semaphore2.prototype._dispatchItem = function(item) {
          var previousValue = this._value;
          this._value -= item.weight;
          item.resolve([previousValue, this._newReleaser(item.weight)]);
        };
        Semaphore2.prototype._newReleaser = function(weight) {
          var _this = this;
          var called = false;
          return function() {
            if (called)
              return;
            called = true;
            _this.release(weight);
          };
        };
        Semaphore2.prototype._drainUnlockWaiters = function() {
          if (this._queue.length === 0) {
            for (var weight = this._value; weight > 0; weight--) {
              var waiters = this._weightedWaiters[weight - 1];
              if (!waiters)
                continue;
              waiters.forEach(function(waiter) {
                return waiter.resolve();
              });
              this._weightedWaiters[weight - 1] = [];
            }
          } else {
            var queuedPriority_1 = this._queue[0].priority;
            for (var weight = this._value; weight > 0; weight--) {
              var waiters = this._weightedWaiters[weight - 1];
              if (!waiters)
                continue;
              var i = waiters.findIndex(function(waiter) {
                return waiter.priority <= queuedPriority_1;
              });
              (i === -1 ? waiters : waiters.splice(0, i)).forEach(function(waiter) {
                return waiter.resolve();
              });
            }
          }
        };
        Semaphore2.prototype._couldLockImmediately = function(weight, priority) {
          return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
        };
        return Semaphore2;
      }()
    );
    function insertSorted(a, v) {
      var i = findIndexFromEnd(a, function(other) {
        return v.priority <= other.priority;
      });
      a.splice(i + 1, 0, v);
    }
    function findIndexFromEnd(a, predicate) {
      for (var i = a.length - 1; i >= 0; i--) {
        if (predicate(a[i])) {
          return i;
        }
      }
      return -1;
    }
    exports2.default = Semaphore;
  }
});

// node_modules/async-mutex/lib/Mutex.js
var require_Mutex = __commonJS({
  "node_modules/async-mutex/lib/Mutex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var Semaphore_1 = require_Semaphore();
    var Mutex = (
      /** @class */
      function() {
        function Mutex2(cancelError) {
          this._semaphore = new Semaphore_1.default(1, cancelError);
        }
        Mutex2.prototype.acquire = function() {
          return tslib_1.__awaiter(this, arguments, void 0, function(priority) {
            var _a, releaser;
            if (priority === void 0) {
              priority = 0;
            }
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this._semaphore.acquire(1, priority)];
                case 1:
                  _a = _b.sent(), releaser = _a[1];
                  return [2, releaser];
              }
            });
          });
        };
        Mutex2.prototype.runExclusive = function(callback, priority) {
          if (priority === void 0) {
            priority = 0;
          }
          return this._semaphore.runExclusive(function() {
            return callback();
          }, 1, priority);
        };
        Mutex2.prototype.isLocked = function() {
          return this._semaphore.isLocked();
        };
        Mutex2.prototype.waitForUnlock = function(priority) {
          if (priority === void 0) {
            priority = 0;
          }
          return this._semaphore.waitForUnlock(1, priority);
        };
        Mutex2.prototype.release = function() {
          if (this._semaphore.isLocked())
            this._semaphore.release();
        };
        Mutex2.prototype.cancel = function() {
          return this._semaphore.cancel();
        };
        return Mutex2;
      }()
    );
    exports2.default = Mutex;
  }
});

// node_modules/async-mutex/lib/withTimeout.js
var require_withTimeout = __commonJS({
  "node_modules/async-mutex/lib/withTimeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withTimeout = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var errors_1 = require_errors2();
    function withTimeout(sync, timeout, timeoutError) {
      var _this = this;
      if (timeoutError === void 0) {
        timeoutError = errors_1.E_TIMEOUT;
      }
      return {
        acquire: function(weightOrPriority, priority) {
          var weight;
          if (isSemaphore(sync)) {
            weight = weightOrPriority;
          } else {
            weight = void 0;
            priority = weightOrPriority;
          }
          if (weight !== void 0 && weight <= 0) {
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
          }
          return new Promise(function(resolve, reject) {
            return tslib_1.__awaiter(_this, void 0, void 0, function() {
              var isTimeout, handle, ticket, release, e_1;
              return tslib_1.__generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    isTimeout = false;
                    handle = setTimeout(function() {
                      isTimeout = true;
                      reject(timeoutError);
                    }, timeout);
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4, isSemaphore(sync) ? sync.acquire(weight, priority) : sync.acquire(priority)];
                  case 2:
                    ticket = _a.sent();
                    if (isTimeout) {
                      release = Array.isArray(ticket) ? ticket[1] : ticket;
                      release();
                    } else {
                      clearTimeout(handle);
                      resolve(ticket);
                    }
                    return [3, 4];
                  case 3:
                    e_1 = _a.sent();
                    if (!isTimeout) {
                      clearTimeout(handle);
                      reject(e_1);
                    }
                    return [3, 4];
                  case 4:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          });
        },
        runExclusive: function(callback, weight, priority) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var release, ticket;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  release = function() {
                    return void 0;
                  };
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, , 7, 8]);
                  return [4, this.acquire(weight, priority)];
                case 2:
                  ticket = _a.sent();
                  if (!Array.isArray(ticket)) return [3, 4];
                  release = ticket[1];
                  return [4, callback(ticket[0])];
                case 3:
                  return [2, _a.sent()];
                case 4:
                  release = ticket;
                  return [4, callback()];
                case 5:
                  return [2, _a.sent()];
                case 6:
                  return [3, 8];
                case 7:
                  release();
                  return [
                    7
                    /*endfinally*/
                  ];
                case 8:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        },
        release: function(weight) {
          sync.release(weight);
        },
        cancel: function() {
          return sync.cancel();
        },
        waitForUnlock: function(weightOrPriority, priority) {
          var weight;
          if (isSemaphore(sync)) {
            weight = weightOrPriority;
          } else {
            weight = void 0;
            priority = weightOrPriority;
          }
          if (weight !== void 0 && weight <= 0) {
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
          }
          return new Promise(function(resolve, reject) {
            var handle = setTimeout(function() {
              return reject(timeoutError);
            }, timeout);
            (isSemaphore(sync) ? sync.waitForUnlock(weight, priority) : sync.waitForUnlock(priority)).then(function() {
              clearTimeout(handle);
              resolve();
            });
          });
        },
        isLocked: function() {
          return sync.isLocked();
        },
        getValue: function() {
          return sync.getValue();
        },
        setValue: function(value) {
          return sync.setValue(value);
        }
      };
    }
    exports2.withTimeout = withTimeout;
    function isSemaphore(sync) {
      return sync.getValue !== void 0;
    }
  }
});

// node_modules/async-mutex/lib/tryAcquire.js
var require_tryAcquire = __commonJS({
  "node_modules/async-mutex/lib/tryAcquire.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tryAcquire = void 0;
    var errors_1 = require_errors2();
    var withTimeout_1 = require_withTimeout();
    function tryAcquire(sync, alreadyAcquiredError) {
      if (alreadyAcquiredError === void 0) {
        alreadyAcquiredError = errors_1.E_ALREADY_LOCKED;
      }
      return (0, withTimeout_1.withTimeout)(sync, 0, alreadyAcquiredError);
    }
    exports2.tryAcquire = tryAcquire;
  }
});

// node_modules/async-mutex/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/async-mutex/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tryAcquire = exports2.withTimeout = exports2.Semaphore = exports2.Mutex = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var Mutex_1 = require_Mutex();
    Object.defineProperty(exports2, "Mutex", { enumerable: true, get: function() {
      return Mutex_1.default;
    } });
    var Semaphore_1 = require_Semaphore();
    Object.defineProperty(exports2, "Semaphore", { enumerable: true, get: function() {
      return Semaphore_1.default;
    } });
    var withTimeout_1 = require_withTimeout();
    Object.defineProperty(exports2, "withTimeout", { enumerable: true, get: function() {
      return withTimeout_1.withTimeout;
    } });
    var tryAcquire_1 = require_tryAcquire();
    Object.defineProperty(exports2, "tryAcquire", { enumerable: true, get: function() {
      return tryAcquire_1.tryAcquire;
    } });
    tslib_1.__exportStar(require_errors2(), exports2);
  }
});

// node_modules/mongodb-memory-server-core/lib/util/lockfile.js
var require_lockfile = __commonJS({
  "node_modules/mongodb-memory-server-core/lib/util/lockfile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LockFile = exports2.LockFileEvents = exports2.LockFileStatus = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var events_1 = require("events");
    var utils = tslib_1.__importStar(require_utils4());
    var debug_1 = tslib_1.__importDefault(require_src2());
    var path = tslib_1.__importStar(require("path"));
    var fs_1 = require("fs");
    var async_mutex_1 = require_lib3();
    var errors_1 = require_errors();
    var log = (0, debug_1.default)("MongoMS:LockFile");
    var RepeatError = class extends Error {
      constructor(repeat) {
        super();
        this.repeat = repeat;
      }
    };
    var LockFileStatus;
    (function(LockFileStatus2) {
      LockFileStatus2[LockFileStatus2["available"] = 0] = "available";
      LockFileStatus2[LockFileStatus2["availableInstance"] = 1] = "availableInstance";
      LockFileStatus2[LockFileStatus2["lockedSelf"] = 2] = "lockedSelf";
      LockFileStatus2[LockFileStatus2["lockedDifferent"] = 3] = "lockedDifferent";
    })(LockFileStatus || (exports2.LockFileStatus = LockFileStatus = {}));
    var LockFileEvents;
    (function(LockFileEvents2) {
      LockFileEvents2["lock"] = "lock";
      LockFileEvents2["unlock"] = "unlock";
    })(LockFileEvents || (exports2.LockFileEvents = LockFileEvents = {}));
    var LockFileEventsClass = class extends events_1.EventEmitter {
    };
    var LockFile = class _LockFile {
      /**
       * Acquire an lockfile
       * @param file The file to use as the LockFile
       */
      static async lock(file) {
        await utils.ensureAsync();
        log(`lock: Locking file "${file}"`);
        const useFile = path.resolve(file.trim());
        utils.assertion(useFile.length > 0, new Error("Provided Path for lock file is length of 0"));
        const status = await this.checkLock(useFile);
        switch (status) {
          case LockFileStatus.lockedDifferent:
          case LockFileStatus.lockedSelf:
            return this.waitForLock(useFile);
          case LockFileStatus.available:
            return this.createLock(useFile);
          default:
            throw new errors_1.UnknownLockfileStatusError(status);
        }
      }
      /**
       * Check the status of the lockfile
       * @param file The file to use as the LockFile
       */
      static async checkLock(file, uuid) {
        log(`checkLock: for file "${file}" with uuid: "${uuid}"`);
        if (!await utils.pathExists(file)) {
          return LockFileStatus.available;
        }
        try {
          const fileData = (await fs_1.promises.readFile(file)).toString().trim().split(" ");
          const readout = parseInt(fileData[0]);
          if (readout === process.pid) {
            log(`checkLock: Lock File Already exists, and is for *this* process, with uuid: "${fileData[1]}"`);
            if (!this.files.has(file)) {
              return LockFileStatus.available;
            }
            if (!utils.isNullOrUndefined(uuid)) {
              return uuid === fileData[1] ? LockFileStatus.availableInstance : LockFileStatus.lockedSelf;
            }
            return LockFileStatus.lockedSelf;
          }
          log(`checkLock: Lock File Aready exists, for a different process: "${readout}"`);
          return utils.isAlive(readout) ? LockFileStatus.lockedDifferent : LockFileStatus.available;
        } catch (err) {
          if (utils.errorWithCode(err) && err.code === "ENOENT") {
            log("checkLock: reading file failed with ENOENT");
            return LockFileStatus.available;
          }
          throw err;
        }
      }
      /**
       * Wait for the Lock file to become available
       * @param file The file to use as the LockFile
       */
      static async waitForLock(file) {
        log(`waitForLock: Starting to wait for file "${file}"`);
        let interval = void 0;
        let eventCB = void 0;
        await new Promise((res) => {
          eventCB = (unlockedFile) => {
            if (unlockedFile === file) {
              res();
            }
          };
          interval = setInterval(async () => {
            const lockStatus2 = await this.checkLock(file);
            log(`waitForLock: Interval for file "${file}" with status "${lockStatus2}"`);
            if (lockStatus2 === LockFileStatus.available) {
              res();
            }
          }, 1e3 * 3);
          this.events.on(LockFileEvents.unlock, eventCB);
        });
        if (interval) {
          clearInterval(interval);
        }
        if (eventCB) {
          this.events.removeListener(LockFileEvents.unlock, eventCB);
        }
        log(`waitForLock: File became available "${file}"`);
        await utils.ensureAsync();
        const lockStatus = await this.checkLock(file);
        log(`waitForLock: Lock File Status reassessment for file "${file}": ${lockStatus}`);
        switch (lockStatus) {
          case LockFileStatus.lockedDifferent:
          case LockFileStatus.lockedSelf:
            return this.waitForLock(file);
          case LockFileStatus.available:
            return this.createLock(file);
          default:
            throw new errors_1.UnknownLockfileStatusError(lockStatus);
        }
      }
      /**
       * Function create the path and lock file
       * @param file The file to use as the LockFile
       */
      static async createLock(file) {
        log(`createLock: trying to create a lock file for "${file}"`);
        const uuid = utils.uuidv4();
        try {
          await this.mutex.runExclusive(async () => {
            if (this.files.has(file)) {
              log(`createLock: Map already has file "${file}"`);
              throw new RepeatError(true);
            }
            await utils.mkdir(path.dirname(file));
            await fs_1.promises.writeFile(file, `${process.pid.toString()} ${uuid}`);
            this.files.add(file);
            this.events.emit(LockFileEvents.lock, file);
          });
        } catch (err) {
          if (err instanceof RepeatError && err.repeat) {
            return this.waitForLock(file);
          }
        }
        log(`createLock: Lock File Created for file "${file}"`);
        return new this(file, uuid);
      }
      constructor(file, uuid) {
        this.file = file;
        this.uuid = uuid;
      }
      /**
       * Unlock the File that is locked by this instance
       */
      async unlock() {
        await utils.ensureAsync();
        log(`unlock: Unlocking file "${this.file}"`);
        if (utils.isNullOrUndefined(this.file) || this.file?.length <= 0) {
          log("unlock: invalid file, returning");
          return;
        }
        switch (await _LockFile.checkLock(this.file, this.uuid)) {
          case LockFileStatus.available:
            log(`unlock: Lock Status was already "available" for file "${this.file}"`);
            await this.unlockCleanup(false);
            return;
          case LockFileStatus.availableInstance:
            log(`unlock: Lock Status was "availableInstance" for file "${this.file}"`);
            await this.unlockCleanup(true);
            return;
          case LockFileStatus.lockedSelf:
            throw new errors_1.UnableToUnlockLockfileError(true, this.file);
          default:
            throw new errors_1.UnableToUnlockLockfileError(false, this.file);
        }
      }
      /**
       * Helper function for the unlock-cleanup
       * @param fileio Unlink the file?
       */
      async unlockCleanup(fileio = true) {
        return await _LockFile.mutex.runExclusive(async () => {
          log(`unlockCleanup: for file "${this.file}"`);
          if (utils.isNullOrUndefined(this.file)) {
            return;
          }
          if (fileio) {
            await fs_1.promises.unlink(this.file).catch((reason) => {
              log(`unlockCleanup: lock file unlink failed: "${reason}"`);
            });
          }
          _LockFile.files.delete(this.file);
          _LockFile.events.emit(LockFileEvents.unlock, this.file);
          this.file = void 0;
          this.uuid = void 0;
        });
      }
    };
    exports2.LockFile = LockFile;
    LockFile.files = /* @__PURE__ */ new Set();
    LockFile.events = new LockFileEventsClass();
    LockFile.mutex = new async_mutex_1.Mutex();
  }
});

// node_modules/mongodb-memory-server-core/lib/util/MongoBinary.js
var require_MongoBinary = __commonJS({
  "node_modules/mongodb-memory-server-core/lib/util/MongoBinary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoBinary = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var os_1 = tslib_1.__importDefault(require("os"));
    var MongoBinaryDownload_1 = tslib_1.__importDefault(require_MongoBinaryDownload());
    var resolveConfig_1 = tslib_1.__importStar(require_resolveConfig());
    var debug_1 = tslib_1.__importDefault(require_src2());
    var semver = tslib_1.__importStar(require_semver2());
    var utils_1 = require_utils4();
    var child_process_1 = require("child_process");
    var lockfile_1 = require_lockfile();
    var DryMongoBinary_1 = require_DryMongoBinary();
    var log = (0, debug_1.default)("MongoMS:MongoBinary");
    var MongoBinary = class {
      /**
       * Probe download path and download the binary
       * @param options Options Configuring which binary to download and to which path
       * @returns The BinaryPath the binary has been downloaded to
       */
      static async download(options2) {
        log("download");
        const { downloadDir, version } = options2;
        await (0, utils_1.mkdir)(downloadDir);
        const lockfile = (0, utils_1.lockfilePath)(downloadDir, version);
        log(`download: Waiting to acquire Download lock for file "${lockfile}"`);
        const lock = await lockfile_1.LockFile.lock(lockfile);
        log("download: Download lock acquired");
        try {
          if (!DryMongoBinary_1.DryMongoBinary.binaryCache.has(version)) {
            log(`download: Adding version ${version} to cache`);
            const downloader = new MongoBinaryDownload_1.default(options2);
            DryMongoBinary_1.DryMongoBinary.binaryCache.set(version, await downloader.getMongodPath());
          }
        } finally {
          log("download: Removing Download lock");
          await lock.unlock();
          log("download: Download lock removed");
        }
        const cachePath = DryMongoBinary_1.DryMongoBinary.binaryCache.get(version);
        (0, utils_1.assertion)(typeof cachePath === "string", new Error(`No Cache Path for version "${version}" found (and download failed silently?)`));
        return cachePath;
      }
      /**
       * Probe all supported paths for an binary and return the binary path
       * @param opts Options configuring which binary to search for
       * @throws {Error} if no valid BinaryPath has been found
       * @returns The first found BinaryPath
       */
      static async getPath(opts = {}) {
        log("getPath");
        const options2 = {
          ...await DryMongoBinary_1.DryMongoBinary.generateOptions(opts),
          platform: opts.platform || (0, resolveConfig_1.default)(resolveConfig_1.ResolveConfigVariables.PLATFORM) || os_1.default.platform(),
          checkMD5: opts.checkMD5 || (0, resolveConfig_1.envToBool)((0, resolveConfig_1.default)(resolveConfig_1.ResolveConfigVariables.MD5_CHECK))
        };
        log(`getPath: MongoBinary options:`, JSON.stringify(options2, null, 2));
        let binaryPath = await DryMongoBinary_1.DryMongoBinary.locateBinary(options2);
        if (!!options2.systemBinary) {
          if (!(0, utils_1.isNullOrUndefined)(binaryPath)) {
            if ((0, resolveConfig_1.envToBool)((0, resolveConfig_1.default)(resolveConfig_1.ResolveConfigVariables.SYSTEM_BINARY_VERSION_CHECK))) {
              log(`getPath: Spawning binaryPath "${binaryPath}" to get version`);
              const spawnOutput = (0, child_process_1.spawnSync)(binaryPath, ["--version"]).stdout?.toString().match(/^\s*db\s+version\s+v?(\d+\.\d+\.\d+)(-\d*)?(-[a-zA-Z0-9].*)?\s*$/im);
              (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(spawnOutput), new Error("Couldnt find an version from system binary output!"));
              log("getPath: Checking & Warning about version conflicts");
              const binaryVersion = spawnOutput[1];
              if (semver.neq(options2.version, binaryVersion)) {
                console.warn(`getPath: MongoMemoryServer: Possible version conflict
  SystemBinary version: "${binaryVersion}"
  Requested version:    "${options2.version}"

  Using SystemBinary!`);
              }
            }
          } else {
            throw new Error('Option "SYSTEM_BINARY" was set, but binaryPath was empty! (system binary could not be found?) [This Error should normally not be thrown, please report this]');
          }
        }
        (0, utils_1.assertion)(typeof options2.version === "string", new Error('"MongoBinary.options.version" is not an string!'));
        if (!binaryPath) {
          if ((0, resolveConfig_1.envToBool)((0, resolveConfig_1.default)(resolveConfig_1.ResolveConfigVariables.RUNTIME_DOWNLOAD))) {
            log('getPath: "RUNTIME_DOWNLOAD" is "true", trying to download');
            binaryPath = await this.download(options2);
          } else {
            log('getPath: "RUNTIME_DOWNLOAD" is "false", not downloading');
          }
        }
        if (!binaryPath) {
          const runtimeDownload = (0, resolveConfig_1.envToBool)((0, resolveConfig_1.default)(resolveConfig_1.ResolveConfigVariables.RUNTIME_DOWNLOAD));
          throw new Error(`MongoBinary.getPath: could not find an valid binary path! (Got: "${binaryPath}", RUNTIME_DOWNLOAD: "${runtimeDownload}")`);
        }
        log(`getPath: Mongod binary path: "${binaryPath}"`);
        return binaryPath;
      }
    };
    exports2.MongoBinary = MongoBinary;
    exports2.default = MongoBinary;
  }
});

// node_modules/bson/lib/bson.cjs
var require_bson = __commonJS({
  "node_modules/bson/lib/bson.cjs"(exports2) {
    "use strict";
    var TypedArrayPrototypeGetSymbolToStringTag = (() => {
      const g = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array.prototype), Symbol.toStringTag).get;
      return (value) => g.call(value);
    })();
    function isUint8Array(value) {
      return TypedArrayPrototypeGetSymbolToStringTag(value) === "Uint8Array";
    }
    function isAnyArrayBuffer(value) {
      return typeof value === "object" && value != null && Symbol.toStringTag in value && (value[Symbol.toStringTag] === "ArrayBuffer" || value[Symbol.toStringTag] === "SharedArrayBuffer");
    }
    function isRegExp(regexp2) {
      return regexp2 instanceof RegExp || Object.prototype.toString.call(regexp2) === "[object RegExp]";
    }
    function isMap(value) {
      return typeof value === "object" && value != null && Symbol.toStringTag in value && value[Symbol.toStringTag] === "Map";
    }
    function isDate(date) {
      return date instanceof Date || Object.prototype.toString.call(date) === "[object Date]";
    }
    function defaultInspect(x, _options) {
      return JSON.stringify(x, (k, v) => {
        if (typeof v === "bigint") {
          return { $numberLong: `${v}` };
        } else if (isMap(v)) {
          return Object.fromEntries(v);
        }
        return v;
      });
    }
    function getStylizeFunction(options2) {
      const stylizeExists = options2 != null && typeof options2 === "object" && "stylize" in options2 && typeof options2.stylize === "function";
      if (stylizeExists) {
        return options2.stylize;
      }
    }
    var BSON_MAJOR_VERSION = 6;
    var BSON_VERSION_SYMBOL = Symbol.for("@@mdb.bson.version");
    var BSON_INT32_MAX = 2147483647;
    var BSON_INT32_MIN = -2147483648;
    var BSON_INT64_MAX = Math.pow(2, 63) - 1;
    var BSON_INT64_MIN = -Math.pow(2, 63);
    var JS_INT_MAX = Math.pow(2, 53);
    var JS_INT_MIN = -Math.pow(2, 53);
    var BSON_DATA_NUMBER = 1;
    var BSON_DATA_STRING = 2;
    var BSON_DATA_OBJECT = 3;
    var BSON_DATA_ARRAY = 4;
    var BSON_DATA_BINARY = 5;
    var BSON_DATA_UNDEFINED = 6;
    var BSON_DATA_OID = 7;
    var BSON_DATA_BOOLEAN = 8;
    var BSON_DATA_DATE = 9;
    var BSON_DATA_NULL = 10;
    var BSON_DATA_REGEXP = 11;
    var BSON_DATA_DBPOINTER = 12;
    var BSON_DATA_CODE = 13;
    var BSON_DATA_SYMBOL = 14;
    var BSON_DATA_CODE_W_SCOPE = 15;
    var BSON_DATA_INT = 16;
    var BSON_DATA_TIMESTAMP = 17;
    var BSON_DATA_LONG = 18;
    var BSON_DATA_DECIMAL128 = 19;
    var BSON_DATA_MIN_KEY = 255;
    var BSON_DATA_MAX_KEY = 127;
    var BSON_BINARY_SUBTYPE_DEFAULT = 0;
    var BSON_BINARY_SUBTYPE_UUID_NEW = 4;
    var BSONType = Object.freeze({
      double: 1,
      string: 2,
      object: 3,
      array: 4,
      binData: 5,
      undefined: 6,
      objectId: 7,
      bool: 8,
      date: 9,
      null: 10,
      regex: 11,
      dbPointer: 12,
      javascript: 13,
      symbol: 14,
      javascriptWithScope: 15,
      int: 16,
      timestamp: 17,
      long: 18,
      decimal: 19,
      minKey: -1,
      maxKey: 127
    });
    var BSONError = class extends Error {
      get bsonError() {
        return true;
      }
      get name() {
        return "BSONError";
      }
      constructor(message, options2) {
        super(message, options2);
      }
      static isBSONError(value) {
        return value != null && typeof value === "object" && "bsonError" in value && value.bsonError === true && "name" in value && "message" in value && "stack" in value;
      }
    };
    var BSONVersionError = class extends BSONError {
      get name() {
        return "BSONVersionError";
      }
      constructor() {
        super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);
      }
    };
    var BSONRuntimeError = class extends BSONError {
      get name() {
        return "BSONRuntimeError";
      }
      constructor(message) {
        super(message);
      }
    };
    var BSONOffsetError = class extends BSONError {
      get name() {
        return "BSONOffsetError";
      }
      constructor(message, offset, options2) {
        super(`${message}. offset: ${offset}`, options2);
        this.offset = offset;
      }
    };
    var TextDecoderFatal;
    var TextDecoderNonFatal;
    function parseUtf8(buffer2, start, end, fatal) {
      if (fatal) {
        TextDecoderFatal ??= new TextDecoder("utf8", { fatal: true });
        try {
          return TextDecoderFatal.decode(buffer2.subarray(start, end));
        } catch (cause) {
          throw new BSONError("Invalid UTF-8 string in BSON document", { cause });
        }
      }
      TextDecoderNonFatal ??= new TextDecoder("utf8", { fatal: false });
      return TextDecoderNonFatal.decode(buffer2.subarray(start, end));
    }
    function tryReadBasicLatin(uint8array, start, end) {
      if (uint8array.length === 0) {
        return "";
      }
      const stringByteLength = end - start;
      if (stringByteLength === 0) {
        return "";
      }
      if (stringByteLength > 20) {
        return null;
      }
      if (stringByteLength === 1 && uint8array[start] < 128) {
        return String.fromCharCode(uint8array[start]);
      }
      if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {
        return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);
      }
      if (stringByteLength === 3 && uint8array[start] < 128 && uint8array[start + 1] < 128 && uint8array[start + 2] < 128) {
        return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]) + String.fromCharCode(uint8array[start + 2]);
      }
      const latinBytes = [];
      for (let i = start; i < end; i++) {
        const byte = uint8array[i];
        if (byte > 127) {
          return null;
        }
        latinBytes.push(byte);
      }
      return String.fromCharCode(...latinBytes);
    }
    function tryWriteBasicLatin(destination, source, offset) {
      if (source.length === 0)
        return 0;
      if (source.length > 25)
        return null;
      if (destination.length - offset < source.length)
        return null;
      for (let charOffset = 0, destinationOffset = offset; charOffset < source.length; charOffset++, destinationOffset++) {
        const char = source.charCodeAt(charOffset);
        if (char > 127)
          return null;
        destination[destinationOffset] = char;
      }
      return source.length;
    }
    function nodejsMathRandomBytes(byteLength) {
      return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
    }
    var nodejsRandomBytes = (() => {
      try {
        return require("crypto").randomBytes;
      } catch {
        return nodejsMathRandomBytes;
      }
    })();
    var nodeJsByteUtils = {
      toLocalBufferType(potentialBuffer) {
        if (Buffer.isBuffer(potentialBuffer)) {
          return potentialBuffer;
        }
        if (ArrayBuffer.isView(potentialBuffer)) {
          return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
        }
        const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);
        if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
          return Buffer.from(potentialBuffer);
        }
        throw new BSONError(`Cannot create Buffer from the passed potentialBuffer.`);
      },
      allocate(size) {
        return Buffer.alloc(size);
      },
      allocateUnsafe(size) {
        return Buffer.allocUnsafe(size);
      },
      equals(a, b) {
        return nodeJsByteUtils.toLocalBufferType(a).equals(b);
      },
      fromNumberArray(array) {
        return Buffer.from(array);
      },
      fromBase64(base64) {
        return Buffer.from(base64, "base64");
      },
      toBase64(buffer2) {
        return nodeJsByteUtils.toLocalBufferType(buffer2).toString("base64");
      },
      fromISO88591(codePoints) {
        return Buffer.from(codePoints, "binary");
      },
      toISO88591(buffer2) {
        return nodeJsByteUtils.toLocalBufferType(buffer2).toString("binary");
      },
      fromHex(hex) {
        return Buffer.from(hex, "hex");
      },
      toHex(buffer2) {
        return nodeJsByteUtils.toLocalBufferType(buffer2).toString("hex");
      },
      toUTF8(buffer2, start, end, fatal) {
        const basicLatin = end - start <= 20 ? tryReadBasicLatin(buffer2, start, end) : null;
        if (basicLatin != null) {
          return basicLatin;
        }
        const string = nodeJsByteUtils.toLocalBufferType(buffer2).toString("utf8", start, end);
        if (fatal) {
          for (let i = 0; i < string.length; i++) {
            if (string.charCodeAt(i) === 65533) {
              parseUtf8(buffer2, start, end, true);
              break;
            }
          }
        }
        return string;
      },
      utf8ByteLength(input) {
        return Buffer.byteLength(input, "utf8");
      },
      encodeUTF8Into(buffer2, source, byteOffset) {
        const latinBytesWritten = tryWriteBasicLatin(buffer2, source, byteOffset);
        if (latinBytesWritten != null) {
          return latinBytesWritten;
        }
        return nodeJsByteUtils.toLocalBufferType(buffer2).write(source, byteOffset, void 0, "utf8");
      },
      randomBytes: nodejsRandomBytes,
      swap32(buffer2) {
        return nodeJsByteUtils.toLocalBufferType(buffer2).swap32();
      }
    };
    function isReactNative() {
      const { navigator: navigator2 } = globalThis;
      return typeof navigator2 === "object" && navigator2.product === "ReactNative";
    }
    function webMathRandomBytes(byteLength) {
      if (byteLength < 0) {
        throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);
      }
      return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
    }
    var webRandomBytes = (() => {
      const { crypto } = globalThis;
      if (crypto != null && typeof crypto.getRandomValues === "function") {
        return (byteLength) => {
          return crypto.getRandomValues(webByteUtils.allocate(byteLength));
        };
      } else {
        if (isReactNative()) {
          const { console: console2 } = globalThis;
          console2?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.");
        }
        return webMathRandomBytes;
      }
    })();
    var HEX_DIGIT = /(\d|[a-f])/i;
    var webByteUtils = {
      toLocalBufferType(potentialUint8array) {
        const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array);
        if (stringTag === "Uint8Array") {
          return potentialUint8array;
        }
        if (ArrayBuffer.isView(potentialUint8array)) {
          return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));
        }
        if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
          return new Uint8Array(potentialUint8array);
        }
        throw new BSONError(`Cannot make a Uint8Array from passed potentialBuffer.`);
      },
      allocate(size) {
        if (typeof size !== "number") {
          throw new TypeError(`The "size" argument must be of type number. Received ${String(size)}`);
        }
        return new Uint8Array(size);
      },
      allocateUnsafe(size) {
        return webByteUtils.allocate(size);
      },
      equals(a, b) {
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        for (let i = 0; i < a.byteLength; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      },
      fromNumberArray(array) {
        return Uint8Array.from(array);
      },
      fromBase64(base64) {
        return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
      },
      toBase64(uint8array) {
        return btoa(webByteUtils.toISO88591(uint8array));
      },
      fromISO88591(codePoints) {
        return Uint8Array.from(codePoints, (c) => c.charCodeAt(0) & 255);
      },
      toISO88591(uint8array) {
        return Array.from(Uint16Array.from(uint8array), (b) => String.fromCharCode(b)).join("");
      },
      fromHex(hex) {
        const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);
        const buffer2 = [];
        for (let i = 0; i < evenLengthHex.length; i += 2) {
          const firstDigit = evenLengthHex[i];
          const secondDigit = evenLengthHex[i + 1];
          if (!HEX_DIGIT.test(firstDigit)) {
            break;
          }
          if (!HEX_DIGIT.test(secondDigit)) {
            break;
          }
          const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);
          buffer2.push(hexDigit);
        }
        return Uint8Array.from(buffer2);
      },
      toHex(uint8array) {
        return Array.from(uint8array, (byte) => byte.toString(16).padStart(2, "0")).join("");
      },
      toUTF8(uint8array, start, end, fatal) {
        const basicLatin = end - start <= 20 ? tryReadBasicLatin(uint8array, start, end) : null;
        if (basicLatin != null) {
          return basicLatin;
        }
        return parseUtf8(uint8array, start, end, fatal);
      },
      utf8ByteLength(input) {
        return new TextEncoder().encode(input).byteLength;
      },
      encodeUTF8Into(uint8array, source, byteOffset) {
        const bytes = new TextEncoder().encode(source);
        uint8array.set(bytes, byteOffset);
        return bytes.byteLength;
      },
      randomBytes: webRandomBytes,
      swap32(buffer2) {
        if (buffer2.length % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < buffer2.length; i += 4) {
          const byte0 = buffer2[i];
          const byte1 = buffer2[i + 1];
          const byte2 = buffer2[i + 2];
          const byte3 = buffer2[i + 3];
          buffer2[i] = byte3;
          buffer2[i + 1] = byte2;
          buffer2[i + 2] = byte1;
          buffer2[i + 3] = byte0;
        }
        return buffer2;
      }
    };
    var hasGlobalBuffer = typeof Buffer === "function" && Buffer.prototype?._isBuffer !== true;
    var ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;
    var BSONValue = class {
      get [BSON_VERSION_SYMBOL]() {
        return BSON_MAJOR_VERSION;
      }
      [Symbol.for("nodejs.util.inspect.custom")](depth, options2, inspect) {
        return this.inspect(depth, options2, inspect);
      }
    };
    var FLOAT = new Float64Array(1);
    var FLOAT_BYTES = new Uint8Array(FLOAT.buffer, 0, 8);
    FLOAT[0] = -1;
    var isBigEndian = FLOAT_BYTES[7] === 0;
    var NumberUtils = {
      isBigEndian,
      getNonnegativeInt32LE(source, offset) {
        if (source[offset + 3] > 127) {
          throw new RangeError(`Size cannot be negative at offset: ${offset}`);
        }
        return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
      },
      getInt32LE(source, offset) {
        return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
      },
      getUint32LE(source, offset) {
        return source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216;
      },
      getUint32BE(source, offset) {
        return source[offset + 3] + source[offset + 2] * 256 + source[offset + 1] * 65536 + source[offset] * 16777216;
      },
      getBigInt64LE(source, offset) {
        const hi = BigInt(source[offset + 4] + source[offset + 5] * 256 + source[offset + 6] * 65536 + (source[offset + 7] << 24));
        const lo = BigInt(source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216);
        return (hi << BigInt(32)) + lo;
      },
      getFloat64LE: isBigEndian ? (source, offset) => {
        FLOAT_BYTES[7] = source[offset];
        FLOAT_BYTES[6] = source[offset + 1];
        FLOAT_BYTES[5] = source[offset + 2];
        FLOAT_BYTES[4] = source[offset + 3];
        FLOAT_BYTES[3] = source[offset + 4];
        FLOAT_BYTES[2] = source[offset + 5];
        FLOAT_BYTES[1] = source[offset + 6];
        FLOAT_BYTES[0] = source[offset + 7];
        return FLOAT[0];
      } : (source, offset) => {
        FLOAT_BYTES[0] = source[offset];
        FLOAT_BYTES[1] = source[offset + 1];
        FLOAT_BYTES[2] = source[offset + 2];
        FLOAT_BYTES[3] = source[offset + 3];
        FLOAT_BYTES[4] = source[offset + 4];
        FLOAT_BYTES[5] = source[offset + 5];
        FLOAT_BYTES[6] = source[offset + 6];
        FLOAT_BYTES[7] = source[offset + 7];
        return FLOAT[0];
      },
      setInt32BE(destination, offset, value) {
        destination[offset + 3] = value;
        value >>>= 8;
        destination[offset + 2] = value;
        value >>>= 8;
        destination[offset + 1] = value;
        value >>>= 8;
        destination[offset] = value;
        return 4;
      },
      setInt32LE(destination, offset, value) {
        destination[offset] = value;
        value >>>= 8;
        destination[offset + 1] = value;
        value >>>= 8;
        destination[offset + 2] = value;
        value >>>= 8;
        destination[offset + 3] = value;
        return 4;
      },
      setBigInt64LE(destination, offset, value) {
        const mask32bits = BigInt(4294967295);
        let lo = Number(value & mask32bits);
        destination[offset] = lo;
        lo >>= 8;
        destination[offset + 1] = lo;
        lo >>= 8;
        destination[offset + 2] = lo;
        lo >>= 8;
        destination[offset + 3] = lo;
        let hi = Number(value >> BigInt(32) & mask32bits);
        destination[offset + 4] = hi;
        hi >>= 8;
        destination[offset + 5] = hi;
        hi >>= 8;
        destination[offset + 6] = hi;
        hi >>= 8;
        destination[offset + 7] = hi;
        return 8;
      },
      setFloat64LE: isBigEndian ? (destination, offset, value) => {
        FLOAT[0] = value;
        destination[offset] = FLOAT_BYTES[7];
        destination[offset + 1] = FLOAT_BYTES[6];
        destination[offset + 2] = FLOAT_BYTES[5];
        destination[offset + 3] = FLOAT_BYTES[4];
        destination[offset + 4] = FLOAT_BYTES[3];
        destination[offset + 5] = FLOAT_BYTES[2];
        destination[offset + 6] = FLOAT_BYTES[1];
        destination[offset + 7] = FLOAT_BYTES[0];
        return 8;
      } : (destination, offset, value) => {
        FLOAT[0] = value;
        destination[offset] = FLOAT_BYTES[0];
        destination[offset + 1] = FLOAT_BYTES[1];
        destination[offset + 2] = FLOAT_BYTES[2];
        destination[offset + 3] = FLOAT_BYTES[3];
        destination[offset + 4] = FLOAT_BYTES[4];
        destination[offset + 5] = FLOAT_BYTES[5];
        destination[offset + 6] = FLOAT_BYTES[6];
        destination[offset + 7] = FLOAT_BYTES[7];
        return 8;
      }
    };
    var Binary = class _Binary extends BSONValue {
      get _bsontype() {
        return "Binary";
      }
      constructor(buffer2, subType) {
        super();
        if (!(buffer2 == null) && typeof buffer2 === "string" && !ArrayBuffer.isView(buffer2) && !isAnyArrayBuffer(buffer2) && !Array.isArray(buffer2)) {
          throw new BSONError("Binary can only be constructed from Uint8Array or number[]");
        }
        this.sub_type = subType ?? _Binary.BSON_BINARY_SUBTYPE_DEFAULT;
        if (buffer2 == null) {
          this.buffer = ByteUtils.allocate(_Binary.BUFFER_SIZE);
          this.position = 0;
        } else {
          this.buffer = Array.isArray(buffer2) ? ByteUtils.fromNumberArray(buffer2) : ByteUtils.toLocalBufferType(buffer2);
          this.position = this.buffer.byteLength;
        }
      }
      put(byteValue) {
        if (typeof byteValue === "string" && byteValue.length !== 1) {
          throw new BSONError("only accepts single character String");
        } else if (typeof byteValue !== "number" && byteValue.length !== 1)
          throw new BSONError("only accepts single character Uint8Array or Array");
        let decodedByte;
        if (typeof byteValue === "string") {
          decodedByte = byteValue.charCodeAt(0);
        } else if (typeof byteValue === "number") {
          decodedByte = byteValue;
        } else {
          decodedByte = byteValue[0];
        }
        if (decodedByte < 0 || decodedByte > 255) {
          throw new BSONError("only accepts number in a valid unsigned byte range 0-255");
        }
        if (this.buffer.byteLength > this.position) {
          this.buffer[this.position++] = decodedByte;
        } else {
          const newSpace = ByteUtils.allocate(_Binary.BUFFER_SIZE + this.buffer.length);
          newSpace.set(this.buffer, 0);
          this.buffer = newSpace;
          this.buffer[this.position++] = decodedByte;
        }
      }
      write(sequence, offset) {
        offset = typeof offset === "number" ? offset : this.position;
        if (this.buffer.byteLength < offset + sequence.length) {
          const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);
          newSpace.set(this.buffer, 0);
          this.buffer = newSpace;
        }
        if (ArrayBuffer.isView(sequence)) {
          this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);
          this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
        } else if (typeof sequence === "string") {
          throw new BSONError("input cannot be string");
        }
      }
      read(position, length) {
        length = length && length > 0 ? length : this.position;
        const end = position + length;
        return this.buffer.subarray(position, end > this.position ? this.position : end);
      }
      value() {
        return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);
      }
      length() {
        return this.position;
      }
      toJSON() {
        return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
      }
      toString(encoding) {
        if (encoding === "hex")
          return ByteUtils.toHex(this.buffer.subarray(0, this.position));
        if (encoding === "base64")
          return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
        if (encoding === "utf8" || encoding === "utf-8")
          return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
        return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
      }
      toExtendedJSON(options2) {
        options2 = options2 || {};
        if (this.sub_type === _Binary.SUBTYPE_VECTOR) {
          validateBinaryVector(this);
        }
        const base64String = ByteUtils.toBase64(this.buffer);
        const subType = Number(this.sub_type).toString(16);
        if (options2.legacy) {
          return {
            $binary: base64String,
            $type: subType.length === 1 ? "0" + subType : subType
          };
        }
        return {
          $binary: {
            base64: base64String,
            subType: subType.length === 1 ? "0" + subType : subType
          }
        };
      }
      toUUID() {
        if (this.sub_type === _Binary.SUBTYPE_UUID) {
          return new UUID(this.buffer.subarray(0, this.position));
        }
        throw new BSONError(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${_Binary.SUBTYPE_UUID}" is currently supported.`);
      }
      static createFromHexString(hex, subType) {
        return new _Binary(ByteUtils.fromHex(hex), subType);
      }
      static createFromBase64(base64, subType) {
        return new _Binary(ByteUtils.fromBase64(base64), subType);
      }
      static fromExtendedJSON(doc, options2) {
        options2 = options2 || {};
        let data;
        let type;
        if ("$binary" in doc) {
          if (options2.legacy && typeof doc.$binary === "string" && "$type" in doc) {
            type = doc.$type ? parseInt(doc.$type, 16) : 0;
            data = ByteUtils.fromBase64(doc.$binary);
          } else {
            if (typeof doc.$binary !== "string") {
              type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
              data = ByteUtils.fromBase64(doc.$binary.base64);
            }
          }
        } else if ("$uuid" in doc) {
          type = 4;
          data = UUID.bytesFromString(doc.$uuid);
        }
        if (!data) {
          throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);
        }
        return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new _Binary(data, type);
      }
      inspect(depth, options2, inspect) {
        inspect ??= defaultInspect;
        const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));
        const base64Arg = inspect(base64, options2);
        const subTypeArg = inspect(this.sub_type, options2);
        return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;
      }
      toInt8Array() {
        if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
          throw new BSONError("Binary sub_type is not Vector");
        }
        if (this.buffer[0] !== _Binary.VECTOR_TYPE.Int8) {
          throw new BSONError("Binary datatype field is not Int8");
        }
        validateBinaryVector(this);
        return new Int8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
      }
      toFloat32Array() {
        if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
          throw new BSONError("Binary sub_type is not Vector");
        }
        if (this.buffer[0] !== _Binary.VECTOR_TYPE.Float32) {
          throw new BSONError("Binary datatype field is not Float32");
        }
        validateBinaryVector(this);
        const floatBytes = new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
        if (NumberUtils.isBigEndian)
          ByteUtils.swap32(floatBytes);
        return new Float32Array(floatBytes.buffer);
      }
      toPackedBits() {
        if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
          throw new BSONError("Binary sub_type is not Vector");
        }
        if (this.buffer[0] !== _Binary.VECTOR_TYPE.PackedBit) {
          throw new BSONError("Binary datatype field is not packed bit");
        }
        validateBinaryVector(this);
        return new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
      }
      toBits() {
        if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
          throw new BSONError("Binary sub_type is not Vector");
        }
        if (this.buffer[0] !== _Binary.VECTOR_TYPE.PackedBit) {
          throw new BSONError("Binary datatype field is not packed bit");
        }
        validateBinaryVector(this);
        const byteCount = this.length() - 2;
        const bitCount = byteCount * 8 - this.buffer[1];
        const bits = new Int8Array(bitCount);
        for (let bitOffset = 0; bitOffset < bits.length; bitOffset++) {
          const byteOffset = bitOffset / 8 | 0;
          const byte = this.buffer[byteOffset + 2];
          const shift = 7 - bitOffset % 8;
          const bit = byte >> shift & 1;
          bits[bitOffset] = bit;
        }
        return bits;
      }
      static fromInt8Array(array) {
        const buffer2 = ByteUtils.allocate(array.byteLength + 2);
        buffer2[0] = _Binary.VECTOR_TYPE.Int8;
        buffer2[1] = 0;
        const intBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
        buffer2.set(intBytes, 2);
        const bin = new this(buffer2, this.SUBTYPE_VECTOR);
        validateBinaryVector(bin);
        return bin;
      }
      static fromFloat32Array(array) {
        const binaryBytes = ByteUtils.allocate(array.byteLength + 2);
        binaryBytes[0] = _Binary.VECTOR_TYPE.Float32;
        binaryBytes[1] = 0;
        const floatBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
        binaryBytes.set(floatBytes, 2);
        if (NumberUtils.isBigEndian)
          ByteUtils.swap32(new Uint8Array(binaryBytes.buffer, 2));
        const bin = new this(binaryBytes, this.SUBTYPE_VECTOR);
        validateBinaryVector(bin);
        return bin;
      }
      static fromPackedBits(array, padding = 0) {
        const buffer2 = ByteUtils.allocate(array.byteLength + 2);
        buffer2[0] = _Binary.VECTOR_TYPE.PackedBit;
        buffer2[1] = padding;
        buffer2.set(array, 2);
        const bin = new this(buffer2, this.SUBTYPE_VECTOR);
        validateBinaryVector(bin);
        return bin;
      }
      static fromBits(bits) {
        const byteLength = bits.length + 7 >>> 3;
        const bytes = new Uint8Array(byteLength + 2);
        bytes[0] = _Binary.VECTOR_TYPE.PackedBit;
        const remainder = bits.length % 8;
        bytes[1] = remainder === 0 ? 0 : 8 - remainder;
        for (let bitOffset = 0; bitOffset < bits.length; bitOffset++) {
          const byteOffset = bitOffset >>> 3;
          const bit = bits[bitOffset];
          if (bit !== 0 && bit !== 1) {
            throw new BSONError(`Invalid bit value at ${bitOffset}: must be 0 or 1, found ${bits[bitOffset]}`);
          }
          if (bit === 0)
            continue;
          const shift = 7 - bitOffset % 8;
          bytes[byteOffset + 2] |= bit << shift;
        }
        return new this(bytes, _Binary.SUBTYPE_VECTOR);
      }
    };
    Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    Binary.BUFFER_SIZE = 256;
    Binary.SUBTYPE_DEFAULT = 0;
    Binary.SUBTYPE_FUNCTION = 1;
    Binary.SUBTYPE_BYTE_ARRAY = 2;
    Binary.SUBTYPE_UUID_OLD = 3;
    Binary.SUBTYPE_UUID = 4;
    Binary.SUBTYPE_MD5 = 5;
    Binary.SUBTYPE_ENCRYPTED = 6;
    Binary.SUBTYPE_COLUMN = 7;
    Binary.SUBTYPE_SENSITIVE = 8;
    Binary.SUBTYPE_VECTOR = 9;
    Binary.SUBTYPE_USER_DEFINED = 128;
    Binary.VECTOR_TYPE = Object.freeze({
      Int8: 3,
      Float32: 39,
      PackedBit: 16
    });
    function validateBinaryVector(vector) {
      if (vector.sub_type !== Binary.SUBTYPE_VECTOR)
        return;
      const size = vector.position;
      const datatype = vector.buffer[0];
      const padding = vector.buffer[1];
      if ((datatype === Binary.VECTOR_TYPE.Float32 || datatype === Binary.VECTOR_TYPE.Int8) && padding !== 0) {
        throw new BSONError("Invalid Vector: padding must be zero for int8 and float32 vectors");
      }
      if (datatype === Binary.VECTOR_TYPE.Float32) {
        if (size !== 0 && size - 2 !== 0 && (size - 2) % 4 !== 0) {
          throw new BSONError("Invalid Vector: Float32 vector must contain a multiple of 4 bytes");
        }
      }
      if (datatype === Binary.VECTOR_TYPE.PackedBit && padding !== 0 && size === 2) {
        throw new BSONError("Invalid Vector: padding must be zero for packed bit vectors that are empty");
      }
      if (datatype === Binary.VECTOR_TYPE.PackedBit && padding > 7) {
        throw new BSONError(`Invalid Vector: padding must be a value between 0 and 7. found: ${padding}`);
      }
    }
    var UUID_BYTE_LENGTH = 16;
    var UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;
    var UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;
    var UUID = class _UUID extends Binary {
      constructor(input) {
        let bytes;
        if (input == null) {
          bytes = _UUID.generate();
        } else if (input instanceof _UUID) {
          bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));
        } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
          bytes = ByteUtils.toLocalBufferType(input);
        } else if (typeof input === "string") {
          bytes = _UUID.bytesFromString(input);
        } else {
          throw new BSONError("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
        }
        super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);
      }
      get id() {
        return this.buffer;
      }
      set id(value) {
        this.buffer = value;
      }
      toHexString(includeDashes = true) {
        if (includeDashes) {
          return [
            ByteUtils.toHex(this.buffer.subarray(0, 4)),
            ByteUtils.toHex(this.buffer.subarray(4, 6)),
            ByteUtils.toHex(this.buffer.subarray(6, 8)),
            ByteUtils.toHex(this.buffer.subarray(8, 10)),
            ByteUtils.toHex(this.buffer.subarray(10, 16))
          ].join("-");
        }
        return ByteUtils.toHex(this.buffer);
      }
      toString(encoding) {
        if (encoding === "hex")
          return ByteUtils.toHex(this.id);
        if (encoding === "base64")
          return ByteUtils.toBase64(this.id);
        return this.toHexString();
      }
      toJSON() {
        return this.toHexString();
      }
      equals(otherId) {
        if (!otherId) {
          return false;
        }
        if (otherId instanceof _UUID) {
          return ByteUtils.equals(otherId.id, this.id);
        }
        try {
          return ByteUtils.equals(new _UUID(otherId).id, this.id);
        } catch {
          return false;
        }
      }
      toBinary() {
        return new Binary(this.id, Binary.SUBTYPE_UUID);
      }
      static generate() {
        const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);
        bytes[6] = bytes[6] & 15 | 64;
        bytes[8] = bytes[8] & 63 | 128;
        return bytes;
      }
      static isValid(input) {
        if (!input) {
          return false;
        }
        if (typeof input === "string") {
          return _UUID.isValidUUIDString(input);
        }
        if (isUint8Array(input)) {
          return input.byteLength === UUID_BYTE_LENGTH;
        }
        return input._bsontype === "Binary" && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;
      }
      static createFromHexString(hexString) {
        const buffer2 = _UUID.bytesFromString(hexString);
        return new _UUID(buffer2);
      }
      static createFromBase64(base64) {
        return new _UUID(ByteUtils.fromBase64(base64));
      }
      static bytesFromString(representation) {
        if (!_UUID.isValidUUIDString(representation)) {
          throw new BSONError("UUID string representation must be 32 hex digits or canonical hyphenated representation");
        }
        return ByteUtils.fromHex(representation.replace(/-/g, ""));
      }
      static isValidUUIDString(representation) {
        return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);
      }
      inspect(depth, options2, inspect) {
        inspect ??= defaultInspect;
        return `new UUID(${inspect(this.toHexString(), options2)})`;
      }
    };
    var Code = class _Code extends BSONValue {
      get _bsontype() {
        return "Code";
      }
      constructor(code, scope) {
        super();
        this.code = code.toString();
        this.scope = scope ?? null;
      }
      toJSON() {
        if (this.scope != null) {
          return { code: this.code, scope: this.scope };
        }
        return { code: this.code };
      }
      toExtendedJSON() {
        if (this.scope) {
          return { $code: this.code, $scope: this.scope };
        }
        return { $code: this.code };
      }
      static fromExtendedJSON(doc) {
        return new _Code(doc.$code, doc.$scope);
      }
      inspect(depth, options2, inspect) {
        inspect ??= defaultInspect;
        let parametersString = inspect(this.code, options2);
        const multiLineFn = parametersString.includes("\n");
        if (this.scope != null) {
          parametersString += `,${multiLineFn ? "\n" : " "}${inspect(this.scope, options2)}`;
        }
        const endingNewline = multiLineFn && this.scope === null;
        return `new Code(${multiLineFn ? "\n" : ""}${parametersString}${endingNewline ? "\n" : ""})`;
      }
    };
    function isDBRefLike(value) {
      return value != null && typeof value === "object" && "$id" in value && value.$id != null && "$ref" in value && typeof value.$ref === "string" && (!("$db" in value) || "$db" in value && typeof value.$db === "string");
    }
    var DBRef = class _DBRef extends BSONValue {
      get _bsontype() {
        return "DBRef";
      }
      constructor(collection, oid, db, fields) {
        super();
        const parts = collection.split(".");
        if (parts.length === 2) {
          db = parts.shift();
          collection = parts.shift();
        }
        this.collection = collection;
        this.oid = oid;
        this.db = db;
        this.fields = fields || {};
      }
      get namespace() {
        return this.collection;
      }
      set namespace(value) {
        this.collection = value;
      }
      toJSON() {
        const o = Object.assign({
          $ref: this.collection,
          $id: this.oid
        }, this.fields);
        if (this.db != null)
          o.$db = this.db;
        return o;
      }
      toExtendedJSON(options2) {
        options2 = options2 || {};
        let o = {
          $ref: this.collection,
          $id: this.oid
        };
        if (options2.legacy) {
          return o;
        }
        if (this.db)
          o.$db = this.db;
        o = Object.assign(o, this.fields);
        return o;
      }
      static fromExtendedJSON(doc) {
        const copy = Object.assign({}, doc);
        delete copy.$ref;
        delete copy.$id;
        delete copy.$db;
        return new _DBRef(doc.$ref, doc.$id, doc.$db, copy);
      }
      inspect(depth, options2, inspect) {
        inspect ??= defaultInspect;
        const args = [
          inspect(this.namespace, options2),
          inspect(this.oid, options2),
          ...this.db ? [inspect(this.db, options2)] : [],
          ...Object.keys(this.fields).length > 0 ? [inspect(this.fields, options2)] : []
        ];
        args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];
        return `new DBRef(${args.join(", ")})`;
      }
    };
    function removeLeadingZerosAndExplicitPlus(str) {
      if (str === "") {
        return str;
      }
      let startIndex = 0;
      const isNegative = str[startIndex] === "-";
      const isExplicitlyPositive = str[startIndex] === "+";
      if (isExplicitlyPositive || isNegative) {
        startIndex += 1;
      }
      let foundInsignificantZero = false;
      for (; startIndex < str.length && str[startIndex] === "0"; ++startIndex) {
        foundInsignificantZero = true;
      }
      if (!foundInsignificantZero) {
        return isExplicitlyPositive ? str.slice(1) : str;
      }
      return `${isNegative ? "-" : ""}${str.length === startIndex ? "0" : str.slice(startIndex)}`;
    }
    function validateStringCharacters(str, radix) {
      radix = radix ?? 10;
      const validCharacters = "0123456789abcdefghijklmnopqrstuvwxyz".slice(0, radix);
      const regex = new RegExp(`[^-+${validCharacters}]`, "i");
      return regex.test(str) ? false : str;
    }
    var wasm = void 0;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
    } catch {
    }
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    var MAX_INT64_STRING_LENGTH = 20;
    var DECIMAL_REG_EX = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;
    var Long = class _Long extends BSONValue {
      get _bsontype() {
        return "Long";
      }
      get __isLong__() {
        return true;
      }
      constructor(lowOrValue = 0, highOrUnsigned, unsigned) {
        super();
        const unsignedBool = typeof highOrUnsigned === "boolean" ? highOrUnsigned : Boolean(unsigned);
        const high = typeof highOrUnsigned === "number" ? highOrUnsigned : 0;
        const res = typeof lowOrValue === "string" ? _Long.fromString(lowOrValue, unsignedBool) : typeof lowOrValue === "bigint" ? _Long.fromBigInt(lowOrValue, unsignedBool) : { low: lowOrValue | 0, high: high | 0, unsigned: unsignedBool };
        this.low = res.low;
        this.high = res.high;
        this.unsigned = res.unsigned;
      }
      static fromBits(lowBits, highBits, unsigned) {
        return new _Long(lowBits, highBits, unsigned);
      }
      static fromInt(value, unsigned) {
        let obj, cachedObj, cache;
        if (unsigned) {
          value >>>= 0;
          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = _Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache)
            UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = _Long.fromBits(value, value < 0 ? -1 : 0, false);
          if (cache)
            INT_CACHE[value] = obj;
          return obj;
        }
      }
      static fromNumber(value, unsigned) {
        if (isNaN(value))
          return unsigned ? _Long.UZERO : _Long.ZERO;
        if (unsigned) {
          if (value < 0)
            return _Long.UZERO;
          if (value >= TWO_PWR_64_DBL)
            return _Long.MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -9223372036854776e3)
            return _Long.MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
            return _Long.MAX_VALUE;
        }
        if (value < 0)
          return _Long.fromNumber(-value, unsigned).neg();
        return _Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      static fromBigInt(value, unsigned) {
        const FROM_BIGINT_BIT_MASK = BigInt(4294967295);
        const FROM_BIGINT_BIT_SHIFT = BigInt(32);
        return new _Long(Number(value & FROM_BIGINT_BIT_MASK), Number(value >> FROM_BIGINT_BIT_SHIFT & FROM_BIGINT_BIT_MASK), unsigned);
      }
      static _fromString(str, unsigned, radix) {
        if (str.length === 0)
          throw new BSONError("empty string");
        if (radix < 2 || 36 < radix)
          throw new BSONError("radix");
        let p;
        if ((p = str.indexOf("-")) > 0)
          throw new BSONError("interior hyphen");
        else if (p === 0) {
          return _Long._fromString(str.substring(1), unsigned, radix).neg();
        }
        const radixToPower = _Long.fromNumber(Math.pow(radix, 8));
        let result = _Long.ZERO;
        for (let i = 0; i < str.length; i += 8) {
          const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
          if (size < 8) {
            const power = _Long.fromNumber(Math.pow(radix, size));
            result = result.mul(power).add(_Long.fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(_Long.fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      static fromStringStrict(str, unsignedOrRadix, radix) {
        let unsigned = false;
        if (typeof unsignedOrRadix === "number") {
          radix = unsignedOrRadix, unsignedOrRadix = false;
        } else {
          unsigned = !!unsignedOrRadix;
        }
        radix ??= 10;
        if (str.trim() !== str) {
          throw new BSONError(`Input: '${str}' contains leading and/or trailing whitespace`);
        }
        if (!validateStringCharacters(str, radix)) {
          throw new BSONError(`Input: '${str}' contains invalid characters for radix: ${radix}`);
        }
        const cleanedStr = removeLeadingZerosAndExplicitPlus(str);
        const result = _Long._fromString(cleanedStr, unsigned, radix);
        if (result.toString(radix).toLowerCase() !== cleanedStr.toLowerCase()) {
          throw new BSONError(`Input: ${str} is not representable as ${result.unsigned ? "an unsigned" : "a signed"} 64-bit Long ${radix != null ? `with radix: ${radix}` : ""}`);
        }
        return result;
      }
      static fromString(str, unsignedOrRadix, radix) {
        let unsigned = false;
        if (typeof unsignedOrRadix === "number") {
          radix = unsignedOrRadix, unsignedOrRadix = false;
        } else {
          unsigned = !!unsignedOrRadix;
        }
        radix ??= 10;
        if (str === "NaN" && radix < 24) {
          return _Long.ZERO;
        } else if ((str === "Infinity" || str === "+Infinity" || str === "-Infinity") && radix < 35) {
          return _Long.ZERO;
        }
        return _Long._fromString(str, unsigned, radix);
      }
      static fromBytes(bytes, unsigned, le) {
        return le ? _Long.fromBytesLE(bytes, unsigned) : _Long.fromBytesBE(bytes, unsigned);
      }
      static fromBytesLE(bytes, unsigned) {
        return new _Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
      }
      static fromBytesBE(bytes, unsigned) {
        return new _Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
      }
      static isLong(value) {
        return value != null && typeof value === "object" && "__isLong__" in value && value.__isLong__ === true;
      }
      static fromValue(val, unsigned) {
        if (typeof val === "number")
          return _Long.fromNumber(val, unsigned);
        if (typeof val === "string")
          return _Long.fromString(val, unsigned);
        return _Long.fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      add(addend) {
        if (!_Long.isLong(addend))
          addend = _Long.fromValue(addend);
        const a48 = this.high >>> 16;
        const a32 = this.high & 65535;
        const a16 = this.low >>> 16;
        const a00 = this.low & 65535;
        const b48 = addend.high >>> 16;
        const b32 = addend.high & 65535;
        const b16 = addend.low >>> 16;
        const b00 = addend.low & 65535;
        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return _Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      }
      and(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        return _Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      }
      compare(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        if (this.eq(other))
          return 0;
        const thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      }
      comp(other) {
        return this.compare(other);
      }
      divide(divisor) {
        if (!_Long.isLong(divisor))
          divisor = _Long.fromValue(divisor);
        if (divisor.isZero())
          throw new BSONError("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
          return _Long.fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (this.isZero())
          return this.unsigned ? _Long.UZERO : _Long.ZERO;
        let approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(_Long.MIN_VALUE)) {
            if (divisor.eq(_Long.ONE) || divisor.eq(_Long.NEG_ONE))
              return _Long.MIN_VALUE;
            else if (divisor.eq(_Long.MIN_VALUE))
              return _Long.ONE;
            else {
              const halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(_Long.ZERO)) {
                return divisor.isNegative() ? _Long.ONE : _Long.NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(_Long.MIN_VALUE))
            return this.unsigned ? _Long.UZERO : _Long.ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = _Long.ZERO;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return _Long.UZERO;
          if (divisor.gt(this.shru(1)))
            return _Long.UONE;
          res = _Long.UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          const log2 = Math.ceil(Math.log(approx) / Math.LN2);
          const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
          let approxRes = _Long.fromNumber(approx);
          let approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = _Long.fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = _Long.ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      }
      div(divisor) {
        return this.divide(divisor);
      }
      equals(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      }
      eq(other) {
        return this.equals(other);
      }
      getHighBits() {
        return this.high;
      }
      getHighBitsUnsigned() {
        return this.high >>> 0;
      }
      getLowBits() {
        return this.low;
      }
      getLowBitsUnsigned() {
        return this.low >>> 0;
      }
      getNumBitsAbs() {
        if (this.isNegative()) {
          return this.eq(_Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        }
        const val = this.high !== 0 ? this.high : this.low;
        let bit;
        for (bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) !== 0)
            break;
        return this.high !== 0 ? bit + 33 : bit + 1;
      }
      greaterThan(other) {
        return this.comp(other) > 0;
      }
      gt(other) {
        return this.greaterThan(other);
      }
      greaterThanOrEqual(other) {
        return this.comp(other) >= 0;
      }
      gte(other) {
        return this.greaterThanOrEqual(other);
      }
      ge(other) {
        return this.greaterThanOrEqual(other);
      }
      isEven() {
        return (this.low & 1) === 0;
      }
      isNegative() {
        return !this.unsigned && this.high < 0;
      }
      isOdd() {
        return (this.low & 1) === 1;
      }
      isPositive() {
        return this.unsigned || this.high >= 0;
      }
      isZero() {
        return this.high === 0 && this.low === 0;
      }
      lessThan(other) {
        return this.comp(other) < 0;
      }
      lt(other) {
        return this.lessThan(other);
      }
      lessThanOrEqual(other) {
        return this.comp(other) <= 0;
      }
      lte(other) {
        return this.lessThanOrEqual(other);
      }
      modulo(divisor) {
        if (!_Long.isLong(divisor))
          divisor = _Long.fromValue(divisor);
        if (wasm) {
          const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
          return _Long.fromBits(low, wasm.get_high(), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      }
      mod(divisor) {
        return this.modulo(divisor);
      }
      rem(divisor) {
        return this.modulo(divisor);
      }
      multiply(multiplier) {
        if (this.isZero())
          return _Long.ZERO;
        if (!_Long.isLong(multiplier))
          multiplier = _Long.fromValue(multiplier);
        if (wasm) {
          const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
          return _Long.fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (multiplier.isZero())
          return _Long.ZERO;
        if (this.eq(_Long.MIN_VALUE))
          return multiplier.isOdd() ? _Long.MIN_VALUE : _Long.ZERO;
        if (multiplier.eq(_Long.MIN_VALUE))
          return this.isOdd() ? _Long.MIN_VALUE : _Long.ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(_Long.TWO_PWR_24) && multiplier.lt(_Long.TWO_PWR_24))
          return _Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        const a48 = this.high >>> 16;
        const a32 = this.high & 65535;
        const a16 = this.low >>> 16;
        const a00 = this.low & 65535;
        const b48 = multiplier.high >>> 16;
        const b32 = multiplier.high & 65535;
        const b16 = multiplier.low >>> 16;
        const b00 = multiplier.low & 65535;
        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return _Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      }
      mul(multiplier) {
        return this.multiply(multiplier);
      }
      negate() {
        if (!this.unsigned && this.eq(_Long.MIN_VALUE))
          return _Long.MIN_VALUE;
        return this.not().add(_Long.ONE);
      }
      neg() {
        return this.negate();
      }
      not() {
        return _Long.fromBits(~this.low, ~this.high, this.unsigned);
      }
      notEquals(other) {
        return !this.equals(other);
      }
      neq(other) {
        return this.notEquals(other);
      }
      ne(other) {
        return this.notEquals(other);
      }
      or(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        return _Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      }
      shiftLeft(numBits) {
        if (_Long.isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return _Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return _Long.fromBits(0, this.low << numBits - 32, this.unsigned);
      }
      shl(numBits) {
        return this.shiftLeft(numBits);
      }
      shiftRight(numBits) {
        if (_Long.isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return _Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return _Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      }
      shr(numBits) {
        return this.shiftRight(numBits);
      }
      shiftRightUnsigned(numBits) {
        if (_Long.isLong(numBits))
          numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
          return this;
        else {
          const high = this.high;
          if (numBits < 32) {
            const low = this.low;
            return _Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32)
            return _Long.fromBits(high, 0, this.unsigned);
          else
            return _Long.fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
      }
      shr_u(numBits) {
        return this.shiftRightUnsigned(numBits);
      }
      shru(numBits) {
        return this.shiftRightUnsigned(numBits);
      }
      subtract(subtrahend) {
        if (!_Long.isLong(subtrahend))
          subtrahend = _Long.fromValue(subtrahend);
        return this.add(subtrahend.neg());
      }
      sub(subtrahend) {
        return this.subtract(subtrahend);
      }
      toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      }
      toNumber() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      }
      toBigInt() {
        return BigInt(this.toString());
      }
      toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      }
      toBytesLE() {
        const hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24
        ];
      }
      toBytesBE() {
        const hi = this.high, lo = this.low;
        return [
          hi >>> 24,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      }
      toSigned() {
        if (!this.unsigned)
          return this;
        return _Long.fromBits(this.low, this.high, false);
      }
      toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw new BSONError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(_Long.MIN_VALUE)) {
            const radixLong = _Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        const radixToPower = _Long.fromNumber(Math.pow(radix, 6), this.unsigned);
        let rem = this;
        let result = "";
        while (true) {
          const remDiv = rem.div(radixToPower);
          const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
          let digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero()) {
            return digits + result;
          } else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      }
      toUnsigned() {
        if (this.unsigned)
          return this;
        return _Long.fromBits(this.low, this.high, true);
      }
      xor(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        return _Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      }
      eqz() {
        return this.isZero();
      }
      le(other) {
        return this.lessThanOrEqual(other);
      }
      toExtendedJSON(options2) {
        if (options2 && options2.relaxed)
          return this.toNumber();
        return { $numberLong: this.toString() };
      }
      static fromExtendedJSON(doc, options2) {
        const { useBigInt64 = false, relaxed = true } = { ...options2 };
        if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {
          throw new BSONError("$numberLong string is too long");
        }
        if (!DECIMAL_REG_EX.test(doc.$numberLong)) {
          throw new BSONError(`$numberLong string "${doc.$numberLong}" is in an invalid format`);
        }
        if (useBigInt64) {
          const bigIntResult = BigInt(doc.$numberLong);
          return BigInt.asIntN(64, bigIntResult);
        }
        const longResult = _Long.fromString(doc.$numberLong);
        if (relaxed) {
          return longResult.toNumber();
        }
        return longResult;
      }
      inspect(depth, options2, inspect) {
        inspect ??= defaultInspect;
        const longVal = inspect(this.toString(), options2);
        const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options2)}` : "";
        return `new Long(${longVal}${unsignedVal})`;
      }
    };
    Long.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);
    Long.MAX_UNSIGNED_VALUE = Long.fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long.ZERO = Long.fromInt(0);
    Long.UZERO = Long.fromInt(0, true);
    Long.ONE = Long.fromInt(1);
    Long.UONE = Long.fromInt(1, true);
    Long.NEG_ONE = Long.fromInt(-1);
    Long.MAX_VALUE = Long.fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long.MIN_VALUE = Long.fromBits(0, 2147483648 | 0, false);
    var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
    var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
    var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
    var EXPONENT_MAX = 6111;
    var EXPONENT_MIN = -6176;
    var EXPONENT_BIAS = 6176;
    var MAX_DIGITS = 34;
    var NAN_BUFFER = ByteUtils.fromNumberArray([
      124,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse());
    var INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([
      248,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse());
    var INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([
      120,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse());
    var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
    var COMBINATION_MASK = 31;
    var EXPONENT_MASK = 16383;
    var COMBINATION_INFINITY = 30;
    var COMBINATION_NAN = 31;
    function isDigit(value) {
      return !isNaN(parseInt(value, 10));
    }
    function divideu128(value) {
      const DIVISOR = Long.fromNumber(1e3 * 1e3 * 1e3);
      let _rem = Long.fromNumber(0);
      if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
        return { quotient: value, rem: _rem };
      }
      for (let i = 0; i <= 3; i++) {
        _rem = _rem.shiftLeft(32);
        _rem = _rem.add(new Long(value.parts[i], 0));
        value.parts[i] = _rem.div(DIVISOR).low;
        _rem = _rem.modulo(DIVISOR);
      }
      return { quotient: value, rem: _rem };
    }
    function multiply64x2(left, right) {
      if (!left && !right) {
        return { high: Long.fromNumber(0), low: Long.fromNumber(0) };
      }
      const leftHigh = left.shiftRightUnsigned(32);
      const leftLow = new Long(left.getLowBits(), 0);
      const rightHigh = right.shiftRightUnsigned(32);
      const rightLow = new Long(right.getLowBits(), 0);
      let productHigh = leftHigh.multiply(rightHigh);
      let productMid = leftHigh.multiply(rightLow);
      const productMid2 = leftLow.multiply(rightHigh);
      let productLow = leftLow.multiply(rightLow);
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));
      return { high: productHigh, low: productLow };
    }
    function lessThan(left, right) {
      const uhleft = left.high >>> 0;
      const uhright = right.high >>> 0;
      if (uhleft < uhright) {
        return true;
      } else if (uhleft === uhright) {
        const ulleft = left.low >>> 0;
        const ulright = right.low >>> 0;
        if (ulleft < ulright)
          return true;
      }
      return false;
    }
    function invalidErr(string, message) {
      throw new BSONError(`"${string}" is not a valid Decimal128 string - ${message}`);
    }
    var Decimal128 = class _Decimal128 extends BSONValue {
      get _bsontype() {
        return "Decimal128";
      }
      constructor(bytes) {
        super();
        if (typeof bytes === "string") {
          this.bytes = _Decimal128.fromString(bytes).bytes;
        } else if (bytes instanceof Uint8Array || isUint8Array(bytes)) {
          if (bytes.byteLength !== 16) {
            throw new BSONError("Decimal128 must take a Buffer of 16 bytes");
          }
          this.bytes = bytes;
        } else {
          throw new BSONError("Decimal128 must take a Buffer or string");
        }
      }
      static fromString(representation) {
        return _Decimal128._fromString(representation, { allowRounding: false });
      }
      static fromStringWithRounding(representation) {
        return _Decimal128._fromString(representation, { allowRounding: true });
      }
      static _fromString(representation, options2) {
        let isNegative = false;
        let sawSign = false;
        let sawRadix = false;
        let foundNonZero = false;
        let significantDigits = 0;
        let nDigitsRead = 0;
        let nDigits = 0;
        let radixPosition = 0;
        let firstNonZero = 0;
        const digits = [0];
        let nDigitsStored = 0;
        let digitsInsert = 0;
        let lastDigit = 0;
        let exponent = 0;
        let significandHigh = new Long(0, 0);
        let significandLow = new Long(0, 0);
        let biasedExponent = 0;
        let index = 0;
        if (representation.length >= 7e3) {
          throw new BSONError("" + representation + " not a valid Decimal128 string");
        }
        const stringMatch = representation.match(PARSE_STRING_REGEXP);
        const infMatch = representation.match(PARSE_INF_REGEXP);
        const nanMatch = representation.match(PARSE_NAN_REGEXP);
        if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
          throw new BSONError("" + representation + " not a valid Decimal128 string");
        }
        if (stringMatch) {
          const unsignedNumber = stringMatch[2];
          const e = stringMatch[4];
          const expSign = stringMatch[5];
          const expNumber = stringMatch[6];
          if (e && expNumber === void 0)
            invalidErr(representation, "missing exponent power");
          if (e && unsignedNumber === void 0)
            invalidErr(representation, "missing exponent base");
          if (e === void 0 && (expSign || expNumber)) {
            invalidErr(representation, "missing e before exponent");
          }
        }
        if (representation[index] === "+" || representation[index] === "-") {
          sawSign = true;
          isNegative = representation[index++] === "-";
        }
        if (!isDigit(representation[index]) && representation[index] !== ".") {
          if (representation[index] === "i" || representation[index] === "I") {
            return new _Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
          } else if (representation[index] === "N") {
            return new _Decimal128(NAN_BUFFER);
          }
        }
        while (isDigit(representation[index]) || representation[index] === ".") {
          if (representation[index] === ".") {
            if (sawRadix)
              invalidErr(representation, "contains multiple periods");
            sawRadix = true;
            index = index + 1;
            continue;
          }
          if (nDigitsStored < MAX_DIGITS) {
            if (representation[index] !== "0" || foundNonZero) {
              if (!foundNonZero) {
                firstNonZero = nDigitsRead;
              }
              foundNonZero = true;
              digits[digitsInsert++] = parseInt(representation[index], 10);
              nDigitsStored = nDigitsStored + 1;
            }
          }
          if (foundNonZero)
            nDigits = nDigits + 1;
          if (sawRadix)
            radixPosition = radixPosition + 1;
          nDigitsRead = nDigitsRead + 1;
          index = index + 1;
        }
        if (sawRadix && !nDigitsRead)
          throw new BSONError("" + representation + " not a valid Decimal128 string");
        if (representation[index] === "e" || representation[index] === "E") {
          const match = representation.substr(++index).match(EXPONENT_REGEX);
          if (!match || !match[2])
            return new _Decimal128(NAN_BUFFER);
          exponent = parseInt(match[0], 10);
          index = index + match[0].length;
        }
        if (representation[index])
          return new _Decimal128(NAN_BUFFER);
        if (!nDigitsStored) {
          digits[0] = 0;
          nDigits = 1;
          nDigitsStored = 1;
          significantDigits = 0;
        } else {
          lastDigit = nDigitsStored - 1;
          significantDigits = nDigits;
          if (significantDigits !== 1) {
            while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === "0") {
              significantDigits = significantDigits - 1;
            }
          }
        }
        if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {
          exponent = EXPONENT_MIN;
        } else {
          exponent = exponent - radixPosition;
        }
        while (exponent > EXPONENT_MAX) {
          lastDigit = lastDigit + 1;
          if (lastDigit >= MAX_DIGITS) {
            if (significantDigits === 0) {
              exponent = EXPONENT_MAX;
              break;
            }
            invalidErr(representation, "overflow");
          }
          exponent = exponent - 1;
        }
        if (options2.allowRounding) {
          while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
            if (lastDigit === 0 && significantDigits < nDigitsStored) {
              exponent = EXPONENT_MIN;
              significantDigits = 0;
              break;
            }
            if (nDigitsStored < nDigits) {
              nDigits = nDigits - 1;
            } else {
              lastDigit = lastDigit - 1;
            }
            if (exponent < EXPONENT_MAX) {
              exponent = exponent + 1;
            } else {
              const digitsString = digits.join("");
              if (digitsString.match(/^0+$/)) {
                exponent = EXPONENT_MAX;
                break;
              }
              invalidErr(representation, "overflow");
            }
          }
          if (lastDigit + 1 < significantDigits) {
            let endOfString = nDigitsRead;
            if (sawRadix) {
              firstNonZero = firstNonZero + 1;
              endOfString = endOfString + 1;
            }
            if (sawSign) {
              firstNonZero = firstNonZero + 1;
              endOfString = endOfString + 1;
            }
            const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
            let roundBit = 0;
            if (roundDigit >= 5) {
              roundBit = 1;
              if (roundDigit === 5) {
                roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
                for (let i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
                  if (parseInt(representation[i], 10)) {
                    roundBit = 1;
                    break;
                  }
                }
              }
            }
            if (roundBit) {
              let dIdx = lastDigit;
              for (; dIdx >= 0; dIdx--) {
                if (++digits[dIdx] > 9) {
                  digits[dIdx] = 0;
                  if (dIdx === 0) {
                    if (exponent < EXPONENT_MAX) {
                      exponent = exponent + 1;
                      digits[dIdx] = 1;
                    } else {
                      return new _Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
                    }
                  }
                } else {
                  break;
                }
              }
            }
          }
        } else {
          while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
            if (lastDigit === 0) {
              if (significantDigits === 0) {
                exponent = EXPONENT_MIN;
                break;
              }
              invalidErr(representation, "exponent underflow");
            }
            if (nDigitsStored < nDigits) {
              if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== "0" && significantDigits !== 0) {
                invalidErr(representation, "inexact rounding");
              }
              nDigits = nDigits - 1;
            } else {
              if (digits[lastDigit] !== 0) {
                invalidErr(representation, "inexact rounding");
              }
              lastDigit = lastDigit - 1;
            }
            if (exponent < EXPONENT_MAX) {
              exponent = exponent + 1;
            } else {
              invalidErr(representation, "overflow");
            }
          }
          if (lastDigit + 1 < significantDigits) {
            if (sawRadix) {
              firstNonZero = firstNonZero + 1;
            }
            if (sawSign) {
              firstNonZero = firstNonZero + 1;
            }
            const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
            if (roundDigit !== 0) {
              invalidErr(representation, "inexact rounding");
            }
          }
        }
        significandHigh = Long.fromNumber(0);
        significandLow = Long.fromNumber(0);
        if (significantDigits === 0) {
          significandHigh = Long.fromNumber(0);
          significandLow = Long.fromNumber(0);
        } else if (lastDigit < 17) {
          let dIdx = 0;
          significandLow = Long.fromNumber(digits[dIdx++]);
          significandHigh = new Long(0, 0);
          for (; dIdx <= lastDigit; dIdx++) {
            significandLow = significandLow.multiply(Long.fromNumber(10));
            significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
          }
        } else {
          let dIdx = 0;
          significandHigh = Long.fromNumber(digits[dIdx++]);
          for (; dIdx <= lastDigit - 17; dIdx++) {
            significandHigh = significandHigh.multiply(Long.fromNumber(10));
            significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));
          }
          significandLow = Long.fromNumber(digits[dIdx++]);
          for (; dIdx <= lastDigit; dIdx++) {
            significandLow = significandLow.multiply(Long.fromNumber(10));
            significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
          }
        }
        const significand = multiply64x2(significandHigh, Long.fromString("100000000000000000"));
        significand.low = significand.low.add(significandLow);
        if (lessThan(significand.low, significandLow)) {
          significand.high = significand.high.add(Long.fromNumber(1));
        }
        biasedExponent = exponent + EXPONENT_BIAS;
        const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };
        if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {
          dec.high = dec.high.or(Long.fromNumber(3).shiftLeft(61));
          dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(16383).shiftLeft(47)));
          dec.high = dec.high.or(significand.high.and(Long.fromNumber(140737488355327)));
        } else {
          dec.high = dec.high.or(Long.fromNumber(biasedExponent & 16383).shiftLeft(49));
          dec.high = dec.high.or(significand.high.and(Long.fromNumber(562949953421311)));
        }
        dec.low = significand.low;
        if (isNegative) {
          dec.high = dec.high.or(Long.fromString("9223372036854775808"));
        }
        const buffer2 = ByteUtils.allocateUnsafe(16);
        index = 0;
        buffer2[index++] = dec.low.low & 255;
        buffer2[index++] = dec.low.low >> 8 & 255;
        buffer2[index++] = dec.low.low >> 16 & 255;
        buffer2[index++] = dec.low.low >> 24 & 255;
        buffer2[index++] = dec.low.high & 255;
        buffer2[index++] = dec.low.high >> 8 & 255;
        buffer2[index++] = dec.low.high >> 16 & 255;
        buffer2[index++] = dec.low.high >> 24 & 255;
        buffer2[index++] = dec.high.low & 255;
        buffer2[index++] = dec.high.low >> 8 & 255;
        buffer2[index++] = dec.high.low >> 16 & 255;
        buffer2[index++] = dec.high.low >> 24 & 255;
        buffer2[index++] = dec.high.high & 255;
        buffer2[index++] = dec.high.high >> 8 & 255;
        buffer2[index++] = dec.high.high >> 16 & 255;
        buffer2[index++] = dec.high.high >> 24 & 255;
        return new _Decimal128(buffer2);
      }
      toString() {
        let biased_exponent;
        let significand_digits = 0;
        const significand = new Array(36);
        for (let i = 0; i < significand.length; i++)
          significand[i] = 0;
        let index = 0;
        let is_zero = false;
        let significand_msb;
        let significand128 = { parts: [0, 0, 0, 0] };
        let j, k;
        const string = [];
        index = 0;
        const buffer2 = this.bytes;
        const low = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const midl = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const midh = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const high = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        index = 0;
        const dec = {
          low: new Long(low, midl),
          high: new Long(midh, high)
        };
        if (dec.high.lessThan(Long.ZERO)) {
          string.push("-");
        }
        const combination = high >> 26 & COMBINATION_MASK;
        if (combination >> 3 === 3) {
          if (combination === COMBINATION_INFINITY) {
            return string.join("") + "Infinity";
          } else if (combination === COMBINATION_NAN) {
            return "NaN";
          } else {
            biased_exponent = high >> 15 & EXPONENT_MASK;
            significand_msb = 8 + (high >> 14 & 1);
          }
        } else {
          significand_msb = high >> 14 & 7;
          biased_exponent = high >> 17 & EXPONENT_MASK;
        }
        const exponent = biased_exponent - EXPONENT_BIAS;
        significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
        significand128.parts[1] = midh;
        significand128.parts[2] = midl;
        significand128.parts[3] = low;
        if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
          is_zero = true;
        } else {
          for (k = 3; k >= 0; k--) {
            let least_digits = 0;
            const result = divideu128(significand128);
            significand128 = result.quotient;
            least_digits = result.rem.low;
            if (!least_digits)
              continue;
            for (j = 8; j >= 0; j--) {
              significand[k * 9 + j] = least_digits % 10;
              least_digits = Math.floor(least_digits / 10);
            }
          }
        }
        if (is_zero) {
          significand_digits = 1;
          significand[index] = 0;
        } else {
          significand_digits = 36;
          while (!significand[index]) {
            significand_digits = significand_digits - 1;
            index = index + 1;
          }
        }
        const scientific_exponent = significand_digits - 1 + exponent;
        if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
          if (significand_digits > 34) {
            string.push(`${0}`);
            if (exponent > 0)
              string.push(`E+${exponent}`);
            else if (exponent < 0)
              string.push(`E${exponent}`);
            return string.join("");
          }
          string.push(`${significand[index++]}`);
          significand_digits = significand_digits - 1;
          if (significand_digits) {
            string.push(".");
          }
          for (let i = 0; i < significand_digits; i++) {
            string.push(`${significand[index++]}`);
          }
          string.push("E");
          if (scientific_exponent > 0) {
            string.push(`+${scientific_exponent}`);
          } else {
            string.push(`${scientific_exponent}`);
          }
        } else {
          if (exponent >= 0) {
            for (let i = 0; i < significand_digits; i++) {
              string.push(`${significand[index++]}`);
            }
          } else {
            let radix_position = significand_digits + exponent;
            if (radix_position > 0) {
              for (let i = 0; i < radix_position; i++) {
                string.push(`${significand[index++]}`);
              }
            } else {
              string.push("0");
            }
            string.push(".");
            while (radix_position++ < 0) {
              string.push("0");
            }
            for (let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
              string.push(`${significand[index++]}`);
            }
          }
        }
        return string.join("");
      }
      toJSON() {
        return { $numberDecimal: this.toString() };
      }
      toExtendedJSON() {
        return { $numberDecimal: this.toString() };
      }
      static fromExtendedJSON(doc) {
        return _Decimal128.fromString(doc.$numberDecimal);
      }
      inspect(depth, options2, inspect) {
        inspect ??= defaultInspect;
        const d128string = inspect(this.toString(), options2);
        return `new Decimal128(${d128string})`;
      }
    };
    var Double = class _Double extends BSONValue {
      get _bsontype() {
        return "Double";
      }
      constructor(value) {
        super();
        if (value instanceof Number) {
          value = value.valueOf();
        }
        this.value = +value;
      }
      static fromString(value) {
        const coercedValue = Number(value);
        if (value === "NaN")
          return new _Double(NaN);
        if (value === "Infinity")
          return new _Double(Infinity);
        if (value === "-Infinity")
          return new _Double(-Infinity);
        if (!Number.isFinite(coercedValue)) {
          throw new BSONError(`Input: ${value} is not representable as a Double`);
        }
        if (value.trim() !== value) {
          throw new BSONError(`Input: '${value}' contains whitespace`);
        }
        if (value === "") {
          throw new BSONError(`Input is an empty string`);
        }
        if (/[^-0-9.+eE]/.test(value)) {
          throw new BSONError(`Input: '${value}' is not in decimal or exponential notation`);
        }
        return new _Double(coercedValue);
      }
      valueOf() {
        return this.value;
      }
      toJSON() {
        return this.value;
      }
      toString(radix) {
        return this.value.toString(radix);
      }
      toExtendedJSON(options2) {
        if (options2 && (options2.legacy || options2.relaxed && isFinite(this.value))) {
          return this.value;
        }
        if (Object.is(Math.sign(this.value), -0)) {
          return { $numberDouble: "-0.0" };
        }
        return {
          $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
        };
      }
      static fromExtendedJSON(doc, options2) {
        const doubleValue = parseFloat(doc.$numberDouble);
        return options2 && options2.relaxed ? doubleValue : new _Double(doubleValue);
      }
      inspect(depth, options2, inspect) {
        inspect ??= defaultInspect;
        return `new Double(${inspect(this.value, options2)})`;
      }
    };
    var Int32 = class _Int32 extends BSONValue {
      get _bsontype() {
        return "Int32";
      }
      constructor(value) {
        super();
        if (value instanceof Number) {
          value = value.valueOf();
        }
        this.value = +value | 0;
      }
      static fromString(value) {
        const cleanedValue = removeLeadingZerosAndExplicitPlus(value);
        const coercedValue = Number(value);
        if (BSON_INT32_MAX < coercedValue) {
          throw new BSONError(`Input: '${value}' is larger than the maximum value for Int32`);
        } else if (BSON_INT32_MIN > coercedValue) {
          throw new BSONError(`Input: '${value}' is smaller than the minimum value for Int32`);
        } else if (!Number.isSafeInteger(coercedValue)) {
          throw new BSONError(`Input: '${value}' is not a safe integer`);
        } else if (coercedValue.toString() !== cleanedValue) {
          throw new BSONError(`Input: '${value}' is not a valid Int32 string`);
        }
        return new _Int32(coercedValue);
      }
      valueOf() {
        return this.value;
      }
      toString(radix) {
        return this.value.toString(radix);
      }
      toJSON() {
        return this.value;
      }
      toExtendedJSON(options2) {
        if (options2 && (options2.relaxed || options2.legacy))
          return this.value;
        return { $numberInt: this.value.toString() };
      }
      static fromExtendedJSON(doc, options2) {
        return options2 && options2.relaxed ? parseInt(doc.$numberInt, 10) : new _Int32(doc.$numberInt);
      }
      inspect(depth, options2, inspect) {
        inspect ??= defaultInspect;
        return `new Int32(${inspect(this.value, options2)})`;
      }
    };
    var MaxKey = class _MaxKey extends BSONValue {
      get _bsontype() {
        return "MaxKey";
      }
      toExtendedJSON() {
        return { $maxKey: 1 };
      }
      static fromExtendedJSON() {
        return new _MaxKey();
      }
      inspect() {
        return "new MaxKey()";
      }
    };
    var MinKey = class _MinKey extends BSONValue {
      get _bsontype() {
        return "MinKey";
      }
      toExtendedJSON() {
        return { $minKey: 1 };
      }
      static fromExtendedJSON() {
        return new _MinKey();
      }
      inspect() {
        return "new MinKey()";
      }
    };
    var PROCESS_UNIQUE = null;
    var __idCache = /* @__PURE__ */ new WeakMap();
    var ObjectId = class _ObjectId extends BSONValue {
      get _bsontype() {
        return "ObjectId";
      }
      constructor(inputId) {
        super();
        let workingId;
        if (typeof inputId === "object" && inputId && "id" in inputId) {
          if (typeof inputId.id !== "string" && !ArrayBuffer.isView(inputId.id)) {
            throw new BSONError("Argument passed in must have an id that is of type string or Buffer");
          }
          if ("toHexString" in inputId && typeof inputId.toHexString === "function") {
            workingId = ByteUtils.fromHex(inputId.toHexString());
          } else {
            workingId = inputId.id;
          }
        } else {
          workingId = inputId;
        }
        if (workingId == null || typeof workingId === "number") {
          this.buffer = _ObjectId.generate(typeof workingId === "number" ? workingId : void 0);
        } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
          this.buffer = ByteUtils.toLocalBufferType(workingId);
        } else if (typeof workingId === "string") {
          if (_ObjectId.validateHexString(workingId)) {
            this.buffer = ByteUtils.fromHex(workingId);
            if (_ObjectId.cacheHexString) {
              __idCache.set(this, workingId);
            }
          } else {
            throw new BSONError("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");
          }
        } else {
          throw new BSONError("Argument passed in does not match the accepted types");
        }
      }
      get id() {
        return this.buffer;
      }
      set id(value) {
        this.buffer = value;
        if (_ObjectId.cacheHexString) {
          __idCache.set(this, ByteUtils.toHex(value));
        }
      }
      static validateHexString(string) {
        if (string?.length !== 24)
          return false;
        for (let i = 0; i < 24; i++) {
          const char = string.charCodeAt(i);
          if (char >= 48 && char <= 57 || char >= 97 && char <= 102 || char >= 65 && char <= 70) {
            continue;
          }
          return false;
        }
        return true;
      }
      toHexString() {
        if (_ObjectId.cacheHexString) {
          const __id = __idCache.get(this);
          if (__id)
            return __id;
        }
        const hexString = ByteUtils.toHex(this.id);
        if (_ObjectId.cacheHexString) {
          __idCache.set(this, hexString);
        }
        return hexString;
      }
      static getInc() {
        return _ObjectId.index = (_ObjectId.index + 1) % 16777215;
      }
      static generate(time) {
        if ("number" !== typeof time) {
          time = Math.floor(Date.now() / 1e3);
        }
        const inc = _ObjectId.getInc();
        const buffer2 = ByteUtils.allocateUnsafe(12);
        NumberUtils.setInt32BE(buffer2, 0, time);
        if (PROCESS_UNIQUE === null) {
          PROCESS_UNIQUE = ByteUtils.randomBytes(5);
        }
        buffer2[4] = PROCESS_UNIQUE[0];
        buffer2[5] = PROCESS_UNIQUE[1];
        buffer2[6] = PROCESS_UNIQUE[2];
        buffer2[7] = PROCESS_UNIQUE[3];
        buffer2[8] = PROCESS_UNIQUE[4];
        buffer2[11] = inc & 255;
        buffer2[10] = inc >> 8 & 255;
        buffer2[9] = inc >> 16 & 255;
        return buffer2;
      }
      toString(encoding) {
        if (encoding === "base64")
          return ByteUtils.toBase64(this.id);
        if (encoding === "hex")
          return this.toHexString();
        return this.toHexString();
      }
      toJSON() {
        return this.toHexString();
      }
      static is(variable) {
        return variable != null && typeof variable === "object" && "_bsontype" in variable && variable._bsontype === "ObjectId";
      }
      equals(otherId) {
        if (otherId === void 0 || otherId === null) {
          return false;
        }
        if (_ObjectId.is(otherId)) {
          return this.buffer[11] === otherId.buffer[11] && ByteUtils.equals(this.buffer, otherId.buffer);
        }
        if (typeof otherId === "string") {
          return otherId.toLowerCase() === this.toHexString();
        }
        if (typeof otherId === "object" && typeof otherId.toHexString === "function") {
          const otherIdString = otherId.toHexString();
          const thisIdString = this.toHexString();
          return typeof otherIdString === "string" && otherIdString.toLowerCase() === thisIdString;
        }
        return false;
      }
      getTimestamp() {
        const timestamp = /* @__PURE__ */ new Date();
        const time = NumberUtils.getUint32BE(this.buffer, 0);
        timestamp.setTime(Math.floor(time) * 1e3);
        return timestamp;
      }
      static createPk() {
        return new _ObjectId();
      }
      serializeInto(uint8array, index) {
        uint8array[index] = this.buffer[0];
        uint8array[index + 1] = this.buffer[1];
        uint8array[index + 2] = this.buffer[2];
        uint8array[index + 3] = this.buffer[3];
        uint8array[index + 4] = this.buffer[4];
        uint8array[index + 5] = this.buffer[5];
        uint8array[index + 6] = this.buffer[6];
        uint8array[index + 7] = this.buffer[7];
        uint8array[index + 8] = this.buffer[8];
        uint8array[index + 9] = this.buffer[9];
        uint8array[index + 10] = this.buffer[10];
        uint8array[index + 11] = this.buffer[11];
        return 12;
      }
      static createFromTime(time) {
        const buffer2 = ByteUtils.allocate(12);
        for (let i = 11; i >= 4; i--)
          buffer2[i] = 0;
        NumberUtils.setInt32BE(buffer2, 0, time);
        return new _ObjectId(buffer2);
      }
      static createFromHexString(hexString) {
        if (hexString?.length !== 24) {
          throw new BSONError("hex string must be 24 characters");
        }
        return new _ObjectId(ByteUtils.fromHex(hexString));
      }
      static createFromBase64(base64) {
        if (base64?.length !== 16) {
          throw new BSONError("base64 string must be 16 characters");
        }
        return new _ObjectId(ByteUtils.fromBase64(base64));
      }
      static isValid(id) {
        if (id == null)
          return false;
        if (typeof id === "string")
          return _ObjectId.validateHexString(id);
        try {
          new _ObjectId(id);
          return true;
        } catch {
          return false;
        }
      }
      toExtendedJSON() {
        if (this.toHexString)
          return { $oid: this.toHexString() };
        return { $oid: this.toString("hex") };
      }
      static fromExtendedJSON(doc) {
        return new _ObjectId(doc.$oid);
      }
      isCached() {
        return _ObjectId.cacheHexString && __idCache.has(this);
      }
      inspect(depth, options2, inspect) {
        inspect ??= defaultInspect;
        return `new ObjectId(${inspect(this.toHexString(), options2)})`;
      }
    };
    ObjectId.index = Math.floor(Math.random() * 16777215);
    function internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {
      let totalLength = 4 + 1;
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; i++) {
          totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
        }
      } else {
        if (typeof object?.toBSON === "function") {
          object = object.toBSON();
        }
        for (const key of Object.keys(object)) {
          totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
        }
      }
      return totalLength;
    }
    function calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {
      if (typeof value?.toBSON === "function") {
        value = value.toBSON();
      }
      switch (typeof value) {
        case "string":
          return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;
        case "number":
          if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {
            if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);
            } else {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
            }
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
          }
        case "undefined":
          if (isArray || !ignoreUndefined)
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
          return 0;
        case "boolean":
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);
        case "object":
          if (value != null && typeof value._bsontype === "string" && value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
            throw new BSONVersionError();
          } else if (value == null || value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
          } else if (value._bsontype === "ObjectId") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);
          } else if (value instanceof Date || isDate(value)) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
          } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;
          } else if (value._bsontype === "Long" || value._bsontype === "Double" || value._bsontype === "Timestamp") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
          } else if (value._bsontype === "Decimal128") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);
          } else if (value._bsontype === "Code") {
            if (value.scope != null && Object.keys(value.scope).length > 0) {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;
            }
          } else if (value._bsontype === "Binary") {
            const binary = value;
            if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);
            } else {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);
            }
          } else if (value._bsontype === "Symbol") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;
          } else if (value._bsontype === "DBRef") {
            const ordered_values = Object.assign({
              $ref: value.collection,
              $id: value.oid
            }, value.fields);
            if (value.db != null) {
              ordered_values["$db"] = value.db;
            }
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
          } else if (value instanceof RegExp || isRegExp(value)) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else if (value._bsontype === "BSONRegExp") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
          }
        case "function":
          if (serializeFunctions) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;
          }
          return 0;
        case "bigint":
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        case "symbol":
          return 0;
        default:
          throw new BSONError(`Unrecognized JS type: ${typeof value}`);
      }
    }
    function alphabetize(str) {
      return str.split("").sort().join("");
    }
    var BSONRegExp = class _BSONRegExp extends BSONValue {
      get _bsontype() {
        return "BSONRegExp";
      }
      constructor(pattern, options2) {
        super();
        this.pattern = pattern;
        this.options = alphabetize(options2 ?? "");
        if (this.pattern.indexOf("\0") !== -1) {
          throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
        }
        if (this.options.indexOf("\0") !== -1) {
          throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
        }
        for (let i = 0; i < this.options.length; i++) {
          if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
            throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);
          }
        }
      }
      static parseOptions(options2) {
        return options2 ? options2.split("").sort().join("") : "";
      }
      toExtendedJSON(options2) {
        options2 = options2 || {};
        if (options2.legacy) {
          return { $regex: this.pattern, $options: this.options };
        }
        return { $regularExpression: { pattern: this.pattern, options: this.options } };
      }
      static fromExtendedJSON(doc) {
        if ("$regex" in doc) {
          if (typeof doc.$regex !== "string") {
            if (doc.$regex._bsontype === "BSONRegExp") {
              return doc;
            }
          } else {
            return new _BSONRegExp(doc.$regex, _BSONRegExp.parseOptions(doc.$options));
          }
        }
        if ("$regularExpression" in doc) {
          return new _BSONRegExp(doc.$regularExpression.pattern, _BSONRegExp.parseOptions(doc.$regularExpression.options));
        }
        throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);
      }
      inspect(depth, options2, inspect) {
        const stylize = getStylizeFunction(options2) ?? ((v) => v);
        inspect ??= defaultInspect;
        const pattern = stylize(inspect(this.pattern), "regexp");
        const flags = stylize(inspect(this.options), "regexp");
        return `new BSONRegExp(${pattern}, ${flags})`;
      }
    };
    var BSONSymbol = class _BSONSymbol extends BSONValue {
      get _bsontype() {
        return "BSONSymbol";
      }
      constructor(value) {
        super();
        this.value = value;
      }
      valueOf() {
        return this.value;
      }
      toString() {
        return this.value;
      }
      toJSON() {
        return this.value;
      }
      toExtendedJSON() {
        return { $symbol: this.value };
      }
      static fromExtendedJSON(doc) {
        return new _BSONSymbol(doc.$symbol);
      }
      inspect(depth, options2, inspect) {
        inspect ??= defaultInspect;
        return `new BSONSymbol(${inspect(this.value, options2)})`;
      }
    };
    var LongWithoutOverridesClass = Long;
    var Timestamp = class _Timestamp extends LongWithoutOverridesClass {
      get _bsontype() {
        return "Timestamp";
      }
      get i() {
        return this.low >>> 0;
      }
      get t() {
        return this.high >>> 0;
      }
      constructor(low) {
        if (low == null) {
          super(0, 0, true);
        } else if (typeof low === "bigint") {
          super(low, true);
        } else if (Long.isLong(low)) {
          super(low.low, low.high, true);
        } else if (typeof low === "object" && "t" in low && "i" in low) {
          if (typeof low.t !== "number" && (typeof low.t !== "object" || low.t._bsontype !== "Int32")) {
            throw new BSONError("Timestamp constructed from { t, i } must provide t as a number");
          }
          if (typeof low.i !== "number" && (typeof low.i !== "object" || low.i._bsontype !== "Int32")) {
            throw new BSONError("Timestamp constructed from { t, i } must provide i as a number");
          }
          const t = Number(low.t);
          const i = Number(low.i);
          if (t < 0 || Number.isNaN(t)) {
            throw new BSONError("Timestamp constructed from { t, i } must provide a positive t");
          }
          if (i < 0 || Number.isNaN(i)) {
            throw new BSONError("Timestamp constructed from { t, i } must provide a positive i");
          }
          if (t > 4294967295) {
            throw new BSONError("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");
          }
          if (i > 4294967295) {
            throw new BSONError("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");
          }
          super(i, t, true);
        } else {
          throw new BSONError("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");
        }
      }
      toJSON() {
        return {
          $timestamp: this.toString()
        };
      }
      static fromInt(value) {
        return new _Timestamp(Long.fromInt(value, true));
      }
      static fromNumber(value) {
        return new _Timestamp(Long.fromNumber(value, true));
      }
      static fromBits(lowBits, highBits) {
        return new _Timestamp({ i: lowBits, t: highBits });
      }
      static fromString(str, optRadix) {
        return new _Timestamp(Long.fromString(str, true, optRadix));
      }
      toExtendedJSON() {
        return { $timestamp: { t: this.t, i: this.i } };
      }
      static fromExtendedJSON(doc) {
        const i = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;
        const t = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;
        return new _Timestamp({ t, i });
      }
      inspect(depth, options2, inspect) {
        inspect ??= defaultInspect;
        const t = inspect(this.t, options2);
        const i = inspect(this.i, options2);
        return `new Timestamp({ t: ${t}, i: ${i} })`;
      }
    };
    Timestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;
    var JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);
    var JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);
    function internalDeserialize(buffer2, options2, isArray) {
      options2 = options2 == null ? {} : options2;
      const index = options2 && options2.index ? options2.index : 0;
      const size = NumberUtils.getInt32LE(buffer2, index);
      if (size < 5) {
        throw new BSONError(`bson size must be >= 5, is ${size}`);
      }
      if (options2.allowObjectSmallerThanBufferSize && buffer2.length < size) {
        throw new BSONError(`buffer length ${buffer2.length} must be >= bson size ${size}`);
      }
      if (!options2.allowObjectSmallerThanBufferSize && buffer2.length !== size) {
        throw new BSONError(`buffer length ${buffer2.length} must === bson size ${size}`);
      }
      if (size + index > buffer2.byteLength) {
        throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer2.byteLength})`);
      }
      if (buffer2[index + size - 1] !== 0) {
        throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
      }
      return deserializeObject(buffer2, index, options2, isArray);
    }
    var allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
    function deserializeObject(buffer2, index, options2, isArray = false) {
      const fieldsAsRaw = options2["fieldsAsRaw"] == null ? null : options2["fieldsAsRaw"];
      const raw = options2["raw"] == null ? false : options2["raw"];
      const bsonRegExp = typeof options2["bsonRegExp"] === "boolean" ? options2["bsonRegExp"] : false;
      const promoteBuffers = options2.promoteBuffers ?? false;
      const promoteLongs = options2.promoteLongs ?? true;
      const promoteValues = options2.promoteValues ?? true;
      const useBigInt64 = options2.useBigInt64 ?? false;
      if (useBigInt64 && !promoteValues) {
        throw new BSONError("Must either request bigint or Long for int64 deserialization");
      }
      if (useBigInt64 && !promoteLongs) {
        throw new BSONError("Must either request bigint or Long for int64 deserialization");
      }
      const validation = options2.validation == null ? { utf8: true } : options2.validation;
      let globalUTFValidation = true;
      let validationSetting;
      let utf8KeysSet;
      const utf8ValidatedKeys = validation.utf8;
      if (typeof utf8ValidatedKeys === "boolean") {
        validationSetting = utf8ValidatedKeys;
      } else {
        globalUTFValidation = false;
        const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key) {
          return utf8ValidatedKeys[key];
        });
        if (utf8ValidationValues.length === 0) {
          throw new BSONError("UTF-8 validation setting cannot be empty");
        }
        if (typeof utf8ValidationValues[0] !== "boolean") {
          throw new BSONError("Invalid UTF-8 validation option, must specify boolean values");
        }
        validationSetting = utf8ValidationValues[0];
        if (!utf8ValidationValues.every((item) => item === validationSetting)) {
          throw new BSONError("Invalid UTF-8 validation option - keys must be all true or all false");
        }
      }
      if (!globalUTFValidation) {
        utf8KeysSet = /* @__PURE__ */ new Set();
        for (const key of Object.keys(utf8ValidatedKeys)) {
          utf8KeysSet.add(key);
        }
      }
      const startIndex = index;
      if (buffer2.length < 5)
        throw new BSONError("corrupt bson message < 5 bytes long");
      const size = NumberUtils.getInt32LE(buffer2, index);
      index += 4;
      if (size < 5 || size > buffer2.length)
        throw new BSONError("corrupt bson message");
      const object = isArray ? [] : {};
      let arrayIndex = 0;
      let isPossibleDBRef = isArray ? false : null;
      while (true) {
        const elementType = buffer2[index++];
        if (elementType === 0)
          break;
        let i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.byteLength)
          throw new BSONError("Bad BSON Document: illegal CString");
        const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer2, index, i, false);
        let shouldValidateKey = true;
        if (globalUTFValidation || utf8KeysSet?.has(name)) {
          shouldValidateKey = validationSetting;
        } else {
          shouldValidateKey = !validationSetting;
        }
        if (isPossibleDBRef !== false && name[0] === "$") {
          isPossibleDBRef = allowedDBRefKeys.test(name);
        }
        let value;
        index = i + 1;
        if (elementType === BSON_DATA_STRING) {
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
            throw new BSONError("bad string length in bson");
          }
          value = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          index = index + stringSize;
        } else if (elementType === BSON_DATA_OID) {
          const oid = ByteUtils.allocateUnsafe(12);
          for (let i2 = 0; i2 < 12; i2++)
            oid[i2] = buffer2[index + i2];
          value = new ObjectId(oid);
          index = index + 12;
        } else if (elementType === BSON_DATA_INT && promoteValues === false) {
          value = new Int32(NumberUtils.getInt32LE(buffer2, index));
          index += 4;
        } else if (elementType === BSON_DATA_INT) {
          value = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
        } else if (elementType === BSON_DATA_NUMBER) {
          value = NumberUtils.getFloat64LE(buffer2, index);
          index += 8;
          if (promoteValues === false)
            value = new Double(value);
        } else if (elementType === BSON_DATA_DATE) {
          const lowBits = NumberUtils.getInt32LE(buffer2, index);
          const highBits = NumberUtils.getInt32LE(buffer2, index + 4);
          index += 8;
          value = new Date(new Long(lowBits, highBits).toNumber());
        } else if (elementType === BSON_DATA_BOOLEAN) {
          if (buffer2[index] !== 0 && buffer2[index] !== 1)
            throw new BSONError("illegal boolean type value");
          value = buffer2[index++] === 1;
        } else if (elementType === BSON_DATA_OBJECT) {
          const _index = index;
          const objectSize = NumberUtils.getInt32LE(buffer2, index);
          if (objectSize <= 0 || objectSize > buffer2.length - index)
            throw new BSONError("bad embedded document length in bson");
          if (raw) {
            value = buffer2.subarray(index, index + objectSize);
          } else {
            let objectOptions = options2;
            if (!globalUTFValidation) {
              objectOptions = { ...options2, validation: { utf8: shouldValidateKey } };
            }
            value = deserializeObject(buffer2, _index, objectOptions, false);
          }
          index = index + objectSize;
        } else if (elementType === BSON_DATA_ARRAY) {
          const _index = index;
          const objectSize = NumberUtils.getInt32LE(buffer2, index);
          let arrayOptions = options2;
          const stopIndex = index + objectSize;
          if (fieldsAsRaw && fieldsAsRaw[name]) {
            arrayOptions = { ...options2, raw: true };
          }
          if (!globalUTFValidation) {
            arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };
          }
          value = deserializeObject(buffer2, _index, arrayOptions, true);
          index = index + objectSize;
          if (buffer2[index - 1] !== 0)
            throw new BSONError("invalid array terminator byte");
          if (index !== stopIndex)
            throw new BSONError("corrupted array bson");
        } else if (elementType === BSON_DATA_UNDEFINED) {
          value = void 0;
        } else if (elementType === BSON_DATA_NULL) {
          value = null;
        } else if (elementType === BSON_DATA_LONG) {
          if (useBigInt64) {
            value = NumberUtils.getBigInt64LE(buffer2, index);
            index += 8;
          } else {
            const lowBits = NumberUtils.getInt32LE(buffer2, index);
            const highBits = NumberUtils.getInt32LE(buffer2, index + 4);
            index += 8;
            const long = new Long(lowBits, highBits);
            if (promoteLongs && promoteValues === true) {
              value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
            } else {
              value = long;
            }
          }
        } else if (elementType === BSON_DATA_DECIMAL128) {
          const bytes = ByteUtils.allocateUnsafe(16);
          for (let i2 = 0; i2 < 16; i2++)
            bytes[i2] = buffer2[index + i2];
          index = index + 16;
          value = new Decimal128(bytes);
        } else if (elementType === BSON_DATA_BINARY) {
          let binarySize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          const totalBinarySize = binarySize;
          const subType = buffer2[index++];
          if (binarySize < 0)
            throw new BSONError("Negative binary type element size found");
          if (binarySize > buffer2.byteLength)
            throw new BSONError("Binary type size larger than document size");
          if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize = NumberUtils.getInt32LE(buffer2, index);
            index += 4;
            if (binarySize < 0)
              throw new BSONError("Negative binary type element size found for subtype 0x02");
            if (binarySize > totalBinarySize - 4)
              throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
            if (binarySize < totalBinarySize - 4)
              throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
          }
          if (promoteBuffers && promoteValues) {
            value = ByteUtils.toLocalBufferType(buffer2.subarray(index, index + binarySize));
          } else {
            value = new Binary(buffer2.subarray(index, index + binarySize), subType);
            if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
              value = value.toUUID();
            }
          }
          index = index + binarySize;
        } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {
          i = index;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new BSONError("Bad BSON Document: illegal CString");
          const source = ByteUtils.toUTF8(buffer2, index, i, false);
          index = i + 1;
          i = index;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new BSONError("Bad BSON Document: illegal CString");
          const regExpOptions = ByteUtils.toUTF8(buffer2, index, i, false);
          index = i + 1;
          const optionsArray = new Array(regExpOptions.length);
          for (i = 0; i < regExpOptions.length; i++) {
            switch (regExpOptions[i]) {
              case "m":
                optionsArray[i] = "m";
                break;
              case "s":
                optionsArray[i] = "g";
                break;
              case "i":
                optionsArray[i] = "i";
                break;
            }
          }
          value = new RegExp(source, optionsArray.join(""));
        } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {
          i = index;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new BSONError("Bad BSON Document: illegal CString");
          const source = ByteUtils.toUTF8(buffer2, index, i, false);
          index = i + 1;
          i = index;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new BSONError("Bad BSON Document: illegal CString");
          const regExpOptions = ByteUtils.toUTF8(buffer2, index, i, false);
          index = i + 1;
          value = new BSONRegExp(source, regExpOptions);
        } else if (elementType === BSON_DATA_SYMBOL) {
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
            throw new BSONError("bad string length in bson");
          }
          const symbol = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          value = promoteValues ? symbol : new BSONSymbol(symbol);
          index = index + stringSize;
        } else if (elementType === BSON_DATA_TIMESTAMP) {
          value = new Timestamp({
            i: NumberUtils.getUint32LE(buffer2, index),
            t: NumberUtils.getUint32LE(buffer2, index + 4)
          });
          index += 8;
        } else if (elementType === BSON_DATA_MIN_KEY) {
          value = new MinKey();
        } else if (elementType === BSON_DATA_MAX_KEY) {
          value = new MaxKey();
        } else if (elementType === BSON_DATA_CODE) {
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
            throw new BSONError("bad string length in bson");
          }
          const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          value = new Code(functionString);
          index = index + stringSize;
        } else if (elementType === BSON_DATA_CODE_W_SCOPE) {
          const totalSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (totalSize < 4 + 4 + 4 + 1) {
            throw new BSONError("code_w_scope total size shorter minimum expected length");
          }
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
            throw new BSONError("bad string length in bson");
          }
          const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          index = index + stringSize;
          const _index = index;
          const objectSize = NumberUtils.getInt32LE(buffer2, index);
          const scopeObject = deserializeObject(buffer2, _index, options2, false);
          index = index + objectSize;
          if (totalSize < 4 + 4 + objectSize + stringSize) {
            throw new BSONError("code_w_scope total size is too short, truncating scope");
          }
          if (totalSize > 4 + 4 + objectSize + stringSize) {
            throw new BSONError("code_w_scope total size is too long, clips outer document");
          }
          value = new Code(functionString, scopeObject);
        } else if (elementType === BSON_DATA_DBPOINTER) {
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0)
            throw new BSONError("bad string length in bson");
          const namespace = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          index = index + stringSize;
          const oidBuffer = ByteUtils.allocateUnsafe(12);
          for (let i2 = 0; i2 < 12; i2++)
            oidBuffer[i2] = buffer2[index + i2];
          const oid = new ObjectId(oidBuffer);
          index = index + 12;
          value = new DBRef(namespace, oid);
        } else {
          throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`);
        }
        if (name === "__proto__") {
          Object.defineProperty(object, name, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        } else {
          object[name] = value;
        }
      }
      if (size !== index - startIndex) {
        if (isArray)
          throw new BSONError("corrupt array bson");
        throw new BSONError("corrupt object bson");
      }
      if (!isPossibleDBRef)
        return object;
      if (isDBRefLike(object)) {
        const copy = Object.assign({}, object);
        delete copy.$ref;
        delete copy.$id;
        delete copy.$db;
        return new DBRef(object.$ref, object.$id, object.$db, copy);
      }
      return object;
    }
    var regexp = /\x00/;
    var ignoreKeys = /* @__PURE__ */ new Set(["$db", "$ref", "$id", "$clusterTime"]);
    function serializeString(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_STRING;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes + 1;
      buffer2[index - 1] = 0;
      const size = ByteUtils.encodeUTF8Into(buffer2, value, index + 4);
      NumberUtils.setInt32LE(buffer2, index, size + 1);
      index = index + 4 + size;
      buffer2[index++] = 0;
      return index;
    }
    function serializeNumber(buffer2, key, value, index) {
      const isNegativeZero = Object.is(value, -0);
      const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;
      buffer2[index++] = type;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      if (type === BSON_DATA_INT) {
        index += NumberUtils.setInt32LE(buffer2, index, value);
      } else {
        index += NumberUtils.setFloat64LE(buffer2, index, value);
      }
      return index;
    }
    function serializeBigInt(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_LONG;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index += numberOfWrittenBytes;
      buffer2[index++] = 0;
      index += NumberUtils.setBigInt64LE(buffer2, index, value);
      return index;
    }
    function serializeNull(buffer2, key, _, index) {
      buffer2[index++] = BSON_DATA_NULL;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      return index;
    }
    function serializeBoolean(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_BOOLEAN;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      buffer2[index++] = value ? 1 : 0;
      return index;
    }
    function serializeDate(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_DATE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const dateInMilis = Long.fromNumber(value.getTime());
      const lowBits = dateInMilis.getLowBits();
      const highBits = dateInMilis.getHighBits();
      index += NumberUtils.setInt32LE(buffer2, index, lowBits);
      index += NumberUtils.setInt32LE(buffer2, index, highBits);
      return index;
    }
    function serializeRegExp(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_REGEXP;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      if (value.source && value.source.match(regexp) != null) {
        throw new BSONError("value " + value.source + " must not contain null bytes");
      }
      index = index + ByteUtils.encodeUTF8Into(buffer2, value.source, index);
      buffer2[index++] = 0;
      if (value.ignoreCase)
        buffer2[index++] = 105;
      if (value.global)
        buffer2[index++] = 115;
      if (value.multiline)
        buffer2[index++] = 109;
      buffer2[index++] = 0;
      return index;
    }
    function serializeBSONRegExp(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_REGEXP;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      if (value.pattern.match(regexp) != null) {
        throw new BSONError("pattern " + value.pattern + " must not contain null bytes");
      }
      index = index + ByteUtils.encodeUTF8Into(buffer2, value.pattern, index);
      buffer2[index++] = 0;
      const sortedOptions = value.options.split("").sort().join("");
      index = index + ByteUtils.encodeUTF8Into(buffer2, sortedOptions, index);
      buffer2[index++] = 0;
      return index;
    }
    function serializeMinMax(buffer2, key, value, index) {
      if (value === null) {
        buffer2[index++] = BSON_DATA_NULL;
      } else if (value._bsontype === "MinKey") {
        buffer2[index++] = BSON_DATA_MIN_KEY;
      } else {
        buffer2[index++] = BSON_DATA_MAX_KEY;
      }
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      return index;
    }
    function serializeObjectId(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_OID;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      index += value.serializeInto(buffer2, index);
      return index;
    }
    function serializeBuffer(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_BINARY;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const size = value.length;
      index += NumberUtils.setInt32LE(buffer2, index, size);
      buffer2[index++] = BSON_BINARY_SUBTYPE_DEFAULT;
      if (size <= 16) {
        for (let i = 0; i < size; i++)
          buffer2[index + i] = value[i];
      } else {
        buffer2.set(value, index);
      }
      index = index + size;
      return index;
    }
    function serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {
      if (path.has(value)) {
        throw new BSONError("Cannot convert circular structure to BSON");
      }
      path.add(value);
      buffer2[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const endIndex = serializeInto(buffer2, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
      path.delete(value);
      return endIndex;
    }
    function serializeDecimal128(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_DECIMAL128;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      for (let i = 0; i < 16; i++)
        buffer2[index + i] = value.bytes[i];
      return index + 16;
    }
    function serializeLong(buffer2, key, value, index) {
      buffer2[index++] = value._bsontype === "Long" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const lowBits = value.getLowBits();
      const highBits = value.getHighBits();
      index += NumberUtils.setInt32LE(buffer2, index, lowBits);
      index += NumberUtils.setInt32LE(buffer2, index, highBits);
      return index;
    }
    function serializeInt32(buffer2, key, value, index) {
      value = value.valueOf();
      buffer2[index++] = BSON_DATA_INT;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      index += NumberUtils.setInt32LE(buffer2, index, value);
      return index;
    }
    function serializeDouble(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_NUMBER;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      index += NumberUtils.setFloat64LE(buffer2, index, value.value);
      return index;
    }
    function serializeFunction(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_CODE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const functionString = value.toString();
      const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
      NumberUtils.setInt32LE(buffer2, index, size);
      index = index + 4 + size - 1;
      buffer2[index++] = 0;
      return index;
    }
    function serializeCode(buffer2, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {
      if (value.scope && typeof value.scope === "object") {
        buffer2[index++] = BSON_DATA_CODE_W_SCOPE;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
        index = index + numberOfWrittenBytes;
        buffer2[index++] = 0;
        let startIndex = index;
        const functionString = value.code;
        index = index + 4;
        const codeSize = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
        NumberUtils.setInt32LE(buffer2, index, codeSize);
        buffer2[index + 4 + codeSize - 1] = 0;
        index = index + codeSize + 4;
        const endIndex = serializeInto(buffer2, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
        index = endIndex - 1;
        const totalSize = endIndex - startIndex;
        startIndex += NumberUtils.setInt32LE(buffer2, startIndex, totalSize);
        buffer2[index++] = 0;
      } else {
        buffer2[index++] = BSON_DATA_CODE;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
        index = index + numberOfWrittenBytes;
        buffer2[index++] = 0;
        const functionString = value.code.toString();
        const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
        NumberUtils.setInt32LE(buffer2, index, size);
        index = index + 4 + size - 1;
        buffer2[index++] = 0;
      }
      return index;
    }
    function serializeBinary(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_BINARY;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const data = value.buffer;
      let size = value.position;
      if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)
        size = size + 4;
      index += NumberUtils.setInt32LE(buffer2, index, size);
      buffer2[index++] = value.sub_type;
      if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
        size = size - 4;
        index += NumberUtils.setInt32LE(buffer2, index, size);
      }
      if (value.sub_type === Binary.SUBTYPE_VECTOR) {
        validateBinaryVector(value);
      }
      if (size <= 16) {
        for (let i = 0; i < size; i++)
          buffer2[index + i] = data[i];
      } else {
        buffer2.set(data, index);
      }
      index = index + value.position;
      return index;
    }
    function serializeSymbol(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_SYMBOL;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const size = ByteUtils.encodeUTF8Into(buffer2, value.value, index + 4) + 1;
      NumberUtils.setInt32LE(buffer2, index, size);
      index = index + 4 + size - 1;
      buffer2[index++] = 0;
      return index;
    }
    function serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path) {
      buffer2[index++] = BSON_DATA_OBJECT;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      let startIndex = index;
      let output = {
        $ref: value.collection || value.namespace,
        $id: value.oid
      };
      if (value.db != null) {
        output.$db = value.db;
      }
      output = Object.assign(output, value.fields);
      const endIndex = serializeInto(buffer2, output, false, index, depth + 1, serializeFunctions, true, path);
      const size = endIndex - startIndex;
      startIndex += NumberUtils.setInt32LE(buffer2, index, size);
      return endIndex;
    }
    function serializeInto(buffer2, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
      if (path == null) {
        if (object == null) {
          buffer2[0] = 5;
          buffer2[1] = 0;
          buffer2[2] = 0;
          buffer2[3] = 0;
          buffer2[4] = 0;
          return 5;
        }
        if (Array.isArray(object)) {
          throw new BSONError("serialize does not support an array as the root input");
        }
        if (typeof object !== "object") {
          throw new BSONError("serialize does not support non-object as the root input");
        } else if ("_bsontype" in object && typeof object._bsontype === "string") {
          throw new BSONError(`BSON types cannot be serialized as a document`);
        } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {
          throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);
        }
        path = /* @__PURE__ */ new Set();
      }
      path.add(object);
      let index = startingIndex + 4;
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; i++) {
          const key = `${i}`;
          let value = object[i];
          if (typeof value?.toBSON === "function") {
            value = value.toBSON();
          }
          const type = typeof value;
          if (value === void 0) {
            index = serializeNull(buffer2, key, value, index);
          } else if (value === null) {
            index = serializeNull(buffer2, key, value, index);
          } else if (type === "string") {
            index = serializeString(buffer2, key, value, index);
          } else if (type === "number") {
            index = serializeNumber(buffer2, key, value, index);
          } else if (type === "bigint") {
            index = serializeBigInt(buffer2, key, value, index);
          } else if (type === "boolean") {
            index = serializeBoolean(buffer2, key, value, index);
          } else if (type === "object" && value._bsontype == null) {
            if (value instanceof Date || isDate(value)) {
              index = serializeDate(buffer2, key, value, index);
            } else if (value instanceof Uint8Array || isUint8Array(value)) {
              index = serializeBuffer(buffer2, key, value, index);
            } else if (value instanceof RegExp || isRegExp(value)) {
              index = serializeRegExp(buffer2, key, value, index);
            } else {
              index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
            }
          } else if (type === "object") {
            if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
              throw new BSONVersionError();
            } else if (value._bsontype === "ObjectId") {
              index = serializeObjectId(buffer2, key, value, index);
            } else if (value._bsontype === "Decimal128") {
              index = serializeDecimal128(buffer2, key, value, index);
            } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
              index = serializeLong(buffer2, key, value, index);
            } else if (value._bsontype === "Double") {
              index = serializeDouble(buffer2, key, value, index);
            } else if (value._bsontype === "Code") {
              index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
            } else if (value._bsontype === "Binary") {
              index = serializeBinary(buffer2, key, value, index);
            } else if (value._bsontype === "BSONSymbol") {
              index = serializeSymbol(buffer2, key, value, index);
            } else if (value._bsontype === "DBRef") {
              index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
            } else if (value._bsontype === "BSONRegExp") {
              index = serializeBSONRegExp(buffer2, key, value, index);
            } else if (value._bsontype === "Int32") {
              index = serializeInt32(buffer2, key, value, index);
            } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
              index = serializeMinMax(buffer2, key, value, index);
            } else if (typeof value._bsontype !== "undefined") {
              throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
            }
          } else if (type === "function" && serializeFunctions) {
            index = serializeFunction(buffer2, key, value, index);
          }
        }
      } else if (object instanceof Map || isMap(object)) {
        const iterator = object.entries();
        let done = false;
        while (!done) {
          const entry = iterator.next();
          done = !!entry.done;
          if (done)
            continue;
          const key = entry.value ? entry.value[0] : void 0;
          let value = entry.value ? entry.value[1] : void 0;
          if (typeof value?.toBSON === "function") {
            value = value.toBSON();
          }
          const type = typeof value;
          if (typeof key === "string" && !ignoreKeys.has(key)) {
            if (key.match(regexp) != null) {
              throw new BSONError("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if ("$" === key[0]) {
                throw new BSONError("key " + key + " must not start with '$'");
              } else if (key.includes(".")) {
                throw new BSONError("key " + key + " must not contain '.'");
              }
            }
          }
          if (value === void 0) {
            if (ignoreUndefined === false)
              index = serializeNull(buffer2, key, value, index);
          } else if (value === null) {
            index = serializeNull(buffer2, key, value, index);
          } else if (type === "string") {
            index = serializeString(buffer2, key, value, index);
          } else if (type === "number") {
            index = serializeNumber(buffer2, key, value, index);
          } else if (type === "bigint") {
            index = serializeBigInt(buffer2, key, value, index);
          } else if (type === "boolean") {
            index = serializeBoolean(buffer2, key, value, index);
          } else if (type === "object" && value._bsontype == null) {
            if (value instanceof Date || isDate(value)) {
              index = serializeDate(buffer2, key, value, index);
            } else if (value instanceof Uint8Array || isUint8Array(value)) {
              index = serializeBuffer(buffer2, key, value, index);
            } else if (value instanceof RegExp || isRegExp(value)) {
              index = serializeRegExp(buffer2, key, value, index);
            } else {
              index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
            }
          } else if (type === "object") {
            if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
              throw new BSONVersionError();
            } else if (value._bsontype === "ObjectId") {
              index = serializeObjectId(buffer2, key, value, index);
            } else if (value._bsontype === "Decimal128") {
              index = serializeDecimal128(buffer2, key, value, index);
            } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
              index = serializeLong(buffer2, key, value, index);
            } else if (value._bsontype === "Double") {
              index = serializeDouble(buffer2, key, value, index);
            } else if (value._bsontype === "Code") {
              index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
            } else if (value._bsontype === "Binary") {
              index = serializeBinary(buffer2, key, value, index);
            } else if (value._bsontype === "BSONSymbol") {
              index = serializeSymbol(buffer2, key, value, index);
            } else if (value._bsontype === "DBRef") {
              index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
            } else if (value._bsontype === "BSONRegExp") {
              index = serializeBSONRegExp(buffer2, key, value, index);
            } else if (value._bsontype === "Int32") {
              index = serializeInt32(buffer2, key, value, index);
            } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
              index = serializeMinMax(buffer2, key, value, index);
            } else if (typeof value._bsontype !== "undefined") {
              throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
            }
          } else if (type === "function" && serializeFunctions) {
            index = serializeFunction(buffer2, key, value, index);
          }
        }
      } else {
        if (typeof object?.toBSON === "function") {
          object = object.toBSON();
          if (object != null && typeof object !== "object") {
            throw new BSONError("toBSON function did not return an object");
          }
        }
        for (const key of Object.keys(object)) {
          let value = object[key];
          if (typeof value?.toBSON === "function") {
            value = value.toBSON();
          }
          const type = typeof value;
          if (typeof key === "string" && !ignoreKeys.has(key)) {
            if (key.match(regexp) != null) {
              throw new BSONError("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if ("$" === key[0]) {
                throw new BSONError("key " + key + " must not start with '$'");
              } else if (key.includes(".")) {
                throw new BSONError("key " + key + " must not contain '.'");
              }
            }
          }
          if (value === void 0) {
            if (ignoreUndefined === false)
              index = serializeNull(buffer2, key, value, index);
          } else if (value === null) {
            index = serializeNull(buffer2, key, value, index);
          } else if (type === "string") {
            index = serializeString(buffer2, key, value, index);
          } else if (type === "number") {
            index = serializeNumber(buffer2, key, value, index);
          } else if (type === "bigint") {
            index = serializeBigInt(buffer2, key, value, index);
          } else if (type === "boolean") {
            index = serializeBoolean(buffer2, key, value, index);
          } else if (type === "object" && value._bsontype == null) {
            if (value instanceof Date || isDate(value)) {
              index = serializeDate(buffer2, key, value, index);
            } else if (value instanceof Uint8Array || isUint8Array(value)) {
              index = serializeBuffer(buffer2, key, value, index);
            } else if (value instanceof RegExp || isRegExp(value)) {
              index = serializeRegExp(buffer2, key, value, index);
            } else {
              index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
            }
          } else if (type === "object") {
            if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
              throw new BSONVersionError();
            } else if (value._bsontype === "ObjectId") {
              index = serializeObjectId(buffer2, key, value, index);
            } else if (value._bsontype === "Decimal128") {
              index = serializeDecimal128(buffer2, key, value, index);
            } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
              index = serializeLong(buffer2, key, value, index);
            } else if (value._bsontype === "Double") {
              index = serializeDouble(buffer2, key, value, index);
            } else if (value._bsontype === "Code") {
              index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
            } else if (value._bsontype === "Binary") {
              index = serializeBinary(buffer2, key, value, index);
            } else if (value._bsontype === "BSONSymbol") {
              index = serializeSymbol(buffer2, key, value, index);
            } else if (value._bsontype === "DBRef") {
              index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
            } else if (value._bsontype === "BSONRegExp") {
              index = serializeBSONRegExp(buffer2, key, value, index);
            } else if (value._bsontype === "Int32") {
              index = serializeInt32(buffer2, key, value, index);
            } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
              index = serializeMinMax(buffer2, key, value, index);
            } else if (typeof value._bsontype !== "undefined") {
              throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
            }
          } else if (type === "function" && serializeFunctions) {
            index = serializeFunction(buffer2, key, value, index);
          }
        }
      }
      path.delete(object);
      buffer2[index++] = 0;
      const size = index - startingIndex;
      startingIndex += NumberUtils.setInt32LE(buffer2, startingIndex, size);
      return index;
    }
    function isBSONType(value) {
      return value != null && typeof value === "object" && "_bsontype" in value && typeof value._bsontype === "string";
    }
    var keysToCodecs = {
      $oid: ObjectId,
      $binary: Binary,
      $uuid: Binary,
      $symbol: BSONSymbol,
      $numberInt: Int32,
      $numberDecimal: Decimal128,
      $numberDouble: Double,
      $numberLong: Long,
      $minKey: MinKey,
      $maxKey: MaxKey,
      $regex: BSONRegExp,
      $regularExpression: BSONRegExp,
      $timestamp: Timestamp
    };
    function deserializeValue(value, options2 = {}) {
      if (typeof value === "number") {
        const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;
        const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;
        if (options2.relaxed || options2.legacy) {
          return value;
        }
        if (Number.isInteger(value) && !Object.is(value, -0)) {
          if (in32BitRange) {
            return new Int32(value);
          }
          if (in64BitRange) {
            if (options2.useBigInt64) {
              return BigInt(value);
            }
            return Long.fromNumber(value);
          }
        }
        return new Double(value);
      }
      if (value == null || typeof value !== "object")
        return value;
      if (value.$undefined)
        return null;
      const keys = Object.keys(value).filter((k) => k.startsWith("$") && value[k] != null);
      for (let i = 0; i < keys.length; i++) {
        const c = keysToCodecs[keys[i]];
        if (c)
          return c.fromExtendedJSON(value, options2);
      }
      if (value.$date != null) {
        const d = value.$date;
        const date = /* @__PURE__ */ new Date();
        if (options2.legacy) {
          if (typeof d === "number")
            date.setTime(d);
          else if (typeof d === "string")
            date.setTime(Date.parse(d));
          else if (typeof d === "bigint")
            date.setTime(Number(d));
          else
            throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
        } else {
          if (typeof d === "string")
            date.setTime(Date.parse(d));
          else if (Long.isLong(d))
            date.setTime(d.toNumber());
          else if (typeof d === "number" && options2.relaxed)
            date.setTime(d);
          else if (typeof d === "bigint")
            date.setTime(Number(d));
          else
            throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
        }
        return date;
      }
      if (value.$code != null) {
        const copy = Object.assign({}, value);
        if (value.$scope) {
          copy.$scope = deserializeValue(value.$scope);
        }
        return Code.fromExtendedJSON(value);
      }
      if (isDBRefLike(value) || value.$dbPointer) {
        const v = value.$ref ? value : value.$dbPointer;
        if (v instanceof DBRef)
          return v;
        const dollarKeys = Object.keys(v).filter((k) => k.startsWith("$"));
        let valid = true;
        dollarKeys.forEach((k) => {
          if (["$ref", "$id", "$db"].indexOf(k) === -1)
            valid = false;
        });
        if (valid)
          return DBRef.fromExtendedJSON(v);
      }
      return value;
    }
    function serializeArray(array, options2) {
      return array.map((v, index) => {
        options2.seenObjects.push({ propertyName: `index ${index}`, obj: null });
        try {
          return serializeValue(v, options2);
        } finally {
          options2.seenObjects.pop();
        }
      });
    }
    function getISOString(date) {
      const isoStr = date.toISOString();
      return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + "Z";
    }
    function serializeValue(value, options2) {
      if (value instanceof Map || isMap(value)) {
        const obj = /* @__PURE__ */ Object.create(null);
        for (const [k, v] of value) {
          if (typeof k !== "string") {
            throw new BSONError("Can only serialize maps with string keys");
          }
          obj[k] = v;
        }
        return serializeValue(obj, options2);
      }
      if ((typeof value === "object" || typeof value === "function") && value !== null) {
        const index = options2.seenObjects.findIndex((entry) => entry.obj === value);
        if (index !== -1) {
          const props = options2.seenObjects.map((entry) => entry.propertyName);
          const leadingPart = props.slice(0, index).map((prop) => `${prop} -> `).join("");
          const alreadySeen = props[index];
          const circularPart = " -> " + props.slice(index + 1, props.length - 1).map((prop) => `${prop} -> `).join("");
          const current = props[props.length - 1];
          const leadingSpace = " ".repeat(leadingPart.length + alreadySeen.length / 2);
          const dashes = "-".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
          throw new BSONError(`Converting circular structure to EJSON:
    ${leadingPart}${alreadySeen}${circularPart}${current}
    ${leadingSpace}\\${dashes}/`);
        }
        options2.seenObjects[options2.seenObjects.length - 1].obj = value;
      }
      if (Array.isArray(value))
        return serializeArray(value, options2);
      if (value === void 0)
        return null;
      if (value instanceof Date || isDate(value)) {
        const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 2534023188e5;
        if (options2.legacy) {
          return options2.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) };
        }
        return options2.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } };
      }
      if (typeof value === "number" && (!options2.relaxed || !isFinite(value))) {
        if (Number.isInteger(value) && !Object.is(value, -0)) {
          if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
            return { $numberInt: value.toString() };
          }
          if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {
            return { $numberLong: value.toString() };
          }
        }
        return { $numberDouble: Object.is(value, -0) ? "-0.0" : value.toString() };
      }
      if (typeof value === "bigint") {
        if (!options2.relaxed) {
          return { $numberLong: BigInt.asIntN(64, value).toString() };
        }
        return Number(BigInt.asIntN(64, value));
      }
      if (value instanceof RegExp || isRegExp(value)) {
        let flags = value.flags;
        if (flags === void 0) {
          const match = value.toString().match(/[gimuy]*$/);
          if (match) {
            flags = match[0];
          }
        }
        const rx = new BSONRegExp(value.source, flags);
        return rx.toExtendedJSON(options2);
      }
      if (value != null && typeof value === "object")
        return serializeDocument(value, options2);
      return value;
    }
    var BSON_TYPE_MAPPINGS = {
      Binary: (o) => new Binary(o.value(), o.sub_type),
      Code: (o) => new Code(o.code, o.scope),
      DBRef: (o) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),
      Decimal128: (o) => new Decimal128(o.bytes),
      Double: (o) => new Double(o.value),
      Int32: (o) => new Int32(o.value),
      Long: (o) => Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),
      MaxKey: () => new MaxKey(),
      MinKey: () => new MinKey(),
      ObjectId: (o) => new ObjectId(o),
      BSONRegExp: (o) => new BSONRegExp(o.pattern, o.options),
      BSONSymbol: (o) => new BSONSymbol(o.value),
      Timestamp: (o) => Timestamp.fromBits(o.low, o.high)
    };
    function serializeDocument(doc, options2) {
      if (doc == null || typeof doc !== "object")
        throw new BSONError("not an object instance");
      const bsontype = doc._bsontype;
      if (typeof bsontype === "undefined") {
        const _doc = {};
        for (const name of Object.keys(doc)) {
          options2.seenObjects.push({ propertyName: name, obj: null });
          try {
            const value = serializeValue(doc[name], options2);
            if (name === "__proto__") {
              Object.defineProperty(_doc, name, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            } else {
              _doc[name] = value;
            }
          } finally {
            options2.seenObjects.pop();
          }
        }
        return _doc;
      } else if (doc != null && typeof doc === "object" && typeof doc._bsontype === "string" && doc[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
        throw new BSONVersionError();
      } else if (isBSONType(doc)) {
        let outDoc = doc;
        if (typeof outDoc.toExtendedJSON !== "function") {
          const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
          if (!mapper) {
            throw new BSONError("Unrecognized or invalid _bsontype: " + doc._bsontype);
          }
          outDoc = mapper(outDoc);
        }
        if (bsontype === "Code" && outDoc.scope) {
          outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options2));
        } else if (bsontype === "DBRef" && outDoc.oid) {
          outDoc = new DBRef(serializeValue(outDoc.collection, options2), serializeValue(outDoc.oid, options2), serializeValue(outDoc.db, options2), serializeValue(outDoc.fields, options2));
        }
        return outDoc.toExtendedJSON(options2);
      } else {
        throw new BSONError("_bsontype must be a string, but was: " + typeof bsontype);
      }
    }
    function parse(text, options2) {
      const ejsonOptions = {
        useBigInt64: options2?.useBigInt64 ?? false,
        relaxed: options2?.relaxed ?? true,
        legacy: options2?.legacy ?? false
      };
      return JSON.parse(text, (key, value) => {
        if (key.indexOf("\0") !== -1) {
          throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);
        }
        return deserializeValue(value, ejsonOptions);
      });
    }
    function stringify(value, replacer, space, options2) {
      if (space != null && typeof space === "object") {
        options2 = space;
        space = 0;
      }
      if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
        options2 = replacer;
        replacer = void 0;
        space = 0;
      }
      const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options2, {
        seenObjects: [{ propertyName: "(root)", obj: null }]
      });
      const doc = serializeValue(value, serializeOptions);
      return JSON.stringify(doc, replacer, space);
    }
    function EJSONserialize(value, options2) {
      options2 = options2 || {};
      return JSON.parse(stringify(value, options2));
    }
    function EJSONdeserialize(ejson, options2) {
      options2 = options2 || {};
      return parse(JSON.stringify(ejson), options2);
    }
    var EJSON = /* @__PURE__ */ Object.create(null);
    EJSON.parse = parse;
    EJSON.stringify = stringify;
    EJSON.serialize = EJSONserialize;
    EJSON.deserialize = EJSONdeserialize;
    Object.freeze(EJSON);
    var BSONElementType = {
      double: 1,
      string: 2,
      object: 3,
      array: 4,
      binData: 5,
      undefined: 6,
      objectId: 7,
      bool: 8,
      date: 9,
      null: 10,
      regex: 11,
      dbPointer: 12,
      javascript: 13,
      symbol: 14,
      javascriptWithScope: 15,
      int: 16,
      timestamp: 17,
      long: 18,
      decimal: 19,
      minKey: 255,
      maxKey: 127
    };
    function getSize(source, offset) {
      try {
        return NumberUtils.getNonnegativeInt32LE(source, offset);
      } catch (cause) {
        throw new BSONOffsetError("BSON size cannot be negative", offset, { cause });
      }
    }
    function findNull(bytes, offset) {
      let nullTerminatorOffset = offset;
      for (; bytes[nullTerminatorOffset] !== 0; nullTerminatorOffset++)
        ;
      if (nullTerminatorOffset === bytes.length - 1) {
        throw new BSONOffsetError("Null terminator not found", offset);
      }
      return nullTerminatorOffset;
    }
    function parseToElements(bytes, startOffset = 0) {
      startOffset ??= 0;
      if (bytes.length < 5) {
        throw new BSONOffsetError(`Input must be at least 5 bytes, got ${bytes.length} bytes`, startOffset);
      }
      const documentSize = getSize(bytes, startOffset);
      if (documentSize > bytes.length - startOffset) {
        throw new BSONOffsetError(`Parsed documentSize (${documentSize} bytes) does not match input length (${bytes.length} bytes)`, startOffset);
      }
      if (bytes[startOffset + documentSize - 1] !== 0) {
        throw new BSONOffsetError("BSON documents must end in 0x00", startOffset + documentSize);
      }
      const elements = [];
      let offset = startOffset + 4;
      while (offset <= documentSize + startOffset) {
        const type = bytes[offset];
        offset += 1;
        if (type === 0) {
          if (offset - startOffset !== documentSize) {
            throw new BSONOffsetError(`Invalid 0x00 type byte`, offset);
          }
          break;
        }
        const nameOffset = offset;
        const nameLength = findNull(bytes, offset) - nameOffset;
        offset += nameLength + 1;
        let length;
        if (type === BSONElementType.double || type === BSONElementType.long || type === BSONElementType.date || type === BSONElementType.timestamp) {
          length = 8;
        } else if (type === BSONElementType.int) {
          length = 4;
        } else if (type === BSONElementType.objectId) {
          length = 12;
        } else if (type === BSONElementType.decimal) {
          length = 16;
        } else if (type === BSONElementType.bool) {
          length = 1;
        } else if (type === BSONElementType.null || type === BSONElementType.undefined || type === BSONElementType.maxKey || type === BSONElementType.minKey) {
          length = 0;
        } else if (type === BSONElementType.regex) {
          length = findNull(bytes, findNull(bytes, offset) + 1) + 1 - offset;
        } else if (type === BSONElementType.object || type === BSONElementType.array || type === BSONElementType.javascriptWithScope) {
          length = getSize(bytes, offset);
        } else if (type === BSONElementType.string || type === BSONElementType.binData || type === BSONElementType.dbPointer || type === BSONElementType.javascript || type === BSONElementType.symbol) {
          length = getSize(bytes, offset) + 4;
          if (type === BSONElementType.binData) {
            length += 1;
          }
          if (type === BSONElementType.dbPointer) {
            length += 12;
          }
        } else {
          throw new BSONOffsetError(`Invalid 0x${type.toString(16).padStart(2, "0")} type byte`, offset);
        }
        if (length > documentSize) {
          throw new BSONOffsetError("value reports length larger than document", offset);
        }
        elements.push([type, nameOffset, nameLength, offset, length]);
        offset += length;
      }
      return elements;
    }
    var onDemand = /* @__PURE__ */ Object.create(null);
    onDemand.parseToElements = parseToElements;
    onDemand.ByteUtils = ByteUtils;
    onDemand.NumberUtils = NumberUtils;
    Object.freeze(onDemand);
    var MAXSIZE = 1024 * 1024 * 17;
    var buffer = ByteUtils.allocate(MAXSIZE);
    function setInternalBufferSize(size) {
      if (buffer.length < size) {
        buffer = ByteUtils.allocate(size);
      }
    }
    function serialize(object, options2 = {}) {
      const checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
      const serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      const ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      const minInternalBufferSize = typeof options2.minInternalBufferSize === "number" ? options2.minInternalBufferSize : MAXSIZE;
      if (buffer.length < minInternalBufferSize) {
        buffer = ByteUtils.allocate(minInternalBufferSize);
      }
      const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
      const finishedBuffer = ByteUtils.allocateUnsafe(serializationIndex);
      finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);
      return finishedBuffer;
    }
    function serializeWithBufferAndIndex(object, finalBuffer, options2 = {}) {
      const checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
      const serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      const ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      const startIndex = typeof options2.index === "number" ? options2.index : 0;
      const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
      finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);
      return startIndex + serializationIndex - 1;
    }
    function deserialize(buffer2, options2 = {}) {
      return internalDeserialize(ByteUtils.toLocalBufferType(buffer2), options2);
    }
    function calculateObjectSize(object, options2 = {}) {
      options2 = options2 || {};
      const serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      const ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);
    }
    function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options2) {
      const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options2);
      const bufferData = ByteUtils.toLocalBufferType(data);
      let index = startIndex;
      for (let i = 0; i < numberOfDocuments; i++) {
        const size = NumberUtils.getInt32LE(bufferData, index);
        internalOptions.index = index;
        documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);
        index = index + size;
      }
      return index;
    }
    var bson = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      BSONError,
      BSONOffsetError,
      BSONRegExp,
      BSONRuntimeError,
      BSONSymbol,
      BSONType,
      BSONValue,
      BSONVersionError,
      Binary,
      Code,
      DBRef,
      Decimal128,
      Double,
      EJSON,
      Int32,
      Long,
      MaxKey,
      MinKey,
      ObjectId,
      Timestamp,
      UUID,
      calculateObjectSize,
      deserialize,
      deserializeStream,
      onDemand,
      serialize,
      serializeWithBufferAndIndex,
      setInternalBufferSize
    });
    exports2.BSON = bson;
    exports2.BSONError = BSONError;
    exports2.BSONOffsetError = BSONOffsetError;
    exports2.BSONRegExp = BSONRegExp;
    exports2.BSONRuntimeError = BSONRuntimeError;
    exports2.BSONSymbol = BSONSymbol;
    exports2.BSONType = BSONType;
    exports2.BSONValue = BSONValue;
    exports2.BSONVersionError = BSONVersionError;
    exports2.Binary = Binary;
    exports2.Code = Code;
    exports2.DBRef = DBRef;
    exports2.Decimal128 = Decimal128;
    exports2.Double = Double;
    exports2.EJSON = EJSON;
    exports2.Int32 = Int32;
    exports2.Long = Long;
    exports2.MaxKey = MaxKey;
    exports2.MinKey = MinKey;
    exports2.ObjectId = ObjectId;
    exports2.Timestamp = Timestamp;
    exports2.UUID = UUID;
    exports2.calculateObjectSize = calculateObjectSize;
    exports2.deserialize = deserialize;
    exports2.deserializeStream = deserializeStream;
    exports2.onDemand = onDemand;
    exports2.serialize = serialize;
    exports2.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
    exports2.setInternalBufferSize = setInternalBufferSize;
  }
});

// node_modules/mongodb/lib/bson.js
var require_bson2 = __commonJS({
  "node_modules/mongodb/lib/bson.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toUTF8 = exports2.getBigInt64LE = exports2.getFloat64LE = exports2.getInt32LE = exports2.UUID = exports2.Timestamp = exports2.serialize = exports2.ObjectId = exports2.MinKey = exports2.MaxKey = exports2.Long = exports2.Int32 = exports2.EJSON = exports2.Double = exports2.deserialize = exports2.Decimal128 = exports2.DBRef = exports2.Code = exports2.calculateObjectSize = exports2.BSONType = exports2.BSONSymbol = exports2.BSONRegExp = exports2.BSONError = exports2.BSON = exports2.Binary = void 0;
    exports2.parseToElementsToArray = parseToElementsToArray;
    exports2.pluckBSONSerializeOptions = pluckBSONSerializeOptions;
    exports2.resolveBSONOptions = resolveBSONOptions;
    exports2.parseUtf8ValidationOption = parseUtf8ValidationOption;
    var bson_1 = require_bson();
    var bson_2 = require_bson();
    Object.defineProperty(exports2, "Binary", { enumerable: true, get: function() {
      return bson_2.Binary;
    } });
    Object.defineProperty(exports2, "BSON", { enumerable: true, get: function() {
      return bson_2.BSON;
    } });
    Object.defineProperty(exports2, "BSONError", { enumerable: true, get: function() {
      return bson_2.BSONError;
    } });
    Object.defineProperty(exports2, "BSONRegExp", { enumerable: true, get: function() {
      return bson_2.BSONRegExp;
    } });
    Object.defineProperty(exports2, "BSONSymbol", { enumerable: true, get: function() {
      return bson_2.BSONSymbol;
    } });
    Object.defineProperty(exports2, "BSONType", { enumerable: true, get: function() {
      return bson_2.BSONType;
    } });
    Object.defineProperty(exports2, "calculateObjectSize", { enumerable: true, get: function() {
      return bson_2.calculateObjectSize;
    } });
    Object.defineProperty(exports2, "Code", { enumerable: true, get: function() {
      return bson_2.Code;
    } });
    Object.defineProperty(exports2, "DBRef", { enumerable: true, get: function() {
      return bson_2.DBRef;
    } });
    Object.defineProperty(exports2, "Decimal128", { enumerable: true, get: function() {
      return bson_2.Decimal128;
    } });
    Object.defineProperty(exports2, "deserialize", { enumerable: true, get: function() {
      return bson_2.deserialize;
    } });
    Object.defineProperty(exports2, "Double", { enumerable: true, get: function() {
      return bson_2.Double;
    } });
    Object.defineProperty(exports2, "EJSON", { enumerable: true, get: function() {
      return bson_2.EJSON;
    } });
    Object.defineProperty(exports2, "Int32", { enumerable: true, get: function() {
      return bson_2.Int32;
    } });
    Object.defineProperty(exports2, "Long", { enumerable: true, get: function() {
      return bson_2.Long;
    } });
    Object.defineProperty(exports2, "MaxKey", { enumerable: true, get: function() {
      return bson_2.MaxKey;
    } });
    Object.defineProperty(exports2, "MinKey", { enumerable: true, get: function() {
      return bson_2.MinKey;
    } });
    Object.defineProperty(exports2, "ObjectId", { enumerable: true, get: function() {
      return bson_2.ObjectId;
    } });
    Object.defineProperty(exports2, "serialize", { enumerable: true, get: function() {
      return bson_2.serialize;
    } });
    Object.defineProperty(exports2, "Timestamp", { enumerable: true, get: function() {
      return bson_2.Timestamp;
    } });
    Object.defineProperty(exports2, "UUID", { enumerable: true, get: function() {
      return bson_2.UUID;
    } });
    function parseToElementsToArray(bytes, offset) {
      const res = bson_1.BSON.onDemand.parseToElements(bytes, offset);
      return Array.isArray(res) ? res : [...res];
    }
    exports2.getInt32LE = bson_1.BSON.onDemand.NumberUtils.getInt32LE;
    exports2.getFloat64LE = bson_1.BSON.onDemand.NumberUtils.getFloat64LE;
    exports2.getBigInt64LE = bson_1.BSON.onDemand.NumberUtils.getBigInt64LE;
    exports2.toUTF8 = bson_1.BSON.onDemand.ByteUtils.toUTF8;
    function pluckBSONSerializeOptions(options2) {
      const { fieldsAsRaw, useBigInt64, promoteValues, promoteBuffers, promoteLongs, serializeFunctions, ignoreUndefined, bsonRegExp, raw, enableUtf8Validation } = options2;
      return {
        fieldsAsRaw,
        useBigInt64,
        promoteValues,
        promoteBuffers,
        promoteLongs,
        serializeFunctions,
        ignoreUndefined,
        bsonRegExp,
        raw,
        enableUtf8Validation
      };
    }
    function resolveBSONOptions(options2, parent) {
      const parentOptions = parent?.bsonOptions;
      return {
        raw: options2?.raw ?? parentOptions?.raw ?? false,
        useBigInt64: options2?.useBigInt64 ?? parentOptions?.useBigInt64 ?? false,
        promoteLongs: options2?.promoteLongs ?? parentOptions?.promoteLongs ?? true,
        promoteValues: options2?.promoteValues ?? parentOptions?.promoteValues ?? true,
        promoteBuffers: options2?.promoteBuffers ?? parentOptions?.promoteBuffers ?? false,
        ignoreUndefined: options2?.ignoreUndefined ?? parentOptions?.ignoreUndefined ?? false,
        bsonRegExp: options2?.bsonRegExp ?? parentOptions?.bsonRegExp ?? false,
        serializeFunctions: options2?.serializeFunctions ?? parentOptions?.serializeFunctions ?? false,
        fieldsAsRaw: options2?.fieldsAsRaw ?? parentOptions?.fieldsAsRaw ?? {},
        enableUtf8Validation: options2?.enableUtf8Validation ?? parentOptions?.enableUtf8Validation ?? true
      };
    }
    function parseUtf8ValidationOption(options2) {
      const enableUtf8Validation = options2?.enableUtf8Validation;
      if (enableUtf8Validation === false) {
        return { utf8: false };
      }
      return { utf8: { writeErrors: false } };
    }
  }
});

// node_modules/mongodb/lib/error.js
var require_error = __commonJS({
  "node_modules/mongodb/lib/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoWriteConcernError = exports2.MongoServerSelectionError = exports2.MongoSystemError = exports2.MongoMissingDependencyError = exports2.MongoMissingCredentialsError = exports2.MongoCompatibilityError = exports2.MongoInvalidArgumentError = exports2.MongoParseError = exports2.MongoNetworkTimeoutError = exports2.MongoNetworkError = exports2.MongoClientClosedError = exports2.MongoTopologyClosedError = exports2.MongoCursorExhaustedError = exports2.MongoServerClosedError = exports2.MongoCursorInUseError = exports2.MongoOperationTimeoutError = exports2.MongoUnexpectedServerResponseError = exports2.MongoGridFSChunkError = exports2.MongoGridFSStreamError = exports2.MongoTailableCursorError = exports2.MongoChangeStreamError = exports2.MongoClientBulkWriteExecutionError = exports2.MongoClientBulkWriteCursorError = exports2.MongoClientBulkWriteError = exports2.MongoGCPError = exports2.MongoAzureError = exports2.MongoOIDCError = exports2.MongoAWSError = exports2.MongoKerberosError = exports2.MongoExpiredSessionError = exports2.MongoTransactionError = exports2.MongoNotConnectedError = exports2.MongoDecompressionError = exports2.MongoBatchReExecutionError = exports2.MongoStalePrimaryError = exports2.MongoRuntimeError = exports2.MongoAPIError = exports2.MongoDriverError = exports2.MongoServerError = exports2.MongoError = exports2.MongoErrorLabel = exports2.GET_MORE_RESUMABLE_CODES = exports2.MONGODB_ERROR_CODES = exports2.NODE_IS_RECOVERING_ERROR_MESSAGE = exports2.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = exports2.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = void 0;
    exports2.needsRetryableWriteLabel = needsRetryableWriteLabel;
    exports2.isRetryableWriteError = isRetryableWriteError;
    exports2.isRetryableReadError = isRetryableReadError;
    exports2.isNodeShuttingDownError = isNodeShuttingDownError;
    exports2.isSDAMUnrecoverableError = isSDAMUnrecoverableError;
    exports2.isNetworkTimeoutError = isNetworkTimeoutError;
    exports2.isResumableError = isResumableError;
    exports2.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = new RegExp("not master", "i");
    exports2.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = new RegExp("not master or secondary", "i");
    exports2.NODE_IS_RECOVERING_ERROR_MESSAGE = new RegExp("node is recovering", "i");
    exports2.MONGODB_ERROR_CODES = Object.freeze({
      HostUnreachable: 6,
      HostNotFound: 7,
      AuthenticationFailed: 18,
      NetworkTimeout: 89,
      ShutdownInProgress: 91,
      PrimarySteppedDown: 189,
      ExceededTimeLimit: 262,
      SocketException: 9001,
      NotWritablePrimary: 10107,
      InterruptedAtShutdown: 11600,
      InterruptedDueToReplStateChange: 11602,
      NotPrimaryNoSecondaryOk: 13435,
      NotPrimaryOrSecondary: 13436,
      StaleShardVersion: 63,
      StaleEpoch: 150,
      StaleConfig: 13388,
      RetryChangeStream: 234,
      FailedToSatisfyReadPreference: 133,
      CursorNotFound: 43,
      LegacyNotPrimary: 10058,
      // WriteConcernTimeout is WriteConcernFailed on pre-8.1 servers
      WriteConcernTimeout: 64,
      NamespaceNotFound: 26,
      IllegalOperation: 20,
      MaxTimeMSExpired: 50,
      UnknownReplWriteConcern: 79,
      UnsatisfiableWriteConcern: 100,
      Reauthenticate: 391,
      ReadConcernMajorityNotAvailableYet: 134
    });
    exports2.GET_MORE_RESUMABLE_CODES = /* @__PURE__ */ new Set([
      exports2.MONGODB_ERROR_CODES.HostUnreachable,
      exports2.MONGODB_ERROR_CODES.HostNotFound,
      exports2.MONGODB_ERROR_CODES.NetworkTimeout,
      exports2.MONGODB_ERROR_CODES.ShutdownInProgress,
      exports2.MONGODB_ERROR_CODES.PrimarySteppedDown,
      exports2.MONGODB_ERROR_CODES.ExceededTimeLimit,
      exports2.MONGODB_ERROR_CODES.SocketException,
      exports2.MONGODB_ERROR_CODES.NotWritablePrimary,
      exports2.MONGODB_ERROR_CODES.InterruptedAtShutdown,
      exports2.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
      exports2.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
      exports2.MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
      exports2.MONGODB_ERROR_CODES.StaleShardVersion,
      exports2.MONGODB_ERROR_CODES.StaleEpoch,
      exports2.MONGODB_ERROR_CODES.StaleConfig,
      exports2.MONGODB_ERROR_CODES.RetryChangeStream,
      exports2.MONGODB_ERROR_CODES.FailedToSatisfyReadPreference,
      exports2.MONGODB_ERROR_CODES.CursorNotFound
    ]);
    exports2.MongoErrorLabel = Object.freeze({
      RetryableWriteError: "RetryableWriteError",
      TransientTransactionError: "TransientTransactionError",
      UnknownTransactionCommitResult: "UnknownTransactionCommitResult",
      ResumableChangeStreamError: "ResumableChangeStreamError",
      HandshakeError: "HandshakeError",
      ResetPool: "ResetPool",
      PoolRequstedRetry: "PoolRequstedRetry",
      InterruptInUseConnections: "InterruptInUseConnections",
      NoWritesPerformed: "NoWritesPerformed"
    });
    function isAggregateError(e) {
      return e != null && typeof e === "object" && "errors" in e && Array.isArray(e.errors);
    }
    var MongoError = class extends Error {
      get errorLabels() {
        return Array.from(this.errorLabelSet);
      }
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options2) {
        super(message, options2);
        this.errorLabelSet = /* @__PURE__ */ new Set();
      }
      /** @internal */
      static buildErrorMessage(e) {
        if (typeof e === "string") {
          return e;
        }
        if (isAggregateError(e) && e.message.length === 0) {
          return e.errors.length === 0 ? "AggregateError has an empty errors array. Please check the `cause` property for more information." : e.errors.map(({ message }) => message).join(", ");
        }
        return e != null && typeof e === "object" && "message" in e && typeof e.message === "string" ? e.message : "empty error message";
      }
      get name() {
        return "MongoError";
      }
      /** Legacy name for server error responses */
      get errmsg() {
        return this.message;
      }
      /**
       * Checks the error to see if it has an error label
       *
       * @param label - The error label to check for
       * @returns returns true if the error has the provided error label
       */
      hasErrorLabel(label) {
        return this.errorLabelSet.has(label);
      }
      addErrorLabel(label) {
        this.errorLabelSet.add(label);
      }
    };
    exports2.MongoError = MongoError;
    var MongoServerError = class extends MongoError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message.message || message.errmsg || message.$err || "n/a");
        if (message.errorLabels) {
          for (const label of message.errorLabels)
            this.addErrorLabel(label);
        }
        this.errorResponse = message;
        for (const name in message) {
          if (name !== "errorLabels" && name !== "errmsg" && name !== "message" && name !== "errorResponse") {
            this[name] = message[name];
          }
        }
      }
      get name() {
        return "MongoServerError";
      }
    };
    exports2.MongoServerError = MongoServerError;
    var MongoDriverError = class extends MongoError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options2) {
        super(message, options2);
      }
      get name() {
        return "MongoDriverError";
      }
    };
    exports2.MongoDriverError = MongoDriverError;
    var MongoAPIError = class extends MongoDriverError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options2) {
        super(message, options2);
      }
      get name() {
        return "MongoAPIError";
      }
    };
    exports2.MongoAPIError = MongoAPIError;
    var MongoRuntimeError = class extends MongoDriverError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options2) {
        super(message, options2);
      }
      get name() {
        return "MongoRuntimeError";
      }
    };
    exports2.MongoRuntimeError = MongoRuntimeError;
    var MongoStalePrimaryError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options2) {
        super(message, options2);
      }
      get name() {
        return "MongoStalePrimaryError";
      }
    };
    exports2.MongoStalePrimaryError = MongoStalePrimaryError;
    var MongoBatchReExecutionError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message = "This batch has already been executed, create new batch to execute") {
        super(message);
      }
      get name() {
        return "MongoBatchReExecutionError";
      }
    };
    exports2.MongoBatchReExecutionError = MongoBatchReExecutionError;
    var MongoDecompressionError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoDecompressionError";
      }
    };
    exports2.MongoDecompressionError = MongoDecompressionError;
    var MongoNotConnectedError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoNotConnectedError";
      }
    };
    exports2.MongoNotConnectedError = MongoNotConnectedError;
    var MongoTransactionError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoTransactionError";
      }
    };
    exports2.MongoTransactionError = MongoTransactionError;
    var MongoExpiredSessionError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message = "Cannot use a session that has ended") {
        super(message);
      }
      get name() {
        return "MongoExpiredSessionError";
      }
    };
    exports2.MongoExpiredSessionError = MongoExpiredSessionError;
    var MongoKerberosError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoKerberosError";
      }
    };
    exports2.MongoKerberosError = MongoKerberosError;
    var MongoAWSError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options2) {
        super(message, options2);
      }
      get name() {
        return "MongoAWSError";
      }
    };
    exports2.MongoAWSError = MongoAWSError;
    var MongoOIDCError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoOIDCError";
      }
    };
    exports2.MongoOIDCError = MongoOIDCError;
    var MongoAzureError = class extends MongoOIDCError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoAzureError";
      }
    };
    exports2.MongoAzureError = MongoAzureError;
    var MongoGCPError = class extends MongoOIDCError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoGCPError";
      }
    };
    exports2.MongoGCPError = MongoGCPError;
    var MongoClientBulkWriteError = class extends MongoServerError {
      /**
       * Initialize the client bulk write error.
       * @param message - The error message.
       */
      constructor(message) {
        super(message);
        this.writeConcernErrors = [];
        this.writeErrors = /* @__PURE__ */ new Map();
      }
      get name() {
        return "MongoClientBulkWriteError";
      }
    };
    exports2.MongoClientBulkWriteError = MongoClientBulkWriteError;
    var MongoClientBulkWriteCursorError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoClientBulkWriteCursorError";
      }
    };
    exports2.MongoClientBulkWriteCursorError = MongoClientBulkWriteCursorError;
    var MongoClientBulkWriteExecutionError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoClientBulkWriteExecutionError";
      }
    };
    exports2.MongoClientBulkWriteExecutionError = MongoClientBulkWriteExecutionError;
    var MongoChangeStreamError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoChangeStreamError";
      }
    };
    exports2.MongoChangeStreamError = MongoChangeStreamError;
    var MongoTailableCursorError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message = "Tailable cursor does not support this operation") {
        super(message);
      }
      get name() {
        return "MongoTailableCursorError";
      }
    };
    exports2.MongoTailableCursorError = MongoTailableCursorError;
    var MongoGridFSStreamError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoGridFSStreamError";
      }
    };
    exports2.MongoGridFSStreamError = MongoGridFSStreamError;
    var MongoGridFSChunkError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoGridFSChunkError";
      }
    };
    exports2.MongoGridFSChunkError = MongoGridFSChunkError;
    var MongoUnexpectedServerResponseError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options2) {
        super(message, options2);
      }
      get name() {
        return "MongoUnexpectedServerResponseError";
      }
    };
    exports2.MongoUnexpectedServerResponseError = MongoUnexpectedServerResponseError;
    var MongoOperationTimeoutError = class extends MongoDriverError {
      get name() {
        return "MongoOperationTimeoutError";
      }
    };
    exports2.MongoOperationTimeoutError = MongoOperationTimeoutError;
    var MongoCursorInUseError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message = "Cursor is already initialized") {
        super(message);
      }
      get name() {
        return "MongoCursorInUseError";
      }
    };
    exports2.MongoCursorInUseError = MongoCursorInUseError;
    var MongoServerClosedError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message = "Server is closed") {
        super(message);
      }
      get name() {
        return "MongoServerClosedError";
      }
    };
    exports2.MongoServerClosedError = MongoServerClosedError;
    var MongoCursorExhaustedError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message || "Cursor is exhausted");
      }
      get name() {
        return "MongoCursorExhaustedError";
      }
    };
    exports2.MongoCursorExhaustedError = MongoCursorExhaustedError;
    var MongoTopologyClosedError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message = "Topology is closed") {
        super(message);
      }
      get name() {
        return "MongoTopologyClosedError";
      }
    };
    exports2.MongoTopologyClosedError = MongoTopologyClosedError;
    var MongoClientClosedError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor() {
        super("Operation interrupted because client was closed");
      }
      get name() {
        return "MongoClientClosedError";
      }
    };
    exports2.MongoClientClosedError = MongoClientClosedError;
    var MongoNetworkError = class extends MongoError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options2) {
        super(message, { cause: options2?.cause });
        this.beforeHandshake = !!options2?.beforeHandshake;
      }
      get name() {
        return "MongoNetworkError";
      }
    };
    exports2.MongoNetworkError = MongoNetworkError;
    var MongoNetworkTimeoutError = class extends MongoNetworkError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options2) {
        super(message, options2);
      }
      get name() {
        return "MongoNetworkTimeoutError";
      }
    };
    exports2.MongoNetworkTimeoutError = MongoNetworkTimeoutError;
    var MongoParseError = class extends MongoDriverError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoParseError";
      }
    };
    exports2.MongoParseError = MongoParseError;
    var MongoInvalidArgumentError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options2) {
        super(message, options2);
      }
      get name() {
        return "MongoInvalidArgumentError";
      }
    };
    exports2.MongoInvalidArgumentError = MongoInvalidArgumentError;
    var MongoCompatibilityError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoCompatibilityError";
      }
    };
    exports2.MongoCompatibilityError = MongoCompatibilityError;
    var MongoMissingCredentialsError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoMissingCredentialsError";
      }
    };
    exports2.MongoMissingCredentialsError = MongoMissingCredentialsError;
    var MongoMissingDependencyError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options2) {
        super(message, options2);
        this.dependencyName = options2.dependencyName;
      }
      get name() {
        return "MongoMissingDependencyError";
      }
    };
    exports2.MongoMissingDependencyError = MongoMissingDependencyError;
    var MongoSystemError = class extends MongoError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, reason) {
        if (reason && reason.error) {
          super(MongoError.buildErrorMessage(reason.error.message || reason.error), {
            cause: reason.error
          });
        } else {
          super(message);
        }
        if (reason) {
          this.reason = reason;
        }
        this.code = reason.error?.code;
      }
      get name() {
        return "MongoSystemError";
      }
    };
    exports2.MongoSystemError = MongoSystemError;
    var MongoServerSelectionError = class extends MongoSystemError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, reason) {
        super(message, reason);
      }
      get name() {
        return "MongoServerSelectionError";
      }
    };
    exports2.MongoServerSelectionError = MongoServerSelectionError;
    var MongoWriteConcernError = class extends MongoServerError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(result) {
        super({ ...result.writeConcernError, ...result });
        this.errInfo = result.writeConcernError.errInfo;
        this.result = result;
      }
      get name() {
        return "MongoWriteConcernError";
      }
    };
    exports2.MongoWriteConcernError = MongoWriteConcernError;
    var RETRYABLE_READ_ERROR_CODES = /* @__PURE__ */ new Set([
      exports2.MONGODB_ERROR_CODES.HostUnreachable,
      exports2.MONGODB_ERROR_CODES.HostNotFound,
      exports2.MONGODB_ERROR_CODES.NetworkTimeout,
      exports2.MONGODB_ERROR_CODES.ShutdownInProgress,
      exports2.MONGODB_ERROR_CODES.PrimarySteppedDown,
      exports2.MONGODB_ERROR_CODES.SocketException,
      exports2.MONGODB_ERROR_CODES.NotWritablePrimary,
      exports2.MONGODB_ERROR_CODES.InterruptedAtShutdown,
      exports2.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
      exports2.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
      exports2.MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
      exports2.MONGODB_ERROR_CODES.ExceededTimeLimit,
      exports2.MONGODB_ERROR_CODES.ReadConcernMajorityNotAvailableYet
    ]);
    var RETRYABLE_WRITE_ERROR_CODES = RETRYABLE_READ_ERROR_CODES;
    function needsRetryableWriteLabel(error2, maxWireVersion, serverType) {
      if (error2 instanceof MongoNetworkError) {
        return true;
      }
      if (error2 instanceof MongoError) {
        if ((maxWireVersion >= 9 || isRetryableWriteError(error2)) && !error2.hasErrorLabel(exports2.MongoErrorLabel.HandshakeError)) {
          return false;
        }
      }
      if (error2 instanceof MongoWriteConcernError) {
        if (serverType === "Mongos" && maxWireVersion < 9) {
          return RETRYABLE_WRITE_ERROR_CODES.has(error2.result.code ?? 0);
        }
        const code = error2.result.writeConcernError.code ?? Number(error2.code);
        return RETRYABLE_WRITE_ERROR_CODES.has(Number.isNaN(code) ? 0 : code);
      }
      if (error2 instanceof MongoError) {
        return RETRYABLE_WRITE_ERROR_CODES.has(Number(error2.code));
      }
      const isNotWritablePrimaryError2 = exports2.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error2.message);
      if (isNotWritablePrimaryError2) {
        return true;
      }
      const isNodeIsRecoveringError = exports2.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error2.message);
      if (isNodeIsRecoveringError) {
        return true;
      }
      return false;
    }
    function isRetryableWriteError(error2) {
      return error2.hasErrorLabel(exports2.MongoErrorLabel.RetryableWriteError) || error2.hasErrorLabel(exports2.MongoErrorLabel.PoolRequstedRetry);
    }
    function isRetryableReadError(error2) {
      const hasRetryableErrorCode = typeof error2.code === "number" ? RETRYABLE_READ_ERROR_CODES.has(error2.code) : false;
      if (hasRetryableErrorCode) {
        return true;
      }
      if (error2 instanceof MongoNetworkError) {
        return true;
      }
      const isNotWritablePrimaryError2 = exports2.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error2.message);
      if (isNotWritablePrimaryError2) {
        return true;
      }
      const isNodeIsRecoveringError = exports2.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error2.message);
      if (isNodeIsRecoveringError) {
        return true;
      }
      return false;
    }
    var SDAM_RECOVERING_CODES = /* @__PURE__ */ new Set([
      exports2.MONGODB_ERROR_CODES.ShutdownInProgress,
      exports2.MONGODB_ERROR_CODES.PrimarySteppedDown,
      exports2.MONGODB_ERROR_CODES.InterruptedAtShutdown,
      exports2.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
      exports2.MONGODB_ERROR_CODES.NotPrimaryOrSecondary
    ]);
    var SDAM_NOT_PRIMARY_CODES = /* @__PURE__ */ new Set([
      exports2.MONGODB_ERROR_CODES.NotWritablePrimary,
      exports2.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
      exports2.MONGODB_ERROR_CODES.LegacyNotPrimary
    ]);
    var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = /* @__PURE__ */ new Set([
      exports2.MONGODB_ERROR_CODES.InterruptedAtShutdown,
      exports2.MONGODB_ERROR_CODES.ShutdownInProgress
    ]);
    function isRecoveringError(err) {
      if (typeof err.code === "number") {
        return SDAM_RECOVERING_CODES.has(err.code);
      }
      return exports2.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE.test(err.message) || exports2.NODE_IS_RECOVERING_ERROR_MESSAGE.test(err.message);
    }
    function isNotWritablePrimaryError(err) {
      if (typeof err.code === "number") {
        return SDAM_NOT_PRIMARY_CODES.has(err.code);
      }
      if (isRecoveringError(err)) {
        return false;
      }
      return exports2.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(err.message);
    }
    function isNodeShuttingDownError(err) {
      return !!(typeof err.code === "number" && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code));
    }
    function isSDAMUnrecoverableError(error2) {
      if (error2 instanceof MongoParseError || error2 == null) {
        return true;
      }
      return isRecoveringError(error2) || isNotWritablePrimaryError(error2);
    }
    function isNetworkTimeoutError(err) {
      return !!(err instanceof MongoNetworkError && err.message.match(/timed out/));
    }
    function isResumableError(error2, wireVersion) {
      if (error2 == null || !(error2 instanceof MongoError)) {
        return false;
      }
      if (error2 instanceof MongoNetworkError) {
        return true;
      }
      if (wireVersion != null && wireVersion >= 9) {
        if (error2.code === exports2.MONGODB_ERROR_CODES.CursorNotFound) {
          return true;
        }
        return error2.hasErrorLabel(exports2.MongoErrorLabel.ResumableChangeStreamError);
      }
      if (typeof error2.code === "number") {
        return exports2.GET_MORE_RESUMABLE_CODES.has(error2.code);
      }
      return false;
    }
  }
});

// node_modules/mongodb/lib/read_preference.js
var require_read_preference = __commonJS({
  "node_modules/mongodb/lib/read_preference.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadPreference = exports2.ReadPreferenceMode = void 0;
    var error_1 = require_error();
    exports2.ReadPreferenceMode = Object.freeze({
      primary: "primary",
      primaryPreferred: "primaryPreferred",
      secondary: "secondary",
      secondaryPreferred: "secondaryPreferred",
      nearest: "nearest"
    });
    var ReadPreference = class _ReadPreference {
      /**
       * @param mode - A string describing the read preference mode (primary|primaryPreferred|secondary|secondaryPreferred|nearest)
       * @param tags - A tag set used to target reads to members with the specified tag(s). tagSet is not available if using read preference mode primary.
       * @param options - Additional read preference options
       */
      constructor(mode, tags, options2) {
        if (!_ReadPreference.isValid(mode)) {
          throw new error_1.MongoInvalidArgumentError(`Invalid read preference mode ${JSON.stringify(mode)}`);
        }
        if (options2 == null && typeof tags === "object" && !Array.isArray(tags)) {
          options2 = tags;
          tags = void 0;
        } else if (tags && !Array.isArray(tags)) {
          throw new error_1.MongoInvalidArgumentError("ReadPreference tags must be an array");
        }
        this.mode = mode;
        this.tags = tags;
        this.hedge = options2?.hedge;
        this.maxStalenessSeconds = void 0;
        this.minWireVersion = void 0;
        options2 = options2 ?? {};
        if (options2.maxStalenessSeconds != null) {
          if (options2.maxStalenessSeconds <= 0) {
            throw new error_1.MongoInvalidArgumentError("maxStalenessSeconds must be a positive integer");
          }
          this.maxStalenessSeconds = options2.maxStalenessSeconds;
          this.minWireVersion = 5;
        }
        if (this.mode === _ReadPreference.PRIMARY) {
          if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
            throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with tags");
          }
          if (this.maxStalenessSeconds) {
            throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with maxStalenessSeconds");
          }
          if (this.hedge) {
            throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with hedge");
          }
        }
      }
      // Support the deprecated `preference` property introduced in the porcelain layer
      get preference() {
        return this.mode;
      }
      static fromString(mode) {
        return new _ReadPreference(mode);
      }
      /**
       * Construct a ReadPreference given an options object.
       *
       * @param options - The options object from which to extract the read preference.
       */
      static fromOptions(options2) {
        if (!options2)
          return;
        const readPreference = options2.readPreference ?? options2.session?.transaction.options.readPreference;
        const readPreferenceTags = options2.readPreferenceTags;
        if (readPreference == null) {
          return;
        }
        if (typeof readPreference === "string") {
          return new _ReadPreference(readPreference, readPreferenceTags, {
            maxStalenessSeconds: options2.maxStalenessSeconds,
            hedge: options2.hedge
          });
        } else if (!(readPreference instanceof _ReadPreference) && typeof readPreference === "object") {
          const mode = readPreference.mode || readPreference.preference;
          if (mode && typeof mode === "string") {
            return new _ReadPreference(mode, readPreference.tags ?? readPreferenceTags, {
              maxStalenessSeconds: readPreference.maxStalenessSeconds,
              hedge: options2.hedge
            });
          }
        }
        if (readPreferenceTags) {
          readPreference.tags = readPreferenceTags;
        }
        return readPreference;
      }
      /**
       * Replaces options.readPreference with a ReadPreference instance
       */
      static translate(options2) {
        if (options2.readPreference == null)
          return options2;
        const r = options2.readPreference;
        if (typeof r === "string") {
          options2.readPreference = new _ReadPreference(r);
        } else if (r && !(r instanceof _ReadPreference) && typeof r === "object") {
          const mode = r.mode || r.preference;
          if (mode && typeof mode === "string") {
            options2.readPreference = new _ReadPreference(mode, r.tags, {
              maxStalenessSeconds: r.maxStalenessSeconds
            });
          }
        } else if (!(r instanceof _ReadPreference)) {
          throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${r}`);
        }
        return options2;
      }
      /**
       * Validate if a mode is legal
       *
       * @param mode - The string representing the read preference mode.
       */
      static isValid(mode) {
        const VALID_MODES = /* @__PURE__ */ new Set([
          _ReadPreference.PRIMARY,
          _ReadPreference.PRIMARY_PREFERRED,
          _ReadPreference.SECONDARY,
          _ReadPreference.SECONDARY_PREFERRED,
          _ReadPreference.NEAREST,
          null
        ]);
        return VALID_MODES.has(mode);
      }
      /**
       * Validate if a mode is legal
       *
       * @param mode - The string representing the read preference mode.
       */
      isValid(mode) {
        return _ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
      }
      /**
       * Indicates that this readPreference needs the "SecondaryOk" bit when sent over the wire
       * @see https://www.mongodb.com/docs/manual/reference/mongodb-wire-protocol/#op-query
       */
      secondaryOk() {
        const NEEDS_SECONDARYOK = /* @__PURE__ */ new Set([
          _ReadPreference.PRIMARY_PREFERRED,
          _ReadPreference.SECONDARY,
          _ReadPreference.SECONDARY_PREFERRED,
          _ReadPreference.NEAREST
        ]);
        return NEEDS_SECONDARYOK.has(this.mode);
      }
      /**
       * Check if the two ReadPreferences are equivalent
       *
       * @param readPreference - The read preference with which to check equality
       */
      equals(readPreference) {
        return readPreference.mode === this.mode;
      }
      /** Return JSON representation */
      toJSON() {
        const readPreference = { mode: this.mode };
        if (Array.isArray(this.tags))
          readPreference.tags = this.tags;
        if (this.maxStalenessSeconds)
          readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
        if (this.hedge)
          readPreference.hedge = this.hedge;
        return readPreference;
      }
    };
    exports2.ReadPreference = ReadPreference;
    ReadPreference.PRIMARY = exports2.ReadPreferenceMode.primary;
    ReadPreference.PRIMARY_PREFERRED = exports2.ReadPreferenceMode.primaryPreferred;
    ReadPreference.SECONDARY = exports2.ReadPreferenceMode.secondary;
    ReadPreference.SECONDARY_PREFERRED = exports2.ReadPreferenceMode.secondaryPreferred;
    ReadPreference.NEAREST = exports2.ReadPreferenceMode.nearest;
    ReadPreference.primary = new ReadPreference(exports2.ReadPreferenceMode.primary);
    ReadPreference.primaryPreferred = new ReadPreference(exports2.ReadPreferenceMode.primaryPreferred);
    ReadPreference.secondary = new ReadPreference(exports2.ReadPreferenceMode.secondary);
    ReadPreference.secondaryPreferred = new ReadPreference(exports2.ReadPreferenceMode.secondaryPreferred);
    ReadPreference.nearest = new ReadPreference(exports2.ReadPreferenceMode.nearest);
  }
});

// node_modules/mongodb/lib/sdam/common.js
var require_common2 = __commonJS({
  "node_modules/mongodb/lib/sdam/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerType = exports2.TopologyType = exports2.STATE_CONNECTED = exports2.STATE_CONNECTING = exports2.STATE_CLOSED = exports2.STATE_CLOSING = void 0;
    exports2._advanceClusterTime = _advanceClusterTime;
    exports2.STATE_CLOSING = "closing";
    exports2.STATE_CLOSED = "closed";
    exports2.STATE_CONNECTING = "connecting";
    exports2.STATE_CONNECTED = "connected";
    exports2.TopologyType = Object.freeze({
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown",
      LoadBalanced: "LoadBalanced"
    });
    exports2.ServerType = Object.freeze({
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown",
      LoadBalancer: "LoadBalancer"
    });
    function _advanceClusterTime(entity, $clusterTime) {
      if (entity.clusterTime == null) {
        entity.clusterTime = $clusterTime;
      } else {
        if ($clusterTime.clusterTime.greaterThan(entity.clusterTime.clusterTime)) {
          entity.clusterTime = $clusterTime;
        }
      }
    }
  }
});

// node_modules/mongodb/lib/sdam/server_selection.js
var require_server_selection = __commonJS({
  "node_modules/mongodb/lib/sdam/server_selection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MIN_SECONDARY_WRITE_WIRE_VERSION = void 0;
    exports2.writableServerSelector = writableServerSelector;
    exports2.sameServerSelector = sameServerSelector;
    exports2.secondaryWritableServerSelector = secondaryWritableServerSelector;
    exports2.readPreferenceServerSelector = readPreferenceServerSelector;
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var common_1 = require_common2();
    var IDLE_WRITE_PERIOD = 1e4;
    var SMALLEST_MAX_STALENESS_SECONDS = 90;
    exports2.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;
    function writableServerSelector() {
      return function writableServer(topologyDescription, servers) {
        return latencyWindowReducer(topologyDescription, servers.filter((s) => s.isWritable));
      };
    }
    function sameServerSelector(description) {
      return function sameServerSelector2(topologyDescription, servers) {
        if (!description)
          return [];
        return servers.filter((sd) => {
          return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;
        });
      };
    }
    function secondaryWritableServerSelector(wireVersion, readPreference) {
      if (!readPreference || !wireVersion || wireVersion && wireVersion < exports2.MIN_SECONDARY_WRITE_WIRE_VERSION) {
        return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);
      }
      return readPreferenceServerSelector(readPreference);
    }
    function maxStalenessReducer(readPreference, topologyDescription, servers) {
      if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
        return servers;
      }
      const maxStaleness = readPreference.maxStalenessSeconds;
      const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1e3;
      if (maxStaleness < maxStalenessVariance) {
        throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${maxStalenessVariance} seconds`);
      }
      if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
        throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
      }
      if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {
        const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
        return servers.reduce((result, server) => {
          const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;
          if (staleness <= maxStalenessSeconds) {
            result.push(server);
          }
          return result;
        }, []);
      }
      if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {
        if (servers.length === 0) {
          return servers;
        }
        const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);
        return servers.reduce((result, server) => {
          const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;
          if (staleness <= maxStalenessSeconds) {
            result.push(server);
          }
          return result;
        }, []);
      }
      return servers;
    }
    function tagSetMatch(tagSet, serverTags) {
      const keys = Object.keys(tagSet);
      const serverTagKeys = Object.keys(serverTags);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
          return false;
        }
      }
      return true;
    }
    function tagSetReducer(readPreference, servers) {
      if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
        return servers;
      }
      for (let i = 0; i < readPreference.tags.length; ++i) {
        const tagSet = readPreference.tags[i];
        const serversMatchingTagset = servers.reduce((matched, server) => {
          if (tagSetMatch(tagSet, server.tags))
            matched.push(server);
          return matched;
        }, []);
        if (serversMatchingTagset.length) {
          return serversMatchingTagset;
        }
      }
      return [];
    }
    function latencyWindowReducer(topologyDescription, servers) {
      const low = servers.reduce((min, server) => Math.min(server.roundTripTime, min), Infinity);
      const high = low + topologyDescription.localThresholdMS;
      return servers.reduce((result, server) => {
        if (server.roundTripTime <= high && server.roundTripTime >= low)
          result.push(server);
        return result;
      }, []);
    }
    function primaryFilter(server) {
      return server.type === common_1.ServerType.RSPrimary;
    }
    function secondaryFilter(server) {
      return server.type === common_1.ServerType.RSSecondary;
    }
    function nearestFilter(server) {
      return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;
    }
    function knownFilter(server) {
      return server.type !== common_1.ServerType.Unknown;
    }
    function loadBalancerFilter(server) {
      return server.type === common_1.ServerType.LoadBalancer;
    }
    function readPreferenceServerSelector(readPreference) {
      if (!readPreference.isValid()) {
        throw new error_1.MongoInvalidArgumentError("Invalid read preference specified");
      }
      return function readPreferenceServers(topologyDescription, servers, deprioritized = []) {
        const commonWireVersion = topologyDescription.commonWireVersion;
        if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
          throw new error_1.MongoCompatibilityError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
        }
        if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {
          return servers.filter(loadBalancerFilter);
        }
        if (topologyDescription.type === common_1.TopologyType.Unknown) {
          return [];
        }
        if (topologyDescription.type === common_1.TopologyType.Single) {
          return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
        }
        if (topologyDescription.type === common_1.TopologyType.Sharded) {
          const filtered = servers.filter((server) => {
            return !deprioritized.includes(server);
          });
          const selectable = filtered.length > 0 ? filtered : deprioritized;
          return latencyWindowReducer(topologyDescription, selectable.filter(knownFilter));
        }
        const mode = readPreference.mode;
        if (mode === read_preference_1.ReadPreference.PRIMARY) {
          return servers.filter(primaryFilter);
        }
        if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {
          const result = servers.filter(primaryFilter);
          if (result.length) {
            return result;
          }
        }
        const filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
        const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));
        if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
          return servers.filter(primaryFilter);
        }
        return selectedServers;
      };
    }
  }
});

// node_modules/mongodb/lib/cmap/wire_protocol/constants.js
var require_constants3 = __commonJS({
  "node_modules/mongodb/lib/cmap/wire_protocol/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OP_MSG = exports2.OP_COMPRESSED = exports2.OP_DELETE = exports2.OP_QUERY = exports2.OP_INSERT = exports2.OP_UPDATE = exports2.OP_REPLY = exports2.MIN_SUPPORTED_QE_SERVER_VERSION = exports2.MIN_SUPPORTED_QE_WIRE_VERSION = exports2.MAX_SUPPORTED_WIRE_VERSION = exports2.MIN_SUPPORTED_WIRE_VERSION = exports2.MAX_SUPPORTED_SERVER_VERSION = exports2.MIN_SUPPORTED_SERVER_VERSION = void 0;
    exports2.MIN_SUPPORTED_SERVER_VERSION = "4.2";
    exports2.MAX_SUPPORTED_SERVER_VERSION = "8.0";
    exports2.MIN_SUPPORTED_WIRE_VERSION = 8;
    exports2.MAX_SUPPORTED_WIRE_VERSION = 25;
    exports2.MIN_SUPPORTED_QE_WIRE_VERSION = 21;
    exports2.MIN_SUPPORTED_QE_SERVER_VERSION = "7.0";
    exports2.OP_REPLY = 1;
    exports2.OP_UPDATE = 2001;
    exports2.OP_INSERT = 2002;
    exports2.OP_QUERY = 2004;
    exports2.OP_DELETE = 2006;
    exports2.OP_COMPRESSED = 2012;
    exports2.OP_MSG = 2013;
  }
});

// node_modules/mongodb/lib/constants.js
var require_constants4 = __commonJS({
  "node_modules/mongodb/lib/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.END = exports2.CHANGE = exports2.INIT = exports2.MORE = exports2.RESPONSE = exports2.SERVER_HEARTBEAT_FAILED = exports2.SERVER_HEARTBEAT_SUCCEEDED = exports2.SERVER_HEARTBEAT_STARTED = exports2.COMMAND_FAILED = exports2.COMMAND_SUCCEEDED = exports2.COMMAND_STARTED = exports2.CLUSTER_TIME_RECEIVED = exports2.CONNECTION_CHECKED_IN = exports2.CONNECTION_CHECKED_OUT = exports2.CONNECTION_CHECK_OUT_FAILED = exports2.CONNECTION_CHECK_OUT_STARTED = exports2.CONNECTION_CLOSED = exports2.CONNECTION_READY = exports2.CONNECTION_CREATED = exports2.CONNECTION_POOL_READY = exports2.CONNECTION_POOL_CLEARED = exports2.CONNECTION_POOL_CLOSED = exports2.CONNECTION_POOL_CREATED = exports2.WAITING_FOR_SUITABLE_SERVER = exports2.SERVER_SELECTION_SUCCEEDED = exports2.SERVER_SELECTION_FAILED = exports2.SERVER_SELECTION_STARTED = exports2.TOPOLOGY_DESCRIPTION_CHANGED = exports2.TOPOLOGY_CLOSED = exports2.TOPOLOGY_OPENING = exports2.SERVER_DESCRIPTION_CHANGED = exports2.SERVER_CLOSED = exports2.SERVER_OPENING = exports2.DESCRIPTION_RECEIVED = exports2.UNPINNED = exports2.PINNED = exports2.MESSAGE = exports2.ENDED = exports2.CLOSED = exports2.CONNECT = exports2.OPEN = exports2.CLOSE = exports2.TIMEOUT = exports2.ERROR = exports2.SYSTEM_JS_COLLECTION = exports2.SYSTEM_COMMAND_COLLECTION = exports2.SYSTEM_USER_COLLECTION = exports2.SYSTEM_PROFILE_COLLECTION = exports2.SYSTEM_INDEX_COLLECTION = exports2.SYSTEM_NAMESPACE_COLLECTION = void 0;
    exports2.kDecoratedKeys = exports2.kDecorateResult = exports2.LEGACY_HELLO_COMMAND_CAMEL_CASE = exports2.LEGACY_HELLO_COMMAND = exports2.MONGO_CLIENT_EVENTS = exports2.LOCAL_SERVER_EVENTS = exports2.SERVER_RELAY_EVENTS = exports2.APM_EVENTS = exports2.TOPOLOGY_EVENTS = exports2.CMAP_EVENTS = exports2.HEARTBEAT_EVENTS = exports2.RESUME_TOKEN_CHANGED = void 0;
    exports2.SYSTEM_NAMESPACE_COLLECTION = "system.namespaces";
    exports2.SYSTEM_INDEX_COLLECTION = "system.indexes";
    exports2.SYSTEM_PROFILE_COLLECTION = "system.profile";
    exports2.SYSTEM_USER_COLLECTION = "system.users";
    exports2.SYSTEM_COMMAND_COLLECTION = "$cmd";
    exports2.SYSTEM_JS_COLLECTION = "system.js";
    exports2.ERROR = "error";
    exports2.TIMEOUT = "timeout";
    exports2.CLOSE = "close";
    exports2.OPEN = "open";
    exports2.CONNECT = "connect";
    exports2.CLOSED = "closed";
    exports2.ENDED = "ended";
    exports2.MESSAGE = "message";
    exports2.PINNED = "pinned";
    exports2.UNPINNED = "unpinned";
    exports2.DESCRIPTION_RECEIVED = "descriptionReceived";
    exports2.SERVER_OPENING = "serverOpening";
    exports2.SERVER_CLOSED = "serverClosed";
    exports2.SERVER_DESCRIPTION_CHANGED = "serverDescriptionChanged";
    exports2.TOPOLOGY_OPENING = "topologyOpening";
    exports2.TOPOLOGY_CLOSED = "topologyClosed";
    exports2.TOPOLOGY_DESCRIPTION_CHANGED = "topologyDescriptionChanged";
    exports2.SERVER_SELECTION_STARTED = "serverSelectionStarted";
    exports2.SERVER_SELECTION_FAILED = "serverSelectionFailed";
    exports2.SERVER_SELECTION_SUCCEEDED = "serverSelectionSucceeded";
    exports2.WAITING_FOR_SUITABLE_SERVER = "waitingForSuitableServer";
    exports2.CONNECTION_POOL_CREATED = "connectionPoolCreated";
    exports2.CONNECTION_POOL_CLOSED = "connectionPoolClosed";
    exports2.CONNECTION_POOL_CLEARED = "connectionPoolCleared";
    exports2.CONNECTION_POOL_READY = "connectionPoolReady";
    exports2.CONNECTION_CREATED = "connectionCreated";
    exports2.CONNECTION_READY = "connectionReady";
    exports2.CONNECTION_CLOSED = "connectionClosed";
    exports2.CONNECTION_CHECK_OUT_STARTED = "connectionCheckOutStarted";
    exports2.CONNECTION_CHECK_OUT_FAILED = "connectionCheckOutFailed";
    exports2.CONNECTION_CHECKED_OUT = "connectionCheckedOut";
    exports2.CONNECTION_CHECKED_IN = "connectionCheckedIn";
    exports2.CLUSTER_TIME_RECEIVED = "clusterTimeReceived";
    exports2.COMMAND_STARTED = "commandStarted";
    exports2.COMMAND_SUCCEEDED = "commandSucceeded";
    exports2.COMMAND_FAILED = "commandFailed";
    exports2.SERVER_HEARTBEAT_STARTED = "serverHeartbeatStarted";
    exports2.SERVER_HEARTBEAT_SUCCEEDED = "serverHeartbeatSucceeded";
    exports2.SERVER_HEARTBEAT_FAILED = "serverHeartbeatFailed";
    exports2.RESPONSE = "response";
    exports2.MORE = "more";
    exports2.INIT = "init";
    exports2.CHANGE = "change";
    exports2.END = "end";
    exports2.RESUME_TOKEN_CHANGED = "resumeTokenChanged";
    exports2.HEARTBEAT_EVENTS = Object.freeze([
      exports2.SERVER_HEARTBEAT_STARTED,
      exports2.SERVER_HEARTBEAT_SUCCEEDED,
      exports2.SERVER_HEARTBEAT_FAILED
    ]);
    exports2.CMAP_EVENTS = Object.freeze([
      exports2.CONNECTION_POOL_CREATED,
      exports2.CONNECTION_POOL_READY,
      exports2.CONNECTION_POOL_CLEARED,
      exports2.CONNECTION_POOL_CLOSED,
      exports2.CONNECTION_CREATED,
      exports2.CONNECTION_READY,
      exports2.CONNECTION_CLOSED,
      exports2.CONNECTION_CHECK_OUT_STARTED,
      exports2.CONNECTION_CHECK_OUT_FAILED,
      exports2.CONNECTION_CHECKED_OUT,
      exports2.CONNECTION_CHECKED_IN
    ]);
    exports2.TOPOLOGY_EVENTS = Object.freeze([
      exports2.SERVER_OPENING,
      exports2.SERVER_CLOSED,
      exports2.SERVER_DESCRIPTION_CHANGED,
      exports2.TOPOLOGY_OPENING,
      exports2.TOPOLOGY_CLOSED,
      exports2.TOPOLOGY_DESCRIPTION_CHANGED,
      exports2.ERROR,
      exports2.TIMEOUT,
      exports2.CLOSE
    ]);
    exports2.APM_EVENTS = Object.freeze([
      exports2.COMMAND_STARTED,
      exports2.COMMAND_SUCCEEDED,
      exports2.COMMAND_FAILED
    ]);
    exports2.SERVER_RELAY_EVENTS = Object.freeze([
      exports2.SERVER_HEARTBEAT_STARTED,
      exports2.SERVER_HEARTBEAT_SUCCEEDED,
      exports2.SERVER_HEARTBEAT_FAILED,
      exports2.COMMAND_STARTED,
      exports2.COMMAND_SUCCEEDED,
      exports2.COMMAND_FAILED,
      ...exports2.CMAP_EVENTS
    ]);
    exports2.LOCAL_SERVER_EVENTS = Object.freeze([
      exports2.CONNECT,
      exports2.DESCRIPTION_RECEIVED,
      exports2.CLOSED,
      exports2.ENDED
    ]);
    exports2.MONGO_CLIENT_EVENTS = Object.freeze([
      ...exports2.CMAP_EVENTS,
      ...exports2.APM_EVENTS,
      ...exports2.TOPOLOGY_EVENTS,
      ...exports2.HEARTBEAT_EVENTS
    ]);
    exports2.LEGACY_HELLO_COMMAND = "ismaster";
    exports2.LEGACY_HELLO_COMMAND_CAMEL_CASE = "isMaster";
    exports2.kDecorateResult = Symbol.for("@@mdb.decorateDecryptionResult");
    exports2.kDecoratedKeys = Symbol.for("@@mdb.decryptedKeys");
  }
});

// node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS({
  "node_modules/mongodb/lib/read_concern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadConcern = exports2.ReadConcernLevel = void 0;
    exports2.ReadConcernLevel = Object.freeze({
      local: "local",
      majority: "majority",
      linearizable: "linearizable",
      available: "available",
      snapshot: "snapshot"
    });
    var ReadConcern = class _ReadConcern {
      /** Constructs a ReadConcern from the read concern level.*/
      constructor(level) {
        this.level = exports2.ReadConcernLevel[level] ?? level;
      }
      /**
       * Construct a ReadConcern given an options object.
       *
       * @param options - The options object from which to extract the write concern.
       */
      static fromOptions(options2) {
        if (options2 == null) {
          return;
        }
        if (options2.readConcern) {
          const { readConcern } = options2;
          if (readConcern instanceof _ReadConcern) {
            return readConcern;
          } else if (typeof readConcern === "string") {
            return new _ReadConcern(readConcern);
          } else if ("level" in readConcern && readConcern.level) {
            return new _ReadConcern(readConcern.level);
          }
        }
        if (options2.level) {
          return new _ReadConcern(options2.level);
        }
        return;
      }
      static get MAJORITY() {
        return exports2.ReadConcernLevel.majority;
      }
      static get AVAILABLE() {
        return exports2.ReadConcernLevel.available;
      }
      static get LINEARIZABLE() {
        return exports2.ReadConcernLevel.linearizable;
      }
      static get SNAPSHOT() {
        return exports2.ReadConcernLevel.snapshot;
      }
      toJSON() {
        return { level: this.level };
      }
    };
    exports2.ReadConcern = ReadConcern;
  }
});

// node_modules/mongodb/lib/cmap/wire_protocol/on_demand/document.js
var require_document = __commonJS({
  "node_modules/mongodb/lib/cmap/wire_protocol/on_demand/document.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OnDemandDocument = void 0;
    var bson_1 = require_bson2();
    var OnDemandDocument = class _OnDemandDocument {
      constructor(bson, offset = 0, isArray = false, elements) {
        this.bson = bson;
        this.offset = offset;
        this.isArray = isArray;
        this.cache = /* @__PURE__ */ Object.create(null);
        this.indexFound = /* @__PURE__ */ Object.create(null);
        this.elements = elements ?? (0, bson_1.parseToElementsToArray)(this.bson, offset);
      }
      /** Only supports basic latin strings */
      isElementName(name, element) {
        const nameLength = element[
          2
          /* BSONElementOffset.nameLength */
        ];
        const nameOffset = element[
          1
          /* BSONElementOffset.nameOffset */
        ];
        if (name.length !== nameLength)
          return false;
        const nameEnd = nameOffset + nameLength;
        for (let byteIndex = nameOffset, charIndex = 0; charIndex < name.length && byteIndex < nameEnd; charIndex++, byteIndex++) {
          if (this.bson[byteIndex] !== name.charCodeAt(charIndex))
            return false;
        }
        return true;
      }
      /**
       * Seeks into the elements array for an element matching the given name.
       *
       * @remarks
       * Caching:
       * - Caches the existence of a property making subsequent look ups for non-existent properties return immediately
       * - Caches names mapped to elements to avoid reiterating the array and comparing the name again
       * - Caches the index at which an element has been found to prevent rechecking against elements already determined to belong to another name
       *
       * @param name - a basic latin string name of a BSON element
       * @returns
       */
      getElement(name) {
        const cachedElement = this.cache[name];
        if (cachedElement === false)
          return null;
        if (cachedElement != null) {
          return cachedElement;
        }
        if (typeof name === "number") {
          if (this.isArray) {
            if (name < this.elements.length) {
              const element = this.elements[name];
              const cachedElement2 = { element, value: void 0 };
              this.cache[name] = cachedElement2;
              this.indexFound[name] = true;
              return cachedElement2;
            } else {
              return null;
            }
          } else {
            return null;
          }
        }
        for (let index = 0; index < this.elements.length; index++) {
          const element = this.elements[index];
          if (!(index in this.indexFound) && this.isElementName(name, element)) {
            const cachedElement2 = { element, value: void 0 };
            this.cache[name] = cachedElement2;
            this.indexFound[index] = true;
            return cachedElement2;
          }
        }
        this.cache[name] = false;
        return null;
      }
      toJSValue(element, as) {
        const type = element[
          0
          /* BSONElementOffset.type */
        ];
        const offset = element[
          3
          /* BSONElementOffset.offset */
        ];
        const length = element[
          4
          /* BSONElementOffset.length */
        ];
        if (as !== type) {
          return null;
        }
        switch (as) {
          case bson_1.BSONType.null:
          case bson_1.BSONType.undefined:
            return null;
          case bson_1.BSONType.double:
            return (0, bson_1.getFloat64LE)(this.bson, offset);
          case bson_1.BSONType.int:
            return (0, bson_1.getInt32LE)(this.bson, offset);
          case bson_1.BSONType.long:
            return (0, bson_1.getBigInt64LE)(this.bson, offset);
          case bson_1.BSONType.bool:
            return Boolean(this.bson[offset]);
          case bson_1.BSONType.objectId:
            return new bson_1.ObjectId(this.bson.subarray(offset, offset + 12));
          case bson_1.BSONType.timestamp:
            return new bson_1.Timestamp((0, bson_1.getBigInt64LE)(this.bson, offset));
          case bson_1.BSONType.string:
            return (0, bson_1.toUTF8)(this.bson, offset + 4, offset + length - 1, false);
          case bson_1.BSONType.binData: {
            const totalBinarySize = (0, bson_1.getInt32LE)(this.bson, offset);
            const subType = this.bson[offset + 4];
            if (subType === 2) {
              const subType2BinarySize = (0, bson_1.getInt32LE)(this.bson, offset + 1 + 4);
              if (subType2BinarySize < 0)
                throw new bson_1.BSONError("Negative binary type element size found for subtype 0x02");
              if (subType2BinarySize > totalBinarySize - 4)
                throw new bson_1.BSONError("Binary type with subtype 0x02 contains too long binary size");
              if (subType2BinarySize < totalBinarySize - 4)
                throw new bson_1.BSONError("Binary type with subtype 0x02 contains too short binary size");
              return new bson_1.Binary(this.bson.subarray(offset + 1 + 4 + 4, offset + 1 + 4 + 4 + subType2BinarySize), 2);
            }
            return new bson_1.Binary(this.bson.subarray(offset + 1 + 4, offset + 1 + 4 + totalBinarySize), subType);
          }
          case bson_1.BSONType.date:
            return new Date(Number((0, bson_1.getBigInt64LE)(this.bson, offset)));
          case bson_1.BSONType.object:
            return new _OnDemandDocument(this.bson, offset);
          case bson_1.BSONType.array:
            return new _OnDemandDocument(this.bson, offset, true);
          default:
            throw new bson_1.BSONError(`Unsupported BSON type: ${as}`);
        }
      }
      /**
       * Returns the number of elements in this BSON document
       */
      size() {
        return this.elements.length;
      }
      /**
       * Checks for the existence of an element by name.
       *
       * @remarks
       * Uses `getElement` with the expectation that will populate caches such that a `has` call
       * followed by a `getElement` call will not repeat the cost paid by the first look up.
       *
       * @param name - element name
       */
      has(name) {
        const cachedElement = this.cache[name];
        if (cachedElement === false)
          return false;
        if (cachedElement != null)
          return true;
        return this.getElement(name) != null;
      }
      get(name, as, required) {
        const element = this.getElement(name);
        if (element == null) {
          if (required === true) {
            throw new bson_1.BSONError(`BSON element "${name}" is missing`);
          } else {
            return null;
          }
        }
        if (element.value == null) {
          const value = this.toJSValue(element.element, as);
          if (value == null) {
            if (required === true) {
              throw new bson_1.BSONError(`BSON element "${name}" is missing`);
            } else {
              return null;
            }
          }
          element.value = value;
        }
        return element.value;
      }
      getNumber(name, required) {
        const maybeBool = this.get(name, bson_1.BSONType.bool);
        const bool = maybeBool == null ? null : maybeBool ? 1 : 0;
        const maybeLong = this.get(name, bson_1.BSONType.long);
        const long = maybeLong == null ? null : Number(maybeLong);
        const result = bool ?? long ?? this.get(name, bson_1.BSONType.int) ?? this.get(name, bson_1.BSONType.double);
        if (required === true && result == null) {
          throw new bson_1.BSONError(`BSON element "${name}" is missing`);
        }
        return result;
      }
      /**
       * Deserialize this object, DOES NOT cache result so avoid multiple invocations
       * @param options - BSON deserialization options
       */
      toObject(options2) {
        return (0, bson_1.deserialize)(this.bson, {
          ...options2,
          index: this.offset,
          allowObjectSmallerThanBufferSize: true
        });
      }
      /** Returns this document's bytes only */
      toBytes() {
        const size = (0, bson_1.getInt32LE)(this.bson, this.offset);
        return this.bson.subarray(this.offset, this.offset + size);
      }
    };
    exports2.OnDemandDocument = OnDemandDocument;
  }
});

// node_modules/mongodb/lib/cmap/wire_protocol/responses.js
var require_responses = __commonJS({
  "node_modules/mongodb/lib/cmap/wire_protocol/responses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientBulkWriteCursorResponse = exports2.ExplainedCursorResponse = exports2.CursorResponse = exports2.MongoDBResponse = void 0;
    exports2.isErrorResponse = isErrorResponse;
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var document_1 = require_document();
    function isErrorResponse(bson, elements) {
      for (let eIdx = 0; eIdx < elements.length; eIdx++) {
        const element = elements[eIdx];
        if (element[
          2
          /* BSONElementOffset.nameLength */
        ] === 2) {
          const nameOffset = element[
            1
            /* BSONElementOffset.nameOffset */
          ];
          if (bson[nameOffset] === 111 && bson[nameOffset + 1] === 107) {
            const valueOffset = element[
              3
              /* BSONElementOffset.offset */
            ];
            const valueLength = element[
              4
              /* BSONElementOffset.length */
            ];
            for (let i = valueOffset; i < valueOffset + valueLength; i++) {
              if (bson[i] !== 0)
                return false;
            }
            return true;
          }
        }
      }
      return true;
    }
    var MongoDBResponse = class _MongoDBResponse extends document_1.OnDemandDocument {
      get(name, as, required) {
        try {
          return super.get(name, as, required);
        } catch (cause) {
          throw new error_1.MongoUnexpectedServerResponseError(cause.message, { cause });
        }
      }
      static is(value) {
        return value instanceof _MongoDBResponse;
      }
      static make(bson) {
        const elements = (0, bson_1.parseToElementsToArray)(bson, 0);
        const isError = isErrorResponse(bson, elements);
        return isError ? new _MongoDBResponse(bson, 0, false, elements) : new this(bson, 0, false, elements);
      }
      /**
       * Returns true iff:
       * - ok is 0 and the top-level code === 50
       * - ok is 1 and the writeErrors array contains a code === 50
       * - ok is 1 and the writeConcern object contains a code === 50
       */
      get isMaxTimeExpiredError() {
        const isTopLevel = this.ok === 0 && this.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
        if (isTopLevel)
          return true;
        if (this.ok === 0)
          return false;
        const isWriteConcern = this.get("writeConcernError", bson_1.BSONType.object)?.getNumber("code") === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
        if (isWriteConcern)
          return true;
        const writeErrors = this.get("writeErrors", bson_1.BSONType.array);
        if (writeErrors?.size()) {
          for (let i = 0; i < writeErrors.size(); i++) {
            const isWriteError = writeErrors.get(i, bson_1.BSONType.object)?.getNumber("code") === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
            if (isWriteError)
              return true;
          }
        }
        return false;
      }
      /**
       * Drivers can safely assume that the `recoveryToken` field is always a BSON document but drivers MUST NOT modify the
       * contents of the document.
       */
      get recoveryToken() {
        return this.get("recoveryToken", bson_1.BSONType.object)?.toObject({
          promoteValues: false,
          promoteLongs: false,
          promoteBuffers: false,
          validation: { utf8: true }
        }) ?? null;
      }
      /**
       * The server creates a cursor in response to a snapshot find/aggregate command and reports atClusterTime within the cursor field in the response.
       * For the distinct command the server adds a top-level atClusterTime field to the response.
       * The atClusterTime field represents the timestamp of the read and is guaranteed to be majority committed.
       */
      get atClusterTime() {
        return this.get("cursor", bson_1.BSONType.object)?.get("atClusterTime", bson_1.BSONType.timestamp) ?? this.get("atClusterTime", bson_1.BSONType.timestamp);
      }
      get operationTime() {
        return this.get("operationTime", bson_1.BSONType.timestamp);
      }
      /** Normalizes whatever BSON value is "ok" to a JS number 1 or 0. */
      get ok() {
        return this.getNumber("ok") ? 1 : 0;
      }
      get $err() {
        return this.get("$err", bson_1.BSONType.string);
      }
      get errmsg() {
        return this.get("errmsg", bson_1.BSONType.string);
      }
      get code() {
        return this.getNumber("code");
      }
      get $clusterTime() {
        if (!("clusterTime" in this)) {
          const clusterTimeDoc = this.get("$clusterTime", bson_1.BSONType.object);
          if (clusterTimeDoc == null) {
            this.clusterTime = null;
            return null;
          }
          const clusterTime = clusterTimeDoc.get("clusterTime", bson_1.BSONType.timestamp, true);
          const signature = clusterTimeDoc.get("signature", bson_1.BSONType.object)?.toObject();
          this.clusterTime = { clusterTime, signature };
        }
        return this.clusterTime ?? null;
      }
      toObject(options2) {
        const exactBSONOptions = {
          ...(0, bson_1.pluckBSONSerializeOptions)(options2 ?? {}),
          validation: (0, bson_1.parseUtf8ValidationOption)(options2)
        };
        return super.toObject(exactBSONOptions);
      }
    };
    exports2.MongoDBResponse = MongoDBResponse;
    MongoDBResponse.empty = new MongoDBResponse(new Uint8Array([13, 0, 0, 0, 16, 111, 107, 0, 1, 0, 0, 0, 0]));
    var CursorResponse = class _CursorResponse extends MongoDBResponse {
      constructor() {
        super(...arguments);
        this._batch = null;
        this.iterated = 0;
        this._encryptedBatch = null;
      }
      /**
       * This supports a feature of the FindCursor.
       * It is an optimization to avoid an extra getMore when the limit has been reached
       */
      static get emptyGetMore() {
        return new _CursorResponse((0, bson_1.serialize)({ ok: 1, cursor: { id: 0n, nextBatch: [] } }));
      }
      static is(value) {
        return value instanceof _CursorResponse || value === _CursorResponse.emptyGetMore;
      }
      get cursor() {
        return this.get("cursor", bson_1.BSONType.object, true);
      }
      get id() {
        try {
          return bson_1.Long.fromBigInt(this.cursor.get("id", bson_1.BSONType.long, true));
        } catch (cause) {
          throw new error_1.MongoUnexpectedServerResponseError(cause.message, { cause });
        }
      }
      get ns() {
        const namespace = this.cursor.get("ns", bson_1.BSONType.string);
        if (namespace != null)
          return (0, utils_1.ns)(namespace);
        return null;
      }
      get length() {
        return Math.max(this.batchSize - this.iterated, 0);
      }
      get encryptedBatch() {
        if (this.encryptedResponse == null)
          return null;
        if (this._encryptedBatch != null)
          return this._encryptedBatch;
        const cursor = this.encryptedResponse?.get("cursor", bson_1.BSONType.object);
        if (cursor?.has("firstBatch"))
          this._encryptedBatch = cursor.get("firstBatch", bson_1.BSONType.array, true);
        else if (cursor?.has("nextBatch"))
          this._encryptedBatch = cursor.get("nextBatch", bson_1.BSONType.array, true);
        else
          throw new error_1.MongoUnexpectedServerResponseError("Cursor document did not contain a batch");
        return this._encryptedBatch;
      }
      get batch() {
        if (this._batch != null)
          return this._batch;
        const cursor = this.cursor;
        if (cursor.has("firstBatch"))
          this._batch = cursor.get("firstBatch", bson_1.BSONType.array, true);
        else if (cursor.has("nextBatch"))
          this._batch = cursor.get("nextBatch", bson_1.BSONType.array, true);
        else
          throw new error_1.MongoUnexpectedServerResponseError("Cursor document did not contain a batch");
        return this._batch;
      }
      get batchSize() {
        return this.batch?.size();
      }
      get postBatchResumeToken() {
        return this.cursor.get("postBatchResumeToken", bson_1.BSONType.object)?.toObject({
          promoteValues: false,
          promoteLongs: false,
          promoteBuffers: false,
          validation: { utf8: true }
        }) ?? null;
      }
      shift(options2) {
        if (this.iterated >= this.batchSize) {
          return null;
        }
        const result = this.batch.get(this.iterated, bson_1.BSONType.object, true) ?? null;
        const encryptedResult = this.encryptedBatch?.get(this.iterated, bson_1.BSONType.object, true) ?? null;
        this.iterated += 1;
        if (options2?.raw) {
          return result.toBytes();
        } else {
          const object = result.toObject(options2);
          if (encryptedResult) {
            (0, utils_1.decorateDecryptionResult)(object, encryptedResult.toObject(options2), true);
          }
          return object;
        }
      }
      clear() {
        this.iterated = this.batchSize;
      }
    };
    exports2.CursorResponse = CursorResponse;
    var ExplainedCursorResponse = class extends CursorResponse {
      constructor() {
        super(...arguments);
        this.isExplain = true;
        this._length = 1;
      }
      get id() {
        return bson_1.Long.fromBigInt(0n);
      }
      get batchSize() {
        return 0;
      }
      get ns() {
        return null;
      }
      get length() {
        return this._length;
      }
      shift(options2) {
        if (this._length === 0)
          return null;
        this._length -= 1;
        return this.toObject(options2);
      }
    };
    exports2.ExplainedCursorResponse = ExplainedCursorResponse;
    var ClientBulkWriteCursorResponse = class extends CursorResponse {
      get insertedCount() {
        return this.get("nInserted", bson_1.BSONType.int, true);
      }
      get upsertedCount() {
        return this.get("nUpserted", bson_1.BSONType.int, true);
      }
      get matchedCount() {
        return this.get("nMatched", bson_1.BSONType.int, true);
      }
      get modifiedCount() {
        return this.get("nModified", bson_1.BSONType.int, true);
      }
      get deletedCount() {
        return this.get("nDeleted", bson_1.BSONType.int, true);
      }
      get writeConcernError() {
        return this.get("writeConcernError", bson_1.BSONType.object, false);
      }
    };
    exports2.ClientBulkWriteCursorResponse = ClientBulkWriteCursorResponse;
  }
});

// node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS({
  "node_modules/mongodb/lib/write_concern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteConcern = exports2.WRITE_CONCERN_KEYS = void 0;
    exports2.throwIfWriteConcernError = throwIfWriteConcernError;
    var responses_1 = require_responses();
    var error_1 = require_error();
    exports2.WRITE_CONCERN_KEYS = ["w", "wtimeout", "j", "journal", "fsync"];
    var WriteConcern = class _WriteConcern {
      /**
       * Constructs a WriteConcern from the write concern properties.
       * @param w - request acknowledgment that the write operation has propagated to a specified number of mongod instances or to mongod instances with specified tags.
       * @param wtimeoutMS - specify a time limit to prevent write operations from blocking indefinitely
       * @param journal - request acknowledgment that the write operation has been written to the on-disk journal
       * @param fsync - equivalent to the j option. Is deprecated and will be removed in the next major version.
       */
      constructor(w, wtimeoutMS, journal, fsync) {
        if (w != null) {
          if (!Number.isNaN(Number(w))) {
            this.w = Number(w);
          } else {
            this.w = w;
          }
        }
        if (wtimeoutMS != null) {
          this.wtimeoutMS = this.wtimeout = wtimeoutMS;
        }
        if (journal != null) {
          this.journal = this.j = journal;
        }
        if (fsync != null) {
          this.journal = this.j = fsync ? true : false;
        }
      }
      /**
       * Apply a write concern to a command document. Will modify and return the command.
       */
      static apply(command, writeConcern) {
        const wc = {};
        if (writeConcern.w != null)
          wc.w = writeConcern.w;
        if (writeConcern.wtimeoutMS != null)
          wc.wtimeout = writeConcern.wtimeoutMS;
        if (writeConcern.journal != null)
          wc.j = writeConcern.j;
        command.writeConcern = wc;
        return command;
      }
      /** Construct a WriteConcern given an options object. */
      static fromOptions(options2, inherit) {
        if (options2 == null)
          return void 0;
        inherit = inherit ?? {};
        let opts;
        if (typeof options2 === "string" || typeof options2 === "number") {
          opts = { w: options2 };
        } else if (options2 instanceof _WriteConcern) {
          opts = options2;
        } else {
          opts = options2.writeConcern;
        }
        const parentOpts = inherit instanceof _WriteConcern ? inherit : inherit.writeConcern;
        const { w = void 0, wtimeout = void 0, j = void 0, fsync = void 0, journal = void 0, wtimeoutMS = void 0 } = {
          ...parentOpts,
          ...opts
        };
        if (w != null || wtimeout != null || wtimeoutMS != null || j != null || journal != null || fsync != null) {
          return new _WriteConcern(w, wtimeout ?? wtimeoutMS, j ?? journal, fsync);
        }
        return void 0;
      }
    };
    exports2.WriteConcern = WriteConcern;
    function throwIfWriteConcernError(response) {
      if (typeof response === "object" && response != null) {
        const writeConcernError = responses_1.MongoDBResponse.is(response) && response.has("writeConcernError") ? response.toObject() : !responses_1.MongoDBResponse.is(response) && "writeConcernError" in response ? response : null;
        if (writeConcernError != null) {
          throw new error_1.MongoWriteConcernError(writeConcernError);
        }
      }
    }
  }
});

// node_modules/mongodb/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/mongodb/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.kDispose = exports2.randomBytes = exports2.COSMOS_DB_MSG = exports2.DOCUMENT_DB_MSG = exports2.COSMOS_DB_CHECK = exports2.DOCUMENT_DB_CHECK = exports2.MONGODB_WARNING_CODE = exports2.DEFAULT_PK_FACTORY = exports2.HostAddress = exports2.BufferPool = exports2.List = exports2.MongoDBCollectionNamespace = exports2.MongoDBNamespace = exports2.ByteUtils = void 0;
    exports2.isUint8Array = isUint8Array;
    exports2.hostMatchesWildcards = hostMatchesWildcards;
    exports2.normalizeHintField = normalizeHintField;
    exports2.isObject = isObject;
    exports2.mergeOptions = mergeOptions;
    exports2.filterOptions = filterOptions;
    exports2.applyRetryableWrites = applyRetryableWrites;
    exports2.isPromiseLike = isPromiseLike;
    exports2.decorateWithCollation = decorateWithCollation;
    exports2.decorateWithReadConcern = decorateWithReadConcern;
    exports2.getTopology = getTopology;
    exports2.ns = ns;
    exports2.makeCounter = makeCounter;
    exports2.uuidV4 = uuidV4;
    exports2.maxWireVersion = maxWireVersion;
    exports2.arrayStrictEqual = arrayStrictEqual;
    exports2.errorStrictEqual = errorStrictEqual;
    exports2.makeStateMachine = makeStateMachine;
    exports2.now = now;
    exports2.calculateDurationInMs = calculateDurationInMs;
    exports2.hasAtomicOperators = hasAtomicOperators;
    exports2.resolveTimeoutOptions = resolveTimeoutOptions;
    exports2.resolveOptions = resolveOptions;
    exports2.isSuperset = isSuperset;
    exports2.isHello = isHello;
    exports2.setDifference = setDifference;
    exports2.isRecord = isRecord;
    exports2.emitWarning = emitWarning;
    exports2.emitWarningOnce = emitWarningOnce;
    exports2.enumToString = enumToString;
    exports2.supportsRetryableWrites = supportsRetryableWrites;
    exports2.shuffle = shuffle;
    exports2.commandSupportsReadConcern = commandSupportsReadConcern;
    exports2.compareObjectId = compareObjectId;
    exports2.parseInteger = parseInteger;
    exports2.parseUnsignedInteger = parseUnsignedInteger;
    exports2.checkParentDomainMatch = checkParentDomainMatch;
    exports2.get = get;
    exports2.request = request2;
    exports2.isHostMatch = isHostMatch;
    exports2.promiseWithResolvers = promiseWithResolvers;
    exports2.squashError = squashError;
    exports2.once = once;
    exports2.maybeAddIdToDocuments = maybeAddIdToDocuments;
    exports2.fileIsAccessible = fileIsAccessible;
    exports2.csotMin = csotMin;
    exports2.noop = noop;
    exports2.decorateDecryptionResult = decorateDecryptionResult;
    exports2.addAbortListener = addAbortListener;
    exports2.abortable = abortable;
    var crypto = require("crypto");
    var fs_1 = require("fs");
    var http = require("http");
    var timers_1 = require("timers");
    var url = require("url");
    var url_1 = require("url");
    var util_1 = require("util");
    var bson_1 = require_bson2();
    var constants_1 = require_constants3();
    var constants_2 = require_constants4();
    var error_1 = require_error();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var common_1 = require_common2();
    var write_concern_1 = require_write_concern();
    exports2.ByteUtils = {
      toLocalBufferType(buffer) {
        return Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      },
      equals(seqA, seqB) {
        return exports2.ByteUtils.toLocalBufferType(seqA).equals(seqB);
      },
      compare(seqA, seqB) {
        return exports2.ByteUtils.toLocalBufferType(seqA).compare(seqB);
      },
      toBase64(uint8array) {
        return exports2.ByteUtils.toLocalBufferType(uint8array).toString("base64");
      }
    };
    function isUint8Array(value) {
      return value != null && typeof value === "object" && Symbol.toStringTag in value && value[Symbol.toStringTag] === "Uint8Array";
    }
    function hostMatchesWildcards(host, wildcards) {
      for (const wildcard of wildcards) {
        if (host === wildcard || wildcard.startsWith("*.") && host?.endsWith(wildcard.substring(2, wildcard.length)) || wildcard.startsWith("*/") && host?.endsWith(wildcard.substring(2, wildcard.length))) {
          return true;
        }
      }
      return false;
    }
    function normalizeHintField(hint) {
      let finalHint = void 0;
      if (typeof hint === "string") {
        finalHint = hint;
      } else if (Array.isArray(hint)) {
        finalHint = {};
        hint.forEach((param) => {
          finalHint[param] = 1;
        });
      } else if (hint != null && typeof hint === "object") {
        finalHint = {};
        for (const name in hint) {
          finalHint[name] = hint[name];
        }
      }
      return finalHint;
    }
    var TO_STRING = (object) => Object.prototype.toString.call(object);
    function isObject(arg) {
      return "[object Object]" === TO_STRING(arg);
    }
    function mergeOptions(target, source) {
      return { ...target, ...source };
    }
    function filterOptions(options2, names) {
      const filterOptions2 = {};
      for (const name in options2) {
        if (names.includes(name)) {
          filterOptions2[name] = options2[name];
        }
      }
      return filterOptions2;
    }
    function applyRetryableWrites(target, db) {
      if (db && db.s.options?.retryWrites) {
        target.retryWrites = true;
      }
      return target;
    }
    function isPromiseLike(value) {
      return value != null && typeof value === "object" && "then" in value && typeof value.then === "function";
    }
    function decorateWithCollation(command, target, options2) {
      const capabilities = getTopology(target).capabilities;
      if (options2.collation && typeof options2.collation === "object") {
        if (capabilities && capabilities.commandsTakeCollation) {
          command.collation = options2.collation;
        } else {
          throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);
        }
      }
    }
    function decorateWithReadConcern(command, coll, options2) {
      if (options2 && options2.session && options2.session.inTransaction()) {
        return;
      }
      const readConcern = Object.assign({}, command.readConcern || {});
      if (coll.s.readConcern) {
        Object.assign(readConcern, coll.s.readConcern);
      }
      if (Object.keys(readConcern).length > 0) {
        Object.assign(command, { readConcern });
      }
    }
    function getTopology(provider) {
      if ("topology" in provider && provider.topology) {
        return provider.topology;
      } else if ("client" in provider && provider.client.topology) {
        return provider.client.topology;
      }
      throw new error_1.MongoNotConnectedError("MongoClient must be connected to perform this operation");
    }
    function ns(ns2) {
      return MongoDBNamespace.fromString(ns2);
    }
    var MongoDBNamespace = class _MongoDBNamespace {
      /**
       * Create a namespace object
       *
       * @param db - database name
       * @param collection - collection name
       */
      constructor(db, collection) {
        this.db = db;
        this.collection = collection;
        this.collection = collection === "" ? void 0 : collection;
      }
      toString() {
        return this.collection ? `${this.db}.${this.collection}` : this.db;
      }
      withCollection(collection) {
        return new MongoDBCollectionNamespace(this.db, collection);
      }
      static fromString(namespace) {
        if (typeof namespace !== "string" || namespace === "") {
          throw new error_1.MongoRuntimeError(`Cannot parse namespace from "${namespace}"`);
        }
        const [db, ...collectionParts] = namespace.split(".");
        const collection = collectionParts.join(".");
        return new _MongoDBNamespace(db, collection === "" ? void 0 : collection);
      }
    };
    exports2.MongoDBNamespace = MongoDBNamespace;
    var MongoDBCollectionNamespace = class extends MongoDBNamespace {
      constructor(db, collection) {
        super(db, collection);
        this.collection = collection;
      }
      static fromString(namespace) {
        return super.fromString(namespace);
      }
    };
    exports2.MongoDBCollectionNamespace = MongoDBCollectionNamespace;
    function* makeCounter(seed = 0) {
      let count = seed;
      while (true) {
        const newCount = count;
        count += 1;
        yield newCount;
      }
    }
    function uuidV4() {
      const result = crypto.randomBytes(16);
      result[6] = result[6] & 15 | 64;
      result[8] = result[8] & 63 | 128;
      return result;
    }
    function maxWireVersion(topologyOrServer) {
      if (topologyOrServer) {
        if (topologyOrServer.loadBalanced || topologyOrServer.serverApi?.version) {
          return constants_1.MAX_SUPPORTED_WIRE_VERSION;
        }
        if (topologyOrServer.hello) {
          return topologyOrServer.hello.maxWireVersion;
        }
        if ("lastHello" in topologyOrServer && typeof topologyOrServer.lastHello === "function") {
          const lastHello = topologyOrServer.lastHello();
          if (lastHello) {
            return lastHello.maxWireVersion;
          }
        }
        if (topologyOrServer.description && "maxWireVersion" in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {
          return topologyOrServer.description.maxWireVersion;
        }
      }
      return 0;
    }
    function arrayStrictEqual(arr, arr2) {
      if (!Array.isArray(arr) || !Array.isArray(arr2)) {
        return false;
      }
      return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
    }
    function errorStrictEqual(lhs, rhs) {
      if (lhs === rhs) {
        return true;
      }
      if (!lhs || !rhs) {
        return lhs === rhs;
      }
      if (lhs == null && rhs != null || lhs != null && rhs == null) {
        return false;
      }
      if (lhs.constructor.name !== rhs.constructor.name) {
        return false;
      }
      if (lhs.message !== rhs.message) {
        return false;
      }
      return true;
    }
    function makeStateMachine(stateTable) {
      return function stateTransition(target, newState) {
        const legalStates = stateTable[target.s.state];
        if (legalStates && legalStates.indexOf(newState) < 0) {
          throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
        }
        target.emit("stateChanged", target.s.state, newState);
        target.s.state = newState;
      };
    }
    function now() {
      const hrtime = process.hrtime();
      return Math.floor(hrtime[0] * 1e3 + hrtime[1] / 1e6);
    }
    function calculateDurationInMs(started) {
      if (typeof started !== "number") {
        return -1;
      }
      const elapsed = now() - started;
      return elapsed < 0 ? 0 : elapsed;
    }
    function hasAtomicOperators(doc, options2) {
      if (Array.isArray(doc)) {
        for (const document2 of doc) {
          if (hasAtomicOperators(document2)) {
            return true;
          }
        }
        return false;
      }
      const keys = Object.keys(doc);
      if (options2?.ignoreUndefined) {
        let allUndefined = true;
        for (const key of keys) {
          if (doc[key] !== void 0) {
            allUndefined = false;
            break;
          }
        }
        if (allUndefined) {
          throw new error_1.MongoInvalidArgumentError("Update operations require that all atomic operators have defined values, but none were provided.");
        }
      }
      return keys.length > 0 && keys[0][0] === "$";
    }
    function resolveTimeoutOptions(client, options2) {
      const { socketTimeoutMS, serverSelectionTimeoutMS, waitQueueTimeoutMS, timeoutMS } = client.s.options;
      return { socketTimeoutMS, serverSelectionTimeoutMS, waitQueueTimeoutMS, timeoutMS, ...options2 };
    }
    function resolveOptions(parent, options2) {
      const result = Object.assign({}, options2, (0, bson_1.resolveBSONOptions)(options2, parent));
      const timeoutMS = options2?.timeoutMS ?? parent?.timeoutMS;
      const session = options2?.session;
      if (!session?.inTransaction()) {
        const readConcern = read_concern_1.ReadConcern.fromOptions(options2) ?? parent?.readConcern;
        if (readConcern) {
          result.readConcern = readConcern;
        }
        let writeConcern = write_concern_1.WriteConcern.fromOptions(options2) ?? parent?.writeConcern;
        if (writeConcern) {
          if (timeoutMS != null) {
            writeConcern = write_concern_1.WriteConcern.fromOptions({
              writeConcern: {
                ...writeConcern,
                wtimeout: void 0,
                wtimeoutMS: void 0
              }
            });
          }
          result.writeConcern = writeConcern;
        }
      }
      result.timeoutMS = timeoutMS;
      const readPreference = read_preference_1.ReadPreference.fromOptions(options2) ?? parent?.readPreference;
      if (readPreference) {
        result.readPreference = readPreference;
      }
      const isConvenientTransaction = session?.explicit && session?.timeoutContext != null;
      if (isConvenientTransaction && options2?.timeoutMS != null) {
        throw new error_1.MongoInvalidArgumentError("An operation cannot be given a timeoutMS setting when inside a withTransaction call that has a timeoutMS setting");
      }
      return result;
    }
    function isSuperset(set, subset) {
      set = Array.isArray(set) ? new Set(set) : set;
      subset = Array.isArray(subset) ? new Set(subset) : subset;
      for (const elem of subset) {
        if (!set.has(elem)) {
          return false;
        }
      }
      return true;
    }
    function isHello(doc) {
      return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;
    }
    function setDifference(setA, setB) {
      const difference = new Set(setA);
      for (const elem of setB) {
        difference.delete(elem);
      }
      return difference;
    }
    var HAS_OWN = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);
    function isRecord(value, requiredKeys = void 0) {
      if (!isObject(value)) {
        return false;
      }
      const ctor = value.constructor;
      if (ctor && ctor.prototype) {
        if (!isObject(ctor.prototype)) {
          return false;
        }
        if (!HAS_OWN(ctor.prototype, "isPrototypeOf")) {
          return false;
        }
      }
      if (requiredKeys) {
        const keys = Object.keys(value);
        return isSuperset(keys, requiredKeys);
      }
      return true;
    }
    var List = class {
      get length() {
        return this.count;
      }
      get [Symbol.toStringTag]() {
        return "List";
      }
      constructor() {
        this.count = 0;
        this.head = {
          next: null,
          prev: null,
          value: null
        };
        this.head.next = this.head;
        this.head.prev = this.head;
      }
      toArray() {
        return Array.from(this);
      }
      toString() {
        return `head <=> ${this.toArray().join(" <=> ")} <=> head`;
      }
      *[Symbol.iterator]() {
        for (const node of this.nodes()) {
          yield node.value;
        }
      }
      *nodes() {
        let ptr = this.head.next;
        while (ptr !== this.head) {
          const { next } = ptr;
          yield ptr;
          ptr = next;
        }
      }
      /** Insert at end of list */
      push(value) {
        this.count += 1;
        const newNode = {
          next: this.head,
          prev: this.head.prev,
          value
        };
        this.head.prev.next = newNode;
        this.head.prev = newNode;
      }
      /** Inserts every item inside an iterable instead of the iterable itself */
      pushMany(iterable) {
        for (const value of iterable) {
          this.push(value);
        }
      }
      /** Insert at front of list */
      unshift(value) {
        this.count += 1;
        const newNode = {
          next: this.head.next,
          prev: this.head,
          value
        };
        this.head.next.prev = newNode;
        this.head.next = newNode;
      }
      remove(node) {
        if (node === this.head || this.length === 0) {
          return null;
        }
        this.count -= 1;
        const prevNode = node.prev;
        const nextNode = node.next;
        prevNode.next = nextNode;
        nextNode.prev = prevNode;
        return node.value;
      }
      /** Removes the first node at the front of the list */
      shift() {
        return this.remove(this.head.next);
      }
      /** Removes the last node at the end of the list */
      pop() {
        return this.remove(this.head.prev);
      }
      /** Iterates through the list and removes nodes where filter returns true */
      prune(filter) {
        for (const node of this.nodes()) {
          if (filter(node.value)) {
            this.remove(node);
          }
        }
      }
      clear() {
        this.count = 0;
        this.head.next = this.head;
        this.head.prev = this.head;
      }
      /** Returns the first item in the list, does not remove */
      first() {
        return this.head.next.value;
      }
      /** Returns the last item in the list, does not remove */
      last() {
        return this.head.prev.value;
      }
    };
    exports2.List = List;
    var BufferPool = class {
      constructor() {
        this.buffers = new List();
        this.totalByteLength = 0;
      }
      get length() {
        return this.totalByteLength;
      }
      /** Adds a buffer to the internal buffer pool list */
      append(buffer) {
        this.buffers.push(buffer);
        this.totalByteLength += buffer.length;
      }
      /**
       * If BufferPool contains 4 bytes or more construct an int32 from the leading bytes,
       * otherwise return null. Size can be negative, caller should error check.
       */
      getInt32() {
        if (this.totalByteLength < 4) {
          return null;
        }
        const firstBuffer = this.buffers.first();
        if (firstBuffer != null && firstBuffer.byteLength >= 4) {
          return firstBuffer.readInt32LE(0);
        }
        const top4Bytes = this.read(4);
        const value = top4Bytes.readInt32LE(0);
        this.totalByteLength += 4;
        this.buffers.unshift(top4Bytes);
        return value;
      }
      /** Reads the requested number of bytes, optionally consuming them */
      read(size) {
        if (typeof size !== "number" || size < 0) {
          throw new error_1.MongoInvalidArgumentError('Argument "size" must be a non-negative number');
        }
        if (size > this.totalByteLength) {
          return Buffer.alloc(0);
        }
        const result = Buffer.allocUnsafe(size);
        for (let bytesRead = 0; bytesRead < size; ) {
          const buffer = this.buffers.shift();
          if (buffer == null) {
            break;
          }
          const bytesRemaining = size - bytesRead;
          const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);
          const bytes = buffer.subarray(0, bytesReadable);
          result.set(bytes, bytesRead);
          bytesRead += bytesReadable;
          this.totalByteLength -= bytesReadable;
          if (bytesReadable < buffer.byteLength) {
            this.buffers.unshift(buffer.subarray(bytesReadable));
          }
        }
        return result;
      }
    };
    exports2.BufferPool = BufferPool;
    var HostAddress = class _HostAddress {
      constructor(hostString) {
        this.host = void 0;
        this.port = void 0;
        this.socketPath = void 0;
        this.isIPv6 = false;
        const escapedHost = hostString.split(" ").join("%20");
        if (escapedHost.endsWith(".sock")) {
          this.socketPath = decodeURIComponent(escapedHost);
          return;
        }
        const urlString = `iLoveJS://${escapedHost}`;
        let url2;
        try {
          url2 = new url_1.URL(urlString);
        } catch (urlError) {
          const runtimeError = new error_1.MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);
          runtimeError.cause = urlError;
          throw runtimeError;
        }
        const hostname = url2.hostname;
        const port = url2.port;
        let normalized = decodeURIComponent(hostname).toLowerCase();
        if (normalized.startsWith("[") && normalized.endsWith("]")) {
          this.isIPv6 = true;
          normalized = normalized.substring(1, hostname.length - 1);
        }
        this.host = normalized.toLowerCase();
        if (typeof port === "number") {
          this.port = port;
        } else if (typeof port === "string" && port !== "") {
          this.port = Number.parseInt(port, 10);
        } else {
          this.port = 27017;
        }
        if (this.port === 0) {
          throw new error_1.MongoParseError("Invalid port (zero) with hostname");
        }
        Object.freeze(this);
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.inspect();
      }
      inspect() {
        return `new HostAddress('${this.toString()}')`;
      }
      toString() {
        if (typeof this.host === "string") {
          if (this.isIPv6) {
            return `[${this.host}]:${this.port}`;
          }
          return `${this.host}:${this.port}`;
        }
        return `${this.socketPath}`;
      }
      static fromString(s) {
        return new _HostAddress(s);
      }
      static fromHostPort(host, port) {
        if (host.includes(":")) {
          host = `[${host}]`;
        }
        return _HostAddress.fromString(`${host}:${port}`);
      }
      static fromSrvRecord({ name, port }) {
        return _HostAddress.fromHostPort(name, port);
      }
      toHostPort() {
        if (this.socketPath) {
          return { host: this.socketPath, port: 0 };
        }
        const host = this.host ?? "";
        const port = this.port ?? 0;
        return { host, port };
      }
    };
    exports2.HostAddress = HostAddress;
    exports2.DEFAULT_PK_FACTORY = {
      // We prefer not to rely on ObjectId having a createPk method
      createPk() {
        return new bson_1.ObjectId();
      }
    };
    exports2.MONGODB_WARNING_CODE = "MONGODB DRIVER";
    function emitWarning(message) {
      return process.emitWarning(message, { code: exports2.MONGODB_WARNING_CODE });
    }
    var emittedWarnings = /* @__PURE__ */ new Set();
    function emitWarningOnce(message) {
      if (!emittedWarnings.has(message)) {
        emittedWarnings.add(message);
        return emitWarning(message);
      }
    }
    function enumToString(en) {
      return Object.values(en).join(", ");
    }
    function supportsRetryableWrites(server) {
      if (!server) {
        return false;
      }
      if (server.loadBalanced) {
        return true;
      }
      if (server.description.logicalSessionTimeoutMinutes != null) {
        if (server.description.type !== common_1.ServerType.Standalone) {
          return true;
        }
      }
      return false;
    }
    function shuffle(sequence, limit = 0) {
      const items = Array.from(sequence);
      if (limit > items.length) {
        throw new error_1.MongoRuntimeError("Limit must be less than the number of items");
      }
      let remainingItemsToShuffle = items.length;
      const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;
      while (remainingItemsToShuffle > lowerBound) {
        const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);
        remainingItemsToShuffle -= 1;
        const swapHold = items[remainingItemsToShuffle];
        items[remainingItemsToShuffle] = items[randomIndex];
        items[randomIndex] = swapHold;
      }
      return limit % items.length === 0 ? items : items.slice(lowerBound);
    }
    function commandSupportsReadConcern(command) {
      if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {
        return true;
      }
      return false;
    }
    function compareObjectId(oid1, oid2) {
      if (oid1 == null && oid2 == null) {
        return 0;
      }
      if (oid1 == null) {
        return -1;
      }
      if (oid2 == null) {
        return 1;
      }
      return exports2.ByteUtils.compare(oid1.id, oid2.id);
    }
    function parseInteger(value) {
      if (typeof value === "number")
        return Math.trunc(value);
      const parsedValue = Number.parseInt(String(value), 10);
      return Number.isNaN(parsedValue) ? null : parsedValue;
    }
    function parseUnsignedInteger(value) {
      const parsedInt = parseInteger(value);
      return parsedInt != null && parsedInt >= 0 ? parsedInt : null;
    }
    function checkParentDomainMatch(address, srvHost) {
      const normalizedAddress = address.endsWith(".") ? address.slice(0, address.length - 1) : address;
      const normalizedSrvHost = srvHost.endsWith(".") ? srvHost.slice(0, srvHost.length - 1) : srvHost;
      const allCharacterBeforeFirstDot = /^.*?\./;
      const srvIsLessThanThreeParts = normalizedSrvHost.split(".").length < 3;
      const addressDomain = `.${normalizedAddress.replace(allCharacterBeforeFirstDot, "")}`;
      let srvHostDomain = srvIsLessThanThreeParts ? normalizedSrvHost : `.${normalizedSrvHost.replace(allCharacterBeforeFirstDot, "")}`;
      if (!srvHostDomain.startsWith(".")) {
        srvHostDomain = "." + srvHostDomain;
      }
      if (srvIsLessThanThreeParts && normalizedAddress.split(".").length <= normalizedSrvHost.split(".").length) {
        throw new error_1.MongoAPIError("Server record does not have at least one more domain level than parent URI");
      }
      if (!addressDomain.endsWith(srvHostDomain)) {
        throw new error_1.MongoAPIError("Server record does not share hostname with parent URI");
      }
    }
    function get(url2, options2 = {}) {
      return new Promise((resolve, reject) => {
        let timeoutId;
        const request3 = http.get(url2, options2, (response) => {
          response.setEncoding("utf8");
          let body = "";
          response.on("data", (chunk) => body += chunk);
          response.on("end", () => {
            (0, timers_1.clearTimeout)(timeoutId);
            resolve({ status: response.statusCode, body });
          });
        }).on("error", (error2) => {
          (0, timers_1.clearTimeout)(timeoutId);
          reject(error2);
        }).end();
        timeoutId = (0, timers_1.setTimeout)(() => {
          request3.destroy(new error_1.MongoNetworkTimeoutError(`request timed out after 10 seconds`));
        }, 1e4);
      });
    }
    async function request2(uri, options2 = {}) {
      return await new Promise((resolve, reject) => {
        const requestOptions = {
          method: "GET",
          timeout: 1e4,
          json: true,
          ...url.parse(uri),
          ...options2
        };
        const req = http.request(requestOptions, (res) => {
          res.setEncoding("utf8");
          let data = "";
          res.on("data", (d) => {
            data += d;
          });
          res.once("end", () => {
            if (options2.json === false) {
              resolve(data);
              return;
            }
            try {
              const parsed = JSON.parse(data);
              resolve(parsed);
            } catch {
              reject(new error_1.MongoRuntimeError(`Invalid JSON response: "${data}"`));
            }
          });
        });
        req.once("timeout", () => req.destroy(new error_1.MongoNetworkTimeoutError(`Network request to ${uri} timed out after ${options2.timeout} ms`)));
        req.once("error", (error2) => reject(error2));
        req.end();
      });
    }
    exports2.DOCUMENT_DB_CHECK = /(\.docdb\.amazonaws\.com$)|(\.docdb-elastic\.amazonaws\.com$)/;
    exports2.COSMOS_DB_CHECK = /\.cosmos\.azure\.com$/;
    exports2.DOCUMENT_DB_MSG = "You appear to be connected to a DocumentDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/documentdb";
    exports2.COSMOS_DB_MSG = "You appear to be connected to a CosmosDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/cosmosdb";
    function isHostMatch(match, host) {
      return host && match.test(host.toLowerCase()) ? true : false;
    }
    function promiseWithResolvers() {
      let resolve;
      let reject;
      const promise = new Promise(function withResolversExecutor(promiseResolve, promiseReject) {
        resolve = promiseResolve;
        reject = promiseReject;
      });
      return { promise, resolve, reject };
    }
    function squashError(_error) {
      return;
    }
    exports2.randomBytes = (0, util_1.promisify)(crypto.randomBytes);
    async function once(ee, name, options2) {
      options2?.signal?.throwIfAborted();
      const { promise, resolve, reject } = promiseWithResolvers();
      const onEvent = (data) => resolve(data);
      const onError = (error2) => reject(error2);
      const abortListener = addAbortListener(options2?.signal, function() {
        reject(this.reason);
      });
      ee.once(name, onEvent).once("error", onError);
      try {
        return await promise;
      } finally {
        ee.off(name, onEvent);
        ee.off("error", onError);
        abortListener?.[exports2.kDispose]();
      }
    }
    function maybeAddIdToDocuments(coll, docOrDocs, options2) {
      const forceServerObjectId = typeof options2.forceServerObjectId === "boolean" ? options2.forceServerObjectId : coll.s.db.options?.forceServerObjectId;
      if (forceServerObjectId === true) {
        return docOrDocs;
      }
      const transform = (doc) => {
        if (doc._id == null) {
          doc._id = coll.s.pkFactory.createPk();
        }
        return doc;
      };
      return Array.isArray(docOrDocs) ? docOrDocs.map(transform) : transform(docOrDocs);
    }
    async function fileIsAccessible(fileName, mode) {
      try {
        await fs_1.promises.access(fileName, mode);
        return true;
      } catch {
        return false;
      }
    }
    function csotMin(duration1, duration2) {
      if (duration1 === 0)
        return duration2;
      if (duration2 === 0)
        return duration1;
      return Math.min(duration1, duration2);
    }
    function noop() {
      return;
    }
    function decorateDecryptionResult(decrypted, original, isTopLevelDecorateCall = true) {
      if (isTopLevelDecorateCall) {
        if (Buffer.isBuffer(original)) {
          original = (0, bson_1.deserialize)(original);
        }
        if (Buffer.isBuffer(decrypted)) {
          throw new error_1.MongoRuntimeError("Expected result of decryption to be deserialized BSON object");
        }
      }
      if (!decrypted || typeof decrypted !== "object")
        return;
      for (const k of Object.keys(decrypted)) {
        const originalValue = original[k];
        if (originalValue && originalValue._bsontype === "Binary" && originalValue.sub_type === 6) {
          if (!decrypted[constants_2.kDecoratedKeys]) {
            Object.defineProperty(decrypted, constants_2.kDecoratedKeys, {
              value: [],
              configurable: true,
              enumerable: false,
              writable: false
            });
          }
          decrypted[constants_2.kDecoratedKeys].push(k);
          continue;
        }
        decorateDecryptionResult(decrypted[k], originalValue, false);
      }
    }
    exports2.kDispose = Symbol.dispose ?? Symbol("dispose");
    function addAbortListener(signal, listener) {
      if (signal == null)
        return;
      signal.addEventListener("abort", listener, { once: true });
      return { [exports2.kDispose]: () => signal.removeEventListener("abort", listener) };
    }
    async function abortable(promise, { signal }) {
      if (signal == null) {
        return await promise;
      }
      const { promise: aborted, reject } = promiseWithResolvers();
      const abortListener = signal.aborted ? reject(signal.reason) : addAbortListener(signal, function() {
        reject(this.reason);
      });
      try {
        return await Promise.race([promise, aborted]);
      } finally {
        abortListener?.[exports2.kDispose]();
      }
    }
  }
});

// node_modules/mongodb/lib/timeout.js
var require_timeout = __commonJS({
  "node_modules/mongodb/lib/timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LegacyTimeoutContext = exports2.CSOTTimeoutContext = exports2.TimeoutContext = exports2.Timeout = exports2.TimeoutError = void 0;
    var timers_1 = require("timers");
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var TimeoutError = class extends Error {
      get name() {
        return "TimeoutError";
      }
      constructor(message, options2) {
        super(message, options2);
        this.duration = options2.duration;
      }
      static is(error2) {
        return error2 != null && typeof error2 === "object" && "name" in error2 && error2.name === "TimeoutError";
      }
    };
    exports2.TimeoutError = TimeoutError;
    var Timeout = class _Timeout extends Promise {
      get remainingTime() {
        if (this.timedOut)
          return 0;
        if (this.duration === 0)
          return Infinity;
        return this.start + this.duration - Math.trunc(performance.now());
      }
      get timeElapsed() {
        return Math.trunc(performance.now()) - this.start;
      }
      /** Create a new timeout that expires in `duration` ms */
      constructor(executor = () => null, options2) {
        const duration = options2?.duration ?? 0;
        const unref = !!options2?.unref;
        const rejection = options2?.rejection;
        if (duration < 0) {
          throw new error_1.MongoInvalidArgumentError("Cannot create a Timeout with a negative duration");
        }
        let reject;
        super((_, promiseReject) => {
          reject = promiseReject;
          executor(utils_1.noop, promiseReject);
        });
        this.ended = null;
        this.timedOut = false;
        this.cleared = false;
        this.duration = duration;
        this.start = Math.trunc(performance.now());
        if (rejection == null && this.duration > 0) {
          this.id = (0, timers_1.setTimeout)(() => {
            this.ended = Math.trunc(performance.now());
            this.timedOut = true;
            reject(new TimeoutError(`Expired after ${duration}ms`, { duration }));
          }, this.duration);
          if (typeof this.id.unref === "function" && unref) {
            this.id.unref();
          }
        } else if (rejection != null) {
          this.ended = Math.trunc(performance.now());
          this.timedOut = true;
          reject(rejection);
        }
      }
      /**
       * Clears the underlying timeout. This method is idempotent
       */
      clear() {
        (0, timers_1.clearTimeout)(this.id);
        this.id = void 0;
        this.timedOut = false;
        this.cleared = true;
      }
      throwIfExpired() {
        if (this.timedOut) {
          this.then(void 0, utils_1.squashError);
          throw new TimeoutError("Timed out", { duration: this.duration });
        }
      }
      static expires(duration, unref) {
        return new _Timeout(void 0, { duration, unref });
      }
      static reject(rejection) {
        return new _Timeout(void 0, { duration: 0, unref: true, rejection });
      }
    };
    exports2.Timeout = Timeout;
    function isLegacyTimeoutContextOptions(v) {
      return v != null && typeof v === "object" && "serverSelectionTimeoutMS" in v && typeof v.serverSelectionTimeoutMS === "number" && "waitQueueTimeoutMS" in v && typeof v.waitQueueTimeoutMS === "number";
    }
    function isCSOTTimeoutContextOptions(v) {
      return v != null && typeof v === "object" && "serverSelectionTimeoutMS" in v && typeof v.serverSelectionTimeoutMS === "number" && "timeoutMS" in v && typeof v.timeoutMS === "number";
    }
    var TimeoutContext = class {
      static create(options2) {
        if (options2.session?.timeoutContext != null)
          return options2.session?.timeoutContext;
        if (isCSOTTimeoutContextOptions(options2))
          return new CSOTTimeoutContext(options2);
        else if (isLegacyTimeoutContextOptions(options2))
          return new LegacyTimeoutContext(options2);
        else
          throw new error_1.MongoRuntimeError("Unrecognized options");
      }
    };
    exports2.TimeoutContext = TimeoutContext;
    var CSOTTimeoutContext = class _CSOTTimeoutContext extends TimeoutContext {
      constructor(options2) {
        super();
        this.minRoundTripTime = 0;
        this.start = Math.trunc(performance.now());
        this.timeoutMS = options2.timeoutMS;
        this.serverSelectionTimeoutMS = options2.serverSelectionTimeoutMS;
        this.socketTimeoutMS = options2.socketTimeoutMS;
        this.clearServerSelectionTimeout = false;
      }
      get maxTimeMS() {
        return this.remainingTimeMS - this.minRoundTripTime;
      }
      get remainingTimeMS() {
        const timePassed = Math.trunc(performance.now()) - this.start;
        return this.timeoutMS <= 0 ? Infinity : this.timeoutMS - timePassed;
      }
      csotEnabled() {
        return true;
      }
      get serverSelectionTimeout() {
        if (typeof this._serverSelectionTimeout !== "object" || this._serverSelectionTimeout?.cleared) {
          const { remainingTimeMS, serverSelectionTimeoutMS } = this;
          if (remainingTimeMS <= 0)
            return Timeout.reject(new error_1.MongoOperationTimeoutError(`Timed out in server selection after ${this.timeoutMS}ms`));
          const usingServerSelectionTimeoutMS = serverSelectionTimeoutMS !== 0 && (0, utils_1.csotMin)(remainingTimeMS, serverSelectionTimeoutMS) === serverSelectionTimeoutMS;
          if (usingServerSelectionTimeoutMS) {
            this._serverSelectionTimeout = Timeout.expires(serverSelectionTimeoutMS);
          } else {
            if (remainingTimeMS > 0 && Number.isFinite(remainingTimeMS)) {
              this._serverSelectionTimeout = Timeout.expires(remainingTimeMS);
            } else {
              this._serverSelectionTimeout = null;
            }
          }
        }
        return this._serverSelectionTimeout;
      }
      get connectionCheckoutTimeout() {
        if (typeof this._connectionCheckoutTimeout !== "object" || this._connectionCheckoutTimeout?.cleared) {
          if (typeof this._serverSelectionTimeout === "object") {
            this._connectionCheckoutTimeout = this._serverSelectionTimeout;
          } else {
            throw new error_1.MongoRuntimeError("Unreachable. If you are seeing this error, please file a ticket on the NODE driver project on Jira");
          }
        }
        return this._connectionCheckoutTimeout;
      }
      get timeoutForSocketWrite() {
        const { remainingTimeMS } = this;
        if (!Number.isFinite(remainingTimeMS))
          return null;
        if (remainingTimeMS > 0)
          return Timeout.expires(remainingTimeMS);
        return Timeout.reject(new error_1.MongoOperationTimeoutError("Timed out before socket write"));
      }
      get timeoutForSocketRead() {
        const { remainingTimeMS } = this;
        if (!Number.isFinite(remainingTimeMS))
          return null;
        if (remainingTimeMS > 0)
          return Timeout.expires(remainingTimeMS);
        return Timeout.reject(new error_1.MongoOperationTimeoutError("Timed out before socket read"));
      }
      refresh() {
        this.start = Math.trunc(performance.now());
        this.minRoundTripTime = 0;
        this._serverSelectionTimeout?.clear();
        this._connectionCheckoutTimeout?.clear();
      }
      clear() {
        this._serverSelectionTimeout?.clear();
        this._connectionCheckoutTimeout?.clear();
      }
      /**
       * @internal
       * Throws a MongoOperationTimeoutError if the context has expired.
       * If the context has not expired, returns the `remainingTimeMS`
       **/
      getRemainingTimeMSOrThrow(message) {
        const { remainingTimeMS } = this;
        if (remainingTimeMS <= 0)
          throw new error_1.MongoOperationTimeoutError(message ?? `Expired after ${this.timeoutMS}ms`);
        return remainingTimeMS;
      }
      /**
       * @internal
       * This method is intended to be used in situations where concurrent operation are on the same deadline, but cannot share a single `TimeoutContext` instance.
       * Returns a new instance of `CSOTTimeoutContext` constructed with identical options, but setting the `start` property to `this.start`.
       */
      clone() {
        const timeoutContext = new _CSOTTimeoutContext({
          timeoutMS: this.timeoutMS,
          serverSelectionTimeoutMS: this.serverSelectionTimeoutMS
        });
        timeoutContext.start = this.start;
        return timeoutContext;
      }
      refreshed() {
        return new _CSOTTimeoutContext(this);
      }
      addMaxTimeMSToCommand(command, options2) {
        if (options2.omitMaxTimeMS)
          return;
        const maxTimeMS = this.remainingTimeMS - this.minRoundTripTime;
        if (maxTimeMS > 0 && Number.isFinite(maxTimeMS))
          command.maxTimeMS = maxTimeMS;
      }
      getSocketTimeoutMS() {
        return 0;
      }
    };
    exports2.CSOTTimeoutContext = CSOTTimeoutContext;
    var LegacyTimeoutContext = class _LegacyTimeoutContext extends TimeoutContext {
      constructor(options2) {
        super();
        this.options = options2;
        this.clearServerSelectionTimeout = true;
      }
      csotEnabled() {
        return false;
      }
      get serverSelectionTimeout() {
        if (this.options.serverSelectionTimeoutMS != null && this.options.serverSelectionTimeoutMS > 0)
          return Timeout.expires(this.options.serverSelectionTimeoutMS);
        return null;
      }
      get connectionCheckoutTimeout() {
        if (this.options.waitQueueTimeoutMS != null && this.options.waitQueueTimeoutMS > 0)
          return Timeout.expires(this.options.waitQueueTimeoutMS);
        return null;
      }
      get timeoutForSocketWrite() {
        return null;
      }
      get timeoutForSocketRead() {
        return null;
      }
      refresh() {
        return;
      }
      clear() {
        return;
      }
      get maxTimeMS() {
        return null;
      }
      refreshed() {
        return new _LegacyTimeoutContext(this.options);
      }
      addMaxTimeMSToCommand(_command, _options) {
      }
      getSocketTimeoutMS() {
        return this.options.socketTimeoutMS;
      }
    };
    exports2.LegacyTimeoutContext = LegacyTimeoutContext;
  }
});

// node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS({
  "node_modules/mongodb/lib/operations/operation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractOperation = exports2.Aspect = void 0;
    exports2.defineAspects = defineAspects;
    var bson_1 = require_bson2();
    var read_preference_1 = require_read_preference();
    exports2.Aspect = {
      READ_OPERATION: Symbol("READ_OPERATION"),
      WRITE_OPERATION: Symbol("WRITE_OPERATION"),
      RETRYABLE: Symbol("RETRYABLE"),
      EXPLAINABLE: Symbol("EXPLAINABLE"),
      SKIP_COLLATION: Symbol("SKIP_COLLATION"),
      CURSOR_CREATING: Symbol("CURSOR_CREATING"),
      MUST_SELECT_SAME_SERVER: Symbol("MUST_SELECT_SAME_SERVER"),
      COMMAND_BATCHING: Symbol("COMMAND_BATCHING")
    };
    var AbstractOperation = class {
      constructor(options2 = {}) {
        this.readPreference = this.hasAspect(exports2.Aspect.WRITE_OPERATION) ? read_preference_1.ReadPreference.primary : read_preference_1.ReadPreference.fromOptions(options2) ?? read_preference_1.ReadPreference.primary;
        this.bsonOptions = (0, bson_1.resolveBSONOptions)(options2);
        this._session = options2.session != null ? options2.session : void 0;
        this.options = options2;
        this.bypassPinningCheck = !!options2.bypassPinningCheck;
        this.trySecondaryWrite = false;
      }
      hasAspect(aspect) {
        const ctor = this.constructor;
        if (ctor.aspects == null) {
          return false;
        }
        return ctor.aspects.has(aspect);
      }
      // Make sure the session is not writable from outside this class.
      get session() {
        return this._session;
      }
      clearSession() {
        this._session = void 0;
      }
      resetBatch() {
        return true;
      }
      get canRetryRead() {
        return this.hasAspect(exports2.Aspect.RETRYABLE) && this.hasAspect(exports2.Aspect.READ_OPERATION);
      }
      get canRetryWrite() {
        return this.hasAspect(exports2.Aspect.RETRYABLE) && this.hasAspect(exports2.Aspect.WRITE_OPERATION);
      }
    };
    exports2.AbstractOperation = AbstractOperation;
    function defineAspects(operation, aspects) {
      if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
        aspects = [aspects];
      }
      aspects = new Set(aspects);
      Object.defineProperty(operation, "aspects", {
        value: aspects,
        writable: false
      });
      return aspects;
    }
  }
});

// node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS({
  "node_modules/mongodb/lib/operations/execute_operation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.executeOperation = executeOperation;
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var server_selection_1 = require_server_selection();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils5();
    var operation_1 = require_operation();
    var MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;
    var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
    async function executeOperation(client, operation, timeoutContext) {
      if (!(operation instanceof operation_1.AbstractOperation)) {
        throw new error_1.MongoRuntimeError("This method requires a valid operation instance");
      }
      const topology = client.topology == null ? await (0, utils_1.abortable)(autoConnect(client), operation.options) : client.topology;
      let session = operation.session;
      let owner;
      if (session == null) {
        owner = Symbol();
        session = client.startSession({ owner, explicit: false });
      } else if (session.hasEnded) {
        throw new error_1.MongoExpiredSessionError("Use of expired sessions is not permitted");
      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {
        throw new error_1.MongoCompatibilityError("Snapshot reads require MongoDB 5.0 or later");
      } else if (session.client !== client) {
        throw new error_1.MongoInvalidArgumentError("ClientSession must be from the same MongoClient");
      }
      const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;
      const inTransaction = !!session?.inTransaction();
      const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
      if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary) && (hasReadAspect || operation.commandName === "runCommand")) {
        throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);
      }
      if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {
        session.unpin();
      }
      timeoutContext ??= timeout_1.TimeoutContext.create({
        session,
        serverSelectionTimeoutMS: client.s.options.serverSelectionTimeoutMS,
        waitQueueTimeoutMS: client.s.options.waitQueueTimeoutMS,
        timeoutMS: operation.options.timeoutMS
      });
      try {
        return await tryOperation(operation, {
          topology,
          timeoutContext,
          session,
          readPreference
        });
      } finally {
        if (session?.owner != null && session.owner === owner) {
          await session.endSession();
        }
      }
    }
    async function autoConnect(client) {
      if (client.topology == null) {
        if (client.s.hasBeenClosed) {
          throw new error_1.MongoNotConnectedError("Client must be connected before running operations");
        }
        client.s.options.__skipPingOnConnect = true;
        try {
          await client.connect();
          if (client.topology == null) {
            throw new error_1.MongoRuntimeError("client.connect did not create a topology but also did not throw");
          }
          return client.topology;
        } finally {
          delete client.s.options.__skipPingOnConnect;
        }
      }
      return client.topology;
    }
    async function tryOperation(operation, { topology, timeoutContext, session, readPreference }) {
      let selector;
      if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {
        selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);
      } else if (operation.trySecondaryWrite) {
        selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);
      } else {
        selector = readPreference;
      }
      let server = await topology.selectServer(selector, {
        session,
        operationName: operation.commandName,
        timeoutContext,
        signal: operation.options.signal
      });
      const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
      const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
      const inTransaction = session?.inTransaction() ?? false;
      const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;
      const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;
      const willRetry = operation.hasAspect(operation_1.Aspect.RETRYABLE) && session != null && (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite);
      if (hasWriteAspect && willRetryWrite && session != null) {
        operation.options.willRetryWrite = true;
        session.incrementTransactionNumber();
      }
      const maxTries = willRetry ? timeoutContext.csotEnabled() ? Infinity : 2 : 1;
      let previousOperationError;
      let previousServer;
      for (let tries = 0; tries < maxTries; tries++) {
        if (previousOperationError) {
          if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {
            throw new error_1.MongoServerError({
              message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
              errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
              originalError: previousOperationError
            });
          }
          if (operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING) && !operation.canRetryWrite) {
            throw previousOperationError;
          }
          if (hasWriteAspect && !(0, error_1.isRetryableWriteError)(previousOperationError))
            throw previousOperationError;
          if (hasReadAspect && !(0, error_1.isRetryableReadError)(previousOperationError))
            throw previousOperationError;
          if (previousOperationError instanceof error_1.MongoNetworkError && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING) && session != null && session.isPinned && !session.inTransaction()) {
            session.unpin({ force: true, forceClear: true });
          }
          server = await topology.selectServer(selector, {
            session,
            operationName: operation.commandName,
            previousServer,
            signal: operation.options.signal
          });
          if (hasWriteAspect && !(0, utils_1.supportsRetryableWrites)(server)) {
            throw new error_1.MongoUnexpectedServerResponseError("Selected server does not support retryable writes");
          }
        }
        try {
          if (tries > 0 && operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING)) {
            operation.resetBatch();
          }
          return await operation.execute(server, session, timeoutContext);
        } catch (operationError) {
          if (!(operationError instanceof error_1.MongoError))
            throw operationError;
          if (previousOperationError != null && operationError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {
            throw previousOperationError;
          }
          previousServer = server.description;
          previousOperationError = operationError;
          timeoutContext.clear();
        }
      }
      throw previousOperationError ?? new error_1.MongoRuntimeError("Tried to propagate retryability error, but no error was found.");
    }
  }
});

// node_modules/mongodb/lib/mongo_logger.js
var require_mongo_logger = __commonJS({
  "node_modules/mongodb/lib/mongo_logger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoLogger = exports2.MongoLoggableComponent = exports2.SEVERITY_LEVEL_MAP = exports2.DEFAULT_MAX_DOCUMENT_LENGTH = exports2.SeverityLevel = void 0;
    exports2.parseSeverityFromString = parseSeverityFromString;
    exports2.createStdioLogger = createStdioLogger;
    exports2.stringifyWithMaxLen = stringifyWithMaxLen;
    exports2.defaultLogTransform = defaultLogTransform;
    var util_1 = require("util");
    var bson_1 = require_bson2();
    var constants_1 = require_constants4();
    var utils_1 = require_utils5();
    exports2.SeverityLevel = Object.freeze({
      EMERGENCY: "emergency",
      ALERT: "alert",
      CRITICAL: "critical",
      ERROR: "error",
      WARNING: "warn",
      NOTICE: "notice",
      INFORMATIONAL: "info",
      DEBUG: "debug",
      TRACE: "trace",
      OFF: "off"
    });
    exports2.DEFAULT_MAX_DOCUMENT_LENGTH = 1e3;
    var SeverityLevelMap = class extends Map {
      constructor(entries) {
        const newEntries = [];
        for (const [level, value] of entries) {
          newEntries.push([value, level]);
        }
        newEntries.push(...entries);
        super(newEntries);
      }
      getNumericSeverityLevel(severity) {
        return this.get(severity);
      }
      getSeverityLevelName(level) {
        return this.get(level);
      }
    };
    exports2.SEVERITY_LEVEL_MAP = new SeverityLevelMap([
      [exports2.SeverityLevel.OFF, -Infinity],
      [exports2.SeverityLevel.EMERGENCY, 0],
      [exports2.SeverityLevel.ALERT, 1],
      [exports2.SeverityLevel.CRITICAL, 2],
      [exports2.SeverityLevel.ERROR, 3],
      [exports2.SeverityLevel.WARNING, 4],
      [exports2.SeverityLevel.NOTICE, 5],
      [exports2.SeverityLevel.INFORMATIONAL, 6],
      [exports2.SeverityLevel.DEBUG, 7],
      [exports2.SeverityLevel.TRACE, 8]
    ]);
    exports2.MongoLoggableComponent = Object.freeze({
      COMMAND: "command",
      TOPOLOGY: "topology",
      SERVER_SELECTION: "serverSelection",
      CONNECTION: "connection",
      CLIENT: "client"
    });
    function parseSeverityFromString(s) {
      const validSeverities = Object.values(exports2.SeverityLevel);
      const lowerSeverity = s?.toLowerCase();
      if (lowerSeverity != null && validSeverities.includes(lowerSeverity)) {
        return lowerSeverity;
      }
      return null;
    }
    function createStdioLogger(stream) {
      return {
        write: (0, util_1.promisify)((log, cb) => {
          const logLine = (0, util_1.inspect)(log, { compact: true, breakLength: Infinity });
          stream.write(`${logLine}
`, "utf-8", cb);
          return;
        })
      };
    }
    function resolveLogPath({ MONGODB_LOG_PATH }, { mongodbLogPath }) {
      if (typeof mongodbLogPath === "string" && /^stderr$/i.test(mongodbLogPath)) {
        return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
      }
      if (typeof mongodbLogPath === "string" && /^stdout$/i.test(mongodbLogPath)) {
        return { mongodbLogPath: createStdioLogger(process.stdout), mongodbLogPathIsStdErr: false };
      }
      if (typeof mongodbLogPath === "object" && typeof mongodbLogPath?.write === "function") {
        return { mongodbLogPath, mongodbLogPathIsStdErr: false };
      }
      if (MONGODB_LOG_PATH && /^stderr$/i.test(MONGODB_LOG_PATH)) {
        return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
      }
      if (MONGODB_LOG_PATH && /^stdout$/i.test(MONGODB_LOG_PATH)) {
        return { mongodbLogPath: createStdioLogger(process.stdout), mongodbLogPathIsStdErr: false };
      }
      return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
    }
    function resolveSeverityConfiguration(clientOption, environmentOption, defaultSeverity) {
      return parseSeverityFromString(clientOption) ?? parseSeverityFromString(environmentOption) ?? defaultSeverity;
    }
    function compareSeverity(s0, s1) {
      const s0Num = exports2.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s0);
      const s1Num = exports2.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s1);
      return s0Num < s1Num ? -1 : s0Num > s1Num ? 1 : 0;
    }
    function stringifyWithMaxLen(value, maxDocumentLength, options2 = {}) {
      let strToTruncate = "";
      let currentLength = 0;
      const maxDocumentLengthEnsurer = function maxDocumentLengthEnsurer2(key, value2) {
        if (currentLength >= maxDocumentLength) {
          return void 0;
        }
        if (key === "") {
          currentLength += 1;
          return value2;
        }
        currentLength += key.length + 4;
        if (value2 == null)
          return value2;
        switch (typeof value2) {
          case "string":
            currentLength += value2.length + 2;
            break;
          case "number":
          case "bigint":
            currentLength += String(value2).length;
            break;
          case "boolean":
            currentLength += value2 ? 4 : 5;
            break;
          case "object":
            if ((0, utils_1.isUint8Array)(value2)) {
              currentLength += 22 + value2.byteLength + value2.byteLength * 0.33 + 18 | 0;
            } else if ("_bsontype" in value2) {
              const v = value2;
              switch (v._bsontype) {
                case "Int32":
                  currentLength += String(v.value).length;
                  break;
                case "Double":
                  currentLength += (v.value | 0) === v.value ? String(v.value).length + 2 : String(v.value).length;
                  break;
                case "Long":
                  currentLength += v.toString().length;
                  break;
                case "ObjectId":
                  currentLength += 35;
                  break;
                case "MaxKey":
                case "MinKey":
                  currentLength += 13;
                  break;
                case "Binary":
                  currentLength += 22 + value2.position + value2.position * 0.33 + 18 | 0;
                  break;
                case "Timestamp":
                  currentLength += 19 + String(v.t).length + 5 + String(v.i).length + 2;
                  break;
                case "Code":
                  if (v.scope == null) {
                    currentLength += v.code.length + 10 + 2;
                  } else {
                    currentLength += v.code.length + 10 + 11;
                  }
                  break;
                case "BSONRegExp":
                  currentLength += 34 + v.pattern.length + 13 + v.options.length + 3;
                  break;
              }
            }
        }
        return value2;
      };
      if (typeof value === "string") {
        strToTruncate = value;
      } else if (typeof value === "function") {
        strToTruncate = value.name;
      } else {
        try {
          if (maxDocumentLength !== 0) {
            strToTruncate = bson_1.EJSON.stringify(value, maxDocumentLengthEnsurer, 0, options2);
          } else {
            strToTruncate = bson_1.EJSON.stringify(value, options2);
          }
        } catch (e) {
          strToTruncate = `Extended JSON serialization failed with: ${e.message}`;
        }
      }
      if (maxDocumentLength !== 0 && strToTruncate.length > maxDocumentLength && strToTruncate.charCodeAt(maxDocumentLength - 1) !== strToTruncate.codePointAt(maxDocumentLength - 1)) {
        maxDocumentLength--;
        if (maxDocumentLength === 0) {
          return "";
        }
      }
      return maxDocumentLength !== 0 && strToTruncate.length > maxDocumentLength ? `${strToTruncate.slice(0, maxDocumentLength)}...` : strToTruncate;
    }
    function isLogConvertible(obj) {
      const objAsLogConvertible = obj;
      return objAsLogConvertible.toLog !== void 0 && typeof objAsLogConvertible.toLog === "function";
    }
    function attachServerSelectionFields(log, serverSelectionEvent, maxDocumentLength = exports2.DEFAULT_MAX_DOCUMENT_LENGTH) {
      const { selector, operation, topologyDescription, message } = serverSelectionEvent;
      log.selector = stringifyWithMaxLen(selector, maxDocumentLength);
      log.operation = operation;
      log.topologyDescription = stringifyWithMaxLen(topologyDescription, maxDocumentLength);
      log.message = message;
      return log;
    }
    function attachCommandFields(log, commandEvent) {
      log.commandName = commandEvent.commandName;
      log.requestId = commandEvent.requestId;
      log.driverConnectionId = commandEvent.connectionId;
      const { host, port } = utils_1.HostAddress.fromString(commandEvent.address).toHostPort();
      log.serverHost = host;
      log.serverPort = port;
      if (commandEvent?.serviceId) {
        log.serviceId = commandEvent.serviceId.toHexString();
      }
      log.databaseName = commandEvent.databaseName;
      log.serverConnectionId = commandEvent.serverConnectionId;
      return log;
    }
    function attachConnectionFields(log, event) {
      const { host, port } = utils_1.HostAddress.fromString(event.address).toHostPort();
      log.serverHost = host;
      log.serverPort = port;
      return log;
    }
    function attachSDAMFields(log, sdamEvent) {
      log.topologyId = sdamEvent.topologyId;
      return log;
    }
    function attachServerHeartbeatFields(log, serverHeartbeatEvent) {
      const { awaited, connectionId } = serverHeartbeatEvent;
      log.awaited = awaited;
      log.driverConnectionId = serverHeartbeatEvent.connectionId;
      const { host, port } = utils_1.HostAddress.fromString(connectionId).toHostPort();
      log.serverHost = host;
      log.serverPort = port;
      return log;
    }
    function defaultLogTransform(logObject, maxDocumentLength = exports2.DEFAULT_MAX_DOCUMENT_LENGTH) {
      let log = /* @__PURE__ */ Object.create(null);
      switch (logObject.name) {
        case constants_1.SERVER_SELECTION_STARTED:
          log = attachServerSelectionFields(log, logObject, maxDocumentLength);
          return log;
        case constants_1.SERVER_SELECTION_FAILED:
          log = attachServerSelectionFields(log, logObject, maxDocumentLength);
          log.failure = logObject.failure?.message;
          return log;
        case constants_1.SERVER_SELECTION_SUCCEEDED:
          log = attachServerSelectionFields(log, logObject, maxDocumentLength);
          log.serverHost = logObject.serverHost;
          log.serverPort = logObject.serverPort;
          return log;
        case constants_1.WAITING_FOR_SUITABLE_SERVER:
          log = attachServerSelectionFields(log, logObject, maxDocumentLength);
          log.remainingTimeMS = logObject.remainingTimeMS;
          return log;
        case constants_1.COMMAND_STARTED:
          log = attachCommandFields(log, logObject);
          log.message = "Command started";
          log.command = stringifyWithMaxLen(logObject.command, maxDocumentLength, { relaxed: true });
          log.databaseName = logObject.databaseName;
          return log;
        case constants_1.COMMAND_SUCCEEDED:
          log = attachCommandFields(log, logObject);
          log.message = "Command succeeded";
          log.durationMS = logObject.duration;
          log.reply = stringifyWithMaxLen(logObject.reply, maxDocumentLength, { relaxed: true });
          return log;
        case constants_1.COMMAND_FAILED:
          log = attachCommandFields(log, logObject);
          log.message = "Command failed";
          log.durationMS = logObject.duration;
          log.failure = logObject.failure?.message ?? "(redacted)";
          return log;
        case constants_1.CONNECTION_POOL_CREATED:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection pool created";
          if (logObject.options) {
            const { maxIdleTimeMS, minPoolSize, maxPoolSize, maxConnecting, waitQueueTimeoutMS } = logObject.options;
            log = {
              ...log,
              maxIdleTimeMS,
              minPoolSize,
              maxPoolSize,
              maxConnecting,
              waitQueueTimeoutMS
            };
          }
          return log;
        case constants_1.CONNECTION_POOL_READY:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection pool ready";
          return log;
        case constants_1.CONNECTION_POOL_CLEARED:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection pool cleared";
          if (logObject.serviceId?._bsontype === "ObjectId") {
            log.serviceId = logObject.serviceId?.toHexString();
          }
          return log;
        case constants_1.CONNECTION_POOL_CLOSED:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection pool closed";
          return log;
        case constants_1.CONNECTION_CREATED:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection created";
          log.driverConnectionId = logObject.connectionId;
          return log;
        case constants_1.CONNECTION_READY:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection ready";
          log.driverConnectionId = logObject.connectionId;
          log.durationMS = logObject.durationMS;
          return log;
        case constants_1.CONNECTION_CLOSED:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection closed";
          log.driverConnectionId = logObject.connectionId;
          switch (logObject.reason) {
            case "stale":
              log.reason = "Connection became stale because the pool was cleared";
              break;
            case "idle":
              log.reason = "Connection has been available but unused for longer than the configured max idle time";
              break;
            case "error":
              log.reason = "An error occurred while using the connection";
              if (logObject.error) {
                log.error = logObject.error;
              }
              break;
            case "poolClosed":
              log.reason = "Connection pool was closed";
              break;
            default:
              log.reason = `Unknown close reason: ${logObject.reason}`;
          }
          return log;
        case constants_1.CONNECTION_CHECK_OUT_STARTED:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection checkout started";
          return log;
        case constants_1.CONNECTION_CHECK_OUT_FAILED:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection checkout failed";
          switch (logObject.reason) {
            case "poolClosed":
              log.reason = "Connection pool was closed";
              break;
            case "timeout":
              log.reason = "Wait queue timeout elapsed without a connection becoming available";
              break;
            case "connectionError":
              log.reason = "An error occurred while trying to establish a new connection";
              if (logObject.error) {
                log.error = logObject.error;
              }
              break;
            default:
              log.reason = `Unknown close reason: ${logObject.reason}`;
          }
          log.durationMS = logObject.durationMS;
          return log;
        case constants_1.CONNECTION_CHECKED_OUT:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection checked out";
          log.driverConnectionId = logObject.connectionId;
          log.durationMS = logObject.durationMS;
          return log;
        case constants_1.CONNECTION_CHECKED_IN:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection checked in";
          log.driverConnectionId = logObject.connectionId;
          return log;
        case constants_1.SERVER_OPENING:
          log = attachSDAMFields(log, logObject);
          log = attachConnectionFields(log, logObject);
          log.message = "Starting server monitoring";
          return log;
        case constants_1.SERVER_CLOSED:
          log = attachSDAMFields(log, logObject);
          log = attachConnectionFields(log, logObject);
          log.message = "Stopped server monitoring";
          return log;
        case constants_1.SERVER_HEARTBEAT_STARTED:
          log = attachSDAMFields(log, logObject);
          log = attachServerHeartbeatFields(log, logObject);
          log.message = "Server heartbeat started";
          return log;
        case constants_1.SERVER_HEARTBEAT_SUCCEEDED:
          log = attachSDAMFields(log, logObject);
          log = attachServerHeartbeatFields(log, logObject);
          log.message = "Server heartbeat succeeded";
          log.durationMS = logObject.duration;
          log.serverConnectionId = logObject.serverConnectionId;
          log.reply = stringifyWithMaxLen(logObject.reply, maxDocumentLength, { relaxed: true });
          return log;
        case constants_1.SERVER_HEARTBEAT_FAILED:
          log = attachSDAMFields(log, logObject);
          log = attachServerHeartbeatFields(log, logObject);
          log.message = "Server heartbeat failed";
          log.durationMS = logObject.duration;
          log.failure = logObject.failure?.message;
          return log;
        case constants_1.TOPOLOGY_OPENING:
          log = attachSDAMFields(log, logObject);
          log.message = "Starting topology monitoring";
          return log;
        case constants_1.TOPOLOGY_CLOSED:
          log = attachSDAMFields(log, logObject);
          log.message = "Stopped topology monitoring";
          return log;
        case constants_1.TOPOLOGY_DESCRIPTION_CHANGED:
          log = attachSDAMFields(log, logObject);
          log.message = "Topology description changed";
          log.previousDescription = log.reply = stringifyWithMaxLen(logObject.previousDescription, maxDocumentLength);
          log.newDescription = log.reply = stringifyWithMaxLen(logObject.newDescription, maxDocumentLength);
          return log;
        default:
          for (const [key, value] of Object.entries(logObject)) {
            if (value != null)
              log[key] = value;
          }
      }
      return log;
    }
    var MongoLogger = class {
      constructor(options2) {
        this.pendingLog = null;
        this.error = this.log.bind(this, "error");
        this.warn = this.log.bind(this, "warn");
        this.info = this.log.bind(this, "info");
        this.debug = this.log.bind(this, "debug");
        this.trace = this.log.bind(this, "trace");
        this.componentSeverities = options2.componentSeverities;
        this.maxDocumentLength = options2.maxDocumentLength;
        this.logDestination = options2.logDestination;
        this.logDestinationIsStdErr = options2.logDestinationIsStdErr;
        this.severities = this.createLoggingSeverities();
      }
      createLoggingSeverities() {
        const severities = Object();
        for (const component of Object.values(exports2.MongoLoggableComponent)) {
          severities[component] = {};
          for (const severityLevel of Object.values(exports2.SeverityLevel)) {
            severities[component][severityLevel] = compareSeverity(severityLevel, this.componentSeverities[component]) <= 0;
          }
        }
        return severities;
      }
      turnOffSeverities() {
        for (const component of Object.values(exports2.MongoLoggableComponent)) {
          this.componentSeverities[component] = exports2.SeverityLevel.OFF;
          for (const severityLevel of Object.values(exports2.SeverityLevel)) {
            this.severities[component][severityLevel] = false;
          }
        }
      }
      logWriteFailureHandler(error2) {
        if (this.logDestinationIsStdErr) {
          this.turnOffSeverities();
          this.clearPendingLog();
          return;
        }
        this.logDestination = createStdioLogger(process.stderr);
        this.logDestinationIsStdErr = true;
        this.clearPendingLog();
        this.error(exports2.MongoLoggableComponent.CLIENT, {
          toLog: function() {
            return {
              message: "User input for mongodbLogPath is now invalid. Logging is halted.",
              error: error2.message
            };
          }
        });
        this.turnOffSeverities();
        this.clearPendingLog();
      }
      clearPendingLog() {
        this.pendingLog = null;
      }
      willLog(component, severity) {
        if (severity === exports2.SeverityLevel.OFF)
          return false;
        return this.severities[component][severity];
      }
      log(severity, component, message) {
        if (!this.willLog(component, severity))
          return;
        let logMessage = { t: /* @__PURE__ */ new Date(), c: component, s: severity };
        if (typeof message === "string") {
          logMessage.message = message;
        } else if (typeof message === "object") {
          if (isLogConvertible(message)) {
            logMessage = { ...logMessage, ...message.toLog() };
          } else {
            logMessage = { ...logMessage, ...defaultLogTransform(message, this.maxDocumentLength) };
          }
        }
        if ((0, utils_1.isPromiseLike)(this.pendingLog)) {
          this.pendingLog = this.pendingLog.then(() => this.logDestination.write(logMessage)).then(this.clearPendingLog.bind(this), this.logWriteFailureHandler.bind(this));
          return;
        }
        try {
          const logResult = this.logDestination.write(logMessage);
          if ((0, utils_1.isPromiseLike)(logResult)) {
            this.pendingLog = logResult.then(this.clearPendingLog.bind(this), this.logWriteFailureHandler.bind(this));
          }
        } catch (error2) {
          this.logWriteFailureHandler(error2);
        }
      }
      /**
       * Merges options set through environment variables and the MongoClient, preferring environment
       * variables when both are set, and substituting defaults for values not set. Options set in
       * constructor take precedence over both environment variables and MongoClient options.
       *
       * @remarks
       * When parsing component severity levels, invalid values are treated as unset and replaced with
       * the default severity.
       *
       * @param envOptions - options set for the logger from the environment
       * @param clientOptions - options set for the logger in the MongoClient options
       * @returns a MongoLoggerOptions object to be used when instantiating a new MongoLogger
       */
      static resolveOptions(envOptions, clientOptions) {
        const resolvedLogPath = resolveLogPath(envOptions, clientOptions);
        const combinedOptions = {
          ...envOptions,
          ...clientOptions,
          mongodbLogPath: resolvedLogPath.mongodbLogPath,
          mongodbLogPathIsStdErr: resolvedLogPath.mongodbLogPathIsStdErr
        };
        const defaultSeverity = resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.default, combinedOptions.MONGODB_LOG_ALL, exports2.SeverityLevel.OFF);
        return {
          componentSeverities: {
            command: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.command, combinedOptions.MONGODB_LOG_COMMAND, defaultSeverity),
            topology: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.topology, combinedOptions.MONGODB_LOG_TOPOLOGY, defaultSeverity),
            serverSelection: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.serverSelection, combinedOptions.MONGODB_LOG_SERVER_SELECTION, defaultSeverity),
            connection: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.connection, combinedOptions.MONGODB_LOG_CONNECTION, defaultSeverity),
            client: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.client, combinedOptions.MONGODB_LOG_CLIENT, defaultSeverity),
            default: defaultSeverity
          },
          maxDocumentLength: combinedOptions.mongodbLogMaxDocumentLength ?? (0, utils_1.parseUnsignedInteger)(combinedOptions.MONGODB_LOG_MAX_DOCUMENT_LENGTH) ?? 1e3,
          logDestination: combinedOptions.mongodbLogPath,
          logDestinationIsStdErr: combinedOptions.mongodbLogPathIsStdErr
        };
      }
    };
    exports2.MongoLogger = MongoLogger;
  }
});

// node_modules/mongodb/lib/mongo_types.js
var require_mongo_types = __commonJS({
  "node_modules/mongodb/lib/mongo_types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationToken = exports2.TypedEventEmitter = void 0;
    var events_1 = require("events");
    var mongo_logger_1 = require_mongo_logger();
    var utils_1 = require_utils5();
    var TypedEventEmitter = class extends events_1.EventEmitter {
      /** @internal */
      emitAndLog(event, ...args) {
        this.emit(event, ...args);
        if (this.component)
          this.mongoLogger?.debug(this.component, args[0]);
      }
      /** @internal */
      emitAndLogHeartbeat(event, topologyId, serverConnectionId, ...args) {
        this.emit(event, ...args);
        if (this.component) {
          const loggableHeartbeatEvent = {
            topologyId,
            serverConnectionId: serverConnectionId ?? null,
            ...args[0]
          };
          this.mongoLogger?.debug(this.component, loggableHeartbeatEvent);
        }
      }
      /** @internal */
      emitAndLogCommand(monitorCommands, event, databaseName, connectionEstablished, ...args) {
        if (monitorCommands) {
          this.emit(event, ...args);
        }
        if (connectionEstablished) {
          const loggableCommandEvent = {
            databaseName,
            ...args[0]
          };
          this.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.COMMAND, loggableCommandEvent);
        }
      }
    };
    exports2.TypedEventEmitter = TypedEventEmitter;
    var CancellationToken = class extends TypedEventEmitter {
      constructor(...args) {
        super(...args);
        this.on("error", utils_1.noop);
      }
    };
    exports2.CancellationToken = CancellationToken;
  }
});

// node_modules/mongodb/lib/operations/get_more.js
var require_get_more = __commonJS({
  "node_modules/mongodb/lib/operations/get_more.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GetMoreOperation = void 0;
    var responses_1 = require_responses();
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var operation_1 = require_operation();
    var GetMoreOperation = class extends operation_1.AbstractOperation {
      constructor(ns, cursorId, server, options2) {
        super(options2);
        this.options = options2;
        this.ns = ns;
        this.cursorId = cursorId;
        this.server = server;
      }
      get commandName() {
        return "getMore";
      }
      /**
       * Although there is a server already associated with the get more operation, the signature
       * for execute passes a server so we will just use that one.
       */
      async execute(server, _session, timeoutContext) {
        if (server !== this.server) {
          throw new error_1.MongoRuntimeError("Getmore must run on the same server operation began on");
        }
        if (this.cursorId == null || this.cursorId.isZero()) {
          throw new error_1.MongoRuntimeError("Unable to iterate cursor with no id");
        }
        const collection = this.ns.collection;
        if (collection == null) {
          throw new error_1.MongoRuntimeError("A collection name must be determined before getMore");
        }
        const getMoreCmd = {
          getMore: this.cursorId,
          collection
        };
        if (typeof this.options.batchSize === "number") {
          getMoreCmd.batchSize = Math.abs(this.options.batchSize);
        }
        if (typeof this.options.maxAwaitTimeMS === "number") {
          getMoreCmd.maxTimeMS = this.options.maxAwaitTimeMS;
        }
        if (this.options.comment !== void 0 && (0, utils_1.maxWireVersion)(server) >= 9) {
          getMoreCmd.comment = this.options.comment;
        }
        const commandOptions = {
          returnFieldSelector: null,
          documentsReturnedIn: "nextBatch",
          timeoutContext,
          ...this.options
        };
        return await server.command(this.ns, getMoreCmd, commandOptions, responses_1.CursorResponse);
      }
    };
    exports2.GetMoreOperation = GetMoreOperation;
    (0, operation_1.defineAspects)(GetMoreOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
  }
});

// node_modules/mongodb/lib/operations/kill_cursors.js
var require_kill_cursors = __commonJS({
  "node_modules/mongodb/lib/operations/kill_cursors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KillCursorsOperation = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var operation_1 = require_operation();
    var KillCursorsOperation = class extends operation_1.AbstractOperation {
      constructor(cursorId, ns, server, options2) {
        super(options2);
        this.ns = ns;
        this.cursorId = cursorId;
        this.server = server;
      }
      get commandName() {
        return "killCursors";
      }
      async execute(server, session, timeoutContext) {
        if (server !== this.server) {
          throw new error_1.MongoRuntimeError("Killcursor must run on the same server operation began on");
        }
        const killCursors = this.ns.collection;
        if (killCursors == null) {
          throw new error_1.MongoRuntimeError("A collection name must be determined before killCursors");
        }
        const killCursorsCommand = {
          killCursors,
          cursors: [this.cursorId]
        };
        try {
          await server.command(this.ns, killCursorsCommand, {
            session,
            timeoutContext
          });
        } catch (error2) {
          (0, utils_1.squashError)(error2);
        }
      }
    };
    exports2.KillCursorsOperation = KillCursorsOperation;
    (0, operation_1.defineAspects)(KillCursorsOperation, [operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
  }
});

// node_modules/mongodb/lib/operations/delete.js
var require_delete = __commonJS({
  "node_modules/mongodb/lib/operations/delete.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeleteManyOperation = exports2.DeleteOneOperation = exports2.DeleteOperation = void 0;
    exports2.makeDeleteStatement = makeDeleteStatement;
    var error_1 = require_error();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var DeleteOperation = class extends command_1.CommandOperation {
      constructor(ns, statements, options2) {
        super(void 0, options2);
        this.options = options2;
        this.ns = ns;
        this.statements = statements;
      }
      get commandName() {
        return "delete";
      }
      get canRetryWrite() {
        if (super.canRetryWrite === false) {
          return false;
        }
        return this.statements.every((op) => op.limit != null ? op.limit > 0 : true);
      }
      async execute(server, session, timeoutContext) {
        const options2 = this.options ?? {};
        const ordered = typeof options2.ordered === "boolean" ? options2.ordered : true;
        const command = {
          delete: this.ns.collection,
          deletes: this.statements,
          ordered
        };
        if (options2.let) {
          command.let = options2.let;
        }
        if (options2.comment !== void 0) {
          command.comment = options2.comment;
        }
        const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
        if (unacknowledgedWrite) {
          if (this.statements.find((o) => o.hint)) {
            throw new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`);
          }
        }
        const res = await super.executeCommand(server, session, command, timeoutContext);
        return res;
      }
    };
    exports2.DeleteOperation = DeleteOperation;
    var DeleteOneOperation = class extends DeleteOperation {
      constructor(collection, filter, options2) {
        super(collection.s.namespace, [makeDeleteStatement(filter, { ...options2, limit: 1 })], options2);
      }
      async execute(server, session, timeoutContext) {
        const res = await super.execute(server, session, timeoutContext);
        if (this.explain)
          return res;
        if (res.code)
          throw new error_1.MongoServerError(res);
        if (res.writeErrors)
          throw new error_1.MongoServerError(res.writeErrors[0]);
        return {
          acknowledged: this.writeConcern?.w !== 0,
          deletedCount: res.n
        };
      }
    };
    exports2.DeleteOneOperation = DeleteOneOperation;
    var DeleteManyOperation = class extends DeleteOperation {
      constructor(collection, filter, options2) {
        super(collection.s.namespace, [makeDeleteStatement(filter, options2)], options2);
      }
      async execute(server, session, timeoutContext) {
        const res = await super.execute(server, session, timeoutContext);
        if (this.explain)
          return res;
        if (res.code)
          throw new error_1.MongoServerError(res);
        if (res.writeErrors)
          throw new error_1.MongoServerError(res.writeErrors[0]);
        return {
          acknowledged: this.writeConcern?.w !== 0,
          deletedCount: res.n
        };
      }
    };
    exports2.DeleteManyOperation = DeleteManyOperation;
    function makeDeleteStatement(filter, options2) {
      const op = {
        q: filter,
        limit: typeof options2.limit === "number" ? options2.limit : 0
      };
      if (options2.collation) {
        op.collation = options2.collation;
      }
      if (options2.hint) {
        op.hint = options2.hint;
      }
      return op;
    }
    (0, operation_1.defineAspects)(DeleteOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(DeleteOneOperation, [
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.SKIP_COLLATION
    ]);
    (0, operation_1.defineAspects)(DeleteManyOperation, [
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.SKIP_COLLATION
    ]);
  }
});

// node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS({
  "node_modules/mongodb/lib/operations/bulk_write.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BulkWriteOperation = void 0;
    var operation_1 = require_operation();
    var BulkWriteOperation = class extends operation_1.AbstractOperation {
      constructor(collection, operations, options2) {
        super(options2);
        this.options = options2;
        this.collection = collection;
        this.operations = operations;
      }
      get commandName() {
        return "bulkWrite";
      }
      async execute(server, session, timeoutContext) {
        const coll = this.collection;
        const operations = this.operations;
        const options2 = {
          ...this.options,
          ...this.bsonOptions,
          readPreference: this.readPreference,
          timeoutContext
        };
        const bulk = options2.ordered === false ? coll.initializeUnorderedBulkOp(options2) : coll.initializeOrderedBulkOp(options2);
        for (let i = 0; i < operations.length; i++) {
          bulk.raw(operations[i]);
        }
        return await bulk.execute({ ...options2, session });
      }
    };
    exports2.BulkWriteOperation = BulkWriteOperation;
    (0, operation_1.defineAspects)(BulkWriteOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// node_modules/mongodb/lib/operations/insert.js
var require_insert = __commonJS({
  "node_modules/mongodb/lib/operations/insert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InsertManyOperation = exports2.InsertOneOperation = exports2.InsertOperation = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var write_concern_1 = require_write_concern();
    var bulk_write_1 = require_bulk_write();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var InsertOperation = class extends command_1.CommandOperation {
      constructor(ns, documents, options2) {
        super(void 0, options2);
        this.options = { ...options2, checkKeys: options2.checkKeys ?? false };
        this.ns = ns;
        this.documents = documents;
      }
      get commandName() {
        return "insert";
      }
      async execute(server, session, timeoutContext) {
        const options2 = this.options ?? {};
        const ordered = typeof options2.ordered === "boolean" ? options2.ordered : true;
        const command = {
          insert: this.ns.collection,
          documents: this.documents,
          ordered
        };
        if (typeof options2.bypassDocumentValidation === "boolean") {
          command.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        if (options2.comment !== void 0) {
          command.comment = options2.comment;
        }
        return await super.executeCommand(server, session, command, timeoutContext);
      }
    };
    exports2.InsertOperation = InsertOperation;
    var InsertOneOperation = class extends InsertOperation {
      constructor(collection, doc, options2) {
        super(collection.s.namespace, (0, utils_1.maybeAddIdToDocuments)(collection, [doc], options2), options2);
      }
      async execute(server, session, timeoutContext) {
        const res = await super.execute(server, session, timeoutContext);
        if (res.code)
          throw new error_1.MongoServerError(res);
        if (res.writeErrors) {
          throw new error_1.MongoServerError(res.writeErrors[0]);
        }
        return {
          acknowledged: this.writeConcern?.w !== 0,
          insertedId: this.documents[0]._id
        };
      }
    };
    exports2.InsertOneOperation = InsertOneOperation;
    var InsertManyOperation = class extends operation_1.AbstractOperation {
      constructor(collection, docs, options2) {
        super(options2);
        if (!Array.isArray(docs)) {
          throw new error_1.MongoInvalidArgumentError('Argument "docs" must be an array of documents');
        }
        this.options = options2;
        this.collection = collection;
        this.docs = docs;
      }
      get commandName() {
        return "insert";
      }
      async execute(server, session, timeoutContext) {
        const coll = this.collection;
        const options2 = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };
        const writeConcern = write_concern_1.WriteConcern.fromOptions(options2);
        const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, this.docs.map((document2) => ({
          insertOne: { document: document2 }
        })), options2);
        try {
          const res = await bulkWriteOperation.execute(server, session, timeoutContext);
          return {
            acknowledged: writeConcern?.w !== 0,
            insertedCount: res.insertedCount,
            insertedIds: res.insertedIds
          };
        } catch (err) {
          if (err && err.message === "Operation must be an object with an operation key") {
            throw new error_1.MongoInvalidArgumentError("Collection.insertMany() cannot be called with an array that has null/undefined values");
          }
          throw err;
        }
      }
    };
    exports2.InsertManyOperation = InsertManyOperation;
    (0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// node_modules/mongodb/lib/sort.js
var require_sort2 = __commonJS({
  "node_modules/mongodb/lib/sort.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatSort = formatSort;
    var error_1 = require_error();
    function prepareDirection(direction = 1) {
      const value = `${direction}`.toLowerCase();
      if (isMeta(direction))
        return direction;
      switch (value) {
        case "ascending":
        case "asc":
        case "1":
          return 1;
        case "descending":
        case "desc":
        case "-1":
          return -1;
        default:
          throw new error_1.MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);
      }
    }
    function isMeta(t) {
      return typeof t === "object" && t != null && "$meta" in t && typeof t.$meta === "string";
    }
    function isPair(t) {
      if (Array.isArray(t) && t.length === 2) {
        try {
          prepareDirection(t[1]);
          return true;
        } catch {
          return false;
        }
      }
      return false;
    }
    function isDeep(t) {
      return Array.isArray(t) && Array.isArray(t[0]);
    }
    function isMap(t) {
      return t instanceof Map && t.size > 0;
    }
    function isReadonlyArray(value) {
      return Array.isArray(value);
    }
    function pairToMap(v) {
      return /* @__PURE__ */ new Map([[`${v[0]}`, prepareDirection([v[1]])]]);
    }
    function deepToMap(t) {
      const sortEntries = t.map(([k, v]) => [`${k}`, prepareDirection(v)]);
      return new Map(sortEntries);
    }
    function stringsToMap(t) {
      const sortEntries = t.map((key) => [`${key}`, 1]);
      return new Map(sortEntries);
    }
    function objectToMap(t) {
      const sortEntries = Object.entries(t).map(([k, v]) => [
        `${k}`,
        prepareDirection(v)
      ]);
      return new Map(sortEntries);
    }
    function mapToMap(t) {
      const sortEntries = Array.from(t).map(([k, v]) => [
        `${k}`,
        prepareDirection(v)
      ]);
      return new Map(sortEntries);
    }
    function formatSort(sort, direction) {
      if (sort == null)
        return void 0;
      if (typeof sort === "string")
        return /* @__PURE__ */ new Map([[sort, prepareDirection(direction)]]);
      if (typeof sort !== "object") {
        throw new error_1.MongoInvalidArgumentError(`Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`);
      }
      if (!isReadonlyArray(sort)) {
        if (isMap(sort))
          return mapToMap(sort);
        if (Object.keys(sort).length)
          return objectToMap(sort);
        return void 0;
      }
      if (!sort.length)
        return void 0;
      if (isDeep(sort))
        return deepToMap(sort);
      if (isPair(sort))
        return pairToMap(sort);
      return stringsToMap(sort);
    }
  }
});

// node_modules/mongodb/lib/operations/update.js
var require_update = __commonJS({
  "node_modules/mongodb/lib/operations/update.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReplaceOneOperation = exports2.UpdateManyOperation = exports2.UpdateOneOperation = exports2.UpdateOperation = void 0;
    exports2.makeUpdateStatement = makeUpdateStatement;
    var error_1 = require_error();
    var sort_1 = require_sort2();
    var utils_1 = require_utils5();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var UpdateOperation = class extends command_1.CommandOperation {
      constructor(ns, statements, options2) {
        super(void 0, options2);
        this.options = options2;
        this.ns = ns;
        this.statements = statements;
      }
      get commandName() {
        return "update";
      }
      get canRetryWrite() {
        if (super.canRetryWrite === false) {
          return false;
        }
        return this.statements.every((op) => op.multi == null || op.multi === false);
      }
      async execute(server, session, timeoutContext) {
        const options2 = this.options ?? {};
        const ordered = typeof options2.ordered === "boolean" ? options2.ordered : true;
        const command = {
          update: this.ns.collection,
          updates: this.statements,
          ordered
        };
        if (typeof options2.bypassDocumentValidation === "boolean") {
          command.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        if (options2.let) {
          command.let = options2.let;
        }
        if (options2.comment !== void 0) {
          command.comment = options2.comment;
        }
        const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
        if (unacknowledgedWrite) {
          if (this.statements.find((o) => o.hint)) {
            throw new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`);
          }
        }
        const res = await super.executeCommand(server, session, command, timeoutContext);
        return res;
      }
    };
    exports2.UpdateOperation = UpdateOperation;
    var UpdateOneOperation = class extends UpdateOperation {
      constructor(collection, filter, update, options2) {
        super(collection.s.namespace, [makeUpdateStatement(filter, update, { ...options2, multi: false })], options2);
        if (!(0, utils_1.hasAtomicOperators)(update, options2)) {
          throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
        }
      }
      async execute(server, session, timeoutContext) {
        const res = await super.execute(server, session, timeoutContext);
        if (this.explain != null)
          return res;
        if (res.code)
          throw new error_1.MongoServerError(res);
        if (res.writeErrors)
          throw new error_1.MongoServerError(res.writeErrors[0]);
        return {
          acknowledged: this.writeConcern?.w !== 0,
          modifiedCount: res.nModified ?? res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        };
      }
    };
    exports2.UpdateOneOperation = UpdateOneOperation;
    var UpdateManyOperation = class extends UpdateOperation {
      constructor(collection, filter, update, options2) {
        super(collection.s.namespace, [makeUpdateStatement(filter, update, { ...options2, multi: true })], options2);
        if (!(0, utils_1.hasAtomicOperators)(update, options2)) {
          throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
        }
      }
      async execute(server, session, timeoutContext) {
        const res = await super.execute(server, session, timeoutContext);
        if (this.explain != null)
          return res;
        if (res.code)
          throw new error_1.MongoServerError(res);
        if (res.writeErrors)
          throw new error_1.MongoServerError(res.writeErrors[0]);
        return {
          acknowledged: this.writeConcern?.w !== 0,
          modifiedCount: res.nModified ?? res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        };
      }
    };
    exports2.UpdateManyOperation = UpdateManyOperation;
    var ReplaceOneOperation = class extends UpdateOperation {
      constructor(collection, filter, replacement, options2) {
        super(collection.s.namespace, [makeUpdateStatement(filter, replacement, { ...options2, multi: false })], options2);
        if ((0, utils_1.hasAtomicOperators)(replacement)) {
          throw new error_1.MongoInvalidArgumentError("Replacement document must not contain atomic operators");
        }
      }
      async execute(server, session, timeoutContext) {
        const res = await super.execute(server, session, timeoutContext);
        if (this.explain != null)
          return res;
        if (res.code)
          throw new error_1.MongoServerError(res);
        if (res.writeErrors)
          throw new error_1.MongoServerError(res.writeErrors[0]);
        return {
          acknowledged: this.writeConcern?.w !== 0,
          modifiedCount: res.nModified ?? res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        };
      }
    };
    exports2.ReplaceOneOperation = ReplaceOneOperation;
    function makeUpdateStatement(filter, update, options2) {
      if (filter == null || typeof filter !== "object") {
        throw new error_1.MongoInvalidArgumentError("Selector must be a valid JavaScript object");
      }
      if (update == null || typeof update !== "object") {
        throw new error_1.MongoInvalidArgumentError("Document must be a valid JavaScript object");
      }
      const op = { q: filter, u: update };
      if (typeof options2.upsert === "boolean") {
        op.upsert = options2.upsert;
      }
      if (options2.multi) {
        op.multi = options2.multi;
      }
      if (options2.hint) {
        op.hint = options2.hint;
      }
      if (options2.arrayFilters) {
        op.arrayFilters = options2.arrayFilters;
      }
      if (options2.collation) {
        op.collation = options2.collation;
      }
      if (!options2.multi && options2.sort != null) {
        op.sort = (0, sort_1.formatSort)(options2.sort);
      }
      return op;
    }
    (0, operation_1.defineAspects)(UpdateOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION]);
    (0, operation_1.defineAspects)(UpdateOneOperation, [
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.SKIP_COLLATION
    ]);
    (0, operation_1.defineAspects)(UpdateManyOperation, [
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.SKIP_COLLATION
    ]);
    (0, operation_1.defineAspects)(ReplaceOneOperation, [
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.SKIP_COLLATION
    ]);
  }
});

// node_modules/mongodb/lib/bulk/common.js
var require_common3 = __commonJS({
  "node_modules/mongodb/lib/bulk/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BulkOperationBase = exports2.BulkWriteShimOperation = exports2.FindOperators = exports2.MongoBulkWriteError = exports2.WriteError = exports2.WriteConcernError = exports2.BulkWriteResult = exports2.Batch = exports2.BatchType = void 0;
    exports2.mergeBatchResults = mergeBatchResults;
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var delete_1 = require_delete();
    var execute_operation_1 = require_execute_operation();
    var insert_1 = require_insert();
    var operation_1 = require_operation();
    var update_1 = require_update();
    var utils_1 = require_utils5();
    var write_concern_1 = require_write_concern();
    exports2.BatchType = Object.freeze({
      INSERT: 1,
      UPDATE: 2,
      DELETE: 3
    });
    var Batch = class {
      constructor(batchType, originalZeroIndex) {
        this.originalZeroIndex = originalZeroIndex;
        this.currentIndex = 0;
        this.originalIndexes = [];
        this.batchType = batchType;
        this.operations = [];
        this.size = 0;
        this.sizeBytes = 0;
      }
    };
    exports2.Batch = Batch;
    var BulkWriteResult = class _BulkWriteResult {
      static generateIdMap(ids) {
        const idMap = {};
        for (const doc of ids) {
          idMap[doc.index] = doc._id;
        }
        return idMap;
      }
      /**
       * Create a new BulkWriteResult instance
       * @internal
       */
      constructor(bulkResult, isOrdered) {
        this.result = bulkResult;
        this.insertedCount = this.result.nInserted ?? 0;
        this.matchedCount = this.result.nMatched ?? 0;
        this.modifiedCount = this.result.nModified ?? 0;
        this.deletedCount = this.result.nRemoved ?? 0;
        this.upsertedCount = this.result.upserted.length ?? 0;
        this.upsertedIds = _BulkWriteResult.generateIdMap(this.result.upserted);
        this.insertedIds = _BulkWriteResult.generateIdMap(this.getSuccessfullyInsertedIds(bulkResult, isOrdered));
        Object.defineProperty(this, "result", { value: this.result, enumerable: false });
      }
      /** Evaluates to true if the bulk operation correctly executes */
      get ok() {
        return this.result.ok;
      }
      /**
       * Returns document_ids that were actually inserted
       * @internal
       */
      getSuccessfullyInsertedIds(bulkResult, isOrdered) {
        if (bulkResult.writeErrors.length === 0)
          return bulkResult.insertedIds;
        if (isOrdered) {
          return bulkResult.insertedIds.slice(0, bulkResult.writeErrors[0].index);
        }
        return bulkResult.insertedIds.filter(({ index }) => !bulkResult.writeErrors.some((writeError) => index === writeError.index));
      }
      /** Returns the upserted id at the given index */
      getUpsertedIdAt(index) {
        return this.result.upserted[index];
      }
      /** Returns raw internal result */
      getRawResponse() {
        return this.result;
      }
      /** Returns true if the bulk operation contains a write error */
      hasWriteErrors() {
        return this.result.writeErrors.length > 0;
      }
      /** Returns the number of write errors from the bulk operation */
      getWriteErrorCount() {
        return this.result.writeErrors.length;
      }
      /** Returns a specific write error object */
      getWriteErrorAt(index) {
        return index < this.result.writeErrors.length ? this.result.writeErrors[index] : void 0;
      }
      /** Retrieve all write errors */
      getWriteErrors() {
        return this.result.writeErrors;
      }
      /** Retrieve the write concern error if one exists */
      getWriteConcernError() {
        if (this.result.writeConcernErrors.length === 0) {
          return;
        } else if (this.result.writeConcernErrors.length === 1) {
          return this.result.writeConcernErrors[0];
        } else {
          let errmsg = "";
          for (let i = 0; i < this.result.writeConcernErrors.length; i++) {
            const err = this.result.writeConcernErrors[i];
            errmsg = errmsg + err.errmsg;
            if (i === 0)
              errmsg = errmsg + " and ";
          }
          return new WriteConcernError({ errmsg, code: error_1.MONGODB_ERROR_CODES.WriteConcernTimeout });
        }
      }
      toString() {
        return `BulkWriteResult(${bson_1.EJSON.stringify(this.result)})`;
      }
      isOk() {
        return this.result.ok === 1;
      }
    };
    exports2.BulkWriteResult = BulkWriteResult;
    var WriteConcernError = class {
      constructor(error2) {
        this.serverError = error2;
      }
      /** Write concern error code. */
      get code() {
        return this.serverError.code;
      }
      /** Write concern error message. */
      get errmsg() {
        return this.serverError.errmsg;
      }
      /** Write concern error info. */
      get errInfo() {
        return this.serverError.errInfo;
      }
      toJSON() {
        return this.serverError;
      }
      toString() {
        return `WriteConcernError(${this.errmsg})`;
      }
    };
    exports2.WriteConcernError = WriteConcernError;
    var WriteError = class {
      constructor(err) {
        this.err = err;
      }
      /** WriteError code. */
      get code() {
        return this.err.code;
      }
      /** WriteError original bulk operation index. */
      get index() {
        return this.err.index;
      }
      /** WriteError message. */
      get errmsg() {
        return this.err.errmsg;
      }
      /** WriteError details. */
      get errInfo() {
        return this.err.errInfo;
      }
      /** Returns the underlying operation that caused the error */
      getOperation() {
        return this.err.op;
      }
      toJSON() {
        return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
      }
      toString() {
        return `WriteError(${JSON.stringify(this.toJSON())})`;
      }
    };
    exports2.WriteError = WriteError;
    function mergeBatchResults(batch, bulkResult, err, result) {
      if (err) {
        result = err;
      } else if (result && result.result) {
        result = result.result;
      }
      if (result == null) {
        return;
      }
      if (result.ok === 0 && bulkResult.ok === 1) {
        bulkResult.ok = 0;
        const writeError = {
          index: 0,
          code: result.code || 0,
          errmsg: result.message,
          errInfo: result.errInfo,
          op: batch.operations[0]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
        return;
      } else if (result.ok === 0 && bulkResult.ok === 0) {
        return;
      }
      if (isInsertBatch(batch) && result.n) {
        bulkResult.nInserted = bulkResult.nInserted + result.n;
      }
      if (isDeleteBatch(batch) && result.n) {
        bulkResult.nRemoved = bulkResult.nRemoved + result.n;
      }
      let nUpserted = 0;
      if (Array.isArray(result.upserted)) {
        nUpserted = result.upserted.length;
        for (let i = 0; i < result.upserted.length; i++) {
          bulkResult.upserted.push({
            index: result.upserted[i].index + batch.originalZeroIndex,
            _id: result.upserted[i]._id
          });
        }
      } else if (result.upserted) {
        nUpserted = 1;
        bulkResult.upserted.push({
          index: batch.originalZeroIndex,
          _id: result.upserted
        });
      }
      if (isUpdateBatch(batch) && result.n) {
        const nModified = result.nModified;
        bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
        bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
        if (typeof nModified === "number") {
          bulkResult.nModified = bulkResult.nModified + nModified;
        } else {
          bulkResult.nModified = 0;
        }
      }
      if (Array.isArray(result.writeErrors)) {
        for (let i = 0; i < result.writeErrors.length; i++) {
          const writeError = {
            index: batch.originalIndexes[result.writeErrors[i].index],
            code: result.writeErrors[i].code,
            errmsg: result.writeErrors[i].errmsg,
            errInfo: result.writeErrors[i].errInfo,
            op: batch.operations[result.writeErrors[i].index]
          };
          bulkResult.writeErrors.push(new WriteError(writeError));
        }
      }
      if (result.writeConcernError) {
        bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
      }
    }
    async function executeCommands(bulkOperation, options2) {
      if (bulkOperation.s.batches.length === 0) {
        return new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
      }
      for (const batch of bulkOperation.s.batches) {
        const finalOptions = (0, utils_1.resolveOptions)(bulkOperation, {
          ...options2,
          ordered: bulkOperation.isOrdered
        });
        if (finalOptions.bypassDocumentValidation !== true) {
          delete finalOptions.bypassDocumentValidation;
        }
        if (bulkOperation.s.bypassDocumentValidation === true) {
          finalOptions.bypassDocumentValidation = true;
        }
        if (bulkOperation.s.checkKeys === false) {
          finalOptions.checkKeys = false;
        }
        if (finalOptions.retryWrites) {
          if (isUpdateBatch(batch)) {
            finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some((op) => op.multi);
          }
          if (isDeleteBatch(batch)) {
            finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some((op) => op.limit === 0);
          }
        }
        const operation = isInsertBatch(batch) ? new insert_1.InsertOperation(bulkOperation.s.namespace, batch.operations, finalOptions) : isUpdateBatch(batch) ? new update_1.UpdateOperation(bulkOperation.s.namespace, batch.operations, finalOptions) : isDeleteBatch(batch) ? new delete_1.DeleteOperation(bulkOperation.s.namespace, batch.operations, finalOptions) : null;
        if (operation == null)
          throw new error_1.MongoRuntimeError(`Unknown batchType: ${batch.batchType}`);
        let thrownError = null;
        let result;
        try {
          result = await (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.client, operation, finalOptions.timeoutContext);
        } catch (error2) {
          thrownError = error2;
        }
        if (thrownError != null) {
          if (thrownError instanceof error_1.MongoWriteConcernError) {
            mergeBatchResults(batch, bulkOperation.s.bulkResult, thrownError, result);
            const writeResult3 = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
            throw new MongoBulkWriteError({
              message: thrownError.result.writeConcernError.errmsg,
              code: thrownError.result.writeConcernError.code
            }, writeResult3);
          } else {
            throw new MongoBulkWriteError(thrownError, new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered));
          }
        }
        mergeBatchResults(batch, bulkOperation.s.bulkResult, thrownError, result);
        const writeResult2 = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
        bulkOperation.handleWriteError(writeResult2);
      }
      bulkOperation.s.batches.length = 0;
      const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
      bulkOperation.handleWriteError(writeResult);
      return writeResult;
    }
    var MongoBulkWriteError = class extends error_1.MongoServerError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(error2, result) {
        super(error2);
        this.writeErrors = [];
        if (error2 instanceof WriteConcernError)
          this.err = error2;
        else if (!(error2 instanceof Error)) {
          this.message = error2.message;
          this.code = error2.code;
          this.writeErrors = error2.writeErrors ?? [];
        }
        this.result = result;
        Object.assign(this, error2);
      }
      get name() {
        return "MongoBulkWriteError";
      }
      /** Number of documents inserted. */
      get insertedCount() {
        return this.result.insertedCount;
      }
      /** Number of documents matched for update. */
      get matchedCount() {
        return this.result.matchedCount;
      }
      /** Number of documents modified. */
      get modifiedCount() {
        return this.result.modifiedCount;
      }
      /** Number of documents deleted. */
      get deletedCount() {
        return this.result.deletedCount;
      }
      /** Number of documents upserted. */
      get upsertedCount() {
        return this.result.upsertedCount;
      }
      /** Inserted document generated Id's, hash key is the index of the originating operation */
      get insertedIds() {
        return this.result.insertedIds;
      }
      /** Upserted document generated Id's, hash key is the index of the originating operation */
      get upsertedIds() {
        return this.result.upsertedIds;
      }
    };
    exports2.MongoBulkWriteError = MongoBulkWriteError;
    var FindOperators = class {
      /**
       * Creates a new FindOperators object.
       * @internal
       */
      constructor(bulkOperation) {
        this.bulkOperation = bulkOperation;
      }
      /** Add a multiple update operation to the bulk operation */
      update(updateDocument) {
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports2.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, {
          ...currentOp,
          multi: true
        }));
      }
      /** Add a single update operation to the bulk operation */
      updateOne(updateDocument) {
        if (!(0, utils_1.hasAtomicOperators)(updateDocument, this.bulkOperation.bsonOptions)) {
          throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
        }
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports2.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, { ...currentOp, multi: false }));
      }
      /** Add a replace one operation to the bulk operation */
      replaceOne(replacement) {
        if ((0, utils_1.hasAtomicOperators)(replacement)) {
          throw new error_1.MongoInvalidArgumentError("Replacement document must not use atomic operators");
        }
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports2.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, replacement, { ...currentOp, multi: false }));
      }
      /** Add a delete one operation to the bulk operation */
      deleteOne() {
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports2.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 1 }));
      }
      /** Add a delete many operation to the bulk operation */
      delete() {
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports2.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 0 }));
      }
      /** Upsert modifier for update bulk operation, noting that this operation is an upsert. */
      upsert() {
        if (!this.bulkOperation.s.currentOp) {
          this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.upsert = true;
        return this;
      }
      /** Specifies the collation for the query condition. */
      collation(collation) {
        if (!this.bulkOperation.s.currentOp) {
          this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.collation = collation;
        return this;
      }
      /** Specifies arrayFilters for UpdateOne or UpdateMany bulk operations. */
      arrayFilters(arrayFilters) {
        if (!this.bulkOperation.s.currentOp) {
          this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.arrayFilters = arrayFilters;
        return this;
      }
      /** Specifies hint for the bulk operation. */
      hint(hint) {
        if (!this.bulkOperation.s.currentOp) {
          this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.hint = hint;
        return this;
      }
    };
    exports2.FindOperators = FindOperators;
    var BulkWriteShimOperation = class extends operation_1.AbstractOperation {
      constructor(bulkOperation, options2) {
        super(options2);
        this.bulkOperation = bulkOperation;
      }
      get commandName() {
        return "bulkWrite";
      }
      async execute(_server, session, timeoutContext) {
        if (this.options.session == null) {
          this.options.session = session;
        }
        return await executeCommands(this.bulkOperation, { ...this.options, timeoutContext });
      }
    };
    exports2.BulkWriteShimOperation = BulkWriteShimOperation;
    var BulkOperationBase = class {
      /**
       * Create a new OrderedBulkOperation or UnorderedBulkOperation instance
       * @internal
       */
      constructor(collection, options2, isOrdered) {
        this.collection = collection;
        this.isOrdered = isOrdered;
        const topology = (0, utils_1.getTopology)(collection);
        options2 = options2 == null ? {} : options2;
        const namespace = collection.s.namespace;
        const executed = false;
        const currentOp = void 0;
        const hello = topology.lastHello();
        const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
        const maxBsonObjectSize = hello && hello.maxBsonObjectSize ? hello.maxBsonObjectSize : 1024 * 1024 * 16;
        const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
        const maxWriteBatchSize = hello && hello.maxWriteBatchSize ? hello.maxWriteBatchSize : 1e3;
        const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
        let finalOptions = Object.assign({}, options2);
        finalOptions = (0, utils_1.applyRetryableWrites)(finalOptions, collection.s.db);
        const bulkResult = {
          ok: 1,
          writeErrors: [],
          writeConcernErrors: [],
          insertedIds: [],
          nInserted: 0,
          nUpserted: 0,
          nMatched: 0,
          nModified: 0,
          nRemoved: 0,
          upserted: []
        };
        this.s = {
          // Final result
          bulkResult,
          // Current batch state
          currentBatch: void 0,
          currentIndex: 0,
          // ordered specific
          currentBatchSize: 0,
          currentBatchSizeBytes: 0,
          // unordered specific
          currentInsertBatch: void 0,
          currentUpdateBatch: void 0,
          currentRemoveBatch: void 0,
          batches: [],
          // Write concern
          writeConcern: write_concern_1.WriteConcern.fromOptions(options2),
          // Max batch size options
          maxBsonObjectSize,
          maxBatchSizeBytes,
          maxWriteBatchSize,
          maxKeySize,
          // Namespace
          namespace,
          // Topology
          topology,
          // Options
          options: finalOptions,
          // BSON options
          bsonOptions: (0, bson_1.resolveBSONOptions)(options2),
          // Current operation
          currentOp,
          // Executed
          executed,
          // Collection
          collection,
          // Fundamental error
          err: void 0,
          // check keys
          checkKeys: typeof options2.checkKeys === "boolean" ? options2.checkKeys : false
        };
        if (options2.bypassDocumentValidation === true) {
          this.s.bypassDocumentValidation = true;
        }
      }
      /**
       * Add a single insert document to the bulk operation
       *
       * @example
       * ```ts
       * const bulkOp = collection.initializeOrderedBulkOp();
       *
       * // Adds three inserts to the bulkOp.
       * bulkOp
       *   .insert({ a: 1 })
       *   .insert({ b: 2 })
       *   .insert({ c: 3 });
       * await bulkOp.execute();
       * ```
       */
      insert(document2) {
        (0, utils_1.maybeAddIdToDocuments)(this.collection, document2, {
          forceServerObjectId: this.shouldForceServerObjectId()
        });
        return this.addToOperationsList(exports2.BatchType.INSERT, document2);
      }
      /**
       * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.
       * Returns a builder object used to complete the definition of the operation.
       *
       * @example
       * ```ts
       * const bulkOp = collection.initializeOrderedBulkOp();
       *
       * // Add an updateOne to the bulkOp
       * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });
       *
       * // Add an updateMany to the bulkOp
       * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });
       *
       * // Add an upsert
       * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });
       *
       * // Add a deletion
       * bulkOp.find({ g: 7 }).deleteOne();
       *
       * // Add a multi deletion
       * bulkOp.find({ h: 8 }).delete();
       *
       * // Add a replaceOne
       * bulkOp.find({ i: 9 }).replaceOne({writeConcern: { j: 10 }});
       *
       * // Update using a pipeline (requires Mongodb 4.2 or higher)
       * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([
       *   { $set: { total: { $sum: [ '$y', '$z' ] } } }
       * ]);
       *
       * // All of the ops will now be executed
       * await bulkOp.execute();
       * ```
       */
      find(selector) {
        if (!selector) {
          throw new error_1.MongoInvalidArgumentError("Bulk find operation must specify a selector");
        }
        this.s.currentOp = {
          selector
        };
        return new FindOperators(this);
      }
      /** Specifies a raw operation to perform in the bulk write. */
      raw(op) {
        if (op == null || typeof op !== "object") {
          throw new error_1.MongoInvalidArgumentError("Operation must be an object with an operation key");
        }
        if ("insertOne" in op) {
          const forceServerObjectId = this.shouldForceServerObjectId();
          const document2 = op.insertOne && op.insertOne.document == null ? (
            // TODO(NODE-6003): remove support for omitting the `documents` subdocument in bulk inserts
            op.insertOne
          ) : op.insertOne.document;
          (0, utils_1.maybeAddIdToDocuments)(this.collection, document2, { forceServerObjectId });
          return this.addToOperationsList(exports2.BatchType.INSERT, document2);
        }
        if ("replaceOne" in op || "updateOne" in op || "updateMany" in op) {
          if ("replaceOne" in op) {
            if ("q" in op.replaceOne) {
              throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
            }
            const updateStatement = (0, update_1.makeUpdateStatement)(op.replaceOne.filter, op.replaceOne.replacement, { ...op.replaceOne, multi: false });
            if ((0, utils_1.hasAtomicOperators)(updateStatement.u)) {
              throw new error_1.MongoInvalidArgumentError("Replacement document must not use atomic operators");
            }
            return this.addToOperationsList(exports2.BatchType.UPDATE, updateStatement);
          }
          if ("updateOne" in op) {
            if ("q" in op.updateOne) {
              throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
            }
            const updateStatement = (0, update_1.makeUpdateStatement)(op.updateOne.filter, op.updateOne.update, {
              ...op.updateOne,
              multi: false
            });
            if (!(0, utils_1.hasAtomicOperators)(updateStatement.u, this.bsonOptions)) {
              throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
            }
            return this.addToOperationsList(exports2.BatchType.UPDATE, updateStatement);
          }
          if ("updateMany" in op) {
            if ("q" in op.updateMany) {
              throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
            }
            const updateStatement = (0, update_1.makeUpdateStatement)(op.updateMany.filter, op.updateMany.update, {
              ...op.updateMany,
              multi: true
            });
            if (!(0, utils_1.hasAtomicOperators)(updateStatement.u, this.bsonOptions)) {
              throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
            }
            return this.addToOperationsList(exports2.BatchType.UPDATE, updateStatement);
          }
        }
        if ("deleteOne" in op) {
          if ("q" in op.deleteOne) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          return this.addToOperationsList(exports2.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteOne.filter, { ...op.deleteOne, limit: 1 }));
        }
        if ("deleteMany" in op) {
          if ("q" in op.deleteMany) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          return this.addToOperationsList(exports2.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteMany.filter, { ...op.deleteMany, limit: 0 }));
        }
        throw new error_1.MongoInvalidArgumentError("bulkWrite only supports insertOne, updateOne, updateMany, deleteOne, deleteMany");
      }
      get length() {
        return this.s.currentIndex;
      }
      get bsonOptions() {
        return this.s.bsonOptions;
      }
      get writeConcern() {
        return this.s.writeConcern;
      }
      get batches() {
        const batches = [...this.s.batches];
        if (this.isOrdered) {
          if (this.s.currentBatch)
            batches.push(this.s.currentBatch);
        } else {
          if (this.s.currentInsertBatch)
            batches.push(this.s.currentInsertBatch);
          if (this.s.currentUpdateBatch)
            batches.push(this.s.currentUpdateBatch);
          if (this.s.currentRemoveBatch)
            batches.push(this.s.currentRemoveBatch);
        }
        return batches;
      }
      async execute(options2 = {}) {
        if (this.s.executed) {
          throw new error_1.MongoBatchReExecutionError();
        }
        const writeConcern = write_concern_1.WriteConcern.fromOptions(options2);
        if (writeConcern) {
          this.s.writeConcern = writeConcern;
        }
        if (this.isOrdered) {
          if (this.s.currentBatch)
            this.s.batches.push(this.s.currentBatch);
        } else {
          if (this.s.currentInsertBatch)
            this.s.batches.push(this.s.currentInsertBatch);
          if (this.s.currentUpdateBatch)
            this.s.batches.push(this.s.currentUpdateBatch);
          if (this.s.currentRemoveBatch)
            this.s.batches.push(this.s.currentRemoveBatch);
        }
        if (this.s.batches.length === 0) {
          throw new error_1.MongoInvalidArgumentError("Invalid BulkOperation, Batch cannot be empty");
        }
        this.s.executed = true;
        const finalOptions = { ...this.s.options, ...options2 };
        const operation = new BulkWriteShimOperation(this, finalOptions);
        return await (0, execute_operation_1.executeOperation)(this.s.collection.client, operation, finalOptions.timeoutContext);
      }
      /**
       * Handles the write error before executing commands
       * @internal
       */
      handleWriteError(writeResult) {
        if (this.s.bulkResult.writeErrors.length > 0) {
          const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
          throw new MongoBulkWriteError({
            message: msg,
            code: this.s.bulkResult.writeErrors[0].code,
            writeErrors: this.s.bulkResult.writeErrors
          }, writeResult);
        }
        const writeConcernError = writeResult.getWriteConcernError();
        if (writeConcernError) {
          throw new MongoBulkWriteError(writeConcernError, writeResult);
        }
      }
      shouldForceServerObjectId() {
        return this.s.options.forceServerObjectId === true || this.s.collection.s.db.options?.forceServerObjectId === true;
      }
    };
    exports2.BulkOperationBase = BulkOperationBase;
    function isInsertBatch(batch) {
      return batch.batchType === exports2.BatchType.INSERT;
    }
    function isUpdateBatch(batch) {
      return batch.batchType === exports2.BatchType.UPDATE;
    }
    function isDeleteBatch(batch) {
      return batch.batchType === exports2.BatchType.DELETE;
    }
    function buildCurrentOp(bulkOp) {
      let { currentOp } = bulkOp.s;
      bulkOp.s.currentOp = void 0;
      if (!currentOp)
        currentOp = {};
      return currentOp;
    }
  }
});

// node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS({
  "node_modules/mongodb/lib/bulk/ordered.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OrderedBulkOperation = void 0;
    var BSON = require_bson2();
    var error_1 = require_error();
    var common_1 = require_common3();
    var OrderedBulkOperation = class extends common_1.BulkOperationBase {
      /** @internal */
      constructor(collection, options2) {
        super(collection, options2, true);
      }
      addToOperationsList(batchType, document2) {
        const bsonSize = BSON.calculateObjectSize(document2, {
          checkKeys: false,
          // Since we don't know what the user selected for BSON options here,
          // err on the safe side, and check the size with ignoreUndefined: false.
          ignoreUndefined: false
        });
        if (bsonSize >= this.s.maxBsonObjectSize)
          throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
        if (this.s.currentBatch == null) {
          this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
        }
        const maxKeySize = this.s.maxKeySize;
        if (
          // New batch if we exceed the max batch op size
          this.s.currentBatchSize + 1 >= this.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,
          // since we can't sent an empty batch
          this.s.currentBatchSize > 0 && this.s.currentBatchSizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch
          this.s.currentBatch.batchType !== batchType
        ) {
          this.s.batches.push(this.s.currentBatch);
          this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
          this.s.currentBatchSize = 0;
          this.s.currentBatchSizeBytes = 0;
        }
        if (batchType === common_1.BatchType.INSERT) {
          this.s.bulkResult.insertedIds.push({
            index: this.s.currentIndex,
            _id: document2._id
          });
        }
        if (Array.isArray(document2)) {
          throw new error_1.MongoInvalidArgumentError("Operation passed in cannot be an Array");
        }
        this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
        this.s.currentBatch.operations.push(document2);
        this.s.currentBatchSize += 1;
        this.s.currentBatchSizeBytes += maxKeySize + bsonSize;
        this.s.currentIndex += 1;
        return this;
      }
    };
    exports2.OrderedBulkOperation = OrderedBulkOperation;
  }
});

// node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS({
  "node_modules/mongodb/lib/bulk/unordered.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnorderedBulkOperation = void 0;
    var BSON = require_bson2();
    var error_1 = require_error();
    var common_1 = require_common3();
    var UnorderedBulkOperation = class extends common_1.BulkOperationBase {
      /** @internal */
      constructor(collection, options2) {
        super(collection, options2, false);
      }
      handleWriteError(writeResult) {
        if (this.s.batches.length) {
          return;
        }
        return super.handleWriteError(writeResult);
      }
      addToOperationsList(batchType, document2) {
        const bsonSize = BSON.calculateObjectSize(document2, {
          checkKeys: false,
          // Since we don't know what the user selected for BSON options here,
          // err on the safe side, and check the size with ignoreUndefined: false.
          ignoreUndefined: false
        });
        if (bsonSize >= this.s.maxBsonObjectSize) {
          throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
        }
        this.s.currentBatch = void 0;
        if (batchType === common_1.BatchType.INSERT) {
          this.s.currentBatch = this.s.currentInsertBatch;
        } else if (batchType === common_1.BatchType.UPDATE) {
          this.s.currentBatch = this.s.currentUpdateBatch;
        } else if (batchType === common_1.BatchType.DELETE) {
          this.s.currentBatch = this.s.currentRemoveBatch;
        }
        const maxKeySize = this.s.maxKeySize;
        if (this.s.currentBatch == null) {
          this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
        }
        if (
          // New batch if we exceed the max batch op size
          this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,
          // since we can't sent an empty batch
          this.s.currentBatch.size > 0 && this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch
          this.s.currentBatch.batchType !== batchType
        ) {
          this.s.batches.push(this.s.currentBatch);
          this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
        }
        if (Array.isArray(document2)) {
          throw new error_1.MongoInvalidArgumentError("Operation passed in cannot be an Array");
        }
        this.s.currentBatch.operations.push(document2);
        this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
        this.s.currentIndex = this.s.currentIndex + 1;
        if (batchType === common_1.BatchType.INSERT) {
          this.s.currentInsertBatch = this.s.currentBatch;
          this.s.bulkResult.insertedIds.push({
            index: this.s.bulkResult.insertedIds.length,
            _id: document2._id
          });
        } else if (batchType === common_1.BatchType.UPDATE) {
          this.s.currentUpdateBatch = this.s.currentBatch;
        } else if (batchType === common_1.BatchType.DELETE) {
          this.s.currentRemoveBatch = this.s.currentBatch;
        }
        this.s.currentBatch.size += 1;
        this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
        return this;
      }
    };
    exports2.UnorderedBulkOperation = UnorderedBulkOperation;
  }
});

// node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS({
  "node_modules/mongodb/lib/operations/aggregate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AggregateOperation = exports2.DB_AGGREGATE_COLLECTION = void 0;
    var responses_1 = require_responses();
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var write_concern_1 = require_write_concern();
    var command_1 = require_command();
    var operation_1 = require_operation();
    exports2.DB_AGGREGATE_COLLECTION = 1;
    var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;
    var AggregateOperation = class extends command_1.CommandOperation {
      constructor(ns, pipeline, options2) {
        super(void 0, { ...options2, dbName: ns.db });
        this.options = { ...options2 };
        this.target = ns.collection || exports2.DB_AGGREGATE_COLLECTION;
        this.pipeline = pipeline;
        this.hasWriteStage = false;
        if (typeof options2?.out === "string") {
          this.pipeline = this.pipeline.concat({ $out: options2.out });
          this.hasWriteStage = true;
        } else if (pipeline.length > 0) {
          const finalStage = pipeline[pipeline.length - 1];
          if (finalStage.$out || finalStage.$merge) {
            this.hasWriteStage = true;
          }
        }
        if (this.hasWriteStage) {
          this.trySecondaryWrite = true;
        } else {
          delete this.options.writeConcern;
        }
        if (this.explain && this.writeConcern) {
          throw new error_1.MongoInvalidArgumentError('Option "explain" cannot be used on an aggregate call with writeConcern');
        }
        if (options2?.cursor != null && typeof options2.cursor !== "object") {
          throw new error_1.MongoInvalidArgumentError("Cursor options must be an object");
        }
      }
      get commandName() {
        return "aggregate";
      }
      get canRetryRead() {
        return !this.hasWriteStage;
      }
      addToPipeline(stage) {
        this.pipeline.push(stage);
      }
      async execute(server, session, timeoutContext) {
        const options2 = this.options;
        const serverWireVersion = (0, utils_1.maxWireVersion)(server);
        const command = { aggregate: this.target, pipeline: this.pipeline };
        if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
          this.readConcern = void 0;
        }
        if (this.hasWriteStage && this.writeConcern) {
          write_concern_1.WriteConcern.apply(command, this.writeConcern);
        }
        if (options2.bypassDocumentValidation === true) {
          command.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        if (typeof options2.allowDiskUse === "boolean") {
          command.allowDiskUse = options2.allowDiskUse;
        }
        if (options2.hint) {
          command.hint = options2.hint;
        }
        if (options2.let) {
          command.let = options2.let;
        }
        if (options2.comment !== void 0) {
          command.comment = options2.comment;
        }
        command.cursor = options2.cursor || {};
        if (options2.batchSize && !this.hasWriteStage) {
          command.cursor.batchSize = options2.batchSize;
        }
        return await super.executeCommand(server, session, command, timeoutContext, this.explain ? responses_1.ExplainedCursorResponse : responses_1.CursorResponse);
      }
    };
    exports2.AggregateOperation = AggregateOperation;
    (0, operation_1.defineAspects)(AggregateOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
  }
});

// node_modules/mongodb/lib/cursor/aggregation_cursor.js
var require_aggregation_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/aggregation_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AggregationCursor = void 0;
    var error_1 = require_error();
    var explain_1 = require_explain();
    var aggregate_1 = require_aggregate();
    var execute_operation_1 = require_execute_operation();
    var utils_1 = require_utils5();
    var abstract_cursor_1 = require_abstract_cursor();
    var AggregationCursor = class _AggregationCursor extends explain_1.ExplainableCursor {
      /** @internal */
      constructor(client, namespace, pipeline = [], options2 = {}) {
        super(client, namespace, options2);
        this.pipeline = pipeline;
        this.aggregateOptions = options2;
        const lastStage = this.pipeline[this.pipeline.length - 1];
        if (this.cursorOptions.timeoutMS != null && this.cursorOptions.timeoutMode === abstract_cursor_1.CursorTimeoutMode.ITERATION && (lastStage?.$merge != null || lastStage?.$out != null))
          throw new error_1.MongoAPIError("Cannot use $out or $merge stage with ITERATION timeoutMode");
      }
      clone() {
        const clonedOptions = (0, utils_1.mergeOptions)({}, this.aggregateOptions);
        delete clonedOptions.session;
        return new _AggregationCursor(this.client, this.namespace, this.pipeline, {
          ...clonedOptions
        });
      }
      map(transform) {
        return super.map(transform);
      }
      /** @internal */
      async _initialize(session) {
        const options2 = {
          ...this.aggregateOptions,
          ...this.cursorOptions,
          session,
          signal: this.signal
        };
        if (options2.explain) {
          try {
            (0, explain_1.validateExplainTimeoutOptions)(options2, explain_1.Explain.fromOptions(options2));
          } catch {
            throw new error_1.MongoAPIError("timeoutMS cannot be used with explain when explain is specified in aggregateOptions");
          }
        }
        const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, options2);
        const response = await (0, execute_operation_1.executeOperation)(this.client, aggregateOperation, this.timeoutContext);
        return { server: aggregateOperation.server, session, response };
      }
      async explain(verbosity, options2) {
        const { explain, timeout } = this.resolveExplainTimeoutOptions(verbosity, options2);
        return (await (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
          ...this.aggregateOptions,
          // NOTE: order matters here, we may need to refine this
          ...this.cursorOptions,
          ...timeout,
          explain: explain ?? true
        }))).shift(this.deserializationOptions);
      }
      addStage(stage) {
        this.throwIfInitialized();
        if (this.cursorOptions.timeoutMS != null && this.cursorOptions.timeoutMode === abstract_cursor_1.CursorTimeoutMode.ITERATION && (stage.$out != null || stage.$merge != null)) {
          throw new error_1.MongoAPIError("Cannot use $out or $merge stage with ITERATION timeoutMode");
        }
        this.pipeline.push(stage);
        return this;
      }
      group($group) {
        return this.addStage({ $group });
      }
      /** Add a limit stage to the aggregation pipeline */
      limit($limit) {
        return this.addStage({ $limit });
      }
      /** Add a match stage to the aggregation pipeline */
      match($match) {
        return this.addStage({ $match });
      }
      /** Add an out stage to the aggregation pipeline */
      out($out) {
        return this.addStage({ $out });
      }
      /**
       * Add a project stage to the aggregation pipeline
       *
       * @remarks
       * In order to strictly type this function you must provide an interface
       * that represents the effect of your projection on the result documents.
       *
       * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.
       * You should specify a parameterized type to have assertions on your final results.
       *
       * @example
       * ```typescript
       * // Best way
       * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });
       * // Flexible way
       * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });
       * ```
       *
       * @remarks
       * In order to strictly type this function you must provide an interface
       * that represents the effect of your projection on the result documents.
       *
       * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
       * it **does not** return a new instance of a cursor. This means when calling project,
       * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
       * Take note of the following example:
       *
       * @example
       * ```typescript
       * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);
       * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });
       * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();
       *
       * // or always use chaining and save the final cursor
       *
       * const cursor = coll.aggregate().project<{ a: string }>({
       *   _id: 0,
       *   a: { $convert: { input: '$a', to: 'string' }
       * }});
       * ```
       */
      project($project) {
        return this.addStage({ $project });
      }
      /** Add a lookup stage to the aggregation pipeline */
      lookup($lookup) {
        return this.addStage({ $lookup });
      }
      /** Add a redact stage to the aggregation pipeline */
      redact($redact) {
        return this.addStage({ $redact });
      }
      /** Add a skip stage to the aggregation pipeline */
      skip($skip) {
        return this.addStage({ $skip });
      }
      /** Add a sort stage to the aggregation pipeline */
      sort($sort) {
        return this.addStage({ $sort });
      }
      /** Add a unwind stage to the aggregation pipeline */
      unwind($unwind) {
        return this.addStage({ $unwind });
      }
      /** Add a geoNear stage to the aggregation pipeline */
      geoNear($geoNear) {
        return this.addStage({ $geoNear });
      }
    };
    exports2.AggregationCursor = AggregationCursor;
  }
});

// node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS({
  "node_modules/mongodb/lib/operations/count.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CountOperation = void 0;
    var command_1 = require_command();
    var operation_1 = require_operation();
    var CountOperation = class extends command_1.CommandOperation {
      constructor(namespace, filter, options2) {
        super({ s: { namespace } }, options2);
        this.options = options2;
        this.collectionName = namespace.collection;
        this.query = filter;
      }
      get commandName() {
        return "count";
      }
      async execute(server, session, timeoutContext) {
        const options2 = this.options;
        const cmd = {
          count: this.collectionName,
          query: this.query
        };
        if (typeof options2.limit === "number") {
          cmd.limit = options2.limit;
        }
        if (typeof options2.skip === "number") {
          cmd.skip = options2.skip;
        }
        if (options2.hint != null) {
          cmd.hint = options2.hint;
        }
        if (typeof options2.maxTimeMS === "number") {
          cmd.maxTimeMS = options2.maxTimeMS;
        }
        const result = await super.executeCommand(server, session, cmd, timeoutContext);
        return result ? result.n : 0;
      }
    };
    exports2.CountOperation = CountOperation;
    (0, operation_1.defineAspects)(CountOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
  }
});

// node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS({
  "node_modules/mongodb/lib/operations/find.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FindOperation = void 0;
    var responses_1 = require_responses();
    var error_1 = require_error();
    var explain_1 = require_explain();
    var read_concern_1 = require_read_concern();
    var sort_1 = require_sort2();
    var utils_1 = require_utils5();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var FindOperation = class extends command_1.CommandOperation {
      constructor(ns, filter = {}, options2 = {}) {
        super(void 0, options2);
        this.options = { ...options2 };
        delete this.options.writeConcern;
        this.ns = ns;
        if (typeof filter !== "object" || Array.isArray(filter)) {
          throw new error_1.MongoInvalidArgumentError("Query filter must be a plain object or ObjectId");
        }
        this.filter = filter != null && filter._bsontype === "ObjectId" ? { _id: filter } : filter;
      }
      get commandName() {
        return "find";
      }
      async execute(server, session, timeoutContext) {
        this.server = server;
        const options2 = this.options;
        let findCommand = makeFindCommand(this.ns, this.filter, options2);
        if (this.explain) {
          (0, explain_1.validateExplainTimeoutOptions)(this.options, this.explain);
          findCommand = (0, explain_1.decorateWithExplain)(findCommand, this.explain);
        }
        return await server.command(this.ns, findCommand, {
          ...this.options,
          ...this.bsonOptions,
          documentsReturnedIn: "firstBatch",
          session,
          timeoutContext
        }, this.explain ? responses_1.ExplainedCursorResponse : responses_1.CursorResponse);
      }
    };
    exports2.FindOperation = FindOperation;
    function makeFindCommand(ns, filter, options2) {
      const findCommand = {
        find: ns.collection,
        filter
      };
      if (options2.sort) {
        findCommand.sort = (0, sort_1.formatSort)(options2.sort);
      }
      if (options2.projection) {
        let projection = options2.projection;
        if (projection && Array.isArray(projection)) {
          projection = projection.length ? projection.reduce((result, field) => {
            result[field] = 1;
            return result;
          }, {}) : { _id: 1 };
        }
        findCommand.projection = projection;
      }
      if (options2.hint) {
        findCommand.hint = (0, utils_1.normalizeHintField)(options2.hint);
      }
      if (typeof options2.skip === "number") {
        findCommand.skip = options2.skip;
      }
      if (typeof options2.limit === "number") {
        if (options2.limit < 0) {
          findCommand.limit = -options2.limit;
          findCommand.singleBatch = true;
        } else {
          findCommand.limit = options2.limit;
        }
      }
      if (typeof options2.batchSize === "number") {
        if (options2.batchSize < 0) {
          if (options2.limit && options2.limit !== 0 && Math.abs(options2.batchSize) < Math.abs(options2.limit)) {
            findCommand.limit = -options2.batchSize;
          }
          findCommand.singleBatch = true;
        } else {
          findCommand.batchSize = options2.batchSize;
        }
      }
      if (typeof options2.singleBatch === "boolean") {
        findCommand.singleBatch = options2.singleBatch;
      }
      if (options2.comment !== void 0) {
        findCommand.comment = options2.comment;
      }
      if (typeof options2.maxTimeMS === "number") {
        findCommand.maxTimeMS = options2.maxTimeMS;
      }
      const readConcern = read_concern_1.ReadConcern.fromOptions(options2);
      if (readConcern) {
        findCommand.readConcern = readConcern.toJSON();
      }
      if (options2.max) {
        findCommand.max = options2.max;
      }
      if (options2.min) {
        findCommand.min = options2.min;
      }
      if (typeof options2.returnKey === "boolean") {
        findCommand.returnKey = options2.returnKey;
      }
      if (typeof options2.showRecordId === "boolean") {
        findCommand.showRecordId = options2.showRecordId;
      }
      if (typeof options2.tailable === "boolean") {
        findCommand.tailable = options2.tailable;
      }
      if (typeof options2.oplogReplay === "boolean") {
        findCommand.oplogReplay = options2.oplogReplay;
      }
      if (typeof options2.timeout === "boolean") {
        findCommand.noCursorTimeout = !options2.timeout;
      } else if (typeof options2.noCursorTimeout === "boolean") {
        findCommand.noCursorTimeout = options2.noCursorTimeout;
      }
      if (typeof options2.awaitData === "boolean") {
        findCommand.awaitData = options2.awaitData;
      }
      if (typeof options2.allowPartialResults === "boolean") {
        findCommand.allowPartialResults = options2.allowPartialResults;
      }
      if (options2.collation) {
        findCommand.collation = options2.collation;
      }
      if (typeof options2.allowDiskUse === "boolean") {
        findCommand.allowDiskUse = options2.allowDiskUse;
      }
      if (options2.let) {
        findCommand.let = options2.let;
      }
      return findCommand;
    }
    (0, operation_1.defineAspects)(FindOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
  }
});

// node_modules/mongodb/lib/cursor/find_cursor.js
var require_find_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/find_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FindCursor = exports2.FLAGS = void 0;
    var responses_1 = require_responses();
    var error_1 = require_error();
    var explain_1 = require_explain();
    var count_1 = require_count();
    var execute_operation_1 = require_execute_operation();
    var find_1 = require_find();
    var sort_1 = require_sort2();
    var utils_1 = require_utils5();
    exports2.FLAGS = [
      "tailable",
      "oplogReplay",
      "noCursorTimeout",
      "awaitData",
      "exhaust",
      "partial"
    ];
    var FindCursor = class _FindCursor extends explain_1.ExplainableCursor {
      /** @internal */
      constructor(client, namespace, filter = {}, options2 = {}) {
        super(client, namespace, options2);
        this.numReturned = 0;
        this.cursorFilter = filter;
        this.findOptions = options2;
        if (options2.sort != null) {
          this.findOptions.sort = (0, sort_1.formatSort)(options2.sort);
        }
      }
      clone() {
        const clonedOptions = (0, utils_1.mergeOptions)({}, this.findOptions);
        delete clonedOptions.session;
        return new _FindCursor(this.client, this.namespace, this.cursorFilter, {
          ...clonedOptions
        });
      }
      map(transform) {
        return super.map(transform);
      }
      /** @internal */
      async _initialize(session) {
        const options2 = {
          ...this.findOptions,
          // NOTE: order matters here, we may need to refine this
          ...this.cursorOptions,
          session,
          signal: this.signal
        };
        if (options2.explain) {
          try {
            (0, explain_1.validateExplainTimeoutOptions)(options2, explain_1.Explain.fromOptions(options2));
          } catch {
            throw new error_1.MongoAPIError("timeoutMS cannot be used with explain when explain is specified in findOptions");
          }
        }
        const findOperation = new find_1.FindOperation(this.namespace, this.cursorFilter, options2);
        const response = await (0, execute_operation_1.executeOperation)(this.client, findOperation, this.timeoutContext);
        this.numReturned = response.batchSize;
        return { server: findOperation.server, session, response };
      }
      /** @internal */
      async getMore(batchSize) {
        const numReturned = this.numReturned;
        if (numReturned) {
          const limit = this.findOptions.limit;
          batchSize = limit && limit > 0 && numReturned + batchSize > limit ? limit - numReturned : batchSize;
          if (batchSize <= 0) {
            try {
              await this.close();
            } catch (error2) {
              (0, utils_1.squashError)(error2);
            }
            return responses_1.CursorResponse.emptyGetMore;
          }
        }
        const response = await super.getMore(batchSize);
        this.numReturned = this.numReturned + response.batchSize;
        return response;
      }
      /**
       * Get the count of documents for this cursor
       * @deprecated Use `collection.estimatedDocumentCount` or `collection.countDocuments` instead
       */
      async count(options2) {
        (0, utils_1.emitWarningOnce)("cursor.count is deprecated and will be removed in the next major version, please use `collection.estimatedDocumentCount` or `collection.countDocuments` instead ");
        if (typeof options2 === "boolean") {
          throw new error_1.MongoInvalidArgumentError("Invalid first parameter to count");
        }
        return await (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.namespace, this.cursorFilter, {
          ...this.findOptions,
          // NOTE: order matters here, we may need to refine this
          ...this.cursorOptions,
          ...options2
        }));
      }
      async explain(verbosity, options2) {
        const { explain, timeout } = this.resolveExplainTimeoutOptions(verbosity, options2);
        return (await (0, execute_operation_1.executeOperation)(this.client, new find_1.FindOperation(this.namespace, this.cursorFilter, {
          ...this.findOptions,
          // NOTE: order matters here, we may need to refine this
          ...this.cursorOptions,
          ...timeout,
          explain: explain ?? true
        }))).shift(this.deserializationOptions);
      }
      /** Set the cursor query */
      filter(filter) {
        this.throwIfInitialized();
        this.cursorFilter = filter;
        return this;
      }
      /**
       * Set the cursor hint
       *
       * @param hint - If specified, then the query system will only consider plans using the hinted index.
       */
      hint(hint) {
        this.throwIfInitialized();
        this.findOptions.hint = hint;
        return this;
      }
      /**
       * Set the cursor min
       *
       * @param min - Specify a $min value to specify the inclusive lower bound for a specific index in order to constrain the results of find(). The $min specifies the lower bound for all keys of a specific index in order.
       */
      min(min) {
        this.throwIfInitialized();
        this.findOptions.min = min;
        return this;
      }
      /**
       * Set the cursor max
       *
       * @param max - Specify a $max value to specify the exclusive upper bound for a specific index in order to constrain the results of find(). The $max specifies the upper bound for all keys of a specific index in order.
       */
      max(max) {
        this.throwIfInitialized();
        this.findOptions.max = max;
        return this;
      }
      /**
       * Set the cursor returnKey.
       * If set to true, modifies the cursor to only return the index field or fields for the results of the query, rather than documents.
       * If set to true and the query does not use an index to perform the read operation, the returned documents will not contain any fields.
       *
       * @param value - the returnKey value.
       */
      returnKey(value) {
        this.throwIfInitialized();
        this.findOptions.returnKey = value;
        return this;
      }
      /**
       * Modifies the output of a query by adding a field $recordId to matching documents. $recordId is the internal key which uniquely identifies a document in a collection.
       *
       * @param value - The $showDiskLoc option has now been deprecated and replaced with the showRecordId field. $showDiskLoc will still be accepted for OP_QUERY stye find.
       */
      showRecordId(value) {
        this.throwIfInitialized();
        this.findOptions.showRecordId = value;
        return this;
      }
      /**
       * Add a query modifier to the cursor query
       *
       * @param name - The query modifier (must start with $, such as $orderby etc)
       * @param value - The modifier value.
       */
      addQueryModifier(name, value) {
        this.throwIfInitialized();
        if (name[0] !== "$") {
          throw new error_1.MongoInvalidArgumentError(`${name} is not a valid query modifier`);
        }
        const field = name.substr(1);
        switch (field) {
          case "comment":
            this.findOptions.comment = value;
            break;
          case "explain":
            this.findOptions.explain = value;
            break;
          case "hint":
            this.findOptions.hint = value;
            break;
          case "max":
            this.findOptions.max = value;
            break;
          case "maxTimeMS":
            this.findOptions.maxTimeMS = value;
            break;
          case "min":
            this.findOptions.min = value;
            break;
          case "orderby":
            this.findOptions.sort = (0, sort_1.formatSort)(value);
            break;
          case "query":
            this.cursorFilter = value;
            break;
          case "returnKey":
            this.findOptions.returnKey = value;
            break;
          case "showDiskLoc":
            this.findOptions.showRecordId = value;
            break;
          default:
            throw new error_1.MongoInvalidArgumentError(`Invalid query modifier: ${name}`);
        }
        return this;
      }
      /**
       * Add a comment to the cursor query allowing for tracking the comment in the log.
       *
       * @param value - The comment attached to this query.
       */
      comment(value) {
        this.throwIfInitialized();
        this.findOptions.comment = value;
        return this;
      }
      /**
       * Set a maxAwaitTimeMS on a tailing cursor query to allow to customize the timeout value for the option awaitData (Only supported on MongoDB 3.2 or higher, ignored otherwise)
       *
       * @param value - Number of milliseconds to wait before aborting the tailed query.
       */
      maxAwaitTimeMS(value) {
        this.throwIfInitialized();
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError("Argument for maxAwaitTimeMS must be a number");
        }
        this.findOptions.maxAwaitTimeMS = value;
        return this;
      }
      /**
       * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
       *
       * @param value - Number of milliseconds to wait before aborting the query.
       */
      maxTimeMS(value) {
        this.throwIfInitialized();
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError("Argument for maxTimeMS must be a number");
        }
        this.findOptions.maxTimeMS = value;
        return this;
      }
      /**
       * Add a project stage to the aggregation pipeline
       *
       * @remarks
       * In order to strictly type this function you must provide an interface
       * that represents the effect of your projection on the result documents.
       *
       * By default chaining a projection to your cursor changes the returned type to the generic
       * {@link Document} type.
       * You should specify a parameterized type to have assertions on your final results.
       *
       * @example
       * ```typescript
       * // Best way
       * const docs: FindCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });
       * // Flexible way
       * const docs: FindCursor<Document> = cursor.project({ _id: 0, a: true });
       * ```
       *
       * @remarks
       *
       * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
       * it **does not** return a new instance of a cursor. This means when calling project,
       * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
       * Take note of the following example:
       *
       * @example
       * ```typescript
       * const cursor: FindCursor<{ a: number; b: string }> = coll.find();
       * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });
       * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();
       *
       * // or always use chaining and save the final cursor
       *
       * const cursor = coll.find().project<{ a: string }>({
       *   _id: 0,
       *   a: { $convert: { input: '$a', to: 'string' }
       * }});
       * ```
       */
      project(value) {
        this.throwIfInitialized();
        this.findOptions.projection = value;
        return this;
      }
      /**
       * Sets the sort order of the cursor query.
       *
       * @param sort - The key or keys set for the sort.
       * @param direction - The direction of the sorting (1 or -1).
       */
      sort(sort, direction) {
        this.throwIfInitialized();
        if (this.findOptions.tailable) {
          throw new error_1.MongoTailableCursorError("Tailable cursor does not support sorting");
        }
        this.findOptions.sort = (0, sort_1.formatSort)(sort, direction);
        return this;
      }
      /**
       * Allows disk use for blocking sort operations exceeding 100MB memory. (MongoDB 3.2 or higher)
       *
       * @remarks
       * {@link https://www.mongodb.com/docs/manual/reference/command/find/#find-cmd-allowdiskuse | find command allowDiskUse documentation}
       */
      allowDiskUse(allow = true) {
        this.throwIfInitialized();
        if (!this.findOptions.sort) {
          throw new error_1.MongoInvalidArgumentError('Option "allowDiskUse" requires a sort specification');
        }
        if (!allow) {
          this.findOptions.allowDiskUse = false;
          return this;
        }
        this.findOptions.allowDiskUse = true;
        return this;
      }
      /**
       * Set the collation options for the cursor.
       *
       * @param value - The cursor collation options (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
       */
      collation(value) {
        this.throwIfInitialized();
        this.findOptions.collation = value;
        return this;
      }
      /**
       * Set the limit for the cursor.
       *
       * @param value - The limit for the cursor query.
       */
      limit(value) {
        this.throwIfInitialized();
        if (this.findOptions.tailable) {
          throw new error_1.MongoTailableCursorError("Tailable cursor does not support limit");
        }
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError('Operation "limit" requires an integer');
        }
        this.findOptions.limit = value;
        return this;
      }
      /**
       * Set the skip for the cursor.
       *
       * @param value - The skip for the cursor query.
       */
      skip(value) {
        this.throwIfInitialized();
        if (this.findOptions.tailable) {
          throw new error_1.MongoTailableCursorError("Tailable cursor does not support skip");
        }
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError('Operation "skip" requires an integer');
        }
        this.findOptions.skip = value;
        return this;
      }
    };
    exports2.FindCursor = FindCursor;
  }
});

// node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/indexes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ListIndexesOperation = exports2.DropIndexOperation = exports2.CreateIndexesOperation = void 0;
    var responses_1 = require_responses();
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var VALID_INDEX_OPTIONS = /* @__PURE__ */ new Set([
      "background",
      "unique",
      "name",
      "partialFilterExpression",
      "sparse",
      "hidden",
      "expireAfterSeconds",
      "storageEngine",
      "collation",
      "version",
      // text indexes
      "weights",
      "default_language",
      "language_override",
      "textIndexVersion",
      // 2d-sphere indexes
      "2dsphereIndexVersion",
      // 2d indexes
      "bits",
      "min",
      "max",
      // geoHaystack Indexes
      "bucketSize",
      // wildcard indexes
      "wildcardProjection"
    ]);
    function isIndexDirection(x) {
      return typeof x === "number" || x === "2d" || x === "2dsphere" || x === "text" || x === "geoHaystack";
    }
    function isSingleIndexTuple(t) {
      return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);
    }
    function constructIndexDescriptionMap(indexSpec) {
      const key = /* @__PURE__ */ new Map();
      const indexSpecs = !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec;
      for (const spec of indexSpecs) {
        if (typeof spec === "string") {
          key.set(spec, 1);
        } else if (Array.isArray(spec)) {
          key.set(spec[0], spec[1] ?? 1);
        } else if (spec instanceof Map) {
          for (const [property, value] of spec) {
            key.set(property, value);
          }
        } else if ((0, utils_1.isObject)(spec)) {
          for (const [property, value] of Object.entries(spec)) {
            key.set(property, value);
          }
        }
      }
      return key;
    }
    function resolveIndexDescription(description) {
      const validProvidedOptions = Object.entries(description).filter(([optionName]) => VALID_INDEX_OPTIONS.has(optionName));
      return Object.fromEntries(
        // we support the `version` option, but the `createIndexes` command expects it to be the `v`
        validProvidedOptions.map(([name, value]) => name === "version" ? ["v", value] : [name, value])
      );
    }
    var CreateIndexesOperation = class _CreateIndexesOperation extends command_1.CommandOperation {
      constructor(parent, collectionName, indexes, options2) {
        super(parent, options2);
        this.options = options2 ?? {};
        this.collectionName = collectionName;
        this.indexes = indexes.map((userIndex) => {
          const key = userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));
          const name = userIndex.name ?? Array.from(key).flat().join("_");
          const validIndexOptions = resolveIndexDescription(userIndex);
          return {
            ...validIndexOptions,
            name,
            key
          };
        });
      }
      static fromIndexDescriptionArray(parent, collectionName, indexes, options2) {
        return new _CreateIndexesOperation(parent, collectionName, indexes, options2);
      }
      static fromIndexSpecification(parent, collectionName, indexSpec, options2 = {}) {
        const key = constructIndexDescriptionMap(indexSpec);
        const description = { ...options2, key };
        return new _CreateIndexesOperation(parent, collectionName, [description], options2);
      }
      get commandName() {
        return "createIndexes";
      }
      async execute(server, session, timeoutContext) {
        const options2 = this.options;
        const indexes = this.indexes;
        const serverWireVersion = (0, utils_1.maxWireVersion)(server);
        const cmd = { createIndexes: this.collectionName, indexes };
        if (options2.commitQuorum != null) {
          if (serverWireVersion < 9) {
            throw new error_1.MongoCompatibilityError("Option `commitQuorum` for `createIndexes` not supported on servers < 4.4");
          }
          cmd.commitQuorum = options2.commitQuorum;
        }
        this.options.collation = void 0;
        await super.executeCommand(server, session, cmd, timeoutContext);
        const indexNames = indexes.map((index) => index.name || "");
        return indexNames;
      }
    };
    exports2.CreateIndexesOperation = CreateIndexesOperation;
    var DropIndexOperation = class extends command_1.CommandOperation {
      constructor(collection, indexName, options2) {
        super(collection, options2);
        this.options = options2 ?? {};
        this.collection = collection;
        this.indexName = indexName;
      }
      get commandName() {
        return "dropIndexes";
      }
      async execute(server, session, timeoutContext) {
        const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };
        return await super.executeCommand(server, session, cmd, timeoutContext);
      }
    };
    exports2.DropIndexOperation = DropIndexOperation;
    var ListIndexesOperation = class extends command_1.CommandOperation {
      constructor(collection, options2) {
        super(collection, options2);
        this.options = { ...options2 };
        delete this.options.writeConcern;
        this.collectionNamespace = collection.s.namespace;
      }
      get commandName() {
        return "listIndexes";
      }
      async execute(server, session, timeoutContext) {
        const serverWireVersion = (0, utils_1.maxWireVersion)(server);
        const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};
        const command = { listIndexes: this.collectionNamespace.collection, cursor };
        if (serverWireVersion >= 9 && this.options.comment !== void 0) {
          command.comment = this.options.comment;
        }
        return await super.executeCommand(server, session, command, timeoutContext, responses_1.CursorResponse);
      }
    };
    exports2.ListIndexesOperation = ListIndexesOperation;
    (0, operation_1.defineAspects)(ListIndexesOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
    (0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// node_modules/mongodb/lib/cursor/list_indexes_cursor.js
var require_list_indexes_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/list_indexes_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ListIndexesCursor = void 0;
    var execute_operation_1 = require_execute_operation();
    var indexes_1 = require_indexes();
    var abstract_cursor_1 = require_abstract_cursor();
    var ListIndexesCursor = class _ListIndexesCursor extends abstract_cursor_1.AbstractCursor {
      constructor(collection, options2) {
        super(collection.client, collection.s.namespace, options2);
        this.parent = collection;
        this.options = options2;
      }
      clone() {
        return new _ListIndexesCursor(this.parent, {
          ...this.options,
          ...this.cursorOptions
        });
      }
      /** @internal */
      async _initialize(session) {
        const operation = new indexes_1.ListIndexesOperation(this.parent, {
          ...this.cursorOptions,
          ...this.options,
          session
        });
        const response = await (0, execute_operation_1.executeOperation)(this.parent.client, operation, this.timeoutContext);
        return { server: operation.server, session, response };
      }
    };
    exports2.ListIndexesCursor = ListIndexesCursor;
  }
});

// node_modules/mongodb/lib/cursor/list_search_indexes_cursor.js
var require_list_search_indexes_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/list_search_indexes_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ListSearchIndexesCursor = void 0;
    var aggregation_cursor_1 = require_aggregation_cursor();
    var ListSearchIndexesCursor = class extends aggregation_cursor_1.AggregationCursor {
      /** @internal */
      constructor({ fullNamespace: ns, client }, name, options2 = {}) {
        const pipeline = name == null ? [{ $listSearchIndexes: {} }] : [{ $listSearchIndexes: { name } }];
        super(client, ns, pipeline, options2);
      }
    };
    exports2.ListSearchIndexesCursor = ListSearchIndexesCursor;
  }
});

// node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS({
  "node_modules/mongodb/lib/operations/distinct.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DistinctOperation = void 0;
    var utils_1 = require_utils5();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var DistinctOperation = class extends command_1.CommandOperation {
      /**
       * Construct a Distinct operation.
       *
       * @param collection - Collection instance.
       * @param key - Field of the document to find distinct values for.
       * @param query - The query for filtering the set of documents to which we apply the distinct filter.
       * @param options - Optional settings. See Collection.prototype.distinct for a list of options.
       */
      constructor(collection, key, query, options2) {
        super(collection, options2);
        this.options = options2 ?? {};
        this.collection = collection;
        this.key = key;
        this.query = query;
      }
      get commandName() {
        return "distinct";
      }
      async execute(server, session, timeoutContext) {
        const coll = this.collection;
        const key = this.key;
        const query = this.query;
        const options2 = this.options;
        const cmd = {
          distinct: coll.collectionName,
          key,
          query
        };
        if (typeof options2.maxTimeMS === "number") {
          cmd.maxTimeMS = options2.maxTimeMS;
        }
        if (typeof options2.comment !== "undefined") {
          cmd.comment = options2.comment;
        }
        if (options2.hint != null) {
          cmd.hint = options2.hint;
        }
        (0, utils_1.decorateWithReadConcern)(cmd, coll, options2);
        (0, utils_1.decorateWithCollation)(cmd, coll, options2);
        const result = await super.executeCommand(server, session, cmd, timeoutContext);
        return this.explain ? result : result.values;
      }
    };
    exports2.DistinctOperation = DistinctOperation;
    (0, operation_1.defineAspects)(DistinctOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE]);
  }
});

// node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS({
  "node_modules/mongodb/lib/operations/drop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DropDatabaseOperation = exports2.DropCollectionOperation = void 0;
    var error_1 = require_error();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var DropCollectionOperation = class _DropCollectionOperation extends command_1.CommandOperation {
      constructor(db, name, options2 = {}) {
        super(db, options2);
        this.db = db;
        this.options = options2;
        this.name = name;
      }
      get commandName() {
        return "drop";
      }
      async execute(server, session, timeoutContext) {
        const db = this.db;
        const options2 = this.options;
        const name = this.name;
        const encryptedFieldsMap = db.client.s.options.autoEncryption?.encryptedFieldsMap;
        let encryptedFields = options2.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];
        if (!encryptedFields && encryptedFieldsMap) {
          const listCollectionsResult = await db.listCollections({ name }, { nameOnly: false }).toArray();
          encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;
        }
        if (encryptedFields) {
          const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;
          const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;
          for (const collectionName of [escCollection, ecocCollection]) {
            const dropOp = new _DropCollectionOperation(db, collectionName);
            try {
              await dropOp.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
            } catch (err) {
              if (!(err instanceof error_1.MongoServerError) || err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
                throw err;
              }
            }
          }
        }
        return await this.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
      }
      async executeWithoutEncryptedFieldsCheck(server, session, timeoutContext) {
        await super.executeCommand(server, session, { drop: this.name }, timeoutContext);
        return true;
      }
    };
    exports2.DropCollectionOperation = DropCollectionOperation;
    var DropDatabaseOperation = class extends command_1.CommandOperation {
      constructor(db, options2) {
        super(db, options2);
        this.options = options2;
      }
      get commandName() {
        return "dropDatabase";
      }
      async execute(server, session, timeoutContext) {
        await super.executeCommand(server, session, { dropDatabase: 1 }, timeoutContext);
        return true;
      }
    };
    exports2.DropDatabaseOperation = DropDatabaseOperation;
    (0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS({
  "node_modules/mongodb/lib/operations/estimated_document_count.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EstimatedDocumentCountOperation = void 0;
    var command_1 = require_command();
    var operation_1 = require_operation();
    var EstimatedDocumentCountOperation = class extends command_1.CommandOperation {
      constructor(collection, options2 = {}) {
        super(collection, options2);
        this.options = options2;
        this.collectionName = collection.collectionName;
      }
      get commandName() {
        return "count";
      }
      async execute(server, session, timeoutContext) {
        const cmd = { count: this.collectionName };
        if (typeof this.options.maxTimeMS === "number") {
          cmd.maxTimeMS = this.options.maxTimeMS;
        }
        if (this.options.comment !== void 0) {
          cmd.comment = this.options.comment;
        }
        const response = await super.executeCommand(server, session, cmd, timeoutContext);
        return response?.n || 0;
      }
    };
    exports2.EstimatedDocumentCountOperation = EstimatedDocumentCountOperation;
    (0, operation_1.defineAspects)(EstimatedDocumentCountOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
  }
});

// node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS({
  "node_modules/mongodb/lib/operations/find_and_modify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FindOneAndUpdateOperation = exports2.FindOneAndReplaceOperation = exports2.FindOneAndDeleteOperation = exports2.FindAndModifyOperation = exports2.ReturnDocument = void 0;
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var sort_1 = require_sort2();
    var utils_1 = require_utils5();
    var command_1 = require_command();
    var operation_1 = require_operation();
    exports2.ReturnDocument = Object.freeze({
      BEFORE: "before",
      AFTER: "after"
    });
    function configureFindAndModifyCmdBaseUpdateOpts(cmdBase, options2) {
      cmdBase.new = options2.returnDocument === exports2.ReturnDocument.AFTER;
      cmdBase.upsert = options2.upsert === true;
      if (options2.bypassDocumentValidation === true) {
        cmdBase.bypassDocumentValidation = options2.bypassDocumentValidation;
      }
      return cmdBase;
    }
    var FindAndModifyOperation = class extends command_1.CommandOperation {
      constructor(collection, query, options2) {
        super(collection, options2);
        this.options = options2 ?? {};
        this.cmdBase = {
          remove: false,
          new: false,
          upsert: false
        };
        options2.includeResultMetadata ??= false;
        const sort = (0, sort_1.formatSort)(options2.sort);
        if (sort) {
          this.cmdBase.sort = sort;
        }
        if (options2.projection) {
          this.cmdBase.fields = options2.projection;
        }
        if (options2.maxTimeMS) {
          this.cmdBase.maxTimeMS = options2.maxTimeMS;
        }
        if (options2.writeConcern) {
          this.cmdBase.writeConcern = options2.writeConcern;
        }
        if (options2.let) {
          this.cmdBase.let = options2.let;
        }
        if (options2.comment !== void 0) {
          this.cmdBase.comment = options2.comment;
        }
        this.readPreference = read_preference_1.ReadPreference.primary;
        this.collection = collection;
        this.query = query;
      }
      get commandName() {
        return "findAndModify";
      }
      async execute(server, session, timeoutContext) {
        const coll = this.collection;
        const query = this.query;
        const options2 = { ...this.options, ...this.bsonOptions };
        const cmd = {
          findAndModify: coll.collectionName,
          query,
          ...this.cmdBase
        };
        (0, utils_1.decorateWithCollation)(cmd, coll, options2);
        if (options2.hint) {
          const unacknowledgedWrite = this.writeConcern?.w === 0;
          if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server) < 8) {
            throw new error_1.MongoCompatibilityError("The current topology does not support a hint on findAndModify commands");
          }
          cmd.hint = options2.hint;
        }
        const result = await super.executeCommand(server, session, cmd, timeoutContext);
        return options2.includeResultMetadata ? result : result.value ?? null;
      }
    };
    exports2.FindAndModifyOperation = FindAndModifyOperation;
    var FindOneAndDeleteOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, options2) {
        if (filter == null || typeof filter !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
        }
        super(collection, filter, options2);
        this.cmdBase.remove = true;
      }
    };
    exports2.FindOneAndDeleteOperation = FindOneAndDeleteOperation;
    var FindOneAndReplaceOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, replacement, options2) {
        if (filter == null || typeof filter !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
        }
        if (replacement == null || typeof replacement !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "replacement" must be an object');
        }
        if ((0, utils_1.hasAtomicOperators)(replacement)) {
          throw new error_1.MongoInvalidArgumentError("Replacement document must not contain atomic operators");
        }
        super(collection, filter, options2);
        this.cmdBase.update = replacement;
        configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options2);
      }
    };
    exports2.FindOneAndReplaceOperation = FindOneAndReplaceOperation;
    var FindOneAndUpdateOperation = class extends FindAndModifyOperation {
      constructor(collection, filter, update, options2) {
        if (filter == null || typeof filter !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
        }
        if (update == null || typeof update !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "update" must be an object');
        }
        if (!(0, utils_1.hasAtomicOperators)(update, options2)) {
          throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
        }
        super(collection, filter, options2);
        this.cmdBase.update = update;
        configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options2);
        if (options2.arrayFilters) {
          this.cmdBase.arrayFilters = options2.arrayFilters;
        }
      }
    };
    exports2.FindOneAndUpdateOperation = FindOneAndUpdateOperation;
    (0, operation_1.defineAspects)(FindAndModifyOperation, [
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.EXPLAINABLE
    ]);
  }
});

// node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS({
  "node_modules/mongodb/lib/operations/is_capped.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsCappedOperation = void 0;
    var error_1 = require_error();
    var operation_1 = require_operation();
    var IsCappedOperation = class extends operation_1.AbstractOperation {
      constructor(collection, options2) {
        super(options2);
        this.options = options2;
        this.collection = collection;
      }
      get commandName() {
        return "listCollections";
      }
      async execute(server, session) {
        const coll = this.collection;
        const [collection] = await coll.s.db.listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session }).toArray();
        if (collection == null || collection.options == null) {
          throw new error_1.MongoAPIError(`collection ${coll.namespace} not found`);
        }
        return !!collection.options?.capped;
      }
    };
    exports2.IsCappedOperation = IsCappedOperation;
  }
});

// node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS({
  "node_modules/mongodb/lib/operations/options_operation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OptionsOperation = void 0;
    var error_1 = require_error();
    var operation_1 = require_operation();
    var OptionsOperation = class extends operation_1.AbstractOperation {
      constructor(collection, options2) {
        super(options2);
        this.options = options2;
        this.collection = collection;
      }
      get commandName() {
        return "listCollections";
      }
      async execute(server, session) {
        const coll = this.collection;
        const [collection] = await coll.s.db.listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session }).toArray();
        if (collection == null || collection.options == null) {
          throw new error_1.MongoAPIError(`collection ${coll.namespace} not found`);
        }
        return collection.options;
      }
    };
    exports2.OptionsOperation = OptionsOperation;
  }
});

// node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS({
  "node_modules/mongodb/lib/operations/rename.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RenameOperation = void 0;
    var collection_1 = require_collection();
    var utils_1 = require_utils5();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var RenameOperation = class extends command_1.CommandOperation {
      constructor(collection, newName, options2) {
        super(collection, options2);
        this.collection = collection;
        this.newName = newName;
        this.options = options2;
        this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
      }
      get commandName() {
        return "renameCollection";
      }
      async execute(server, session, timeoutContext) {
        const renameCollection = this.collection.namespace;
        const toCollection = this.collection.s.namespace.withCollection(this.newName).toString();
        const dropTarget = typeof this.options.dropTarget === "boolean" ? this.options.dropTarget : false;
        const command = {
          renameCollection,
          to: toCollection,
          dropTarget
        };
        await super.executeCommand(server, session, command, timeoutContext);
        return new collection_1.Collection(this.collection.s.db, this.newName, this.collection.s.options);
      }
    };
    exports2.RenameOperation = RenameOperation;
    (0, operation_1.defineAspects)(RenameOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// node_modules/mongodb/lib/operations/search_indexes/create.js
var require_create = __commonJS({
  "node_modules/mongodb/lib/operations/search_indexes/create.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CreateSearchIndexesOperation = void 0;
    var operation_1 = require_operation();
    var CreateSearchIndexesOperation = class extends operation_1.AbstractOperation {
      constructor(collection, descriptions) {
        super();
        this.collection = collection;
        this.descriptions = descriptions;
      }
      get commandName() {
        return "createSearchIndexes";
      }
      async execute(server, session, timeoutContext) {
        const namespace = this.collection.fullNamespace;
        const command = {
          createSearchIndexes: namespace.collection,
          indexes: this.descriptions
        };
        const res = await server.command(namespace, command, {
          session,
          timeoutContext
        });
        const indexesCreated = res?.indexesCreated ?? [];
        return indexesCreated.map(({ name }) => name);
      }
    };
    exports2.CreateSearchIndexesOperation = CreateSearchIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/search_indexes/drop.js
var require_drop2 = __commonJS({
  "node_modules/mongodb/lib/operations/search_indexes/drop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DropSearchIndexOperation = void 0;
    var error_1 = require_error();
    var operation_1 = require_operation();
    var DropSearchIndexOperation = class extends operation_1.AbstractOperation {
      constructor(collection, name) {
        super();
        this.collection = collection;
        this.name = name;
      }
      get commandName() {
        return "dropSearchIndex";
      }
      async execute(server, session, timeoutContext) {
        const namespace = this.collection.fullNamespace;
        const command = {
          dropSearchIndex: namespace.collection
        };
        if (typeof this.name === "string") {
          command.name = this.name;
        }
        try {
          await server.command(namespace, command, { session, timeoutContext });
        } catch (error2) {
          const isNamespaceNotFoundError = error2 instanceof error_1.MongoServerError && error2.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound;
          if (!isNamespaceNotFoundError) {
            throw error2;
          }
        }
      }
    };
    exports2.DropSearchIndexOperation = DropSearchIndexOperation;
  }
});

// node_modules/mongodb/lib/operations/search_indexes/update.js
var require_update2 = __commonJS({
  "node_modules/mongodb/lib/operations/search_indexes/update.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UpdateSearchIndexOperation = void 0;
    var operation_1 = require_operation();
    var UpdateSearchIndexOperation = class extends operation_1.AbstractOperation {
      constructor(collection, name, definition) {
        super();
        this.collection = collection;
        this.name = name;
        this.definition = definition;
      }
      get commandName() {
        return "updateSearchIndex";
      }
      async execute(server, session, timeoutContext) {
        const namespace = this.collection.fullNamespace;
        const command = {
          updateSearchIndex: namespace.collection,
          name: this.name,
          definition: this.definition
        };
        await server.command(namespace, command, { session, timeoutContext });
        return;
      }
    };
    exports2.UpdateSearchIndexOperation = UpdateSearchIndexOperation;
  }
});

// node_modules/mongodb/lib/collection.js
var require_collection = __commonJS({
  "node_modules/mongodb/lib/collection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Collection = void 0;
    var bson_1 = require_bson2();
    var ordered_1 = require_ordered();
    var unordered_1 = require_unordered();
    var change_stream_1 = require_change_stream();
    var aggregation_cursor_1 = require_aggregation_cursor();
    var find_cursor_1 = require_find_cursor();
    var list_indexes_cursor_1 = require_list_indexes_cursor();
    var list_search_indexes_cursor_1 = require_list_search_indexes_cursor();
    var error_1 = require_error();
    var bulk_write_1 = require_bulk_write();
    var count_1 = require_count();
    var delete_1 = require_delete();
    var distinct_1 = require_distinct();
    var drop_1 = require_drop();
    var estimated_document_count_1 = require_estimated_document_count();
    var execute_operation_1 = require_execute_operation();
    var find_and_modify_1 = require_find_and_modify();
    var indexes_1 = require_indexes();
    var insert_1 = require_insert();
    var is_capped_1 = require_is_capped();
    var options_operation_1 = require_options_operation();
    var rename_1 = require_rename();
    var create_1 = require_create();
    var drop_2 = require_drop2();
    var update_1 = require_update2();
    var update_2 = require_update();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var utils_1 = require_utils5();
    var write_concern_1 = require_write_concern();
    var Collection = class {
      /**
       * Create a new Collection instance
       * @internal
       */
      constructor(db, name, options2) {
        this.s = {
          db,
          options: options2,
          namespace: new utils_1.MongoDBCollectionNamespace(db.databaseName, name),
          pkFactory: db.options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,
          readPreference: read_preference_1.ReadPreference.fromOptions(options2),
          bsonOptions: (0, bson_1.resolveBSONOptions)(options2, db),
          readConcern: read_concern_1.ReadConcern.fromOptions(options2),
          writeConcern: write_concern_1.WriteConcern.fromOptions(options2)
        };
        this.client = db.client;
      }
      /**
       * The name of the database this collection belongs to
       */
      get dbName() {
        return this.s.namespace.db;
      }
      /**
       * The name of this collection
       */
      get collectionName() {
        return this.s.namespace.collection;
      }
      /**
       * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`
       */
      get namespace() {
        return this.fullNamespace.toString();
      }
      /**
       *  @internal
       *
       * The `MongoDBNamespace` for the collection.
       */
      get fullNamespace() {
        return this.s.namespace;
      }
      /**
       * The current readConcern of the collection. If not explicitly defined for
       * this collection, will be inherited from the parent DB
       */
      get readConcern() {
        if (this.s.readConcern == null) {
          return this.s.db.readConcern;
        }
        return this.s.readConcern;
      }
      /**
       * The current readPreference of the collection. If not explicitly defined for
       * this collection, will be inherited from the parent DB
       */
      get readPreference() {
        if (this.s.readPreference == null) {
          return this.s.db.readPreference;
        }
        return this.s.readPreference;
      }
      get bsonOptions() {
        return this.s.bsonOptions;
      }
      /**
       * The current writeConcern of the collection. If not explicitly defined for
       * this collection, will be inherited from the parent DB
       */
      get writeConcern() {
        if (this.s.writeConcern == null) {
          return this.s.db.writeConcern;
        }
        return this.s.writeConcern;
      }
      /** The current index hint for the collection */
      get hint() {
        return this.s.collectionHint;
      }
      set hint(v) {
        this.s.collectionHint = (0, utils_1.normalizeHintField)(v);
      }
      get timeoutMS() {
        return this.s.options.timeoutMS;
      }
      /**
       * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,
       * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
       * can be overridden by setting the **forceServerObjectId** flag.
       *
       * @param doc - The document to insert
       * @param options - Optional settings for the command
       */
      async insertOne(doc, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
       * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
       * can be overridden by setting the **forceServerObjectId** flag.
       *
       * @param docs - The documents to insert
       * @param options - Optional settings for the command
       */
      async insertMany(docs, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options2 ?? { ordered: true })));
      }
      /**
       * Perform a bulkWrite operation without a fluent API
       *
       * Legal operation types are
       * - `insertOne`
       * - `replaceOne`
       * - `updateOne`
       * - `updateMany`
       * - `deleteOne`
       * - `deleteMany`
       *
       * If documents passed in do not contain the **_id** field,
       * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
       * can be overridden by setting the **forceServerObjectId** flag.
       *
       * @param operations - Bulk operations to perform
       * @param options - Optional settings for the command
       * @throws MongoDriverError if operations is not an array
       */
      async bulkWrite(operations, options2) {
        if (!Array.isArray(operations)) {
          throw new error_1.MongoInvalidArgumentError('Argument "operations" must be an array of documents');
        }
        return await (0, execute_operation_1.executeOperation)(this.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options2 ?? { ordered: true })));
      }
      /**
       * Update a single document in a collection
       *
       * The value of `update` can be either:
       * - UpdateFilter<TSchema> - A document that contains update operator expressions,
       * - Document[] - an aggregation pipeline.
       *
       * @param filter - The filter used to select the document to update
       * @param update - The modifications to apply
       * @param options - Optional settings for the command
       */
      async updateOne(filter, update, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Replace a document in a collection with another document
       *
       * @param filter - The filter used to select the document to replace
       * @param replacement - The Document that replaces the matching document
       * @param options - Optional settings for the command
       */
      async replaceOne(filter, replacement, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new update_2.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Update multiple documents in a collection
       *
       * The value of `update` can be either:
       * - UpdateFilter<TSchema> - A document that contains update operator expressions,
       * - Document[] - an aggregation pipeline.
       *
       * @param filter - The filter used to select the document to update
       * @param update - The modifications to apply
       * @param options - Optional settings for the command
       */
      async updateMany(filter, update, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Delete a document from a collection
       *
       * @param filter - The filter used to select the document to remove
       * @param options - Optional settings for the command
       */
      async deleteOne(filter = {}, options2 = {}) {
        return await (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Delete multiple documents from a collection
       *
       * @param filter - The filter used to select the documents to remove
       * @param options - Optional settings for the command
       */
      async deleteMany(filter = {}, options2 = {}) {
        return await (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Rename the collection.
       *
       * @remarks
       * This operation does not inherit options from the Db or MongoClient.
       *
       * @param newName - New name of of the collection.
       * @param options - Optional settings for the command
       */
      async rename(newName, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this, newName, (0, utils_1.resolveOptions)(void 0, {
          ...options2,
          readPreference: read_preference_1.ReadPreference.PRIMARY
        })));
      }
      /**
       * Drop the collection from the database, removing it permanently. New accesses will create a new collection.
       *
       * @param options - Optional settings for the command
       */
      async drop(options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options2));
      }
      async findOne(filter = {}, options2 = {}) {
        const cursor = this.find(filter, options2).limit(-1).batchSize(1);
        const res = await cursor.next();
        await cursor.close();
        return res;
      }
      find(filter = {}, options2 = {}) {
        return new find_cursor_1.FindCursor(this.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options2));
      }
      /**
       * Returns the options of the collection.
       *
       * @param options - Optional settings for the command
       */
      async options(options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Returns if the collection is a capped collection
       *
       * @param options - Optional settings for the command
       */
      async isCapped(options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Creates an index on the db and collection collection.
       *
       * @param indexSpec - The field name or index specification to create an index for
       * @param options - Optional settings for the command
       *
       * @example
       * ```ts
       * const collection = client.db('foo').collection('bar');
       *
       * await collection.createIndex({ a: 1, b: -1 });
       *
       * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes
       * await collection.createIndex([ [c, 1], [d, -1] ]);
       *
       * // Equivalent to { e: 1 }
       * await collection.createIndex('e');
       *
       * // Equivalent to { f: 1, g: 1 }
       * await collection.createIndex(['f', 'g'])
       *
       * // Equivalent to { h: 1, i: -1 }
       * await collection.createIndex([ { h: 1 }, { i: -1 } ]);
       *
       * // Equivalent to { j: 1, k: -1, l: 2d }
       * await collection.createIndex(['j', ['k', -1], { l: '2d' }])
       * ```
       */
      async createIndex(indexSpec, options2) {
        const indexes = await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexSpecification(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options2)));
        return indexes[0];
      }
      /**
       * Creates multiple indexes in the collection, this method is only supported for
       * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported
       * error.
       *
       * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.
       * Index specifications are defined {@link https://www.mongodb.com/docs/manual/reference/command/createIndexes/| here}.
       *
       * @param indexSpecs - An array of index specifications to be created
       * @param options - Optional settings for the command
       *
       * @example
       * ```ts
       * const collection = client.db('foo').collection('bar');
       * await collection.createIndexes([
       *   // Simple index on field fizz
       *   {
       *     key: { fizz: 1 },
       *   }
       *   // wildcard index
       *   {
       *     key: { '$**': 1 }
       *   },
       *   // named index on darmok and jalad
       *   {
       *     key: { darmok: 1, jalad: -1 }
       *     name: 'tanagra'
       *   }
       * ]);
       * ```
       */
      async createIndexes(indexSpecs, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexDescriptionArray(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, { ...options2, maxTimeMS: void 0 })));
      }
      /**
       * Drops an index from this collection.
       *
       * @param indexName - Name of the index to drop.
       * @param options - Optional settings for the command
       */
      async dropIndex(indexName, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, indexName, {
          ...(0, utils_1.resolveOptions)(this, options2),
          readPreference: read_preference_1.ReadPreference.primary
        }));
      }
      /**
       * Drops all indexes from this collection.
       *
       * @param options - Optional settings for the command
       */
      async dropIndexes(options2) {
        try {
          await (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, "*", (0, utils_1.resolveOptions)(this, options2)));
          return true;
        } catch (error2) {
          if (error2 instanceof error_1.MongoOperationTimeoutError)
            throw error2;
          return false;
        }
      }
      /**
       * Get the list of all indexes information for the collection.
       *
       * @param options - Optional settings for the command
       */
      listIndexes(options2) {
        return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options2));
      }
      /**
       * Checks if one or more indexes exist on the collection, fails on first non-existing index
       *
       * @param indexes - One or more index names to check.
       * @param options - Optional settings for the command
       */
      async indexExists(indexes, options2) {
        const indexNames = Array.isArray(indexes) ? indexes : [indexes];
        const allIndexes = new Set(await this.listIndexes(options2).map(({ name }) => name).toArray());
        return indexNames.every((name) => allIndexes.has(name));
      }
      async indexInformation(options2) {
        return await this.indexes({
          ...options2,
          full: options2?.full ?? false
        });
      }
      /**
       * Gets an estimate of the count of documents in a collection using collection metadata.
       * This will always run a count command on all server versions.
       *
       * due to an oversight in versions 5.0.0-5.0.8 of MongoDB, the count command,
       * which estimatedDocumentCount uses in its implementation, was not included in v1 of
       * the Stable API, and so users of the Stable API with estimatedDocumentCount are
       * recommended to upgrade their server version to 5.0.9+ or set apiStrict: false to avoid
       * encountering errors.
       *
       * @see {@link https://www.mongodb.com/docs/manual/reference/command/count/#behavior|Count: Behavior}
       * @param options - Optional settings for the command
       */
      async estimatedDocumentCount(options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Gets the number of documents matching the filter.
       * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.
       *
       * Due to countDocuments using the $match aggregation pipeline stage, certain query operators cannot be used in countDocuments. This includes the $where and $near query operators, among others. Details can be found in the documentation for the $match aggregation pipeline stage.
       *
       * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}
       * the following query operators must be replaced:
       *
       * | Operator | Replacement |
       * | -------- | ----------- |
       * | `$where`   | [`$expr`][1] |
       * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |
       * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |
       *
       * [1]: https://www.mongodb.com/docs/manual/reference/operator/query/expr/
       * [2]: https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/
       * [3]: https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center
       * [4]: https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere
       *
       * @param filter - The filter for the count
       * @param options - Optional settings for the command
       *
       * @see https://www.mongodb.com/docs/manual/reference/operator/query/expr/
       * @see https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/
       * @see https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center
       * @see https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere
       */
      async countDocuments(filter = {}, options2 = {}) {
        const pipeline = [];
        pipeline.push({ $match: filter });
        if (typeof options2.skip === "number") {
          pipeline.push({ $skip: options2.skip });
        }
        if (typeof options2.limit === "number") {
          pipeline.push({ $limit: options2.limit });
        }
        pipeline.push({ $group: { _id: 1, n: { $sum: 1 } } });
        const cursor = this.aggregate(pipeline, options2);
        const doc = await cursor.next();
        await cursor.close();
        return doc?.n ?? 0;
      }
      async distinct(key, filter = {}, options2 = {}) {
        return await (0, execute_operation_1.executeOperation)(this.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options2)));
      }
      async indexes(options2) {
        const indexes = await this.listIndexes(options2).toArray();
        const full = options2?.full ?? true;
        if (full) {
          return indexes;
        }
        const object = Object.fromEntries(indexes.map(({ name, key }) => [name, Object.entries(key)]));
        return object;
      }
      async findOneAndDelete(filter, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options2)));
      }
      async findOneAndReplace(filter, replacement, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options2)));
      }
      async findOneAndUpdate(filter, update, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Execute an aggregation framework pipeline against the collection, needs MongoDB \>= 2.2
       *
       * @param pipeline - An array of aggregation pipelines to execute
       * @param options - Optional settings for the command
       */
      aggregate(pipeline = [], options2) {
        if (!Array.isArray(pipeline)) {
          throw new error_1.MongoInvalidArgumentError('Argument "pipeline" must be an array of aggregation stages');
        }
        return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options2));
      }
      /**
       * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.
       *
       * @remarks
       * watch() accepts two generic arguments for distinct use cases:
       * - The first is to override the schema that may be defined for this specific collection
       * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
       * @example
       * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`
       * ```ts
       * collection.watch<{ _id: number }>()
       *   .on('change', change => console.log(change._id.toFixed(4)));
       * ```
       *
       * @example
       * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.
       * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.
       * No need start from scratch on the ChangeStreamInsertDocument type!
       * By using an intersection we can save time and ensure defaults remain the same type!
       * ```ts
       * collection
       *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([
       *     { $addFields: { comment: 'big changes' } },
       *     { $match: { operationType: 'insert' } }
       *   ])
       *   .on('change', change => {
       *     change.comment.startsWith('big');
       *     change.operationType === 'insert';
       *     // No need to narrow in code because the generics did that for us!
       *     expectType<Schema>(change.fullDocument);
       *   });
       * ```
       *
       * @remarks
       * When `timeoutMS` is configured for a change stream, it will have different behaviour depending
       * on whether the change stream is in iterator mode or emitter mode. In both cases, a change
       * stream will time out if it does not receive a change event within `timeoutMS` of the last change
       * event.
       *
       * Note that if a change stream is consistently timing out when watching a collection, database or
       * client that is being changed, then this may be due to the server timing out before it can finish
       * processing the existing oplog. To address this, restart the change stream with a higher
       * `timeoutMS`.
       *
       * If the change stream times out the initial aggregate operation to establish the change stream on
       * the server, then the client will close the change stream. If the getMore calls to the server
       * time out, then the change stream will be left open, but will throw a MongoOperationTimeoutError
       * when in iterator mode and emit an error event that returns a MongoOperationTimeoutError in
       * emitter mode.
       *
       * To determine whether or not the change stream is still open following a timeout, check the
       * {@link ChangeStream.closed} getter.
       *
       * @example
       * In iterator mode, if a next() call throws a timeout error, it will attempt to resume the change stream.
       * The next call can just be retried after this succeeds.
       * ```ts
       * const changeStream = collection.watch([], { timeoutMS: 100 });
       * try {
       *     await changeStream.next();
       * } catch (e) {
       *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {
       *       await changeStream.next();
       *     }
       *     throw e;
       * }
       * ```
       *
       * @example
       * In emitter mode, if the change stream goes `timeoutMS` without emitting a change event, it will
       * emit an error event that returns a MongoOperationTimeoutError, but will not close the change
       * stream unless the resume attempt fails. There is no need to re-establish change listeners as
       * this will automatically continue emitting change events once the resume attempt completes.
       *
       * ```ts
       * const changeStream = collection.watch([], { timeoutMS: 100 });
       * changeStream.on('change', console.log);
       * changeStream.on('error', e => {
       *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {
       *         // do nothing
       *     } else {
       *         changeStream.close();
       *     }
       * });
       * ```
       *
       * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
       * @param options - Optional settings for the command
       * @typeParam TLocal - Type of the data being detected by the change stream
       * @typeParam TChange - Type of the whole change stream document emitted
       */
      watch(pipeline = [], options2 = {}) {
        if (!Array.isArray(pipeline)) {
          options2 = pipeline;
          pipeline = [];
        }
        return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options2));
      }
      /**
       * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
       *
       * @throws MongoNotConnectedError
       * @remarks
       * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.
       * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.
       */
      initializeUnorderedBulkOp(options2) {
        return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options2));
      }
      /**
       * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.
       *
       * @throws MongoNotConnectedError
       * @remarks
       * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.
       * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.
       */
      initializeOrderedBulkOp(options2) {
        return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options2));
      }
      /**
       * An estimated count of matching documents in the db to a filter.
       *
       * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents
       * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.
       * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.
       *
       * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead
       *
       * @param filter - The filter for the count.
       * @param options - Optional settings for the command
       */
      async count(filter = {}, options2 = {}) {
        return await (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.fullNamespace, filter, (0, utils_1.resolveOptions)(this, options2)));
      }
      listSearchIndexes(indexNameOrOptions, options2) {
        options2 = typeof indexNameOrOptions === "object" ? indexNameOrOptions : options2 == null ? {} : options2;
        const indexName = indexNameOrOptions == null ? null : typeof indexNameOrOptions === "object" ? null : indexNameOrOptions;
        return new list_search_indexes_cursor_1.ListSearchIndexesCursor(this, indexName, options2);
      }
      /**
       * Creates a single search index for the collection.
       *
       * @param description - The index description for the new search index.
       * @returns A promise that resolves to the name of the new search index.
       *
       * @remarks Only available when used against a 7.0+ Atlas cluster.
       */
      async createSearchIndex(description) {
        const [index] = await this.createSearchIndexes([description]);
        return index;
      }
      /**
       * Creates multiple search indexes for the current collection.
       *
       * @param descriptions - An array of `SearchIndexDescription`s for the new search indexes.
       * @returns A promise that resolves to an array of the newly created search index names.
       *
       * @remarks Only available when used against a 7.0+ Atlas cluster.
       * @returns
       */
      async createSearchIndexes(descriptions) {
        return await (0, execute_operation_1.executeOperation)(this.client, new create_1.CreateSearchIndexesOperation(this, descriptions));
      }
      /**
       * Deletes a search index by index name.
       *
       * @param name - The name of the search index to be deleted.
       *
       * @remarks Only available when used against a 7.0+ Atlas cluster.
       */
      async dropSearchIndex(name) {
        return await (0, execute_operation_1.executeOperation)(this.client, new drop_2.DropSearchIndexOperation(this, name));
      }
      /**
       * Updates a search index by replacing the existing index definition with the provided definition.
       *
       * @param name - The name of the search index to update.
       * @param definition - The new search index definition.
       *
       * @remarks Only available when used against a 7.0+ Atlas cluster.
       */
      async updateSearchIndex(name, definition) {
        return await (0, execute_operation_1.executeOperation)(this.client, new update_1.UpdateSearchIndexOperation(this, name, definition));
      }
    };
    exports2.Collection = Collection;
  }
});

// node_modules/mongodb/lib/cursor/change_stream_cursor.js
var require_change_stream_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/change_stream_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChangeStreamCursor = void 0;
    var change_stream_1 = require_change_stream();
    var constants_1 = require_constants4();
    var aggregate_1 = require_aggregate();
    var execute_operation_1 = require_execute_operation();
    var utils_1 = require_utils5();
    var abstract_cursor_1 = require_abstract_cursor();
    var ChangeStreamCursor = class _ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {
      constructor(client, namespace, pipeline = [], options2 = {}) {
        super(client, namespace, { ...options2, tailable: true, awaitData: true });
        this.pipeline = pipeline;
        this.changeStreamCursorOptions = options2;
        this._resumeToken = null;
        this.startAtOperationTime = options2.startAtOperationTime ?? null;
        if (options2.startAfter) {
          this.resumeToken = options2.startAfter;
        } else if (options2.resumeAfter) {
          this.resumeToken = options2.resumeAfter;
        }
      }
      set resumeToken(token) {
        this._resumeToken = token;
        this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);
      }
      get resumeToken() {
        return this._resumeToken;
      }
      get resumeOptions() {
        const options2 = {
          ...this.changeStreamCursorOptions
        };
        for (const key of ["resumeAfter", "startAfter", "startAtOperationTime"]) {
          delete options2[key];
        }
        if (this.resumeToken != null) {
          if (this.changeStreamCursorOptions.startAfter && !this.hasReceived) {
            options2.startAfter = this.resumeToken;
          } else {
            options2.resumeAfter = this.resumeToken;
          }
        } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {
          options2.startAtOperationTime = this.startAtOperationTime;
        }
        return options2;
      }
      cacheResumeToken(resumeToken) {
        if (this.bufferedCount() === 0 && this.postBatchResumeToken) {
          this.resumeToken = this.postBatchResumeToken;
        } else {
          this.resumeToken = resumeToken;
        }
        this.hasReceived = true;
      }
      _processBatch(response) {
        const { postBatchResumeToken } = response;
        if (postBatchResumeToken) {
          this.postBatchResumeToken = postBatchResumeToken;
          if (response.batchSize === 0) {
            this.resumeToken = postBatchResumeToken;
          }
        }
      }
      clone() {
        return new _ChangeStreamCursor(this.client, this.namespace, this.pipeline, {
          ...this.cursorOptions
        });
      }
      async _initialize(session) {
        const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
          ...this.cursorOptions,
          ...this.changeStreamCursorOptions,
          session
        });
        const response = await (0, execute_operation_1.executeOperation)(session.client, aggregateOperation, this.timeoutContext);
        const server = aggregateOperation.server;
        this.maxWireVersion = (0, utils_1.maxWireVersion)(server);
        if (this.startAtOperationTime == null && this.changeStreamCursorOptions.resumeAfter == null && this.changeStreamCursorOptions.startAfter == null && this.maxWireVersion >= 7) {
          this.startAtOperationTime = response.operationTime;
        }
        this._processBatch(response);
        this.emit(constants_1.INIT, response);
        this.emit(constants_1.RESPONSE);
        return { server, session, response };
      }
      async getMore(batchSize) {
        const response = await super.getMore(batchSize);
        this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);
        this._processBatch(response);
        this.emit(change_stream_1.ChangeStream.MORE, response);
        this.emit(change_stream_1.ChangeStream.RESPONSE);
        return response;
      }
    };
    exports2.ChangeStreamCursor = ChangeStreamCursor;
  }
});

// node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS({
  "node_modules/mongodb/lib/operations/list_collections.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ListCollectionsOperation = void 0;
    var responses_1 = require_responses();
    var utils_1 = require_utils5();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var ListCollectionsOperation = class extends command_1.CommandOperation {
      constructor(db, filter, options2) {
        super(db, options2);
        this.options = { ...options2 };
        delete this.options.writeConcern;
        this.db = db;
        this.filter = filter;
        this.nameOnly = !!this.options.nameOnly;
        this.authorizedCollections = !!this.options.authorizedCollections;
        if (typeof this.options.batchSize === "number") {
          this.batchSize = this.options.batchSize;
        }
      }
      get commandName() {
        return "listCollections";
      }
      async execute(server, session, timeoutContext) {
        return await super.executeCommand(server, session, this.generateCommand((0, utils_1.maxWireVersion)(server)), timeoutContext, responses_1.CursorResponse);
      }
      /* This is here for the purpose of unit testing the final command that gets sent. */
      generateCommand(wireVersion) {
        const command = {
          listCollections: 1,
          filter: this.filter,
          cursor: this.batchSize ? { batchSize: this.batchSize } : {},
          nameOnly: this.nameOnly,
          authorizedCollections: this.authorizedCollections
        };
        if (wireVersion >= 9 && this.options.comment !== void 0) {
          command.comment = this.options.comment;
        }
        return command;
      }
    };
    exports2.ListCollectionsOperation = ListCollectionsOperation;
    (0, operation_1.defineAspects)(ListCollectionsOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
  }
});

// node_modules/mongodb/lib/cursor/list_collections_cursor.js
var require_list_collections_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/list_collections_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ListCollectionsCursor = void 0;
    var execute_operation_1 = require_execute_operation();
    var list_collections_1 = require_list_collections();
    var abstract_cursor_1 = require_abstract_cursor();
    var ListCollectionsCursor = class _ListCollectionsCursor extends abstract_cursor_1.AbstractCursor {
      constructor(db, filter, options2) {
        super(db.client, db.s.namespace, options2);
        this.parent = db;
        this.filter = filter;
        this.options = options2;
      }
      clone() {
        return new _ListCollectionsCursor(this.parent, this.filter, {
          ...this.options,
          ...this.cursorOptions
        });
      }
      /** @internal */
      async _initialize(session) {
        const operation = new list_collections_1.ListCollectionsOperation(this.parent, this.filter, {
          ...this.cursorOptions,
          ...this.options,
          session,
          signal: this.signal
        });
        const response = await (0, execute_operation_1.executeOperation)(this.parent.client, operation, this.timeoutContext);
        return { server: operation.server, session, response };
      }
    };
    exports2.ListCollectionsCursor = ListCollectionsCursor;
  }
});

// node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS({
  "node_modules/mongodb/lib/operations/run_command.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RunAdminCommandOperation = exports2.RunCommandOperation = void 0;
    var utils_1 = require_utils5();
    var operation_1 = require_operation();
    var RunCommandOperation = class extends operation_1.AbstractOperation {
      constructor(parent, command, options2) {
        super(options2);
        this.command = command;
        this.options = options2;
        this.ns = parent.s.namespace.withCollection("$cmd");
      }
      get commandName() {
        return "runCommand";
      }
      async execute(server, session, timeoutContext) {
        this.server = server;
        const res = await server.command(this.ns, this.command, {
          ...this.options,
          readPreference: this.readPreference,
          session,
          timeoutContext
        }, this.options.responseType);
        return res;
      }
    };
    exports2.RunCommandOperation = RunCommandOperation;
    var RunAdminCommandOperation = class extends operation_1.AbstractOperation {
      constructor(command, options2) {
        super(options2);
        this.command = command;
        this.options = options2;
        this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
      }
      get commandName() {
        return "runCommand";
      }
      async execute(server, session, timeoutContext) {
        this.server = server;
        const res = await server.command(this.ns, this.command, {
          ...this.options,
          readPreference: this.readPreference,
          session,
          timeoutContext
        });
        return res;
      }
    };
    exports2.RunAdminCommandOperation = RunAdminCommandOperation;
  }
});

// node_modules/mongodb/lib/cursor/run_command_cursor.js
var require_run_command_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/run_command_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RunCommandCursor = void 0;
    var responses_1 = require_responses();
    var error_1 = require_error();
    var execute_operation_1 = require_execute_operation();
    var get_more_1 = require_get_more();
    var run_command_1 = require_run_command();
    var utils_1 = require_utils5();
    var abstract_cursor_1 = require_abstract_cursor();
    var RunCommandCursor = class extends abstract_cursor_1.AbstractCursor {
      /**
       * Controls the `getMore.comment` field
       * @param comment - any BSON value
       */
      setComment(comment) {
        this.getMoreOptions.comment = comment;
        return this;
      }
      /**
       * Controls the `getMore.maxTimeMS` field. Only valid when cursor is tailable await
       * @param maxTimeMS - the number of milliseconds to wait for new data
       */
      setMaxTimeMS(maxTimeMS) {
        this.getMoreOptions.maxAwaitTimeMS = maxTimeMS;
        return this;
      }
      /**
       * Controls the `getMore.batchSize` field
       * @param batchSize - the number documents to return in the `nextBatch`
       */
      setBatchSize(batchSize) {
        this.getMoreOptions.batchSize = batchSize;
        return this;
      }
      /** Unsupported for RunCommandCursor */
      clone() {
        throw new error_1.MongoAPIError("Clone not supported, create a new cursor with db.runCursorCommand");
      }
      /** Unsupported for RunCommandCursor: readConcern must be configured directly on command document */
      withReadConcern(_) {
        throw new error_1.MongoAPIError("RunCommandCursor does not support readConcern it must be attached to the command being run");
      }
      /** Unsupported for RunCommandCursor: various cursor flags must be configured directly on command document */
      addCursorFlag(_, __) {
        throw new error_1.MongoAPIError("RunCommandCursor does not support cursor flags, they must be attached to the command being run");
      }
      /**
       * Unsupported for RunCommandCursor: maxTimeMS must be configured directly on command document
       */
      maxTimeMS(_) {
        throw new error_1.MongoAPIError("maxTimeMS must be configured on the command document directly, to configure getMore.maxTimeMS use cursor.setMaxTimeMS()");
      }
      /** Unsupported for RunCommandCursor: batchSize must be configured directly on command document */
      batchSize(_) {
        throw new error_1.MongoAPIError("batchSize must be configured on the command document directly, to configure getMore.batchSize use cursor.setBatchSize()");
      }
      /** @internal */
      constructor(db, command, options2 = {}) {
        super(db.client, (0, utils_1.ns)(db.namespace), options2);
        this.getMoreOptions = {};
        this.db = db;
        this.command = Object.freeze({ ...command });
      }
      /** @internal */
      async _initialize(session) {
        const operation = new run_command_1.RunCommandOperation(this.db, this.command, {
          ...this.cursorOptions,
          session,
          readPreference: this.cursorOptions.readPreference,
          responseType: responses_1.CursorResponse
        });
        const response = await (0, execute_operation_1.executeOperation)(this.client, operation, this.timeoutContext);
        return {
          server: operation.server,
          session,
          response
        };
      }
      /** @internal */
      async getMore(_batchSize) {
        const getMoreOperation = new get_more_1.GetMoreOperation(this.namespace, this.id, this.server, {
          ...this.cursorOptions,
          session: this.session,
          ...this.getMoreOptions
        });
        return await (0, execute_operation_1.executeOperation)(this.client, getMoreOperation, this.timeoutContext);
      }
    };
    exports2.RunCommandCursor = RunCommandCursor;
  }
});

// node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS({
  "node_modules/mongodb/lib/operations/collections.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CollectionsOperation = void 0;
    var collection_1 = require_collection();
    var operation_1 = require_operation();
    var CollectionsOperation = class extends operation_1.AbstractOperation {
      constructor(db, options2) {
        super(options2);
        this.options = options2;
        this.db = db;
      }
      get commandName() {
        return "listCollections";
      }
      async execute(server, session) {
        const documents = await this.db.listCollections({}, { ...this.options, nameOnly: true, readPreference: this.readPreference, session }).toArray();
        const collections = [];
        for (const { name } of documents) {
          if (!name.includes("$")) {
            collections.push(new collection_1.Collection(this.db, name, this.db.s.options));
          }
        }
        return collections;
      }
    };
    exports2.CollectionsOperation = CollectionsOperation;
  }
});

// node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS({
  "node_modules/mongodb/lib/operations/create_collection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CreateCollectionOperation = void 0;
    var constants_1 = require_constants3();
    var collection_1 = require_collection();
    var error_1 = require_error();
    var command_1 = require_command();
    var indexes_1 = require_indexes();
    var operation_1 = require_operation();
    var ILLEGAL_COMMAND_FIELDS = /* @__PURE__ */ new Set([
      "w",
      "wtimeout",
      "timeoutMS",
      "j",
      "fsync",
      "autoIndexId",
      "pkFactory",
      "raw",
      "readPreference",
      "session",
      "readConcern",
      "writeConcern",
      "raw",
      "fieldsAsRaw",
      "useBigInt64",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "serializeFunctions",
      "ignoreUndefined",
      "enableUtf8Validation"
    ]);
    var INVALID_QE_VERSION = "Driver support of Queryable Encryption is incompatible with server. Upgrade server to use Queryable Encryption.";
    var CreateCollectionOperation = class _CreateCollectionOperation extends command_1.CommandOperation {
      constructor(db, name, options2 = {}) {
        super(db, options2);
        this.options = options2;
        this.db = db;
        this.name = name;
      }
      get commandName() {
        return "create";
      }
      async execute(server, session, timeoutContext) {
        const db = this.db;
        const name = this.name;
        const options2 = this.options;
        const encryptedFields = options2.encryptedFields ?? db.client.s.options.autoEncryption?.encryptedFieldsMap?.[`${db.databaseName}.${name}`];
        if (encryptedFields) {
          if (!server.loadBalanced && server.description.maxWireVersion < constants_1.MIN_SUPPORTED_QE_WIRE_VERSION) {
            throw new error_1.MongoCompatibilityError(`${INVALID_QE_VERSION} The minimum server version required is ${constants_1.MIN_SUPPORTED_QE_SERVER_VERSION}`);
          }
          const escCollection = encryptedFields.escCollection ?? `enxcol_.${name}.esc`;
          const ecocCollection = encryptedFields.ecocCollection ?? `enxcol_.${name}.ecoc`;
          for (const collectionName of [escCollection, ecocCollection]) {
            const createOp = new _CreateCollectionOperation(db, collectionName, {
              clusteredIndex: {
                key: { _id: 1 },
                unique: true
              }
            });
            await createOp.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
          }
          if (!options2.encryptedFields) {
            this.options = { ...this.options, encryptedFields };
          }
        }
        const coll = await this.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
        if (encryptedFields) {
          const createIndexOp = indexes_1.CreateIndexesOperation.fromIndexSpecification(db, name, { __safeContent__: 1 }, {});
          await createIndexOp.execute(server, session, timeoutContext);
        }
        return coll;
      }
      async executeWithoutEncryptedFieldsCheck(server, session, timeoutContext) {
        const db = this.db;
        const name = this.name;
        const options2 = this.options;
        const cmd = { create: name };
        for (const n in options2) {
          if (options2[n] != null && typeof options2[n] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n)) {
            cmd[n] = options2[n];
          }
        }
        await super.executeCommand(server, session, cmd, timeoutContext);
        return new collection_1.Collection(db, name, options2);
      }
    };
    exports2.CreateCollectionOperation = CreateCollectionOperation;
    (0, operation_1.defineAspects)(CreateCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/profiling_level.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProfilingLevelOperation = void 0;
    var error_1 = require_error();
    var command_1 = require_command();
    var ProfilingLevelOperation = class extends command_1.CommandOperation {
      constructor(db, options2) {
        super(db, options2);
        this.options = options2;
      }
      get commandName() {
        return "profile";
      }
      async execute(server, session, timeoutContext) {
        const doc = await super.executeCommand(server, session, { profile: -1 }, timeoutContext);
        if (doc.ok === 1) {
          const was = doc.was;
          if (was === 0)
            return "off";
          if (was === 1)
            return "slow_only";
          if (was === 2)
            return "all";
          throw new error_1.MongoUnexpectedServerResponseError(`Illegal profiling level value ${was}`);
        } else {
          throw new error_1.MongoUnexpectedServerResponseError("Error with profile command");
        }
      }
    };
    exports2.ProfilingLevelOperation = ProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS({
  "node_modules/mongodb/lib/operations/remove_user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RemoveUserOperation = void 0;
    var command_1 = require_command();
    var operation_1 = require_operation();
    var RemoveUserOperation = class extends command_1.CommandOperation {
      constructor(db, username, options2) {
        super(db, options2);
        this.options = options2;
        this.username = username;
      }
      get commandName() {
        return "dropUser";
      }
      async execute(server, session, timeoutContext) {
        await super.executeCommand(server, session, { dropUser: this.username }, timeoutContext);
        return true;
      }
    };
    exports2.RemoveUserOperation = RemoveUserOperation;
    (0, operation_1.defineAspects)(RemoveUserOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/set_profiling_level.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SetProfilingLevelOperation = exports2.ProfilingLevel = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var command_1 = require_command();
    var levelValues = /* @__PURE__ */ new Set(["off", "slow_only", "all"]);
    exports2.ProfilingLevel = Object.freeze({
      off: "off",
      slowOnly: "slow_only",
      all: "all"
    });
    var SetProfilingLevelOperation = class extends command_1.CommandOperation {
      constructor(db, level, options2) {
        super(db, options2);
        this.options = options2;
        switch (level) {
          case exports2.ProfilingLevel.off:
            this.profile = 0;
            break;
          case exports2.ProfilingLevel.slowOnly:
            this.profile = 1;
            break;
          case exports2.ProfilingLevel.all:
            this.profile = 2;
            break;
          default:
            this.profile = 0;
            break;
        }
        this.level = level;
      }
      get commandName() {
        return "profile";
      }
      async execute(server, session, timeoutContext) {
        const level = this.level;
        if (!levelValues.has(level)) {
          throw new error_1.MongoInvalidArgumentError(`Profiling level must be one of "${(0, utils_1.enumToString)(exports2.ProfilingLevel)}"`);
        }
        await super.executeCommand(server, session, { profile: this.profile }, timeoutContext);
        return level;
      }
    };
    exports2.SetProfilingLevelOperation = SetProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS({
  "node_modules/mongodb/lib/operations/stats.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DbStatsOperation = void 0;
    var command_1 = require_command();
    var operation_1 = require_operation();
    var DbStatsOperation = class extends command_1.CommandOperation {
      constructor(db, options2) {
        super(db, options2);
        this.options = options2;
      }
      get commandName() {
        return "dbStats";
      }
      async execute(server, session, timeoutContext) {
        const command = { dbStats: true };
        if (this.options.scale != null) {
          command.scale = this.options.scale;
        }
        return await super.executeCommand(server, session, command, timeoutContext);
      }
    };
    exports2.DbStatsOperation = DbStatsOperation;
    (0, operation_1.defineAspects)(DbStatsOperation, [operation_1.Aspect.READ_OPERATION]);
  }
});

// node_modules/mongodb/lib/db.js
var require_db2 = __commonJS({
  "node_modules/mongodb/lib/db.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Db = void 0;
    var admin_1 = require_admin();
    var bson_1 = require_bson2();
    var change_stream_1 = require_change_stream();
    var collection_1 = require_collection();
    var CONSTANTS = require_constants4();
    var aggregation_cursor_1 = require_aggregation_cursor();
    var list_collections_cursor_1 = require_list_collections_cursor();
    var run_command_cursor_1 = require_run_command_cursor();
    var error_1 = require_error();
    var collections_1 = require_collections();
    var create_collection_1 = require_create_collection();
    var drop_1 = require_drop();
    var execute_operation_1 = require_execute_operation();
    var indexes_1 = require_indexes();
    var profiling_level_1 = require_profiling_level();
    var remove_user_1 = require_remove_user();
    var rename_1 = require_rename();
    var run_command_1 = require_run_command();
    var set_profiling_level_1 = require_set_profiling_level();
    var stats_1 = require_stats();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var utils_1 = require_utils5();
    var write_concern_1 = require_write_concern();
    var DB_OPTIONS_ALLOW_LIST = [
      "writeConcern",
      "readPreference",
      "readPreferenceTags",
      "native_parser",
      "forceServerObjectId",
      "pkFactory",
      "serializeFunctions",
      "raw",
      "authSource",
      "ignoreUndefined",
      "readConcern",
      "retryMiliSeconds",
      "numberOfRetries",
      "useBigInt64",
      "promoteBuffers",
      "promoteLongs",
      "bsonRegExp",
      "enableUtf8Validation",
      "promoteValues",
      "compression",
      "retryWrites",
      "timeoutMS"
    ];
    var Db = class {
      /**
       * Creates a new Db instance.
       *
       * Db name cannot contain a dot, the server may apply more restrictions when an operation is run.
       *
       * @param client - The MongoClient for the database.
       * @param databaseName - The name of the database this instance represents.
       * @param options - Optional settings for Db construction.
       */
      constructor(client, databaseName, options2) {
        options2 = options2 ?? {};
        options2 = (0, utils_1.filterOptions)(options2, DB_OPTIONS_ALLOW_LIST);
        if (typeof databaseName === "string" && databaseName.includes(".")) {
          throw new error_1.MongoInvalidArgumentError(`Database names cannot contain the character '.'`);
        }
        this.s = {
          // Options
          options: options2,
          // Unpack read preference
          readPreference: read_preference_1.ReadPreference.fromOptions(options2),
          // Merge bson options
          bsonOptions: (0, bson_1.resolveBSONOptions)(options2, client),
          // Set up the primary key factory or fallback to ObjectId
          pkFactory: options2?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,
          // ReadConcern
          readConcern: read_concern_1.ReadConcern.fromOptions(options2),
          writeConcern: write_concern_1.WriteConcern.fromOptions(options2),
          // Namespace
          namespace: new utils_1.MongoDBNamespace(databaseName)
        };
        this.client = client;
      }
      get databaseName() {
        return this.s.namespace.db;
      }
      // Options
      get options() {
        return this.s.options;
      }
      /**
       * Check if a secondary can be used (because the read preference is *not* set to primary)
       */
      get secondaryOk() {
        return this.s.readPreference?.preference !== "primary" || false;
      }
      get readConcern() {
        return this.s.readConcern;
      }
      /**
       * The current readPreference of the Db. If not explicitly defined for
       * this Db, will be inherited from the parent MongoClient
       */
      get readPreference() {
        if (this.s.readPreference == null) {
          return this.client.readPreference;
        }
        return this.s.readPreference;
      }
      get bsonOptions() {
        return this.s.bsonOptions;
      }
      // get the write Concern
      get writeConcern() {
        return this.s.writeConcern;
      }
      get namespace() {
        return this.s.namespace.toString();
      }
      get timeoutMS() {
        return this.s.options?.timeoutMS;
      }
      /**
       * Create a new collection on a server with the specified options. Use this to create capped collections.
       * More information about command options available at https://www.mongodb.com/docs/manual/reference/command/create/
       *
       * Collection namespace validation is performed server-side.
       *
       * @param name - The name of the collection to create
       * @param options - Optional settings for the command
       */
      async createCollection(name, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new create_collection_1.CreateCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Execute a command
       *
       * @remarks
       * This command does not inherit options from the MongoClient.
       *
       * The driver will ensure the following fields are attached to the command sent to the server:
       * - `lsid` - sourced from an implicit session or options.session
       * - `$readPreference` - defaults to primary or can be configured by options.readPreference
       * - `$db` - sourced from the name of this database
       *
       * If the client has a serverApi setting:
       * - `apiVersion`
       * - `apiStrict`
       * - `apiDeprecationErrors`
       *
       * When in a transaction:
       * - `readConcern` - sourced from readConcern set on the TransactionOptions
       * - `writeConcern` - sourced from writeConcern set on the TransactionOptions
       *
       * Attaching any of the above fields to the command will have no effect as the driver will overwrite the value.
       *
       * @param command - The command to run
       * @param options - Optional settings for the command
       */
      async command(command, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new run_command_1.RunCommandOperation(this, command, (0, utils_1.resolveOptions)(void 0, {
          ...(0, bson_1.resolveBSONOptions)(options2),
          timeoutMS: options2?.timeoutMS ?? this.timeoutMS,
          session: options2?.session,
          readPreference: options2?.readPreference,
          signal: options2?.signal
        })));
      }
      /**
       * Execute an aggregation framework pipeline against the database.
       *
       * @param pipeline - An array of aggregation stages to be executed
       * @param options - Optional settings for the command
       */
      aggregate(pipeline = [], options2) {
        return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options2));
      }
      /** Return the Admin db instance */
      admin() {
        return new admin_1.Admin(this);
      }
      /**
       * Returns a reference to a MongoDB Collection. If it does not exist it will be created implicitly.
       *
       * Collection namespace validation is performed server-side.
       *
       * @param name - the collection name we wish to access.
       * @returns return the new Collection instance
       */
      collection(name, options2 = {}) {
        if (typeof options2 === "function") {
          throw new error_1.MongoInvalidArgumentError("The callback form of this helper has been removed.");
        }
        return new collection_1.Collection(this, name, (0, utils_1.resolveOptions)(this, options2));
      }
      /**
       * Get all the db statistics.
       *
       * @param options - Optional settings for the command
       */
      async stats(options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new stats_1.DbStatsOperation(this, (0, utils_1.resolveOptions)(this, options2)));
      }
      listCollections(filter = {}, options2 = {}) {
        return new list_collections_cursor_1.ListCollectionsCursor(this, filter, (0, utils_1.resolveOptions)(this, options2));
      }
      /**
       * Rename a collection.
       *
       * @remarks
       * This operation does not inherit options from the MongoClient.
       *
       * @param fromCollection - Name of current collection to rename
       * @param toCollection - New name of of the collection
       * @param options - Optional settings for the command
       */
      async renameCollection(fromCollection, toCollection, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this.collection(fromCollection), toCollection, (0, utils_1.resolveOptions)(void 0, {
          ...options2,
          new_collection: true,
          readPreference: read_preference_1.ReadPreference.primary
        })));
      }
      /**
       * Drop a collection from the database, removing it permanently. New accesses will create a new collection.
       *
       * @param name - Name of collection to drop
       * @param options - Optional settings for the command
       */
      async dropCollection(name, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Drop a database, removing it permanently from the server.
       *
       * @param options - Optional settings for the command
       */
      async dropDatabase(options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropDatabaseOperation(this, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Fetch all collections for the current db.
       *
       * @param options - Optional settings for the command
       */
      async collections(options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new collections_1.CollectionsOperation(this, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Creates an index on the db and collection.
       *
       * @param name - Name of the collection to create the index on.
       * @param indexSpec - Specify the field to index, or an index specification
       * @param options - Optional settings for the command
       */
      async createIndex(name, indexSpec, options2) {
        const indexes = await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexSpecification(this, name, indexSpec, options2));
        return indexes[0];
      }
      /**
       * Remove a user from a database
       *
       * @param username - The username to remove
       * @param options - Optional settings for the command
       */
      async removeUser(username, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new remove_user_1.RemoveUserOperation(this, username, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Set the current profiling level of MongoDB
       *
       * @param level - The new profiling level (off, slow_only, all).
       * @param options - Optional settings for the command
       */
      async setProfilingLevel(level, options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new set_profiling_level_1.SetProfilingLevelOperation(this, level, (0, utils_1.resolveOptions)(this, options2)));
      }
      /**
       * Retrieve the current profiling Level for MongoDB
       *
       * @param options - Optional settings for the command
       */
      async profilingLevel(options2) {
        return await (0, execute_operation_1.executeOperation)(this.client, new profiling_level_1.ProfilingLevelOperation(this, (0, utils_1.resolveOptions)(this, options2)));
      }
      async indexInformation(name, options2) {
        return await this.collection(name).indexInformation((0, utils_1.resolveOptions)(this, options2));
      }
      /**
       * Create a new Change Stream, watching for new changes (insertions, updates,
       * replacements, deletions, and invalidations) in this database. Will ignore all
       * changes to system collections.
       *
       * @remarks
       * watch() accepts two generic arguments for distinct use cases:
       * - The first is to provide the schema that may be defined for all the collections within this database
       * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
       *
       * @remarks
       * When `timeoutMS` is configured for a change stream, it will have different behaviour depending
       * on whether the change stream is in iterator mode or emitter mode. In both cases, a change
       * stream will time out if it does not receive a change event within `timeoutMS` of the last change
       * event.
       *
       * Note that if a change stream is consistently timing out when watching a collection, database or
       * client that is being changed, then this may be due to the server timing out before it can finish
       * processing the existing oplog. To address this, restart the change stream with a higher
       * `timeoutMS`.
       *
       * If the change stream times out the initial aggregate operation to establish the change stream on
       * the server, then the client will close the change stream. If the getMore calls to the server
       * time out, then the change stream will be left open, but will throw a MongoOperationTimeoutError
       * when in iterator mode and emit an error event that returns a MongoOperationTimeoutError in
       * emitter mode.
       *
       * To determine whether or not the change stream is still open following a timeout, check the
       * {@link ChangeStream.closed} getter.
       *
       * @example
       * In iterator mode, if a next() call throws a timeout error, it will attempt to resume the change stream.
       * The next call can just be retried after this succeeds.
       * ```ts
       * const changeStream = collection.watch([], { timeoutMS: 100 });
       * try {
       *     await changeStream.next();
       * } catch (e) {
       *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {
       *       await changeStream.next();
       *     }
       *     throw e;
       * }
       * ```
       *
       * @example
       * In emitter mode, if the change stream goes `timeoutMS` without emitting a change event, it will
       * emit an error event that returns a MongoOperationTimeoutError, but will not close the change
       * stream unless the resume attempt fails. There is no need to re-establish change listeners as
       * this will automatically continue emitting change events once the resume attempt completes.
       *
       * ```ts
       * const changeStream = collection.watch([], { timeoutMS: 100 });
       * changeStream.on('change', console.log);
       * changeStream.on('error', e => {
       *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {
       *         // do nothing
       *     } else {
       *         changeStream.close();
       *     }
       * });
       * ```
       * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
       * @param options - Optional settings for the command
       * @typeParam TSchema - Type of the data being detected by the change stream
       * @typeParam TChange - Type of the whole change stream document emitted
       */
      watch(pipeline = [], options2 = {}) {
        if (!Array.isArray(pipeline)) {
          options2 = pipeline;
          pipeline = [];
        }
        return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options2));
      }
      /**
       * A low level cursor API providing basic driver functionality:
       * - ClientSession management
       * - ReadPreference for server selection
       * - Running getMores automatically when a local batch is exhausted
       *
       * @param command - The command that will start a cursor on the server.
       * @param options - Configurations for running the command, bson options will apply to getMores
       */
      runCursorCommand(command, options2) {
        return new run_command_cursor_1.RunCommandCursor(this, command, options2);
      }
    };
    exports2.Db = Db;
    Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
    Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
    Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
    Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
    Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
    Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
  }
});

// node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS({
  "node_modules/mongodb/lib/change_stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChangeStream = void 0;
    var collection_1 = require_collection();
    var constants_1 = require_constants4();
    var abstract_cursor_1 = require_abstract_cursor();
    var change_stream_cursor_1 = require_change_stream_cursor();
    var db_1 = require_db2();
    var error_1 = require_error();
    var mongo_client_1 = require_mongo_client();
    var mongo_types_1 = require_mongo_types();
    var resource_management_1 = require_resource_management();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils5();
    var CHANGE_STREAM_OPTIONS = [
      "resumeAfter",
      "startAfter",
      "startAtOperationTime",
      "fullDocument",
      "fullDocumentBeforeChange",
      "showExpandedEvents"
    ];
    var CHANGE_DOMAIN_TYPES = {
      COLLECTION: Symbol("Collection"),
      DATABASE: Symbol("Database"),
      CLUSTER: Symbol("Cluster")
    };
    var CHANGE_STREAM_EVENTS = [constants_1.RESUME_TOKEN_CHANGED, constants_1.END, constants_1.CLOSE];
    var NO_RESUME_TOKEN_ERROR = "A change stream document has been received that lacks a resume token (_id).";
    var CHANGESTREAM_CLOSED_ERROR = "ChangeStream is closed";
    var ChangeStream = class _ChangeStream extends mongo_types_1.TypedEventEmitter {
      /** @internal */
      async asyncDispose() {
        await this.close();
      }
      /**
       * @internal
       *
       * @param parent - The parent object that created this change stream
       * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents
       */
      constructor(parent, pipeline = [], options2 = {}) {
        super();
        this.pipeline = pipeline;
        this.options = { ...options2 };
        let serverSelectionTimeoutMS;
        delete this.options.writeConcern;
        if (parent instanceof collection_1.Collection) {
          this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
          serverSelectionTimeoutMS = parent.s.db.client.options.serverSelectionTimeoutMS;
        } else if (parent instanceof db_1.Db) {
          this.type = CHANGE_DOMAIN_TYPES.DATABASE;
          serverSelectionTimeoutMS = parent.client.options.serverSelectionTimeoutMS;
        } else if (parent instanceof mongo_client_1.MongoClient) {
          this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
          serverSelectionTimeoutMS = parent.options.serverSelectionTimeoutMS;
        } else {
          throw new error_1.MongoChangeStreamError("Parent provided to ChangeStream constructor must be an instance of Collection, Db, or MongoClient");
        }
        this.contextOwner = Symbol();
        this.parent = parent;
        this.namespace = parent.s.namespace;
        if (!this.options.readPreference && parent.readPreference) {
          this.options.readPreference = parent.readPreference;
        }
        this.cursor = this._createChangeStreamCursor(options2);
        this.isClosed = false;
        this.mode = false;
        this.on("newListener", (eventName) => {
          if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
            this._streamEvents(this.cursor);
          }
        });
        this.on("removeListener", (eventName) => {
          if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
            this.cursorStream?.removeAllListeners("data");
          }
        });
        if (this.options.timeoutMS != null) {
          this.timeoutContext = new timeout_1.CSOTTimeoutContext({
            timeoutMS: this.options.timeoutMS,
            serverSelectionTimeoutMS
          });
        }
      }
      /** The cached resume token that is used to resume after the most recently returned change. */
      get resumeToken() {
        return this.cursor?.resumeToken;
      }
      /** Check if there is any document still available in the Change Stream */
      async hasNext() {
        this._setIsIterator();
        this.timeoutContext?.refresh();
        try {
          while (true) {
            try {
              const hasNext = await this.cursor.hasNext();
              return hasNext;
            } catch (error2) {
              try {
                await this._processErrorIteratorMode(error2, this.cursor.id != null);
              } catch (error3) {
                if (error3 instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null) {
                  throw error3;
                }
                try {
                  await this.close();
                } catch (error4) {
                  (0, utils_1.squashError)(error4);
                }
                throw error3;
              }
            }
          }
        } finally {
          this.timeoutContext?.clear();
        }
      }
      /** Get the next available document from the Change Stream. */
      async next() {
        this._setIsIterator();
        this.timeoutContext?.refresh();
        try {
          while (true) {
            try {
              const change = await this.cursor.next();
              const processedChange = this._processChange(change ?? null);
              return processedChange;
            } catch (error2) {
              try {
                await this._processErrorIteratorMode(error2, this.cursor.id != null);
              } catch (error3) {
                if (error3 instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null) {
                  throw error3;
                }
                try {
                  await this.close();
                } catch (error4) {
                  (0, utils_1.squashError)(error4);
                }
                throw error3;
              }
            }
          }
        } finally {
          this.timeoutContext?.clear();
        }
      }
      /**
       * Try to get the next available document from the Change Stream's cursor or `null` if an empty batch is returned
       */
      async tryNext() {
        this._setIsIterator();
        this.timeoutContext?.refresh();
        try {
          while (true) {
            try {
              const change = await this.cursor.tryNext();
              return change ?? null;
            } catch (error2) {
              try {
                await this._processErrorIteratorMode(error2, this.cursor.id != null);
              } catch (error3) {
                if (error3 instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null)
                  throw error3;
                try {
                  await this.close();
                } catch (error4) {
                  (0, utils_1.squashError)(error4);
                }
                throw error3;
              }
            }
          }
        } finally {
          this.timeoutContext?.clear();
        }
      }
      async *[Symbol.asyncIterator]() {
        if (this.closed) {
          return;
        }
        try {
          while (true) {
            yield await this.next();
          }
        } finally {
          try {
            await this.close();
          } catch (error2) {
            (0, utils_1.squashError)(error2);
          }
        }
      }
      /** Is the cursor closed */
      get closed() {
        return this.isClosed || this.cursor.closed;
      }
      /**
       * Frees the internal resources used by the change stream.
       */
      async close() {
        this.timeoutContext?.clear();
        this.timeoutContext = void 0;
        this.isClosed = true;
        const cursor = this.cursor;
        try {
          await cursor.close();
        } finally {
          this._endStream();
        }
      }
      /**
       * Return a modified Readable stream including a possible transform method.
       *
       * NOTE: When using a Stream to process change stream events, the stream will
       * NOT automatically resume in the case a resumable error is encountered.
       *
       * @throws MongoChangeStreamError if the underlying cursor or the change stream is closed
       */
      stream(options2) {
        if (this.closed) {
          throw new error_1.MongoChangeStreamError(CHANGESTREAM_CLOSED_ERROR);
        }
        this.streamOptions = options2;
        return this.cursor.stream(options2);
      }
      /** @internal */
      _setIsEmitter() {
        if (this.mode === "iterator") {
          throw new error_1.MongoAPIError("ChangeStream cannot be used as an EventEmitter after being used as an iterator");
        }
        this.mode = "emitter";
      }
      /** @internal */
      _setIsIterator() {
        if (this.mode === "emitter") {
          throw new error_1.MongoAPIError("ChangeStream cannot be used as an iterator after being used as an EventEmitter");
        }
        this.mode = "iterator";
      }
      /**
       * Create a new change stream cursor based on self's configuration
       * @internal
       */
      _createChangeStreamCursor(options2) {
        const changeStreamStageOptions = (0, utils_1.filterOptions)(options2, CHANGE_STREAM_OPTIONS);
        if (this.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
          changeStreamStageOptions.allChangesForCluster = true;
        }
        const pipeline = [{ $changeStream: changeStreamStageOptions }, ...this.pipeline];
        const client = this.type === CHANGE_DOMAIN_TYPES.CLUSTER ? this.parent : this.type === CHANGE_DOMAIN_TYPES.DATABASE ? this.parent.client : this.type === CHANGE_DOMAIN_TYPES.COLLECTION ? this.parent.client : null;
        if (client == null) {
          throw new error_1.MongoRuntimeError(`Changestream type should only be one of cluster, database, collection. Found ${this.type.toString()}`);
        }
        const changeStreamCursor = new change_stream_cursor_1.ChangeStreamCursor(client, this.namespace, pipeline, {
          ...options2,
          timeoutContext: this.timeoutContext ? new abstract_cursor_1.CursorTimeoutContext(this.timeoutContext, this.contextOwner) : void 0
        });
        for (const event of CHANGE_STREAM_EVENTS) {
          changeStreamCursor.on(event, (e) => this.emit(event, e));
        }
        if (this.listenerCount(_ChangeStream.CHANGE) > 0) {
          this._streamEvents(changeStreamCursor);
        }
        return changeStreamCursor;
      }
      /** @internal */
      _closeEmitterModeWithError(error2) {
        this.emit(_ChangeStream.ERROR, error2);
        this.close().then(void 0, utils_1.squashError);
      }
      /** @internal */
      _streamEvents(cursor) {
        this._setIsEmitter();
        const stream = this.cursorStream ?? cursor.stream();
        this.cursorStream = stream;
        stream.on("data", (change) => {
          try {
            const processedChange = this._processChange(change);
            this.emit(_ChangeStream.CHANGE, processedChange);
          } catch (error2) {
            this.emit(_ChangeStream.ERROR, error2);
          }
          this.timeoutContext?.refresh();
        });
        stream.on("error", (error2) => this._processErrorStreamMode(error2, this.cursor.id != null));
      }
      /** @internal */
      _endStream() {
        this.cursorStream?.removeAllListeners("data");
        this.cursorStream?.removeAllListeners("close");
        this.cursorStream?.removeAllListeners("end");
        this.cursorStream?.destroy();
        this.cursorStream = void 0;
      }
      /** @internal */
      _processChange(change) {
        if (this.isClosed) {
          throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
        }
        if (change == null) {
          throw new error_1.MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR);
        }
        if (change && !change._id) {
          throw new error_1.MongoChangeStreamError(NO_RESUME_TOKEN_ERROR);
        }
        this.cursor.cacheResumeToken(change._id);
        this.options.startAtOperationTime = void 0;
        return change;
      }
      /** @internal */
      _processErrorStreamMode(changeStreamError, cursorInitialized) {
        if (this.isClosed)
          return;
        if (cursorInitialized && ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion) || changeStreamError instanceof error_1.MongoOperationTimeoutError)) {
          this._endStream();
          this.cursor.close().then(() => this._resume(changeStreamError), (e) => {
            (0, utils_1.squashError)(e);
            return this._resume(changeStreamError);
          }).then(() => {
            if (changeStreamError instanceof error_1.MongoOperationTimeoutError)
              this.emit(_ChangeStream.ERROR, changeStreamError);
          }, () => this._closeEmitterModeWithError(changeStreamError));
        } else {
          this._closeEmitterModeWithError(changeStreamError);
        }
      }
      /** @internal */
      async _processErrorIteratorMode(changeStreamError, cursorInitialized) {
        if (this.isClosed) {
          throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
        }
        if (cursorInitialized && ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion) || changeStreamError instanceof error_1.MongoOperationTimeoutError)) {
          try {
            await this.cursor.close();
          } catch (error2) {
            (0, utils_1.squashError)(error2);
          }
          await this._resume(changeStreamError);
          if (changeStreamError instanceof error_1.MongoOperationTimeoutError)
            throw changeStreamError;
        } else {
          try {
            await this.close();
          } catch (error2) {
            (0, utils_1.squashError)(error2);
          }
          throw changeStreamError;
        }
      }
      async _resume(changeStreamError) {
        this.timeoutContext?.refresh();
        const topology = (0, utils_1.getTopology)(this.parent);
        try {
          await topology.selectServer(this.cursor.readPreference, {
            operationName: "reconnect topology in change stream",
            timeoutContext: this.timeoutContext
          });
          this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
        } catch {
          await this.close();
          throw changeStreamError;
        }
      }
    };
    exports2.ChangeStream = ChangeStream;
    ChangeStream.RESPONSE = constants_1.RESPONSE;
    ChangeStream.MORE = constants_1.MORE;
    ChangeStream.INIT = constants_1.INIT;
    ChangeStream.CLOSE = constants_1.CLOSE;
    ChangeStream.CHANGE = constants_1.CHANGE;
    ChangeStream.END = constants_1.END;
    ChangeStream.ERROR = constants_1.ERROR;
    ChangeStream.RESUME_TOKEN_CHANGED = constants_1.RESUME_TOKEN_CHANGED;
    (0, resource_management_1.configureResourceManagement)(ChangeStream.prototype);
  }
});

// node_modules/mongodb/lib/deps.js
var require_deps = __commonJS({
  "node_modules/mongodb/lib/deps.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.aws4 = void 0;
    exports2.getKerberos = getKerberos;
    exports2.getZstdLibrary = getZstdLibrary;
    exports2.getAwsCredentialProvider = getAwsCredentialProvider;
    exports2.getGcpMetadata = getGcpMetadata;
    exports2.getSnappy = getSnappy;
    exports2.getSocks = getSocks;
    exports2.getMongoDBClientEncryption = getMongoDBClientEncryption;
    var error_1 = require_error();
    function makeErrorModule(error2) {
      const props = error2 ? { kModuleError: error2 } : {};
      return new Proxy(props, {
        get: (_, key) => {
          if (key === "kModuleError") {
            return error2;
          }
          throw error2;
        },
        set: () => {
          throw error2;
        }
      });
    }
    function getKerberos() {
      let kerberos;
      try {
        kerberos = require("kerberos");
      } catch (error2) {
        kerberos = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `kerberos` not found. Please install it to enable kerberos authentication", { cause: error2, dependencyName: "kerberos" }));
      }
      return kerberos;
    }
    function getZstdLibrary() {
      let ZStandard;
      try {
        ZStandard = require("@mongodb-js/zstd");
      } catch (error2) {
        ZStandard = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@mongodb-js/zstd` not found. Please install it to enable zstd compression", { cause: error2, dependencyName: "zstd" }));
      }
      return ZStandard;
    }
    function getAwsCredentialProvider() {
      try {
        const credentialProvider = require("@aws-sdk/credential-providers");
        return credentialProvider;
      } catch (error2) {
        return makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@aws-sdk/credential-providers` not found. Please install it to enable getting aws credentials via the official sdk.", { cause: error2, dependencyName: "@aws-sdk/credential-providers" }));
      }
    }
    function getGcpMetadata() {
      try {
        const credentialProvider = require("gcp-metadata");
        return credentialProvider;
      } catch (error2) {
        return makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `gcp-metadata` not found. Please install it to enable getting gcp credentials via the official sdk.", { cause: error2, dependencyName: "gcp-metadata" }));
      }
    }
    function getSnappy() {
      try {
        const value = require("snappy");
        return value;
      } catch (error2) {
        const kModuleError = new error_1.MongoMissingDependencyError("Optional module `snappy` not found. Please install it to enable snappy compression", { cause: error2, dependencyName: "snappy" });
        return { kModuleError };
      }
    }
    function getSocks() {
      try {
        const value = require("socks");
        return value;
      } catch (error2) {
        const kModuleError = new error_1.MongoMissingDependencyError("Optional module `socks` not found. Please install it to connections over a SOCKS5 proxy", { cause: error2, dependencyName: "socks" });
        return { kModuleError };
      }
    }
    exports2.aws4 = loadAws4();
    function loadAws4() {
      let aws4;
      try {
        aws4 = require("aws4");
      } catch (error2) {
        aws4 = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `aws4` not found. Please install it to enable AWS authentication", { cause: error2, dependencyName: "aws4" }));
      }
      return aws4;
    }
    function getMongoDBClientEncryption() {
      let mongodbClientEncryption = null;
      try {
        mongodbClientEncryption = require("mongodb-client-encryption");
      } catch (error2) {
        const kModuleError = new error_1.MongoMissingDependencyError("Optional module `mongodb-client-encryption` not found. Please install it to use auto encryption or ClientEncryption.", { cause: error2, dependencyName: "mongodb-client-encryption" });
        return { kModuleError };
      }
      return mongodbClientEncryption;
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/auth_provider.js
var require_auth_provider = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/auth_provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuthProvider = exports2.AuthContext = void 0;
    var error_1 = require_error();
    var AuthContext = class {
      constructor(connection, credentials, options2) {
        this.reauthenticating = false;
        this.connection = connection;
        this.credentials = credentials;
        this.options = options2;
      }
    };
    exports2.AuthContext = AuthContext;
    var AuthProvider = class {
      /**
       * Prepare the handshake document before the initial handshake.
       *
       * @param handshakeDoc - The document used for the initial handshake on a connection
       * @param authContext - Context for authentication flow
       */
      async prepare(handshakeDoc, _authContext) {
        return handshakeDoc;
      }
      /**
       * Reauthenticate.
       * @param context - The shared auth context.
       */
      async reauth(context) {
        if (context.reauthenticating) {
          throw new error_1.MongoRuntimeError("Reauthentication already in progress.");
        }
        try {
          context.reauthenticating = true;
          await this.auth(context);
        } finally {
          context.reauthenticating = false;
        }
      }
    };
    exports2.AuthProvider = AuthProvider;
  }
});

// node_modules/mongodb/lib/cmap/auth/gssapi.js
var require_gssapi = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/gssapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GSSAPI = exports2.GSSAPICanonicalizationValue = void 0;
    exports2.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;
    exports2.resolveCname = resolveCname;
    var dns = require("dns");
    var deps_1 = require_deps();
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var auth_provider_1 = require_auth_provider();
    exports2.GSSAPICanonicalizationValue = Object.freeze({
      on: true,
      off: false,
      none: "none",
      forward: "forward",
      forwardAndReverse: "forwardAndReverse"
    });
    async function externalCommand(connection, command) {
      const response = await connection.command((0, utils_1.ns)("$external.$cmd"), command);
      return response;
    }
    var krb;
    var GSSAPI = class extends auth_provider_1.AuthProvider {
      async auth(authContext) {
        const { connection, credentials } = authContext;
        if (credentials == null) {
          throw new error_1.MongoMissingCredentialsError("Credentials required for GSSAPI authentication");
        }
        const { username } = credentials;
        const client = await makeKerberosClient(authContext);
        const payload = await client.step("");
        const saslStartResponse = await externalCommand(connection, saslStart(payload));
        const negotiatedPayload = await negotiate(client, 10, saslStartResponse.payload);
        const saslContinueResponse = await externalCommand(connection, saslContinue(negotiatedPayload, saslStartResponse.conversationId));
        const finalizePayload = await finalize(client, username, saslContinueResponse.payload);
        await externalCommand(connection, {
          saslContinue: 1,
          conversationId: saslContinueResponse.conversationId,
          payload: finalizePayload
        });
      }
    };
    exports2.GSSAPI = GSSAPI;
    async function makeKerberosClient(authContext) {
      const { hostAddress } = authContext.options;
      const { credentials } = authContext;
      if (!hostAddress || typeof hostAddress.host !== "string" || !credentials) {
        throw new error_1.MongoInvalidArgumentError("Connection must have host and port and credentials defined.");
      }
      loadKrb();
      if ("kModuleError" in krb) {
        throw krb["kModuleError"];
      }
      const { initializeClient } = krb;
      const { username, password } = credentials;
      const mechanismProperties = credentials.mechanismProperties;
      const serviceName = mechanismProperties.SERVICE_NAME ?? "mongodb";
      const host = await performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);
      const initOptions = {};
      if (password != null) {
        Object.assign(initOptions, { user: username, password });
      }
      const spnHost = mechanismProperties.SERVICE_HOST ?? host;
      let spn = `${serviceName}${process.platform === "win32" ? "/" : "@"}${spnHost}`;
      if ("SERVICE_REALM" in mechanismProperties) {
        spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;
      }
      return await initializeClient(spn, initOptions);
    }
    function saslStart(payload) {
      return {
        saslStart: 1,
        mechanism: "GSSAPI",
        payload,
        autoAuthorize: 1
      };
    }
    function saslContinue(payload, conversationId) {
      return {
        saslContinue: 1,
        conversationId,
        payload
      };
    }
    async function negotiate(client, retries, payload) {
      try {
        const response = await client.step(payload);
        return response || "";
      } catch (error2) {
        if (retries === 0) {
          throw error2;
        }
        return await negotiate(client, retries - 1, payload);
      }
    }
    async function finalize(client, user, payload) {
      const response = await client.unwrap(payload);
      return await client.wrap(response || "", { user });
    }
    async function performGSSAPICanonicalizeHostName(host, mechanismProperties) {
      const mode = mechanismProperties.CANONICALIZE_HOST_NAME;
      if (!mode || mode === exports2.GSSAPICanonicalizationValue.none) {
        return host;
      }
      if (mode === exports2.GSSAPICanonicalizationValue.on || mode === exports2.GSSAPICanonicalizationValue.forwardAndReverse) {
        const { address } = await dns.promises.lookup(host);
        try {
          const results = await dns.promises.resolvePtr(address);
          return results.length > 0 ? results[0] : host;
        } catch {
          return await resolveCname(host);
        }
      } else {
        return await resolveCname(host);
      }
    }
    async function resolveCname(host) {
      try {
        const results = await dns.promises.resolveCname(host);
        return results.length > 0 ? results[0] : host;
      } catch {
        return host;
      }
    }
    function loadKrb() {
      if (!krb) {
        krb = (0, deps_1.getKerberos)();
      }
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/providers.js
var require_providers = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/providers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AUTH_MECHS_AUTH_SRC_EXTERNAL = exports2.AuthMechanism = void 0;
    exports2.AuthMechanism = Object.freeze({
      MONGODB_AWS: "MONGODB-AWS",
      MONGODB_CR: "MONGODB-CR",
      MONGODB_DEFAULT: "DEFAULT",
      MONGODB_GSSAPI: "GSSAPI",
      MONGODB_PLAIN: "PLAIN",
      MONGODB_SCRAM_SHA1: "SCRAM-SHA-1",
      MONGODB_SCRAM_SHA256: "SCRAM-SHA-256",
      MONGODB_X509: "MONGODB-X509",
      MONGODB_OIDC: "MONGODB-OIDC"
    });
    exports2.AUTH_MECHS_AUTH_SRC_EXTERNAL = /* @__PURE__ */ new Set([
      exports2.AuthMechanism.MONGODB_GSSAPI,
      exports2.AuthMechanism.MONGODB_AWS,
      exports2.AuthMechanism.MONGODB_OIDC,
      exports2.AuthMechanism.MONGODB_X509
    ]);
  }
});

// node_modules/mongodb/lib/cmap/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongo_credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoCredentials = exports2.DEFAULT_ALLOWED_HOSTS = void 0;
    var error_1 = require_error();
    var gssapi_1 = require_gssapi();
    var providers_1 = require_providers();
    function getDefaultAuthMechanism(hello) {
      if (hello) {
        if (Array.isArray(hello.saslSupportedMechs)) {
          return hello.saslSupportedMechs.includes(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA256 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
        }
      }
      return providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;
    }
    var ALLOWED_ENVIRONMENT_NAMES = [
      "test",
      "azure",
      "gcp",
      "k8s"
    ];
    var ALLOWED_HOSTS_ERROR = "Auth mechanism property ALLOWED_HOSTS must be an array of strings.";
    exports2.DEFAULT_ALLOWED_HOSTS = [
      "*.mongodb.net",
      "*.mongodb-qa.net",
      "*.mongodb-dev.net",
      "*.mongodbgov.net",
      "localhost",
      "127.0.0.1",
      "::1"
    ];
    var TOKEN_RESOURCE_MISSING_ERROR = "TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is azure or gcp.";
    var MongoCredentials = class _MongoCredentials {
      constructor(options2) {
        this.username = options2.username ?? "";
        this.password = options2.password;
        this.source = options2.source;
        if (!this.source && options2.db) {
          this.source = options2.db;
        }
        this.mechanism = options2.mechanism || providers_1.AuthMechanism.MONGODB_DEFAULT;
        this.mechanismProperties = options2.mechanismProperties || {};
        if (this.mechanism.match(/MONGODB-AWS/i)) {
          if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
            this.username = process.env.AWS_ACCESS_KEY_ID;
          }
          if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
            this.password = process.env.AWS_SECRET_ACCESS_KEY;
          }
          if (this.mechanismProperties.AWS_SESSION_TOKEN == null && process.env.AWS_SESSION_TOKEN != null) {
            this.mechanismProperties = {
              ...this.mechanismProperties,
              AWS_SESSION_TOKEN: process.env.AWS_SESSION_TOKEN
            };
          }
        }
        if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC && !this.mechanismProperties.ALLOWED_HOSTS) {
          this.mechanismProperties = {
            ...this.mechanismProperties,
            ALLOWED_HOSTS: exports2.DEFAULT_ALLOWED_HOSTS
          };
        }
        Object.freeze(this.mechanismProperties);
        Object.freeze(this);
      }
      /** Determines if two MongoCredentials objects are equivalent */
      equals(other) {
        return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
      }
      /**
       * If the authentication mechanism is set to "default", resolves the authMechanism
       * based on the server version and server supported sasl mechanisms.
       *
       * @param hello - A hello response from the server
       */
      resolveAuthMechanism(hello) {
        if (this.mechanism.match(/DEFAULT/i)) {
          return new _MongoCredentials({
            username: this.username,
            password: this.password,
            source: this.source,
            mechanism: getDefaultAuthMechanism(hello),
            mechanismProperties: this.mechanismProperties
          });
        }
        return this;
      }
      validate() {
        if ((this.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI || this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) && !this.username) {
          throw new error_1.MongoMissingCredentialsError(`Username required for mechanism '${this.mechanism}'`);
        }
        if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
          if (this.username && this.mechanismProperties.ENVIRONMENT && this.mechanismProperties.ENVIRONMENT !== "azure") {
            throw new error_1.MongoInvalidArgumentError(`username and ENVIRONMENT '${this.mechanismProperties.ENVIRONMENT}' may not be used together for mechanism '${this.mechanism}'.`);
          }
          if (this.username && this.password) {
            throw new error_1.MongoInvalidArgumentError(`No password is allowed in ENVIRONMENT '${this.mechanismProperties.ENVIRONMENT}' for '${this.mechanism}'.`);
          }
          if ((this.mechanismProperties.ENVIRONMENT === "azure" || this.mechanismProperties.ENVIRONMENT === "gcp") && !this.mechanismProperties.TOKEN_RESOURCE) {
            throw new error_1.MongoInvalidArgumentError(TOKEN_RESOURCE_MISSING_ERROR);
          }
          if (this.mechanismProperties.ENVIRONMENT && !ALLOWED_ENVIRONMENT_NAMES.includes(this.mechanismProperties.ENVIRONMENT)) {
            throw new error_1.MongoInvalidArgumentError(`Currently only a ENVIRONMENT in ${ALLOWED_ENVIRONMENT_NAMES.join(",")} is supported for mechanism '${this.mechanism}'.`);
          }
          if (!this.mechanismProperties.ENVIRONMENT && !this.mechanismProperties.OIDC_CALLBACK && !this.mechanismProperties.OIDC_HUMAN_CALLBACK) {
            throw new error_1.MongoInvalidArgumentError(`Either a ENVIRONMENT, OIDC_CALLBACK, or OIDC_HUMAN_CALLBACK must be specified for mechanism '${this.mechanism}'.`);
          }
          if (this.mechanismProperties.ALLOWED_HOSTS) {
            const hosts = this.mechanismProperties.ALLOWED_HOSTS;
            if (!Array.isArray(hosts)) {
              throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
            }
            for (const host of hosts) {
              if (typeof host !== "string") {
                throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
              }
            }
          }
        }
        if (providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(this.mechanism)) {
          if (this.source != null && this.source !== "$external") {
            throw new error_1.MongoAPIError(`Invalid source '${this.source}' for mechanism '${this.mechanism}' specified.`);
          }
        }
        if (this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN && this.source == null) {
          throw new error_1.MongoAPIError("PLAIN Authentication Mechanism needs an auth source");
        }
        if (this.mechanism === providers_1.AuthMechanism.MONGODB_X509 && this.password != null) {
          if (this.password === "") {
            Reflect.set(this, "password", void 0);
            return;
          }
          throw new error_1.MongoAPIError(`Password not allowed for mechanism MONGODB-X509`);
        }
        const canonicalization = this.mechanismProperties.CANONICALIZE_HOST_NAME ?? false;
        if (!Object.values(gssapi_1.GSSAPICanonicalizationValue).includes(canonicalization)) {
          throw new error_1.MongoAPIError(`Invalid CANONICALIZE_HOST_NAME value: ${canonicalization}`);
        }
      }
      static merge(creds, options2) {
        return new _MongoCredentials({
          username: options2.username ?? creds?.username ?? "",
          password: options2.password ?? creds?.password ?? "",
          mechanism: options2.mechanism ?? creds?.mechanism ?? providers_1.AuthMechanism.MONGODB_DEFAULT,
          mechanismProperties: options2.mechanismProperties ?? creds?.mechanismProperties ?? {},
          source: options2.source ?? options2.db ?? creds?.source ?? "admin"
        });
      }
    };
    exports2.MongoCredentials = MongoCredentials;
  }
});

// node_modules/mongodb-connection-string-url/node_modules/webidl-conversions/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/webidl-conversions/lib/index.js"(exports2) {
    "use strict";
    function makeException(ErrorType, message, options2) {
      if (options2.globals) {
        ErrorType = options2.globals[ErrorType.name];
      }
      return new ErrorType(`${options2.context ? options2.context : "Value"} ${message}.`);
    }
    function toNumber(value, options2) {
      if (typeof value === "bigint") {
        throw makeException(TypeError, "is a BigInt which cannot be converted to a number", options2);
      }
      if (!options2.globals) {
        return Number(value);
      }
      return options2.globals.Number(value);
    }
    function evenRound(x) {
      if (x > 0 && x % 1 === 0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {
        return censorNegativeZero(Math.floor(x));
      }
      return censorNegativeZero(Math.round(x));
    }
    function integerPart(n) {
      return censorNegativeZero(Math.trunc(n));
    }
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function modulo(x, y) {
      const signMightNotMatch = x % y;
      if (sign(y) !== sign(signMightNotMatch)) {
        return signMightNotMatch + y;
      }
      return signMightNotMatch;
    }
    function censorNegativeZero(x) {
      return x === 0 ? 0 : x;
    }
    function createIntegerConversion(bitLength, { unsigned }) {
      let lowerBound, upperBound;
      if (unsigned) {
        lowerBound = 0;
        upperBound = 2 ** bitLength - 1;
      } else {
        lowerBound = -(2 ** (bitLength - 1));
        upperBound = 2 ** (bitLength - 1) - 1;
      }
      const twoToTheBitLength = 2 ** bitLength;
      const twoToOneLessThanTheBitLength = 2 ** (bitLength - 1);
      return (value, options2 = {}) => {
        let x = toNumber(value, options2);
        x = censorNegativeZero(x);
        if (options2.enforceRange) {
          if (!Number.isFinite(x)) {
            throw makeException(TypeError, "is not a finite number", options2);
          }
          x = integerPart(x);
          if (x < lowerBound || x > upperBound) {
            throw makeException(
              TypeError,
              `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
              options2
            );
          }
          return x;
        }
        if (!Number.isNaN(x) && options2.clamp) {
          x = Math.min(Math.max(x, lowerBound), upperBound);
          x = evenRound(x);
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = integerPart(x);
        if (x >= lowerBound && x <= upperBound) {
          return x;
        }
        x = modulo(x, twoToTheBitLength);
        if (!unsigned && x >= twoToOneLessThanTheBitLength) {
          return x - twoToTheBitLength;
        }
        return x;
      };
    }
    function createLongLongConversion(bitLength, { unsigned }) {
      const upperBound = Number.MAX_SAFE_INTEGER;
      const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
      const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;
      return (value, options2 = {}) => {
        let x = toNumber(value, options2);
        x = censorNegativeZero(x);
        if (options2.enforceRange) {
          if (!Number.isFinite(x)) {
            throw makeException(TypeError, "is not a finite number", options2);
          }
          x = integerPart(x);
          if (x < lowerBound || x > upperBound) {
            throw makeException(
              TypeError,
              `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
              options2
            );
          }
          return x;
        }
        if (!Number.isNaN(x) && options2.clamp) {
          x = Math.min(Math.max(x, lowerBound), upperBound);
          x = evenRound(x);
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        let xBigInt = BigInt(integerPart(x));
        xBigInt = asBigIntN(bitLength, xBigInt);
        return Number(xBigInt);
      };
    }
    exports2.any = (value) => {
      return value;
    };
    exports2.undefined = () => {
      return void 0;
    };
    exports2.boolean = (value) => {
      return Boolean(value);
    };
    exports2.byte = createIntegerConversion(8, { unsigned: false });
    exports2.octet = createIntegerConversion(8, { unsigned: true });
    exports2.short = createIntegerConversion(16, { unsigned: false });
    exports2["unsigned short"] = createIntegerConversion(16, { unsigned: true });
    exports2.long = createIntegerConversion(32, { unsigned: false });
    exports2["unsigned long"] = createIntegerConversion(32, { unsigned: true });
    exports2["long long"] = createLongLongConversion(64, { unsigned: false });
    exports2["unsigned long long"] = createLongLongConversion(64, { unsigned: true });
    exports2.double = (value, options2 = {}) => {
      const x = toNumber(value, options2);
      if (!Number.isFinite(x)) {
        throw makeException(TypeError, "is not a finite floating-point value", options2);
      }
      return x;
    };
    exports2["unrestricted double"] = (value, options2 = {}) => {
      const x = toNumber(value, options2);
      return x;
    };
    exports2.float = (value, options2 = {}) => {
      const x = toNumber(value, options2);
      if (!Number.isFinite(x)) {
        throw makeException(TypeError, "is not a finite floating-point value", options2);
      }
      if (Object.is(x, -0)) {
        return x;
      }
      const y = Math.fround(x);
      if (!Number.isFinite(y)) {
        throw makeException(TypeError, "is outside the range of a single-precision floating-point value", options2);
      }
      return y;
    };
    exports2["unrestricted float"] = (value, options2 = {}) => {
      const x = toNumber(value, options2);
      if (isNaN(x)) {
        return x;
      }
      if (Object.is(x, -0)) {
        return x;
      }
      return Math.fround(x);
    };
    exports2.DOMString = (value, options2 = {}) => {
      if (options2.treatNullAsEmptyString && value === null) {
        return "";
      }
      if (typeof value === "symbol") {
        throw makeException(TypeError, "is a symbol, which cannot be converted to a string", options2);
      }
      const StringCtor = options2.globals ? options2.globals.String : String;
      return StringCtor(value);
    };
    exports2.ByteString = (value, options2 = {}) => {
      const x = exports2.DOMString(value, options2);
      let c;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw makeException(TypeError, "is not a valid ByteString", options2);
        }
      }
      return x;
    };
    exports2.USVString = (value, options2 = {}) => {
      const S = exports2.DOMString(value, options2);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else if (i === n - 1) {
          U.push(String.fromCodePoint(65533));
        } else {
          const d = S.charCodeAt(i + 1);
          if (56320 <= d && d <= 57343) {
            const a = c & 1023;
            const b = d & 1023;
            U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
            ++i;
          } else {
            U.push(String.fromCodePoint(65533));
          }
        }
      }
      return U.join("");
    };
    exports2.object = (value, options2 = {}) => {
      if (value === null || typeof value !== "object" && typeof value !== "function") {
        throw makeException(TypeError, "is not an object", options2);
      }
      return value;
    };
    var abByteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
    var sabByteLengthGetter = typeof SharedArrayBuffer === "function" ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get : null;
    function isNonSharedArrayBuffer(value) {
      try {
        abByteLengthGetter.call(value);
        return true;
      } catch {
        return false;
      }
    }
    function isSharedArrayBuffer(value) {
      try {
        sabByteLengthGetter.call(value);
        return true;
      } catch {
        return false;
      }
    }
    function isArrayBufferDetached(value) {
      try {
        new Uint8Array(value);
        return false;
      } catch {
        return true;
      }
    }
    exports2.ArrayBuffer = (value, options2 = {}) => {
      if (!isNonSharedArrayBuffer(value)) {
        if (options2.allowShared && !isSharedArrayBuffer(value)) {
          throw makeException(TypeError, "is not an ArrayBuffer or SharedArrayBuffer", options2);
        }
        throw makeException(TypeError, "is not an ArrayBuffer", options2);
      }
      if (isArrayBufferDetached(value)) {
        throw makeException(TypeError, "is a detached ArrayBuffer", options2);
      }
      return value;
    };
    var dvByteLengthGetter = Object.getOwnPropertyDescriptor(DataView.prototype, "byteLength").get;
    exports2.DataView = (value, options2 = {}) => {
      try {
        dvByteLengthGetter.call(value);
      } catch (e) {
        throw makeException(TypeError, "is not a DataView", options2);
      }
      if (!options2.allowShared && isSharedArrayBuffer(value.buffer)) {
        throw makeException(TypeError, "is backed by a SharedArrayBuffer, which is not allowed", options2);
      }
      if (isArrayBufferDetached(value.buffer)) {
        throw makeException(TypeError, "is backed by a detached ArrayBuffer", options2);
      }
      return value;
    };
    var typedArrayNameGetter = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(Uint8Array).prototype,
      Symbol.toStringTag
    ).get;
    [
      Int8Array,
      Int16Array,
      Int32Array,
      Uint8Array,
      Uint16Array,
      Uint32Array,
      Uint8ClampedArray,
      Float32Array,
      Float64Array
    ].forEach((func) => {
      const { name } = func;
      const article = /^[AEIOU]/u.test(name) ? "an" : "a";
      exports2[name] = (value, options2 = {}) => {
        if (!ArrayBuffer.isView(value) || typedArrayNameGetter.call(value) !== name) {
          throw makeException(TypeError, `is not ${article} ${name} object`, options2);
        }
        if (!options2.allowShared && isSharedArrayBuffer(value.buffer)) {
          throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options2);
        }
        if (isArrayBufferDetached(value.buffer)) {
          throw makeException(TypeError, "is a view on a detached ArrayBuffer", options2);
        }
        return value;
      };
    });
    exports2.ArrayBufferView = (value, options2 = {}) => {
      if (!ArrayBuffer.isView(value)) {
        throw makeException(TypeError, "is not a view on an ArrayBuffer or SharedArrayBuffer", options2);
      }
      if (!options2.allowShared && isSharedArrayBuffer(value.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options2);
      }
      if (isArrayBufferDetached(value.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", options2);
      }
      return value;
    };
    exports2.BufferSource = (value, options2 = {}) => {
      if (ArrayBuffer.isView(value)) {
        if (!options2.allowShared && isSharedArrayBuffer(value.buffer)) {
          throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options2);
        }
        if (isArrayBufferDetached(value.buffer)) {
          throw makeException(TypeError, "is a view on a detached ArrayBuffer", options2);
        }
        return value;
      }
      if (!options2.allowShared && !isNonSharedArrayBuffer(value)) {
        throw makeException(TypeError, "is not an ArrayBuffer or a view on one", options2);
      }
      if (options2.allowShared && !isSharedArrayBuffer(value) && !isNonSharedArrayBuffer(value)) {
        throw makeException(TypeError, "is not an ArrayBuffer, SharedArrayBuffer, or a view on one", options2);
      }
      if (isArrayBufferDetached(value)) {
        throw makeException(TypeError, "is a detached ArrayBuffer", options2);
      }
      return value;
    };
    exports2.DOMTimeStamp = exports2["unsigned long long"];
  }
});

// node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/utils.js
var require_utils6 = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/utils.js"(exports2, module2) {
    "use strict";
    function isObject(value) {
      return typeof value === "object" && value !== null || typeof value === "function";
    }
    var hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
    function define(target, source) {
      for (const key of Reflect.ownKeys(source)) {
        const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
        if (descriptor && !Reflect.defineProperty(target, key, descriptor)) {
          throw new TypeError(`Cannot redefine property: ${String(key)}`);
        }
      }
    }
    function newObjectInRealm(globalObject, object) {
      const ctorRegistry = initCtorRegistry(globalObject);
      return Object.defineProperties(
        Object.create(ctorRegistry["%Object.prototype%"]),
        Object.getOwnPropertyDescriptors(object)
      );
    }
    var wrapperSymbol = Symbol("wrapper");
    var implSymbol = Symbol("impl");
    var sameObjectCaches = Symbol("SameObject caches");
    var ctorRegistrySymbol = Symbol.for("[webidl2js] constructor registry");
    var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
    }).prototype);
    function initCtorRegistry(globalObject) {
      if (hasOwn(globalObject, ctorRegistrySymbol)) {
        return globalObject[ctorRegistrySymbol];
      }
      const ctorRegistry = /* @__PURE__ */ Object.create(null);
      ctorRegistry["%Object.prototype%"] = globalObject.Object.prototype;
      ctorRegistry["%IteratorPrototype%"] = Object.getPrototypeOf(
        Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]())
      );
      try {
        ctorRegistry["%AsyncIteratorPrototype%"] = Object.getPrototypeOf(
          Object.getPrototypeOf(
            globalObject.eval("(async function* () {})").prototype
          )
        );
      } catch {
        ctorRegistry["%AsyncIteratorPrototype%"] = AsyncIteratorPrototype;
      }
      globalObject[ctorRegistrySymbol] = ctorRegistry;
      return ctorRegistry;
    }
    function getSameObject(wrapper, prop, creator) {
      if (!wrapper[sameObjectCaches]) {
        wrapper[sameObjectCaches] = /* @__PURE__ */ Object.create(null);
      }
      if (prop in wrapper[sameObjectCaches]) {
        return wrapper[sameObjectCaches][prop];
      }
      wrapper[sameObjectCaches][prop] = creator();
      return wrapper[sameObjectCaches][prop];
    }
    function wrapperForImpl(impl) {
      return impl ? impl[wrapperSymbol] : null;
    }
    function implForWrapper(wrapper) {
      return wrapper ? wrapper[implSymbol] : null;
    }
    function tryWrapperForImpl(impl) {
      const wrapper = wrapperForImpl(impl);
      return wrapper ? wrapper : impl;
    }
    function tryImplForWrapper(wrapper) {
      const impl = implForWrapper(wrapper);
      return impl ? impl : wrapper;
    }
    var iterInternalSymbol = Symbol("internal");
    function isArrayIndexPropName(P) {
      if (typeof P !== "string") {
        return false;
      }
      const i = P >>> 0;
      if (i === 2 ** 32 - 1) {
        return false;
      }
      const s = `${i}`;
      if (P !== s) {
        return false;
      }
      return true;
    }
    var byteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
    function isArrayBuffer(value) {
      try {
        byteLengthGetter.call(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    function iteratorResult([key, value], kind) {
      let result;
      switch (kind) {
        case "key":
          result = key;
          break;
        case "value":
          result = value;
          break;
        case "key+value":
          result = [key, value];
          break;
      }
      return { value: result, done: false };
    }
    var supportsPropertyIndex = Symbol("supports property index");
    var supportedPropertyIndices = Symbol("supported property indices");
    var supportsPropertyName = Symbol("supports property name");
    var supportedPropertyNames = Symbol("supported property names");
    var indexedGet = Symbol("indexed property get");
    var indexedSetNew = Symbol("indexed property set new");
    var indexedSetExisting = Symbol("indexed property set existing");
    var namedGet = Symbol("named property get");
    var namedSetNew = Symbol("named property set new");
    var namedSetExisting = Symbol("named property set existing");
    var namedDelete = Symbol("named property delete");
    var asyncIteratorNext = Symbol("async iterator get the next iteration result");
    var asyncIteratorReturn = Symbol("async iterator return steps");
    var asyncIteratorInit = Symbol("async iterator initialization steps");
    var asyncIteratorEOI = Symbol("async iterator end of iteration");
    module2.exports = exports2 = {
      isObject,
      hasOwn,
      define,
      newObjectInRealm,
      wrapperSymbol,
      implSymbol,
      getSameObject,
      ctorRegistrySymbol,
      initCtorRegistry,
      wrapperForImpl,
      implForWrapper,
      tryWrapperForImpl,
      tryImplForWrapper,
      iterInternalSymbol,
      isArrayBuffer,
      isArrayIndexPropName,
      supportsPropertyIndex,
      supportedPropertyIndices,
      supportsPropertyName,
      supportedPropertyNames,
      indexedGet,
      indexedSetNew,
      indexedSetExisting,
      namedGet,
      namedSetNew,
      namedSetExisting,
      namedDelete,
      asyncIteratorNext,
      asyncIteratorReturn,
      asyncIteratorInit,
      asyncIteratorEOI,
      iteratorResult
    };
  }
});

// node_modules/punycode/punycode.es6.js
var punycode_es6_exports = {};
__export(punycode_es6_exports, {
  decode: () => decode,
  default: () => punycode_es6_default,
  encode: () => encode,
  toASCII: () => toASCII,
  toUnicode: () => toUnicode,
  ucs2decode: () => ucs2decode,
  ucs2encode: () => ucs2encode
});
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter, regexPunycode, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode, ucs2encode, basicToDigit, digitToBasic, adapt, decode, encode, toUnicode, toASCII, punycode, punycode_es6_default;
var init_punycode_es6 = __esm({
  "node_modules/punycode/punycode.es6.js"() {
    "use strict";
    maxInt = 2147483647;
    base = 36;
    tMin = 1;
    tMax = 26;
    skew = 38;
    damp = 700;
    initialBias = 72;
    initialN = 128;
    delimiter = "-";
    regexPunycode = /^xn--/;
    regexNonASCII = /[^\0-\x7F]/;
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    baseMinusTMin = base - tMin;
    floor = Math.floor;
    stringFromCharCode = String.fromCharCode;
    ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
    basicToDigit = function(codePoint) {
      if (codePoint >= 48 && codePoint < 58) {
        return 26 + (codePoint - 48);
      }
      if (codePoint >= 65 && codePoint < 91) {
        return codePoint - 65;
      }
      if (codePoint >= 97 && codePoint < 123) {
        return codePoint - 97;
      }
      return base;
    };
    digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    adapt = function(delta, numPoints, firstTime) {
      let k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    decode = function(input) {
      const output = [];
      const inputLength = input.length;
      let i = 0;
      let n = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        const oldi = i;
        for (let w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base) {
            error("invalid-input");
          }
          if (digit > floor((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          const baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint(...output);
    };
    encode = function(input) {
      const output = [];
      input = ucs2decode(input);
      const inputLength = input.length;
      let n = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      const basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of input) {
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue === n) {
            let q = delta;
            for (let k = base; ; k += base) {
              const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              const qMinusT = q - t;
              const baseMinusT = base - t;
              output.push(
                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
              );
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    toUnicode = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    toASCII = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    punycode = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.3.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    punycode_es6_default = punycode;
  }
});

// node_modules/mongodb-connection-string-url/node_modules/tr46/lib/regexes.js
var require_regexes = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/tr46/lib/regexes.js"(exports2, module2) {
    "use strict";
    var combiningMarks = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113B8}-\u{113C0}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}-\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{11F5A}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]/u;
    var combiningClassVirama = /[\u094D\u09CD\u0A4D\u0ACD\u0B4D\u0BCD\u0C4D\u0CCD\u0D3B\u0D3C\u0D4D\u0DCA\u0E3A\u0EBA\u0F84\u1039\u103A\u1714\u1715\u1734\u17D2\u1A60\u1B44\u1BAA\u1BAB\u1BF2\u1BF3\u2D7F\uA806\uA82C\uA8C4\uA953\uA9C0\uAAF6\uABED\u{10A3F}\u{11046}\u{11070}\u{1107F}\u{110B9}\u{11133}\u{11134}\u{111C0}\u{11235}\u{112EA}\u{1134D}\u{113CE}-\u{113D0}\u{11442}\u{114C2}\u{115BF}\u{1163F}\u{116B6}\u{1172B}\u{11839}\u{1193D}\u{1193E}\u{119E0}\u{11A34}\u{11A47}\u{11A99}\u{11C3F}\u{11D44}\u{11D45}\u{11D97}\u{11F41}\u{11F42}\u{1612F}]/u;
    var validZWNJ = /[\u0620\u0626\u0628\u062A-\u062E\u0633-\u063F\u0641-\u0647\u0649\u064A\u066E\u066F\u0678-\u0687\u069A-\u06BF\u06C1\u06C2\u06CC\u06CE\u06D0\u06D1\u06FA-\u06FC\u06FF\u0712-\u0714\u071A-\u071D\u071F-\u0727\u0729\u072B\u072D\u072E\u074E-\u0758\u075C-\u076A\u076D-\u0770\u0772\u0775-\u0777\u077A-\u077F\u07CA-\u07EA\u0841-\u0845\u0848\u084A-\u0853\u0855\u0860\u0862-\u0865\u0868\u0886\u0889-\u088D\u08A0-\u08A9\u08AF\u08B0\u08B3-\u08B8\u08BA-\u08C8\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA872\u{10AC0}-\u{10AC4}\u{10ACD}\u{10AD3}-\u{10ADC}\u{10ADE}-\u{10AE0}\u{10AEB}-\u{10AEE}\u{10B80}\u{10B82}\u{10B86}-\u{10B88}\u{10B8A}\u{10B8B}\u{10B8D}\u{10B90}\u{10BAD}\u{10BAE}\u{10D00}-\u{10D21}\u{10D23}\u{10EC3}\u{10EC4}\u{10F30}-\u{10F32}\u{10F34}-\u{10F44}\u{10F51}-\u{10F53}\u{10F70}-\u{10F73}\u{10F76}-\u{10F81}\u{10FB0}\u{10FB2}\u{10FB3}\u{10FB8}\u{10FBB}\u{10FBC}\u{10FBE}\u{10FBF}\u{10FC1}\u{10FC4}\u{10FCA}\u{10FCB}\u{1E900}-\u{1E943}][\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13430}-\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*\u200C[\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13430}-\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*[\u0620\u0622-\u063F\u0641-\u064A\u066E\u066F\u0671-\u0673\u0675-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u077F\u07CA-\u07EA\u0840-\u0858\u0860\u0862-\u0865\u0867-\u086A\u0870-\u0882\u0886\u0889-\u088E\u08A0-\u08AC\u08AE-\u08C8\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA871\u{10AC0}-\u{10AC5}\u{10AC7}\u{10AC9}\u{10ACA}\u{10ACE}-\u{10AD6}\u{10AD8}-\u{10AE1}\u{10AE4}\u{10AEB}-\u{10AEF}\u{10B80}-\u{10B91}\u{10BA9}-\u{10BAE}\u{10D01}-\u{10D23}\u{10EC2}-\u{10EC4}\u{10F30}-\u{10F44}\u{10F51}-\u{10F54}\u{10F70}-\u{10F81}\u{10FB0}\u{10FB2}-\u{10FB6}\u{10FB8}-\u{10FBF}\u{10FC1}-\u{10FC4}\u{10FC9}\u{10FCA}\u{1E900}-\u{1E943}]/u;
    var bidiDomain = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10D40}-\u{10D65}\u{10D6F}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
    var bidiS1LTR = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B4E-\u1B6A\u1B74-\u1B7F\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{105C0}-\u{105F3}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11380}-\u{11389}\u{1138B}\u{1138E}\u{11390}-\u{113B5}\u{113B7}-\u{113BA}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}\u{113CD}\u{113CF}\u{113D1}\u{113D3}-\u{113D5}\u{113D7}\u{113D8}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{116D0}-\u{116E3}\u{11700}-\u{1171A}\u{1171E}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11BC0}-\u{11BE1}\u{11BF0}-\u{11BF9}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{13460}-\u{143FA}\u{14400}-\u{14646}\u{16100}-\u{1611D}\u{1612A}-\u{1612C}\u{16130}-\u{16139}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16D40}-\u{16D79}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18CFF}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CCD6}-\u{1CCEF}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6C0}\u{1D6C2}-\u{1D6DA}\u{1D6DC}-\u{1D6FA}\u{1D6FC}-\u{1D714}\u{1D716}-\u{1D734}\u{1D736}-\u{1D74E}\u{1D750}-\u{1D76E}\u{1D770}-\u{1D788}\u{1D78A}-\u{1D7A8}\u{1D7AA}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D800}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E5D0}-\u{1E5ED}\u{1E5F0}-\u{1E5FA}\u{1E5FF}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]/u;
    var bidiS1RTL = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D4A}-\u{10D65}\u{10D6F}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
    var bidiS2 = /^[\0-\x08\x0E-\x1B!-@\[-`\{-\x84\x86-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02B9\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u036F\u0374\u0375\u037E\u0384\u0385\u0387\u03F6\u0483-\u0489\u058A\u058D-\u058F\u0591-\u05C7\u05D0-\u05EA\u05EF-\u05F4\u0600-\u070D\u070F-\u074A\u074D-\u07B1\u07C0-\u07FA\u07FD-\u082D\u0830-\u083E\u0840-\u085B\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u0897-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09F2\u09F3\u09FB\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AF1\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0BF3-\u0BFA\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C78-\u0C7E\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E3F\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39-\u0F3D\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1390-\u1399\u1400\u169B\u169C\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DB\u17DD\u17F0-\u17F9\u1800-\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1940\u1944\u1945\u19DE-\u19FF\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u200B-\u200D\u200F-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20C0\u20D0-\u20F0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u218B\u2190-\u2335\u237B-\u2394\u2396-\u2429\u2440-\u244A\u2460-\u249B\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF9-\u2CFF\u2D7F\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3001-\u3004\u3008-\u3020\u302A-\u302D\u3030\u3036\u3037\u303D-\u303F\u3099-\u309C\u30A0\u30FB\u31C0-\u31E5\u31EF\u321D\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA66F-\uA67F\uA69E\uA69F\uA6F0\uA6F1\uA700-\uA721\uA788\uA802\uA806\uA80B\uA825\uA826\uA828-\uA82C\uA838\uA839\uA874-\uA877\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uAB6A\uAB6B\uABE5\uABE8\uABED\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD8F\uFD92-\uFDC7\uFDCF\uFDF0-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFE70-\uFE74\uFE76-\uFEFC\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10101}\u{10140}-\u{1018C}\u{10190}-\u{1019C}\u{101A0}\u{101FD}\u{102E0}-\u{102FB}\u{10376}-\u{1037A}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{1091F}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A38}-\u{10A3A}\u{10A3F}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE6}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B39}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D27}\u{10D30}-\u{10D39}\u{10D40}-\u{10D65}\u{10D69}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAB}-\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10EFC}-\u{10F27}\u{10F30}-\u{10F59}\u{10F70}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{11001}\u{11038}-\u{11046}\u{11052}-\u{11065}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{11660}-\u{1166C}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{11FD5}-\u{11FF1}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE2}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CC00}-\u{1CCD5}\u{1CCF0}-\u{1CCF9}\u{1CD00}-\u{1CEB3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D1E9}\u{1D1EA}\u{1D200}-\u{1D245}\u{1D300}-\u{1D356}\u{1D6C1}\u{1D6DB}\u{1D6FB}\u{1D715}\u{1D735}\u{1D74F}\u{1D76F}\u{1D789}\u{1D7A9}\u{1D7C3}\u{1D7CE}-\u{1D7FF}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E2FF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8D6}\u{1E900}-\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F10F}\u{1F12F}\u{1F16A}-\u{1F16F}\u{1F1AD}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}-\u{1F8BB}\u{1F8C0}\u{1F8C1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA89}\u{1FA8F}-\u{1FAC6}\u{1FACE}-\u{1FADC}\u{1FADF}-\u{1FAE9}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBF9}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*$/u;
    var bidiS3 = /[0-9\xB2\xB3\xB9\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\u{102E1}-\u{102FB}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10D40}-\u{10D65}\u{10D6F}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1CCF0}-\u{1CCF9}\u{1D7CE}-\u{1D7FF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
    var bidiS4EN = /[0-9\xB2\xB3\xB9\u06F0-\u06F9\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFF10-\uFF19\u{102E1}-\u{102FB}\u{1CCF0}-\u{1CCF9}\u{1D7CE}-\u{1D7FF}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}]/u;
    var bidiS4AN = /[\u0600-\u0605\u0660-\u0669\u066B\u066C\u06DD\u0890\u0891\u08E2\u{10D30}-\u{10D39}\u{10D40}-\u{10D49}\u{10E60}-\u{10E7E}]/u;
    var bidiS5 = /^[\0-\x08\x0E-\x1B!-\x84\x86-\u0377\u037A-\u037F\u0384-\u038A\u038C\u038E-\u03A1\u03A3-\u052F\u0531-\u0556\u0559-\u058A\u058D-\u058F\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0606\u0607\u0609\u060A\u060C\u060E-\u061A\u064B-\u065F\u066A\u0670\u06D6-\u06DC\u06DE-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07F6-\u07F9\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A76\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C77-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E3A\u0E3F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FDA\u1000-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u13A0-\u13F5\u13F8-\u13FD\u1400-\u167F\u1681-\u169C\u16A0-\u16F8\u1700-\u1715\u171F-\u1736\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u1800-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE-\u1A1B\u1A1E-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1AB0-\u1ACE\u1B00-\u1B4C\u1B4E-\u1BF3\u1BFC-\u1C37\u1C3B-\u1C49\u1C4D-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD0-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u200B-\u200E\u2010-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2071\u2074-\u208E\u2090-\u209C\u20A0-\u20C0\u20D0-\u20F0\u2100-\u218B\u2190-\u2429\u2440-\u244A\u2460-\u2B73\u2B76-\u2B95\u2B97-\u2CF3\u2CF9-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3001-\u303F\u3041-\u3096\u3099-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31E5\u31EF-\u321E\u3220-\uA48C\uA490-\uA4C6\uA4D0-\uA62B\uA640-\uA6F7\uA700-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA82C\uA830-\uA839\uA840-\uA877\uA880-\uA8C5\uA8CE-\uA8D9\uA8E0-\uA953\uA95F-\uA97C\uA980-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAAC2\uAADB-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB6B\uAB70-\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1E\uFB29\uFD3E-\uFD4F\uFDCF\uFDFD-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}-\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1018E}\u{10190}-\u{1019C}\u{101A0}\u{101D0}-\u{101FD}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E0}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{1037A}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{105C0}-\u{105F3}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{1091F}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10B39}-\u{10B3F}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6E}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{1104D}\u{11052}-\u{11075}\u{1107F}-\u{110C2}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11100}-\u{11134}\u{11136}-\u{11147}\u{11150}-\u{11176}\u{11180}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{11241}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112EA}\u{112F0}-\u{112F9}\u{11300}-\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133B}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11380}-\u{11389}\u{1138B}\u{1138E}\u{11390}-\u{113B5}\u{113B7}-\u{113C0}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}-\u{113D5}\u{113D7}\u{113D8}\u{113E1}\u{113E2}\u{11400}-\u{1145B}\u{1145D}-\u{11461}\u{11480}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B5}\u{115B8}-\u{115DD}\u{11600}-\u{11644}\u{11650}-\u{11659}\u{11660}-\u{1166C}\u{11680}-\u{116B9}\u{116C0}-\u{116C9}\u{116D0}-\u{116E3}\u{11700}-\u{1171A}\u{1171D}-\u{1172B}\u{11730}-\u{11746}\u{11800}-\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D7}\u{119DA}-\u{119E4}\u{11A00}-\u{11A47}\u{11A50}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11BC0}-\u{11BE1}\u{11BF0}-\u{11BF9}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C36}\u{11C38}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D47}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF8}\u{11F00}-\u{11F10}\u{11F12}-\u{11F3A}\u{11F3E}-\u{11F5A}\u{11FB0}\u{11FC0}-\u{11FF1}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{13455}\u{13460}-\u{143FA}\u{14400}-\u{14646}\u{16100}-\u{16139}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF0}-\u{16AF5}\u{16B00}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16D40}-\u{16D79}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F4F}-\u{16F87}\u{16F8F}-\u{16F9F}\u{16FE0}-\u{16FE4}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18CFF}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}-\u{1BCA3}\u{1CC00}-\u{1CCF9}\u{1CD00}-\u{1CEB3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D1EA}\u{1D200}-\u{1D245}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D300}-\u{1D356}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D7CB}\u{1D7CE}-\u{1DA8B}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E030}-\u{1E06D}\u{1E08F}\u{1E100}-\u{1E12C}\u{1E130}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AE}\u{1E2C0}-\u{1E2F9}\u{1E2FF}\u{1E4D0}-\u{1E4F9}\u{1E5D0}-\u{1E5FA}\u{1E5FF}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F1AD}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}-\u{1F8BB}\u{1F8C0}\u{1F8C1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA89}\u{1FA8F}-\u{1FAC6}\u{1FACE}-\u{1FADC}\u{1FADF}-\u{1FAE9}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]*$/u;
    var bidiS6 = /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u06F0-\u06F9\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B4E-\u1B6A\u1B74-\u1B7F\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u2488-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E1}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{105C0}-\u{105F3}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11380}-\u{11389}\u{1138B}\u{1138E}\u{11390}-\u{113B5}\u{113B7}-\u{113BA}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}\u{113CD}\u{113CF}\u{113D1}\u{113D3}-\u{113D5}\u{113D7}\u{113D8}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{116D0}-\u{116E3}\u{11700}-\u{1171A}\u{1171E}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11BC0}-\u{11BE1}\u{11BF0}-\u{11BF9}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{13460}-\u{143FA}\u{14400}-\u{14646}\u{16100}-\u{1611D}\u{1612A}-\u{1612C}\u{16130}-\u{16139}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16D40}-\u{16D79}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18CFF}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CCD6}-\u{1CCF9}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6C0}\u{1D6C2}-\u{1D6DA}\u{1D6DC}-\u{1D6FA}\u{1D6FC}-\u{1D714}\u{1D716}-\u{1D734}\u{1D736}-\u{1D74E}\u{1D750}-\u{1D76E}\u{1D770}-\u{1D788}\u{1D78A}-\u{1D7A8}\u{1D7AA}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D7CE}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E5D0}-\u{1E5ED}\u{1E5F0}-\u{1E5FA}\u{1E5FF}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F100}-\u{1F10A}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
    module2.exports = {
      combiningMarks,
      combiningClassVirama,
      validZWNJ,
      bidiDomain,
      bidiS1LTR,
      bidiS1RTL,
      bidiS2,
      bidiS3,
      bidiS4EN,
      bidiS4AN,
      bidiS5,
      bidiS6
    };
  }
});

// node_modules/mongodb-connection-string-url/node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/tr46/lib/mappingTable.json"(exports2, module2) {
    module2.exports = [[[0, 44], 2], [[45, 46], 2], [47, 2], [[48, 57], 2], [[58, 64], 2], [65, 1, "a"], [66, 1, "b"], [67, 1, "c"], [68, 1, "d"], [69, 1, "e"], [70, 1, "f"], [71, 1, "g"], [72, 1, "h"], [73, 1, "i"], [74, 1, "j"], [75, 1, "k"], [76, 1, "l"], [77, 1, "m"], [78, 1, "n"], [79, 1, "o"], [80, 1, "p"], [81, 1, "q"], [82, 1, "r"], [83, 1, "s"], [84, 1, "t"], [85, 1, "u"], [86, 1, "v"], [87, 1, "w"], [88, 1, "x"], [89, 1, "y"], [90, 1, "z"], [[91, 96], 2], [[97, 122], 2], [[123, 127], 2], [[128, 159], 3], [160, 1, " "], [[161, 167], 2], [168, 1, " \u0308"], [169, 2], [170, 1, "a"], [[171, 172], 2], [173, 7], [174, 2], [175, 1, " \u0304"], [[176, 177], 2], [178, 1, "2"], [179, 1, "3"], [180, 1, " \u0301"], [181, 1, "\u03BC"], [182, 2], [183, 2], [184, 1, " \u0327"], [185, 1, "1"], [186, 1, "o"], [187, 2], [188, 1, "1\u20444"], [189, 1, "1\u20442"], [190, 1, "3\u20444"], [191, 2], [192, 1, "\xE0"], [193, 1, "\xE1"], [194, 1, "\xE2"], [195, 1, "\xE3"], [196, 1, "\xE4"], [197, 1, "\xE5"], [198, 1, "\xE6"], [199, 1, "\xE7"], [200, 1, "\xE8"], [201, 1, "\xE9"], [202, 1, "\xEA"], [203, 1, "\xEB"], [204, 1, "\xEC"], [205, 1, "\xED"], [206, 1, "\xEE"], [207, 1, "\xEF"], [208, 1, "\xF0"], [209, 1, "\xF1"], [210, 1, "\xF2"], [211, 1, "\xF3"], [212, 1, "\xF4"], [213, 1, "\xF5"], [214, 1, "\xF6"], [215, 2], [216, 1, "\xF8"], [217, 1, "\xF9"], [218, 1, "\xFA"], [219, 1, "\xFB"], [220, 1, "\xFC"], [221, 1, "\xFD"], [222, 1, "\xFE"], [223, 6, "ss"], [[224, 246], 2], [247, 2], [[248, 255], 2], [256, 1, "\u0101"], [257, 2], [258, 1, "\u0103"], [259, 2], [260, 1, "\u0105"], [261, 2], [262, 1, "\u0107"], [263, 2], [264, 1, "\u0109"], [265, 2], [266, 1, "\u010B"], [267, 2], [268, 1, "\u010D"], [269, 2], [270, 1, "\u010F"], [271, 2], [272, 1, "\u0111"], [273, 2], [274, 1, "\u0113"], [275, 2], [276, 1, "\u0115"], [277, 2], [278, 1, "\u0117"], [279, 2], [280, 1, "\u0119"], [281, 2], [282, 1, "\u011B"], [283, 2], [284, 1, "\u011D"], [285, 2], [286, 1, "\u011F"], [287, 2], [288, 1, "\u0121"], [289, 2], [290, 1, "\u0123"], [291, 2], [292, 1, "\u0125"], [293, 2], [294, 1, "\u0127"], [295, 2], [296, 1, "\u0129"], [297, 2], [298, 1, "\u012B"], [299, 2], [300, 1, "\u012D"], [301, 2], [302, 1, "\u012F"], [303, 2], [304, 1, "i\u0307"], [305, 2], [[306, 307], 1, "ij"], [308, 1, "\u0135"], [309, 2], [310, 1, "\u0137"], [[311, 312], 2], [313, 1, "\u013A"], [314, 2], [315, 1, "\u013C"], [316, 2], [317, 1, "\u013E"], [318, 2], [[319, 320], 1, "l\xB7"], [321, 1, "\u0142"], [322, 2], [323, 1, "\u0144"], [324, 2], [325, 1, "\u0146"], [326, 2], [327, 1, "\u0148"], [328, 2], [329, 1, "\u02BCn"], [330, 1, "\u014B"], [331, 2], [332, 1, "\u014D"], [333, 2], [334, 1, "\u014F"], [335, 2], [336, 1, "\u0151"], [337, 2], [338, 1, "\u0153"], [339, 2], [340, 1, "\u0155"], [341, 2], [342, 1, "\u0157"], [343, 2], [344, 1, "\u0159"], [345, 2], [346, 1, "\u015B"], [347, 2], [348, 1, "\u015D"], [349, 2], [350, 1, "\u015F"], [351, 2], [352, 1, "\u0161"], [353, 2], [354, 1, "\u0163"], [355, 2], [356, 1, "\u0165"], [357, 2], [358, 1, "\u0167"], [359, 2], [360, 1, "\u0169"], [361, 2], [362, 1, "\u016B"], [363, 2], [364, 1, "\u016D"], [365, 2], [366, 1, "\u016F"], [367, 2], [368, 1, "\u0171"], [369, 2], [370, 1, "\u0173"], [371, 2], [372, 1, "\u0175"], [373, 2], [374, 1, "\u0177"], [375, 2], [376, 1, "\xFF"], [377, 1, "\u017A"], [378, 2], [379, 1, "\u017C"], [380, 2], [381, 1, "\u017E"], [382, 2], [383, 1, "s"], [384, 2], [385, 1, "\u0253"], [386, 1, "\u0183"], [387, 2], [388, 1, "\u0185"], [389, 2], [390, 1, "\u0254"], [391, 1, "\u0188"], [392, 2], [393, 1, "\u0256"], [394, 1, "\u0257"], [395, 1, "\u018C"], [[396, 397], 2], [398, 1, "\u01DD"], [399, 1, "\u0259"], [400, 1, "\u025B"], [401, 1, "\u0192"], [402, 2], [403, 1, "\u0260"], [404, 1, "\u0263"], [405, 2], [406, 1, "\u0269"], [407, 1, "\u0268"], [408, 1, "\u0199"], [[409, 411], 2], [412, 1, "\u026F"], [413, 1, "\u0272"], [414, 2], [415, 1, "\u0275"], [416, 1, "\u01A1"], [417, 2], [418, 1, "\u01A3"], [419, 2], [420, 1, "\u01A5"], [421, 2], [422, 1, "\u0280"], [423, 1, "\u01A8"], [424, 2], [425, 1, "\u0283"], [[426, 427], 2], [428, 1, "\u01AD"], [429, 2], [430, 1, "\u0288"], [431, 1, "\u01B0"], [432, 2], [433, 1, "\u028A"], [434, 1, "\u028B"], [435, 1, "\u01B4"], [436, 2], [437, 1, "\u01B6"], [438, 2], [439, 1, "\u0292"], [440, 1, "\u01B9"], [[441, 443], 2], [444, 1, "\u01BD"], [[445, 451], 2], [[452, 454], 1, "d\u017E"], [[455, 457], 1, "lj"], [[458, 460], 1, "nj"], [461, 1, "\u01CE"], [462, 2], [463, 1, "\u01D0"], [464, 2], [465, 1, "\u01D2"], [466, 2], [467, 1, "\u01D4"], [468, 2], [469, 1, "\u01D6"], [470, 2], [471, 1, "\u01D8"], [472, 2], [473, 1, "\u01DA"], [474, 2], [475, 1, "\u01DC"], [[476, 477], 2], [478, 1, "\u01DF"], [479, 2], [480, 1, "\u01E1"], [481, 2], [482, 1, "\u01E3"], [483, 2], [484, 1, "\u01E5"], [485, 2], [486, 1, "\u01E7"], [487, 2], [488, 1, "\u01E9"], [489, 2], [490, 1, "\u01EB"], [491, 2], [492, 1, "\u01ED"], [493, 2], [494, 1, "\u01EF"], [[495, 496], 2], [[497, 499], 1, "dz"], [500, 1, "\u01F5"], [501, 2], [502, 1, "\u0195"], [503, 1, "\u01BF"], [504, 1, "\u01F9"], [505, 2], [506, 1, "\u01FB"], [507, 2], [508, 1, "\u01FD"], [509, 2], [510, 1, "\u01FF"], [511, 2], [512, 1, "\u0201"], [513, 2], [514, 1, "\u0203"], [515, 2], [516, 1, "\u0205"], [517, 2], [518, 1, "\u0207"], [519, 2], [520, 1, "\u0209"], [521, 2], [522, 1, "\u020B"], [523, 2], [524, 1, "\u020D"], [525, 2], [526, 1, "\u020F"], [527, 2], [528, 1, "\u0211"], [529, 2], [530, 1, "\u0213"], [531, 2], [532, 1, "\u0215"], [533, 2], [534, 1, "\u0217"], [535, 2], [536, 1, "\u0219"], [537, 2], [538, 1, "\u021B"], [539, 2], [540, 1, "\u021D"], [541, 2], [542, 1, "\u021F"], [543, 2], [544, 1, "\u019E"], [545, 2], [546, 1, "\u0223"], [547, 2], [548, 1, "\u0225"], [549, 2], [550, 1, "\u0227"], [551, 2], [552, 1, "\u0229"], [553, 2], [554, 1, "\u022B"], [555, 2], [556, 1, "\u022D"], [557, 2], [558, 1, "\u022F"], [559, 2], [560, 1, "\u0231"], [561, 2], [562, 1, "\u0233"], [563, 2], [[564, 566], 2], [[567, 569], 2], [570, 1, "\u2C65"], [571, 1, "\u023C"], [572, 2], [573, 1, "\u019A"], [574, 1, "\u2C66"], [[575, 576], 2], [577, 1, "\u0242"], [578, 2], [579, 1, "\u0180"], [580, 1, "\u0289"], [581, 1, "\u028C"], [582, 1, "\u0247"], [583, 2], [584, 1, "\u0249"], [585, 2], [586, 1, "\u024B"], [587, 2], [588, 1, "\u024D"], [589, 2], [590, 1, "\u024F"], [591, 2], [[592, 680], 2], [[681, 685], 2], [[686, 687], 2], [688, 1, "h"], [689, 1, "\u0266"], [690, 1, "j"], [691, 1, "r"], [692, 1, "\u0279"], [693, 1, "\u027B"], [694, 1, "\u0281"], [695, 1, "w"], [696, 1, "y"], [[697, 705], 2], [[706, 709], 2], [[710, 721], 2], [[722, 727], 2], [728, 1, " \u0306"], [729, 1, " \u0307"], [730, 1, " \u030A"], [731, 1, " \u0328"], [732, 1, " \u0303"], [733, 1, " \u030B"], [734, 2], [735, 2], [736, 1, "\u0263"], [737, 1, "l"], [738, 1, "s"], [739, 1, "x"], [740, 1, "\u0295"], [[741, 745], 2], [[746, 747], 2], [748, 2], [749, 2], [750, 2], [[751, 767], 2], [[768, 831], 2], [832, 1, "\u0300"], [833, 1, "\u0301"], [834, 2], [835, 1, "\u0313"], [836, 1, "\u0308\u0301"], [837, 1, "\u03B9"], [[838, 846], 2], [847, 7], [[848, 855], 2], [[856, 860], 2], [[861, 863], 2], [[864, 865], 2], [866, 2], [[867, 879], 2], [880, 1, "\u0371"], [881, 2], [882, 1, "\u0373"], [883, 2], [884, 1, "\u02B9"], [885, 2], [886, 1, "\u0377"], [887, 2], [[888, 889], 3], [890, 1, " \u03B9"], [[891, 893], 2], [894, 1, ";"], [895, 1, "\u03F3"], [[896, 899], 3], [900, 1, " \u0301"], [901, 1, " \u0308\u0301"], [902, 1, "\u03AC"], [903, 1, "\xB7"], [904, 1, "\u03AD"], [905, 1, "\u03AE"], [906, 1, "\u03AF"], [907, 3], [908, 1, "\u03CC"], [909, 3], [910, 1, "\u03CD"], [911, 1, "\u03CE"], [912, 2], [913, 1, "\u03B1"], [914, 1, "\u03B2"], [915, 1, "\u03B3"], [916, 1, "\u03B4"], [917, 1, "\u03B5"], [918, 1, "\u03B6"], [919, 1, "\u03B7"], [920, 1, "\u03B8"], [921, 1, "\u03B9"], [922, 1, "\u03BA"], [923, 1, "\u03BB"], [924, 1, "\u03BC"], [925, 1, "\u03BD"], [926, 1, "\u03BE"], [927, 1, "\u03BF"], [928, 1, "\u03C0"], [929, 1, "\u03C1"], [930, 3], [931, 1, "\u03C3"], [932, 1, "\u03C4"], [933, 1, "\u03C5"], [934, 1, "\u03C6"], [935, 1, "\u03C7"], [936, 1, "\u03C8"], [937, 1, "\u03C9"], [938, 1, "\u03CA"], [939, 1, "\u03CB"], [[940, 961], 2], [962, 6, "\u03C3"], [[963, 974], 2], [975, 1, "\u03D7"], [976, 1, "\u03B2"], [977, 1, "\u03B8"], [978, 1, "\u03C5"], [979, 1, "\u03CD"], [980, 1, "\u03CB"], [981, 1, "\u03C6"], [982, 1, "\u03C0"], [983, 2], [984, 1, "\u03D9"], [985, 2], [986, 1, "\u03DB"], [987, 2], [988, 1, "\u03DD"], [989, 2], [990, 1, "\u03DF"], [991, 2], [992, 1, "\u03E1"], [993, 2], [994, 1, "\u03E3"], [995, 2], [996, 1, "\u03E5"], [997, 2], [998, 1, "\u03E7"], [999, 2], [1e3, 1, "\u03E9"], [1001, 2], [1002, 1, "\u03EB"], [1003, 2], [1004, 1, "\u03ED"], [1005, 2], [1006, 1, "\u03EF"], [1007, 2], [1008, 1, "\u03BA"], [1009, 1, "\u03C1"], [1010, 1, "\u03C3"], [1011, 2], [1012, 1, "\u03B8"], [1013, 1, "\u03B5"], [1014, 2], [1015, 1, "\u03F8"], [1016, 2], [1017, 1, "\u03C3"], [1018, 1, "\u03FB"], [1019, 2], [1020, 2], [1021, 1, "\u037B"], [1022, 1, "\u037C"], [1023, 1, "\u037D"], [1024, 1, "\u0450"], [1025, 1, "\u0451"], [1026, 1, "\u0452"], [1027, 1, "\u0453"], [1028, 1, "\u0454"], [1029, 1, "\u0455"], [1030, 1, "\u0456"], [1031, 1, "\u0457"], [1032, 1, "\u0458"], [1033, 1, "\u0459"], [1034, 1, "\u045A"], [1035, 1, "\u045B"], [1036, 1, "\u045C"], [1037, 1, "\u045D"], [1038, 1, "\u045E"], [1039, 1, "\u045F"], [1040, 1, "\u0430"], [1041, 1, "\u0431"], [1042, 1, "\u0432"], [1043, 1, "\u0433"], [1044, 1, "\u0434"], [1045, 1, "\u0435"], [1046, 1, "\u0436"], [1047, 1, "\u0437"], [1048, 1, "\u0438"], [1049, 1, "\u0439"], [1050, 1, "\u043A"], [1051, 1, "\u043B"], [1052, 1, "\u043C"], [1053, 1, "\u043D"], [1054, 1, "\u043E"], [1055, 1, "\u043F"], [1056, 1, "\u0440"], [1057, 1, "\u0441"], [1058, 1, "\u0442"], [1059, 1, "\u0443"], [1060, 1, "\u0444"], [1061, 1, "\u0445"], [1062, 1, "\u0446"], [1063, 1, "\u0447"], [1064, 1, "\u0448"], [1065, 1, "\u0449"], [1066, 1, "\u044A"], [1067, 1, "\u044B"], [1068, 1, "\u044C"], [1069, 1, "\u044D"], [1070, 1, "\u044E"], [1071, 1, "\u044F"], [[1072, 1103], 2], [1104, 2], [[1105, 1116], 2], [1117, 2], [[1118, 1119], 2], [1120, 1, "\u0461"], [1121, 2], [1122, 1, "\u0463"], [1123, 2], [1124, 1, "\u0465"], [1125, 2], [1126, 1, "\u0467"], [1127, 2], [1128, 1, "\u0469"], [1129, 2], [1130, 1, "\u046B"], [1131, 2], [1132, 1, "\u046D"], [1133, 2], [1134, 1, "\u046F"], [1135, 2], [1136, 1, "\u0471"], [1137, 2], [1138, 1, "\u0473"], [1139, 2], [1140, 1, "\u0475"], [1141, 2], [1142, 1, "\u0477"], [1143, 2], [1144, 1, "\u0479"], [1145, 2], [1146, 1, "\u047B"], [1147, 2], [1148, 1, "\u047D"], [1149, 2], [1150, 1, "\u047F"], [1151, 2], [1152, 1, "\u0481"], [1153, 2], [1154, 2], [[1155, 1158], 2], [1159, 2], [[1160, 1161], 2], [1162, 1, "\u048B"], [1163, 2], [1164, 1, "\u048D"], [1165, 2], [1166, 1, "\u048F"], [1167, 2], [1168, 1, "\u0491"], [1169, 2], [1170, 1, "\u0493"], [1171, 2], [1172, 1, "\u0495"], [1173, 2], [1174, 1, "\u0497"], [1175, 2], [1176, 1, "\u0499"], [1177, 2], [1178, 1, "\u049B"], [1179, 2], [1180, 1, "\u049D"], [1181, 2], [1182, 1, "\u049F"], [1183, 2], [1184, 1, "\u04A1"], [1185, 2], [1186, 1, "\u04A3"], [1187, 2], [1188, 1, "\u04A5"], [1189, 2], [1190, 1, "\u04A7"], [1191, 2], [1192, 1, "\u04A9"], [1193, 2], [1194, 1, "\u04AB"], [1195, 2], [1196, 1, "\u04AD"], [1197, 2], [1198, 1, "\u04AF"], [1199, 2], [1200, 1, "\u04B1"], [1201, 2], [1202, 1, "\u04B3"], [1203, 2], [1204, 1, "\u04B5"], [1205, 2], [1206, 1, "\u04B7"], [1207, 2], [1208, 1, "\u04B9"], [1209, 2], [1210, 1, "\u04BB"], [1211, 2], [1212, 1, "\u04BD"], [1213, 2], [1214, 1, "\u04BF"], [1215, 2], [1216, 1, "\u04CF"], [1217, 1, "\u04C2"], [1218, 2], [1219, 1, "\u04C4"], [1220, 2], [1221, 1, "\u04C6"], [1222, 2], [1223, 1, "\u04C8"], [1224, 2], [1225, 1, "\u04CA"], [1226, 2], [1227, 1, "\u04CC"], [1228, 2], [1229, 1, "\u04CE"], [1230, 2], [1231, 2], [1232, 1, "\u04D1"], [1233, 2], [1234, 1, "\u04D3"], [1235, 2], [1236, 1, "\u04D5"], [1237, 2], [1238, 1, "\u04D7"], [1239, 2], [1240, 1, "\u04D9"], [1241, 2], [1242, 1, "\u04DB"], [1243, 2], [1244, 1, "\u04DD"], [1245, 2], [1246, 1, "\u04DF"], [1247, 2], [1248, 1, "\u04E1"], [1249, 2], [1250, 1, "\u04E3"], [1251, 2], [1252, 1, "\u04E5"], [1253, 2], [1254, 1, "\u04E7"], [1255, 2], [1256, 1, "\u04E9"], [1257, 2], [1258, 1, "\u04EB"], [1259, 2], [1260, 1, "\u04ED"], [1261, 2], [1262, 1, "\u04EF"], [1263, 2], [1264, 1, "\u04F1"], [1265, 2], [1266, 1, "\u04F3"], [1267, 2], [1268, 1, "\u04F5"], [1269, 2], [1270, 1, "\u04F7"], [1271, 2], [1272, 1, "\u04F9"], [1273, 2], [1274, 1, "\u04FB"], [1275, 2], [1276, 1, "\u04FD"], [1277, 2], [1278, 1, "\u04FF"], [1279, 2], [1280, 1, "\u0501"], [1281, 2], [1282, 1, "\u0503"], [1283, 2], [1284, 1, "\u0505"], [1285, 2], [1286, 1, "\u0507"], [1287, 2], [1288, 1, "\u0509"], [1289, 2], [1290, 1, "\u050B"], [1291, 2], [1292, 1, "\u050D"], [1293, 2], [1294, 1, "\u050F"], [1295, 2], [1296, 1, "\u0511"], [1297, 2], [1298, 1, "\u0513"], [1299, 2], [1300, 1, "\u0515"], [1301, 2], [1302, 1, "\u0517"], [1303, 2], [1304, 1, "\u0519"], [1305, 2], [1306, 1, "\u051B"], [1307, 2], [1308, 1, "\u051D"], [1309, 2], [1310, 1, "\u051F"], [1311, 2], [1312, 1, "\u0521"], [1313, 2], [1314, 1, "\u0523"], [1315, 2], [1316, 1, "\u0525"], [1317, 2], [1318, 1, "\u0527"], [1319, 2], [1320, 1, "\u0529"], [1321, 2], [1322, 1, "\u052B"], [1323, 2], [1324, 1, "\u052D"], [1325, 2], [1326, 1, "\u052F"], [1327, 2], [1328, 3], [1329, 1, "\u0561"], [1330, 1, "\u0562"], [1331, 1, "\u0563"], [1332, 1, "\u0564"], [1333, 1, "\u0565"], [1334, 1, "\u0566"], [1335, 1, "\u0567"], [1336, 1, "\u0568"], [1337, 1, "\u0569"], [1338, 1, "\u056A"], [1339, 1, "\u056B"], [1340, 1, "\u056C"], [1341, 1, "\u056D"], [1342, 1, "\u056E"], [1343, 1, "\u056F"], [1344, 1, "\u0570"], [1345, 1, "\u0571"], [1346, 1, "\u0572"], [1347, 1, "\u0573"], [1348, 1, "\u0574"], [1349, 1, "\u0575"], [1350, 1, "\u0576"], [1351, 1, "\u0577"], [1352, 1, "\u0578"], [1353, 1, "\u0579"], [1354, 1, "\u057A"], [1355, 1, "\u057B"], [1356, 1, "\u057C"], [1357, 1, "\u057D"], [1358, 1, "\u057E"], [1359, 1, "\u057F"], [1360, 1, "\u0580"], [1361, 1, "\u0581"], [1362, 1, "\u0582"], [1363, 1, "\u0583"], [1364, 1, "\u0584"], [1365, 1, "\u0585"], [1366, 1, "\u0586"], [[1367, 1368], 3], [1369, 2], [[1370, 1375], 2], [1376, 2], [[1377, 1414], 2], [1415, 1, "\u0565\u0582"], [1416, 2], [1417, 2], [1418, 2], [[1419, 1420], 3], [[1421, 1422], 2], [1423, 2], [1424, 3], [[1425, 1441], 2], [1442, 2], [[1443, 1455], 2], [[1456, 1465], 2], [1466, 2], [[1467, 1469], 2], [1470, 2], [1471, 2], [1472, 2], [[1473, 1474], 2], [1475, 2], [1476, 2], [1477, 2], [1478, 2], [1479, 2], [[1480, 1487], 3], [[1488, 1514], 2], [[1515, 1518], 3], [1519, 2], [[1520, 1524], 2], [[1525, 1535], 3], [[1536, 1539], 3], [1540, 3], [1541, 3], [[1542, 1546], 2], [1547, 2], [1548, 2], [[1549, 1551], 2], [[1552, 1557], 2], [[1558, 1562], 2], [1563, 2], [1564, 3], [1565, 2], [1566, 2], [1567, 2], [1568, 2], [[1569, 1594], 2], [[1595, 1599], 2], [1600, 2], [[1601, 1618], 2], [[1619, 1621], 2], [[1622, 1624], 2], [[1625, 1630], 2], [1631, 2], [[1632, 1641], 2], [[1642, 1645], 2], [[1646, 1647], 2], [[1648, 1652], 2], [1653, 1, "\u0627\u0674"], [1654, 1, "\u0648\u0674"], [1655, 1, "\u06C7\u0674"], [1656, 1, "\u064A\u0674"], [[1657, 1719], 2], [[1720, 1721], 2], [[1722, 1726], 2], [1727, 2], [[1728, 1742], 2], [1743, 2], [[1744, 1747], 2], [1748, 2], [[1749, 1756], 2], [1757, 3], [1758, 2], [[1759, 1768], 2], [1769, 2], [[1770, 1773], 2], [[1774, 1775], 2], [[1776, 1785], 2], [[1786, 1790], 2], [1791, 2], [[1792, 1805], 2], [1806, 3], [1807, 3], [[1808, 1836], 2], [[1837, 1839], 2], [[1840, 1866], 2], [[1867, 1868], 3], [[1869, 1871], 2], [[1872, 1901], 2], [[1902, 1919], 2], [[1920, 1968], 2], [1969, 2], [[1970, 1983], 3], [[1984, 2037], 2], [[2038, 2042], 2], [[2043, 2044], 3], [2045, 2], [[2046, 2047], 2], [[2048, 2093], 2], [[2094, 2095], 3], [[2096, 2110], 2], [2111, 3], [[2112, 2139], 2], [[2140, 2141], 3], [2142, 2], [2143, 3], [[2144, 2154], 2], [[2155, 2159], 3], [[2160, 2183], 2], [2184, 2], [[2185, 2190], 2], [2191, 3], [[2192, 2193], 3], [[2194, 2198], 3], [2199, 2], [[2200, 2207], 2], [2208, 2], [2209, 2], [[2210, 2220], 2], [[2221, 2226], 2], [[2227, 2228], 2], [2229, 2], [[2230, 2237], 2], [[2238, 2247], 2], [[2248, 2258], 2], [2259, 2], [[2260, 2273], 2], [2274, 3], [2275, 2], [[2276, 2302], 2], [2303, 2], [2304, 2], [[2305, 2307], 2], [2308, 2], [[2309, 2361], 2], [[2362, 2363], 2], [[2364, 2381], 2], [2382, 2], [2383, 2], [[2384, 2388], 2], [2389, 2], [[2390, 2391], 2], [2392, 1, "\u0915\u093C"], [2393, 1, "\u0916\u093C"], [2394, 1, "\u0917\u093C"], [2395, 1, "\u091C\u093C"], [2396, 1, "\u0921\u093C"], [2397, 1, "\u0922\u093C"], [2398, 1, "\u092B\u093C"], [2399, 1, "\u092F\u093C"], [[2400, 2403], 2], [[2404, 2405], 2], [[2406, 2415], 2], [2416, 2], [[2417, 2418], 2], [[2419, 2423], 2], [2424, 2], [[2425, 2426], 2], [[2427, 2428], 2], [2429, 2], [[2430, 2431], 2], [2432, 2], [[2433, 2435], 2], [2436, 3], [[2437, 2444], 2], [[2445, 2446], 3], [[2447, 2448], 2], [[2449, 2450], 3], [[2451, 2472], 2], [2473, 3], [[2474, 2480], 2], [2481, 3], [2482, 2], [[2483, 2485], 3], [[2486, 2489], 2], [[2490, 2491], 3], [2492, 2], [2493, 2], [[2494, 2500], 2], [[2501, 2502], 3], [[2503, 2504], 2], [[2505, 2506], 3], [[2507, 2509], 2], [2510, 2], [[2511, 2518], 3], [2519, 2], [[2520, 2523], 3], [2524, 1, "\u09A1\u09BC"], [2525, 1, "\u09A2\u09BC"], [2526, 3], [2527, 1, "\u09AF\u09BC"], [[2528, 2531], 2], [[2532, 2533], 3], [[2534, 2545], 2], [[2546, 2554], 2], [2555, 2], [2556, 2], [2557, 2], [2558, 2], [[2559, 2560], 3], [2561, 2], [2562, 2], [2563, 2], [2564, 3], [[2565, 2570], 2], [[2571, 2574], 3], [[2575, 2576], 2], [[2577, 2578], 3], [[2579, 2600], 2], [2601, 3], [[2602, 2608], 2], [2609, 3], [2610, 2], [2611, 1, "\u0A32\u0A3C"], [2612, 3], [2613, 2], [2614, 1, "\u0A38\u0A3C"], [2615, 3], [[2616, 2617], 2], [[2618, 2619], 3], [2620, 2], [2621, 3], [[2622, 2626], 2], [[2627, 2630], 3], [[2631, 2632], 2], [[2633, 2634], 3], [[2635, 2637], 2], [[2638, 2640], 3], [2641, 2], [[2642, 2648], 3], [2649, 1, "\u0A16\u0A3C"], [2650, 1, "\u0A17\u0A3C"], [2651, 1, "\u0A1C\u0A3C"], [2652, 2], [2653, 3], [2654, 1, "\u0A2B\u0A3C"], [[2655, 2661], 3], [[2662, 2676], 2], [2677, 2], [2678, 2], [[2679, 2688], 3], [[2689, 2691], 2], [2692, 3], [[2693, 2699], 2], [2700, 2], [2701, 2], [2702, 3], [[2703, 2705], 2], [2706, 3], [[2707, 2728], 2], [2729, 3], [[2730, 2736], 2], [2737, 3], [[2738, 2739], 2], [2740, 3], [[2741, 2745], 2], [[2746, 2747], 3], [[2748, 2757], 2], [2758, 3], [[2759, 2761], 2], [2762, 3], [[2763, 2765], 2], [[2766, 2767], 3], [2768, 2], [[2769, 2783], 3], [2784, 2], [[2785, 2787], 2], [[2788, 2789], 3], [[2790, 2799], 2], [2800, 2], [2801, 2], [[2802, 2808], 3], [2809, 2], [[2810, 2815], 2], [2816, 3], [[2817, 2819], 2], [2820, 3], [[2821, 2828], 2], [[2829, 2830], 3], [[2831, 2832], 2], [[2833, 2834], 3], [[2835, 2856], 2], [2857, 3], [[2858, 2864], 2], [2865, 3], [[2866, 2867], 2], [2868, 3], [2869, 2], [[2870, 2873], 2], [[2874, 2875], 3], [[2876, 2883], 2], [2884, 2], [[2885, 2886], 3], [[2887, 2888], 2], [[2889, 2890], 3], [[2891, 2893], 2], [[2894, 2900], 3], [2901, 2], [[2902, 2903], 2], [[2904, 2907], 3], [2908, 1, "\u0B21\u0B3C"], [2909, 1, "\u0B22\u0B3C"], [2910, 3], [[2911, 2913], 2], [[2914, 2915], 2], [[2916, 2917], 3], [[2918, 2927], 2], [2928, 2], [2929, 2], [[2930, 2935], 2], [[2936, 2945], 3], [[2946, 2947], 2], [2948, 3], [[2949, 2954], 2], [[2955, 2957], 3], [[2958, 2960], 2], [2961, 3], [[2962, 2965], 2], [[2966, 2968], 3], [[2969, 2970], 2], [2971, 3], [2972, 2], [2973, 3], [[2974, 2975], 2], [[2976, 2978], 3], [[2979, 2980], 2], [[2981, 2983], 3], [[2984, 2986], 2], [[2987, 2989], 3], [[2990, 2997], 2], [2998, 2], [[2999, 3001], 2], [[3002, 3005], 3], [[3006, 3010], 2], [[3011, 3013], 3], [[3014, 3016], 2], [3017, 3], [[3018, 3021], 2], [[3022, 3023], 3], [3024, 2], [[3025, 3030], 3], [3031, 2], [[3032, 3045], 3], [3046, 2], [[3047, 3055], 2], [[3056, 3058], 2], [[3059, 3066], 2], [[3067, 3071], 3], [3072, 2], [[3073, 3075], 2], [3076, 2], [[3077, 3084], 2], [3085, 3], [[3086, 3088], 2], [3089, 3], [[3090, 3112], 2], [3113, 3], [[3114, 3123], 2], [3124, 2], [[3125, 3129], 2], [[3130, 3131], 3], [3132, 2], [3133, 2], [[3134, 3140], 2], [3141, 3], [[3142, 3144], 2], [3145, 3], [[3146, 3149], 2], [[3150, 3156], 3], [[3157, 3158], 2], [3159, 3], [[3160, 3161], 2], [3162, 2], [[3163, 3164], 3], [3165, 2], [[3166, 3167], 3], [[3168, 3169], 2], [[3170, 3171], 2], [[3172, 3173], 3], [[3174, 3183], 2], [[3184, 3190], 3], [3191, 2], [[3192, 3199], 2], [3200, 2], [3201, 2], [[3202, 3203], 2], [3204, 2], [[3205, 3212], 2], [3213, 3], [[3214, 3216], 2], [3217, 3], [[3218, 3240], 2], [3241, 3], [[3242, 3251], 2], [3252, 3], [[3253, 3257], 2], [[3258, 3259], 3], [[3260, 3261], 2], [[3262, 3268], 2], [3269, 3], [[3270, 3272], 2], [3273, 3], [[3274, 3277], 2], [[3278, 3284], 3], [[3285, 3286], 2], [[3287, 3292], 3], [3293, 2], [3294, 2], [3295, 3], [[3296, 3297], 2], [[3298, 3299], 2], [[3300, 3301], 3], [[3302, 3311], 2], [3312, 3], [[3313, 3314], 2], [3315, 2], [[3316, 3327], 3], [3328, 2], [3329, 2], [[3330, 3331], 2], [3332, 2], [[3333, 3340], 2], [3341, 3], [[3342, 3344], 2], [3345, 3], [[3346, 3368], 2], [3369, 2], [[3370, 3385], 2], [3386, 2], [[3387, 3388], 2], [3389, 2], [[3390, 3395], 2], [3396, 2], [3397, 3], [[3398, 3400], 2], [3401, 3], [[3402, 3405], 2], [3406, 2], [3407, 2], [[3408, 3411], 3], [[3412, 3414], 2], [3415, 2], [[3416, 3422], 2], [3423, 2], [[3424, 3425], 2], [[3426, 3427], 2], [[3428, 3429], 3], [[3430, 3439], 2], [[3440, 3445], 2], [[3446, 3448], 2], [3449, 2], [[3450, 3455], 2], [3456, 3], [3457, 2], [[3458, 3459], 2], [3460, 3], [[3461, 3478], 2], [[3479, 3481], 3], [[3482, 3505], 2], [3506, 3], [[3507, 3515], 2], [3516, 3], [3517, 2], [[3518, 3519], 3], [[3520, 3526], 2], [[3527, 3529], 3], [3530, 2], [[3531, 3534], 3], [[3535, 3540], 2], [3541, 3], [3542, 2], [3543, 3], [[3544, 3551], 2], [[3552, 3557], 3], [[3558, 3567], 2], [[3568, 3569], 3], [[3570, 3571], 2], [3572, 2], [[3573, 3584], 3], [[3585, 3634], 2], [3635, 1, "\u0E4D\u0E32"], [[3636, 3642], 2], [[3643, 3646], 3], [3647, 2], [[3648, 3662], 2], [3663, 2], [[3664, 3673], 2], [[3674, 3675], 2], [[3676, 3712], 3], [[3713, 3714], 2], [3715, 3], [3716, 2], [3717, 3], [3718, 2], [[3719, 3720], 2], [3721, 2], [3722, 2], [3723, 3], [3724, 2], [3725, 2], [[3726, 3731], 2], [[3732, 3735], 2], [3736, 2], [[3737, 3743], 2], [3744, 2], [[3745, 3747], 2], [3748, 3], [3749, 2], [3750, 3], [3751, 2], [[3752, 3753], 2], [[3754, 3755], 2], [3756, 2], [[3757, 3762], 2], [3763, 1, "\u0ECD\u0EB2"], [[3764, 3769], 2], [3770, 2], [[3771, 3773], 2], [[3774, 3775], 3], [[3776, 3780], 2], [3781, 3], [3782, 2], [3783, 3], [[3784, 3789], 2], [3790, 2], [3791, 3], [[3792, 3801], 2], [[3802, 3803], 3], [3804, 1, "\u0EAB\u0E99"], [3805, 1, "\u0EAB\u0EA1"], [[3806, 3807], 2], [[3808, 3839], 3], [3840, 2], [[3841, 3850], 2], [3851, 2], [3852, 1, "\u0F0B"], [[3853, 3863], 2], [[3864, 3865], 2], [[3866, 3871], 2], [[3872, 3881], 2], [[3882, 3892], 2], [3893, 2], [3894, 2], [3895, 2], [3896, 2], [3897, 2], [[3898, 3901], 2], [[3902, 3906], 2], [3907, 1, "\u0F42\u0FB7"], [[3908, 3911], 2], [3912, 3], [[3913, 3916], 2], [3917, 1, "\u0F4C\u0FB7"], [[3918, 3921], 2], [3922, 1, "\u0F51\u0FB7"], [[3923, 3926], 2], [3927, 1, "\u0F56\u0FB7"], [[3928, 3931], 2], [3932, 1, "\u0F5B\u0FB7"], [[3933, 3944], 2], [3945, 1, "\u0F40\u0FB5"], [3946, 2], [[3947, 3948], 2], [[3949, 3952], 3], [[3953, 3954], 2], [3955, 1, "\u0F71\u0F72"], [3956, 2], [3957, 1, "\u0F71\u0F74"], [3958, 1, "\u0FB2\u0F80"], [3959, 1, "\u0FB2\u0F71\u0F80"], [3960, 1, "\u0FB3\u0F80"], [3961, 1, "\u0FB3\u0F71\u0F80"], [[3962, 3968], 2], [3969, 1, "\u0F71\u0F80"], [[3970, 3972], 2], [3973, 2], [[3974, 3979], 2], [[3980, 3983], 2], [[3984, 3986], 2], [3987, 1, "\u0F92\u0FB7"], [[3988, 3989], 2], [3990, 2], [3991, 2], [3992, 3], [[3993, 3996], 2], [3997, 1, "\u0F9C\u0FB7"], [[3998, 4001], 2], [4002, 1, "\u0FA1\u0FB7"], [[4003, 4006], 2], [4007, 1, "\u0FA6\u0FB7"], [[4008, 4011], 2], [4012, 1, "\u0FAB\u0FB7"], [4013, 2], [[4014, 4016], 2], [[4017, 4023], 2], [4024, 2], [4025, 1, "\u0F90\u0FB5"], [[4026, 4028], 2], [4029, 3], [[4030, 4037], 2], [4038, 2], [[4039, 4044], 2], [4045, 3], [4046, 2], [4047, 2], [[4048, 4049], 2], [[4050, 4052], 2], [[4053, 4056], 2], [[4057, 4058], 2], [[4059, 4095], 3], [[4096, 4129], 2], [4130, 2], [[4131, 4135], 2], [4136, 2], [[4137, 4138], 2], [4139, 2], [[4140, 4146], 2], [[4147, 4149], 2], [[4150, 4153], 2], [[4154, 4159], 2], [[4160, 4169], 2], [[4170, 4175], 2], [[4176, 4185], 2], [[4186, 4249], 2], [[4250, 4253], 2], [[4254, 4255], 2], [4256, 1, "\u2D00"], [4257, 1, "\u2D01"], [4258, 1, "\u2D02"], [4259, 1, "\u2D03"], [4260, 1, "\u2D04"], [4261, 1, "\u2D05"], [4262, 1, "\u2D06"], [4263, 1, "\u2D07"], [4264, 1, "\u2D08"], [4265, 1, "\u2D09"], [4266, 1, "\u2D0A"], [4267, 1, "\u2D0B"], [4268, 1, "\u2D0C"], [4269, 1, "\u2D0D"], [4270, 1, "\u2D0E"], [4271, 1, "\u2D0F"], [4272, 1, "\u2D10"], [4273, 1, "\u2D11"], [4274, 1, "\u2D12"], [4275, 1, "\u2D13"], [4276, 1, "\u2D14"], [4277, 1, "\u2D15"], [4278, 1, "\u2D16"], [4279, 1, "\u2D17"], [4280, 1, "\u2D18"], [4281, 1, "\u2D19"], [4282, 1, "\u2D1A"], [4283, 1, "\u2D1B"], [4284, 1, "\u2D1C"], [4285, 1, "\u2D1D"], [4286, 1, "\u2D1E"], [4287, 1, "\u2D1F"], [4288, 1, "\u2D20"], [4289, 1, "\u2D21"], [4290, 1, "\u2D22"], [4291, 1, "\u2D23"], [4292, 1, "\u2D24"], [4293, 1, "\u2D25"], [4294, 3], [4295, 1, "\u2D27"], [[4296, 4300], 3], [4301, 1, "\u2D2D"], [[4302, 4303], 3], [[4304, 4342], 2], [[4343, 4344], 2], [[4345, 4346], 2], [4347, 2], [4348, 1, "\u10DC"], [[4349, 4351], 2], [[4352, 4441], 2], [[4442, 4446], 2], [[4447, 4448], 7], [[4449, 4514], 2], [[4515, 4519], 2], [[4520, 4601], 2], [[4602, 4607], 2], [[4608, 4614], 2], [4615, 2], [[4616, 4678], 2], [4679, 2], [4680, 2], [4681, 3], [[4682, 4685], 2], [[4686, 4687], 3], [[4688, 4694], 2], [4695, 3], [4696, 2], [4697, 3], [[4698, 4701], 2], [[4702, 4703], 3], [[4704, 4742], 2], [4743, 2], [4744, 2], [4745, 3], [[4746, 4749], 2], [[4750, 4751], 3], [[4752, 4782], 2], [4783, 2], [4784, 2], [4785, 3], [[4786, 4789], 2], [[4790, 4791], 3], [[4792, 4798], 2], [4799, 3], [4800, 2], [4801, 3], [[4802, 4805], 2], [[4806, 4807], 3], [[4808, 4814], 2], [4815, 2], [[4816, 4822], 2], [4823, 3], [[4824, 4846], 2], [4847, 2], [[4848, 4878], 2], [4879, 2], [4880, 2], [4881, 3], [[4882, 4885], 2], [[4886, 4887], 3], [[4888, 4894], 2], [4895, 2], [[4896, 4934], 2], [4935, 2], [[4936, 4954], 2], [[4955, 4956], 3], [[4957, 4958], 2], [4959, 2], [4960, 2], [[4961, 4988], 2], [[4989, 4991], 3], [[4992, 5007], 2], [[5008, 5017], 2], [[5018, 5023], 3], [[5024, 5108], 2], [5109, 2], [[5110, 5111], 3], [5112, 1, "\u13F0"], [5113, 1, "\u13F1"], [5114, 1, "\u13F2"], [5115, 1, "\u13F3"], [5116, 1, "\u13F4"], [5117, 1, "\u13F5"], [[5118, 5119], 3], [5120, 2], [[5121, 5740], 2], [[5741, 5742], 2], [[5743, 5750], 2], [[5751, 5759], 2], [5760, 3], [[5761, 5786], 2], [[5787, 5788], 2], [[5789, 5791], 3], [[5792, 5866], 2], [[5867, 5872], 2], [[5873, 5880], 2], [[5881, 5887], 3], [[5888, 5900], 2], [5901, 2], [[5902, 5908], 2], [5909, 2], [[5910, 5918], 3], [5919, 2], [[5920, 5940], 2], [[5941, 5942], 2], [[5943, 5951], 3], [[5952, 5971], 2], [[5972, 5983], 3], [[5984, 5996], 2], [5997, 3], [[5998, 6e3], 2], [6001, 3], [[6002, 6003], 2], [[6004, 6015], 3], [[6016, 6067], 2], [[6068, 6069], 7], [[6070, 6099], 2], [[6100, 6102], 2], [6103, 2], [[6104, 6107], 2], [6108, 2], [6109, 2], [[6110, 6111], 3], [[6112, 6121], 2], [[6122, 6127], 3], [[6128, 6137], 2], [[6138, 6143], 3], [[6144, 6154], 2], [[6155, 6158], 7], [6159, 7], [[6160, 6169], 2], [[6170, 6175], 3], [[6176, 6263], 2], [6264, 2], [[6265, 6271], 3], [[6272, 6313], 2], [6314, 2], [[6315, 6319], 3], [[6320, 6389], 2], [[6390, 6399], 3], [[6400, 6428], 2], [[6429, 6430], 2], [6431, 3], [[6432, 6443], 2], [[6444, 6447], 3], [[6448, 6459], 2], [[6460, 6463], 3], [6464, 2], [[6465, 6467], 3], [[6468, 6469], 2], [[6470, 6509], 2], [[6510, 6511], 3], [[6512, 6516], 2], [[6517, 6527], 3], [[6528, 6569], 2], [[6570, 6571], 2], [[6572, 6575], 3], [[6576, 6601], 2], [[6602, 6607], 3], [[6608, 6617], 2], [6618, 2], [[6619, 6621], 3], [[6622, 6623], 2], [[6624, 6655], 2], [[6656, 6683], 2], [[6684, 6685], 3], [[6686, 6687], 2], [[6688, 6750], 2], [6751, 3], [[6752, 6780], 2], [[6781, 6782], 3], [[6783, 6793], 2], [[6794, 6799], 3], [[6800, 6809], 2], [[6810, 6815], 3], [[6816, 6822], 2], [6823, 2], [[6824, 6829], 2], [[6830, 6831], 3], [[6832, 6845], 2], [6846, 2], [[6847, 6848], 2], [[6849, 6862], 2], [[6863, 6911], 3], [[6912, 6987], 2], [6988, 2], [6989, 3], [[6990, 6991], 2], [[6992, 7001], 2], [[7002, 7018], 2], [[7019, 7027], 2], [[7028, 7036], 2], [[7037, 7038], 2], [7039, 2], [[7040, 7082], 2], [[7083, 7085], 2], [[7086, 7097], 2], [[7098, 7103], 2], [[7104, 7155], 2], [[7156, 7163], 3], [[7164, 7167], 2], [[7168, 7223], 2], [[7224, 7226], 3], [[7227, 7231], 2], [[7232, 7241], 2], [[7242, 7244], 3], [[7245, 7293], 2], [[7294, 7295], 2], [7296, 1, "\u0432"], [7297, 1, "\u0434"], [7298, 1, "\u043E"], [7299, 1, "\u0441"], [[7300, 7301], 1, "\u0442"], [7302, 1, "\u044A"], [7303, 1, "\u0463"], [7304, 1, "\uA64B"], [7305, 1, "\u1C8A"], [7306, 2], [[7307, 7311], 3], [7312, 1, "\u10D0"], [7313, 1, "\u10D1"], [7314, 1, "\u10D2"], [7315, 1, "\u10D3"], [7316, 1, "\u10D4"], [7317, 1, "\u10D5"], [7318, 1, "\u10D6"], [7319, 1, "\u10D7"], [7320, 1, "\u10D8"], [7321, 1, "\u10D9"], [7322, 1, "\u10DA"], [7323, 1, "\u10DB"], [7324, 1, "\u10DC"], [7325, 1, "\u10DD"], [7326, 1, "\u10DE"], [7327, 1, "\u10DF"], [7328, 1, "\u10E0"], [7329, 1, "\u10E1"], [7330, 1, "\u10E2"], [7331, 1, "\u10E3"], [7332, 1, "\u10E4"], [7333, 1, "\u10E5"], [7334, 1, "\u10E6"], [7335, 1, "\u10E7"], [7336, 1, "\u10E8"], [7337, 1, "\u10E9"], [7338, 1, "\u10EA"], [7339, 1, "\u10EB"], [7340, 1, "\u10EC"], [7341, 1, "\u10ED"], [7342, 1, "\u10EE"], [7343, 1, "\u10EF"], [7344, 1, "\u10F0"], [7345, 1, "\u10F1"], [7346, 1, "\u10F2"], [7347, 1, "\u10F3"], [7348, 1, "\u10F4"], [7349, 1, "\u10F5"], [7350, 1, "\u10F6"], [7351, 1, "\u10F7"], [7352, 1, "\u10F8"], [7353, 1, "\u10F9"], [7354, 1, "\u10FA"], [[7355, 7356], 3], [7357, 1, "\u10FD"], [7358, 1, "\u10FE"], [7359, 1, "\u10FF"], [[7360, 7367], 2], [[7368, 7375], 3], [[7376, 7378], 2], [7379, 2], [[7380, 7410], 2], [[7411, 7414], 2], [7415, 2], [[7416, 7417], 2], [7418, 2], [[7419, 7423], 3], [[7424, 7467], 2], [7468, 1, "a"], [7469, 1, "\xE6"], [7470, 1, "b"], [7471, 2], [7472, 1, "d"], [7473, 1, "e"], [7474, 1, "\u01DD"], [7475, 1, "g"], [7476, 1, "h"], [7477, 1, "i"], [7478, 1, "j"], [7479, 1, "k"], [7480, 1, "l"], [7481, 1, "m"], [7482, 1, "n"], [7483, 2], [7484, 1, "o"], [7485, 1, "\u0223"], [7486, 1, "p"], [7487, 1, "r"], [7488, 1, "t"], [7489, 1, "u"], [7490, 1, "w"], [7491, 1, "a"], [7492, 1, "\u0250"], [7493, 1, "\u0251"], [7494, 1, "\u1D02"], [7495, 1, "b"], [7496, 1, "d"], [7497, 1, "e"], [7498, 1, "\u0259"], [7499, 1, "\u025B"], [7500, 1, "\u025C"], [7501, 1, "g"], [7502, 2], [7503, 1, "k"], [7504, 1, "m"], [7505, 1, "\u014B"], [7506, 1, "o"], [7507, 1, "\u0254"], [7508, 1, "\u1D16"], [7509, 1, "\u1D17"], [7510, 1, "p"], [7511, 1, "t"], [7512, 1, "u"], [7513, 1, "\u1D1D"], [7514, 1, "\u026F"], [7515, 1, "v"], [7516, 1, "\u1D25"], [7517, 1, "\u03B2"], [7518, 1, "\u03B3"], [7519, 1, "\u03B4"], [7520, 1, "\u03C6"], [7521, 1, "\u03C7"], [7522, 1, "i"], [7523, 1, "r"], [7524, 1, "u"], [7525, 1, "v"], [7526, 1, "\u03B2"], [7527, 1, "\u03B3"], [7528, 1, "\u03C1"], [7529, 1, "\u03C6"], [7530, 1, "\u03C7"], [7531, 2], [[7532, 7543], 2], [7544, 1, "\u043D"], [[7545, 7578], 2], [7579, 1, "\u0252"], [7580, 1, "c"], [7581, 1, "\u0255"], [7582, 1, "\xF0"], [7583, 1, "\u025C"], [7584, 1, "f"], [7585, 1, "\u025F"], [7586, 1, "\u0261"], [7587, 1, "\u0265"], [7588, 1, "\u0268"], [7589, 1, "\u0269"], [7590, 1, "\u026A"], [7591, 1, "\u1D7B"], [7592, 1, "\u029D"], [7593, 1, "\u026D"], [7594, 1, "\u1D85"], [7595, 1, "\u029F"], [7596, 1, "\u0271"], [7597, 1, "\u0270"], [7598, 1, "\u0272"], [7599, 1, "\u0273"], [7600, 1, "\u0274"], [7601, 1, "\u0275"], [7602, 1, "\u0278"], [7603, 1, "\u0282"], [7604, 1, "\u0283"], [7605, 1, "\u01AB"], [7606, 1, "\u0289"], [7607, 1, "\u028A"], [7608, 1, "\u1D1C"], [7609, 1, "\u028B"], [7610, 1, "\u028C"], [7611, 1, "z"], [7612, 1, "\u0290"], [7613, 1, "\u0291"], [7614, 1, "\u0292"], [7615, 1, "\u03B8"], [[7616, 7619], 2], [[7620, 7626], 2], [[7627, 7654], 2], [[7655, 7669], 2], [[7670, 7673], 2], [7674, 2], [7675, 2], [7676, 2], [7677, 2], [[7678, 7679], 2], [7680, 1, "\u1E01"], [7681, 2], [7682, 1, "\u1E03"], [7683, 2], [7684, 1, "\u1E05"], [7685, 2], [7686, 1, "\u1E07"], [7687, 2], [7688, 1, "\u1E09"], [7689, 2], [7690, 1, "\u1E0B"], [7691, 2], [7692, 1, "\u1E0D"], [7693, 2], [7694, 1, "\u1E0F"], [7695, 2], [7696, 1, "\u1E11"], [7697, 2], [7698, 1, "\u1E13"], [7699, 2], [7700, 1, "\u1E15"], [7701, 2], [7702, 1, "\u1E17"], [7703, 2], [7704, 1, "\u1E19"], [7705, 2], [7706, 1, "\u1E1B"], [7707, 2], [7708, 1, "\u1E1D"], [7709, 2], [7710, 1, "\u1E1F"], [7711, 2], [7712, 1, "\u1E21"], [7713, 2], [7714, 1, "\u1E23"], [7715, 2], [7716, 1, "\u1E25"], [7717, 2], [7718, 1, "\u1E27"], [7719, 2], [7720, 1, "\u1E29"], [7721, 2], [7722, 1, "\u1E2B"], [7723, 2], [7724, 1, "\u1E2D"], [7725, 2], [7726, 1, "\u1E2F"], [7727, 2], [7728, 1, "\u1E31"], [7729, 2], [7730, 1, "\u1E33"], [7731, 2], [7732, 1, "\u1E35"], [7733, 2], [7734, 1, "\u1E37"], [7735, 2], [7736, 1, "\u1E39"], [7737, 2], [7738, 1, "\u1E3B"], [7739, 2], [7740, 1, "\u1E3D"], [7741, 2], [7742, 1, "\u1E3F"], [7743, 2], [7744, 1, "\u1E41"], [7745, 2], [7746, 1, "\u1E43"], [7747, 2], [7748, 1, "\u1E45"], [7749, 2], [7750, 1, "\u1E47"], [7751, 2], [7752, 1, "\u1E49"], [7753, 2], [7754, 1, "\u1E4B"], [7755, 2], [7756, 1, "\u1E4D"], [7757, 2], [7758, 1, "\u1E4F"], [7759, 2], [7760, 1, "\u1E51"], [7761, 2], [7762, 1, "\u1E53"], [7763, 2], [7764, 1, "\u1E55"], [7765, 2], [7766, 1, "\u1E57"], [7767, 2], [7768, 1, "\u1E59"], [7769, 2], [7770, 1, "\u1E5B"], [7771, 2], [7772, 1, "\u1E5D"], [7773, 2], [7774, 1, "\u1E5F"], [7775, 2], [7776, 1, "\u1E61"], [7777, 2], [7778, 1, "\u1E63"], [7779, 2], [7780, 1, "\u1E65"], [7781, 2], [7782, 1, "\u1E67"], [7783, 2], [7784, 1, "\u1E69"], [7785, 2], [7786, 1, "\u1E6B"], [7787, 2], [7788, 1, "\u1E6D"], [7789, 2], [7790, 1, "\u1E6F"], [7791, 2], [7792, 1, "\u1E71"], [7793, 2], [7794, 1, "\u1E73"], [7795, 2], [7796, 1, "\u1E75"], [7797, 2], [7798, 1, "\u1E77"], [7799, 2], [7800, 1, "\u1E79"], [7801, 2], [7802, 1, "\u1E7B"], [7803, 2], [7804, 1, "\u1E7D"], [7805, 2], [7806, 1, "\u1E7F"], [7807, 2], [7808, 1, "\u1E81"], [7809, 2], [7810, 1, "\u1E83"], [7811, 2], [7812, 1, "\u1E85"], [7813, 2], [7814, 1, "\u1E87"], [7815, 2], [7816, 1, "\u1E89"], [7817, 2], [7818, 1, "\u1E8B"], [7819, 2], [7820, 1, "\u1E8D"], [7821, 2], [7822, 1, "\u1E8F"], [7823, 2], [7824, 1, "\u1E91"], [7825, 2], [7826, 1, "\u1E93"], [7827, 2], [7828, 1, "\u1E95"], [[7829, 7833], 2], [7834, 1, "a\u02BE"], [7835, 1, "\u1E61"], [[7836, 7837], 2], [7838, 1, "\xDF"], [7839, 2], [7840, 1, "\u1EA1"], [7841, 2], [7842, 1, "\u1EA3"], [7843, 2], [7844, 1, "\u1EA5"], [7845, 2], [7846, 1, "\u1EA7"], [7847, 2], [7848, 1, "\u1EA9"], [7849, 2], [7850, 1, "\u1EAB"], [7851, 2], [7852, 1, "\u1EAD"], [7853, 2], [7854, 1, "\u1EAF"], [7855, 2], [7856, 1, "\u1EB1"], [7857, 2], [7858, 1, "\u1EB3"], [7859, 2], [7860, 1, "\u1EB5"], [7861, 2], [7862, 1, "\u1EB7"], [7863, 2], [7864, 1, "\u1EB9"], [7865, 2], [7866, 1, "\u1EBB"], [7867, 2], [7868, 1, "\u1EBD"], [7869, 2], [7870, 1, "\u1EBF"], [7871, 2], [7872, 1, "\u1EC1"], [7873, 2], [7874, 1, "\u1EC3"], [7875, 2], [7876, 1, "\u1EC5"], [7877, 2], [7878, 1, "\u1EC7"], [7879, 2], [7880, 1, "\u1EC9"], [7881, 2], [7882, 1, "\u1ECB"], [7883, 2], [7884, 1, "\u1ECD"], [7885, 2], [7886, 1, "\u1ECF"], [7887, 2], [7888, 1, "\u1ED1"], [7889, 2], [7890, 1, "\u1ED3"], [7891, 2], [7892, 1, "\u1ED5"], [7893, 2], [7894, 1, "\u1ED7"], [7895, 2], [7896, 1, "\u1ED9"], [7897, 2], [7898, 1, "\u1EDB"], [7899, 2], [7900, 1, "\u1EDD"], [7901, 2], [7902, 1, "\u1EDF"], [7903, 2], [7904, 1, "\u1EE1"], [7905, 2], [7906, 1, "\u1EE3"], [7907, 2], [7908, 1, "\u1EE5"], [7909, 2], [7910, 1, "\u1EE7"], [7911, 2], [7912, 1, "\u1EE9"], [7913, 2], [7914, 1, "\u1EEB"], [7915, 2], [7916, 1, "\u1EED"], [7917, 2], [7918, 1, "\u1EEF"], [7919, 2], [7920, 1, "\u1EF1"], [7921, 2], [7922, 1, "\u1EF3"], [7923, 2], [7924, 1, "\u1EF5"], [7925, 2], [7926, 1, "\u1EF7"], [7927, 2], [7928, 1, "\u1EF9"], [7929, 2], [7930, 1, "\u1EFB"], [7931, 2], [7932, 1, "\u1EFD"], [7933, 2], [7934, 1, "\u1EFF"], [7935, 2], [[7936, 7943], 2], [7944, 1, "\u1F00"], [7945, 1, "\u1F01"], [7946, 1, "\u1F02"], [7947, 1, "\u1F03"], [7948, 1, "\u1F04"], [7949, 1, "\u1F05"], [7950, 1, "\u1F06"], [7951, 1, "\u1F07"], [[7952, 7957], 2], [[7958, 7959], 3], [7960, 1, "\u1F10"], [7961, 1, "\u1F11"], [7962, 1, "\u1F12"], [7963, 1, "\u1F13"], [7964, 1, "\u1F14"], [7965, 1, "\u1F15"], [[7966, 7967], 3], [[7968, 7975], 2], [7976, 1, "\u1F20"], [7977, 1, "\u1F21"], [7978, 1, "\u1F22"], [7979, 1, "\u1F23"], [7980, 1, "\u1F24"], [7981, 1, "\u1F25"], [7982, 1, "\u1F26"], [7983, 1, "\u1F27"], [[7984, 7991], 2], [7992, 1, "\u1F30"], [7993, 1, "\u1F31"], [7994, 1, "\u1F32"], [7995, 1, "\u1F33"], [7996, 1, "\u1F34"], [7997, 1, "\u1F35"], [7998, 1, "\u1F36"], [7999, 1, "\u1F37"], [[8e3, 8005], 2], [[8006, 8007], 3], [8008, 1, "\u1F40"], [8009, 1, "\u1F41"], [8010, 1, "\u1F42"], [8011, 1, "\u1F43"], [8012, 1, "\u1F44"], [8013, 1, "\u1F45"], [[8014, 8015], 3], [[8016, 8023], 2], [8024, 3], [8025, 1, "\u1F51"], [8026, 3], [8027, 1, "\u1F53"], [8028, 3], [8029, 1, "\u1F55"], [8030, 3], [8031, 1, "\u1F57"], [[8032, 8039], 2], [8040, 1, "\u1F60"], [8041, 1, "\u1F61"], [8042, 1, "\u1F62"], [8043, 1, "\u1F63"], [8044, 1, "\u1F64"], [8045, 1, "\u1F65"], [8046, 1, "\u1F66"], [8047, 1, "\u1F67"], [8048, 2], [8049, 1, "\u03AC"], [8050, 2], [8051, 1, "\u03AD"], [8052, 2], [8053, 1, "\u03AE"], [8054, 2], [8055, 1, "\u03AF"], [8056, 2], [8057, 1, "\u03CC"], [8058, 2], [8059, 1, "\u03CD"], [8060, 2], [8061, 1, "\u03CE"], [[8062, 8063], 3], [8064, 1, "\u1F00\u03B9"], [8065, 1, "\u1F01\u03B9"], [8066, 1, "\u1F02\u03B9"], [8067, 1, "\u1F03\u03B9"], [8068, 1, "\u1F04\u03B9"], [8069, 1, "\u1F05\u03B9"], [8070, 1, "\u1F06\u03B9"], [8071, 1, "\u1F07\u03B9"], [8072, 1, "\u1F00\u03B9"], [8073, 1, "\u1F01\u03B9"], [8074, 1, "\u1F02\u03B9"], [8075, 1, "\u1F03\u03B9"], [8076, 1, "\u1F04\u03B9"], [8077, 1, "\u1F05\u03B9"], [8078, 1, "\u1F06\u03B9"], [8079, 1, "\u1F07\u03B9"], [8080, 1, "\u1F20\u03B9"], [8081, 1, "\u1F21\u03B9"], [8082, 1, "\u1F22\u03B9"], [8083, 1, "\u1F23\u03B9"], [8084, 1, "\u1F24\u03B9"], [8085, 1, "\u1F25\u03B9"], [8086, 1, "\u1F26\u03B9"], [8087, 1, "\u1F27\u03B9"], [8088, 1, "\u1F20\u03B9"], [8089, 1, "\u1F21\u03B9"], [8090, 1, "\u1F22\u03B9"], [8091, 1, "\u1F23\u03B9"], [8092, 1, "\u1F24\u03B9"], [8093, 1, "\u1F25\u03B9"], [8094, 1, "\u1F26\u03B9"], [8095, 1, "\u1F27\u03B9"], [8096, 1, "\u1F60\u03B9"], [8097, 1, "\u1F61\u03B9"], [8098, 1, "\u1F62\u03B9"], [8099, 1, "\u1F63\u03B9"], [8100, 1, "\u1F64\u03B9"], [8101, 1, "\u1F65\u03B9"], [8102, 1, "\u1F66\u03B9"], [8103, 1, "\u1F67\u03B9"], [8104, 1, "\u1F60\u03B9"], [8105, 1, "\u1F61\u03B9"], [8106, 1, "\u1F62\u03B9"], [8107, 1, "\u1F63\u03B9"], [8108, 1, "\u1F64\u03B9"], [8109, 1, "\u1F65\u03B9"], [8110, 1, "\u1F66\u03B9"], [8111, 1, "\u1F67\u03B9"], [[8112, 8113], 2], [8114, 1, "\u1F70\u03B9"], [8115, 1, "\u03B1\u03B9"], [8116, 1, "\u03AC\u03B9"], [8117, 3], [8118, 2], [8119, 1, "\u1FB6\u03B9"], [8120, 1, "\u1FB0"], [8121, 1, "\u1FB1"], [8122, 1, "\u1F70"], [8123, 1, "\u03AC"], [8124, 1, "\u03B1\u03B9"], [8125, 1, " \u0313"], [8126, 1, "\u03B9"], [8127, 1, " \u0313"], [8128, 1, " \u0342"], [8129, 1, " \u0308\u0342"], [8130, 1, "\u1F74\u03B9"], [8131, 1, "\u03B7\u03B9"], [8132, 1, "\u03AE\u03B9"], [8133, 3], [8134, 2], [8135, 1, "\u1FC6\u03B9"], [8136, 1, "\u1F72"], [8137, 1, "\u03AD"], [8138, 1, "\u1F74"], [8139, 1, "\u03AE"], [8140, 1, "\u03B7\u03B9"], [8141, 1, " \u0313\u0300"], [8142, 1, " \u0313\u0301"], [8143, 1, " \u0313\u0342"], [[8144, 8146], 2], [8147, 1, "\u0390"], [[8148, 8149], 3], [[8150, 8151], 2], [8152, 1, "\u1FD0"], [8153, 1, "\u1FD1"], [8154, 1, "\u1F76"], [8155, 1, "\u03AF"], [8156, 3], [8157, 1, " \u0314\u0300"], [8158, 1, " \u0314\u0301"], [8159, 1, " \u0314\u0342"], [[8160, 8162], 2], [8163, 1, "\u03B0"], [[8164, 8167], 2], [8168, 1, "\u1FE0"], [8169, 1, "\u1FE1"], [8170, 1, "\u1F7A"], [8171, 1, "\u03CD"], [8172, 1, "\u1FE5"], [8173, 1, " \u0308\u0300"], [8174, 1, " \u0308\u0301"], [8175, 1, "`"], [[8176, 8177], 3], [8178, 1, "\u1F7C\u03B9"], [8179, 1, "\u03C9\u03B9"], [8180, 1, "\u03CE\u03B9"], [8181, 3], [8182, 2], [8183, 1, "\u1FF6\u03B9"], [8184, 1, "\u1F78"], [8185, 1, "\u03CC"], [8186, 1, "\u1F7C"], [8187, 1, "\u03CE"], [8188, 1, "\u03C9\u03B9"], [8189, 1, " \u0301"], [8190, 1, " \u0314"], [8191, 3], [[8192, 8202], 1, " "], [8203, 7], [[8204, 8205], 6, ""], [[8206, 8207], 3], [8208, 2], [8209, 1, "\u2010"], [[8210, 8214], 2], [8215, 1, " \u0333"], [[8216, 8227], 2], [[8228, 8230], 3], [8231, 2], [[8232, 8238], 3], [8239, 1, " "], [[8240, 8242], 2], [8243, 1, "\u2032\u2032"], [8244, 1, "\u2032\u2032\u2032"], [8245, 2], [8246, 1, "\u2035\u2035"], [8247, 1, "\u2035\u2035\u2035"], [[8248, 8251], 2], [8252, 1, "!!"], [8253, 2], [8254, 1, " \u0305"], [[8255, 8262], 2], [8263, 1, "??"], [8264, 1, "?!"], [8265, 1, "!?"], [[8266, 8269], 2], [[8270, 8274], 2], [[8275, 8276], 2], [[8277, 8278], 2], [8279, 1, "\u2032\u2032\u2032\u2032"], [[8280, 8286], 2], [8287, 1, " "], [[8288, 8291], 7], [8292, 7], [8293, 3], [[8294, 8297], 3], [[8298, 8303], 7], [8304, 1, "0"], [8305, 1, "i"], [[8306, 8307], 3], [8308, 1, "4"], [8309, 1, "5"], [8310, 1, "6"], [8311, 1, "7"], [8312, 1, "8"], [8313, 1, "9"], [8314, 1, "+"], [8315, 1, "\u2212"], [8316, 1, "="], [8317, 1, "("], [8318, 1, ")"], [8319, 1, "n"], [8320, 1, "0"], [8321, 1, "1"], [8322, 1, "2"], [8323, 1, "3"], [8324, 1, "4"], [8325, 1, "5"], [8326, 1, "6"], [8327, 1, "7"], [8328, 1, "8"], [8329, 1, "9"], [8330, 1, "+"], [8331, 1, "\u2212"], [8332, 1, "="], [8333, 1, "("], [8334, 1, ")"], [8335, 3], [8336, 1, "a"], [8337, 1, "e"], [8338, 1, "o"], [8339, 1, "x"], [8340, 1, "\u0259"], [8341, 1, "h"], [8342, 1, "k"], [8343, 1, "l"], [8344, 1, "m"], [8345, 1, "n"], [8346, 1, "p"], [8347, 1, "s"], [8348, 1, "t"], [[8349, 8351], 3], [[8352, 8359], 2], [8360, 1, "rs"], [[8361, 8362], 2], [8363, 2], [8364, 2], [[8365, 8367], 2], [[8368, 8369], 2], [[8370, 8373], 2], [[8374, 8376], 2], [8377, 2], [8378, 2], [[8379, 8381], 2], [8382, 2], [8383, 2], [8384, 2], [[8385, 8399], 3], [[8400, 8417], 2], [[8418, 8419], 2], [[8420, 8426], 2], [8427, 2], [[8428, 8431], 2], [8432, 2], [[8433, 8447], 3], [8448, 1, "a/c"], [8449, 1, "a/s"], [8450, 1, "c"], [8451, 1, "\xB0c"], [8452, 2], [8453, 1, "c/o"], [8454, 1, "c/u"], [8455, 1, "\u025B"], [8456, 2], [8457, 1, "\xB0f"], [8458, 1, "g"], [[8459, 8462], 1, "h"], [8463, 1, "\u0127"], [[8464, 8465], 1, "i"], [[8466, 8467], 1, "l"], [8468, 2], [8469, 1, "n"], [8470, 1, "no"], [[8471, 8472], 2], [8473, 1, "p"], [8474, 1, "q"], [[8475, 8477], 1, "r"], [[8478, 8479], 2], [8480, 1, "sm"], [8481, 1, "tel"], [8482, 1, "tm"], [8483, 2], [8484, 1, "z"], [8485, 2], [8486, 1, "\u03C9"], [8487, 2], [8488, 1, "z"], [8489, 2], [8490, 1, "k"], [8491, 1, "\xE5"], [8492, 1, "b"], [8493, 1, "c"], [8494, 2], [[8495, 8496], 1, "e"], [8497, 1, "f"], [8498, 1, "\u214E"], [8499, 1, "m"], [8500, 1, "o"], [8501, 1, "\u05D0"], [8502, 1, "\u05D1"], [8503, 1, "\u05D2"], [8504, 1, "\u05D3"], [8505, 1, "i"], [8506, 2], [8507, 1, "fax"], [8508, 1, "\u03C0"], [[8509, 8510], 1, "\u03B3"], [8511, 1, "\u03C0"], [8512, 1, "\u2211"], [[8513, 8516], 2], [[8517, 8518], 1, "d"], [8519, 1, "e"], [8520, 1, "i"], [8521, 1, "j"], [[8522, 8523], 2], [8524, 2], [8525, 2], [8526, 2], [8527, 2], [8528, 1, "1\u20447"], [8529, 1, "1\u20449"], [8530, 1, "1\u204410"], [8531, 1, "1\u20443"], [8532, 1, "2\u20443"], [8533, 1, "1\u20445"], [8534, 1, "2\u20445"], [8535, 1, "3\u20445"], [8536, 1, "4\u20445"], [8537, 1, "1\u20446"], [8538, 1, "5\u20446"], [8539, 1, "1\u20448"], [8540, 1, "3\u20448"], [8541, 1, "5\u20448"], [8542, 1, "7\u20448"], [8543, 1, "1\u2044"], [8544, 1, "i"], [8545, 1, "ii"], [8546, 1, "iii"], [8547, 1, "iv"], [8548, 1, "v"], [8549, 1, "vi"], [8550, 1, "vii"], [8551, 1, "viii"], [8552, 1, "ix"], [8553, 1, "x"], [8554, 1, "xi"], [8555, 1, "xii"], [8556, 1, "l"], [8557, 1, "c"], [8558, 1, "d"], [8559, 1, "m"], [8560, 1, "i"], [8561, 1, "ii"], [8562, 1, "iii"], [8563, 1, "iv"], [8564, 1, "v"], [8565, 1, "vi"], [8566, 1, "vii"], [8567, 1, "viii"], [8568, 1, "ix"], [8569, 1, "x"], [8570, 1, "xi"], [8571, 1, "xii"], [8572, 1, "l"], [8573, 1, "c"], [8574, 1, "d"], [8575, 1, "m"], [[8576, 8578], 2], [8579, 1, "\u2184"], [8580, 2], [[8581, 8584], 2], [8585, 1, "0\u20443"], [[8586, 8587], 2], [[8588, 8591], 3], [[8592, 8682], 2], [[8683, 8691], 2], [[8692, 8703], 2], [[8704, 8747], 2], [8748, 1, "\u222B\u222B"], [8749, 1, "\u222B\u222B\u222B"], [8750, 2], [8751, 1, "\u222E\u222E"], [8752, 1, "\u222E\u222E\u222E"], [[8753, 8945], 2], [[8946, 8959], 2], [8960, 2], [8961, 2], [[8962, 9e3], 2], [9001, 1, "\u3008"], [9002, 1, "\u3009"], [[9003, 9082], 2], [9083, 2], [9084, 2], [[9085, 9114], 2], [[9115, 9166], 2], [[9167, 9168], 2], [[9169, 9179], 2], [[9180, 9191], 2], [9192, 2], [[9193, 9203], 2], [[9204, 9210], 2], [[9211, 9214], 2], [9215, 2], [[9216, 9252], 2], [[9253, 9254], 2], [[9255, 9257], 2], [[9258, 9279], 3], [[9280, 9290], 2], [[9291, 9311], 3], [9312, 1, "1"], [9313, 1, "2"], [9314, 1, "3"], [9315, 1, "4"], [9316, 1, "5"], [9317, 1, "6"], [9318, 1, "7"], [9319, 1, "8"], [9320, 1, "9"], [9321, 1, "10"], [9322, 1, "11"], [9323, 1, "12"], [9324, 1, "13"], [9325, 1, "14"], [9326, 1, "15"], [9327, 1, "16"], [9328, 1, "17"], [9329, 1, "18"], [9330, 1, "19"], [9331, 1, "20"], [9332, 1, "(1)"], [9333, 1, "(2)"], [9334, 1, "(3)"], [9335, 1, "(4)"], [9336, 1, "(5)"], [9337, 1, "(6)"], [9338, 1, "(7)"], [9339, 1, "(8)"], [9340, 1, "(9)"], [9341, 1, "(10)"], [9342, 1, "(11)"], [9343, 1, "(12)"], [9344, 1, "(13)"], [9345, 1, "(14)"], [9346, 1, "(15)"], [9347, 1, "(16)"], [9348, 1, "(17)"], [9349, 1, "(18)"], [9350, 1, "(19)"], [9351, 1, "(20)"], [[9352, 9371], 3], [9372, 1, "(a)"], [9373, 1, "(b)"], [9374, 1, "(c)"], [9375, 1, "(d)"], [9376, 1, "(e)"], [9377, 1, "(f)"], [9378, 1, "(g)"], [9379, 1, "(h)"], [9380, 1, "(i)"], [9381, 1, "(j)"], [9382, 1, "(k)"], [9383, 1, "(l)"], [9384, 1, "(m)"], [9385, 1, "(n)"], [9386, 1, "(o)"], [9387, 1, "(p)"], [9388, 1, "(q)"], [9389, 1, "(r)"], [9390, 1, "(s)"], [9391, 1, "(t)"], [9392, 1, "(u)"], [9393, 1, "(v)"], [9394, 1, "(w)"], [9395, 1, "(x)"], [9396, 1, "(y)"], [9397, 1, "(z)"], [9398, 1, "a"], [9399, 1, "b"], [9400, 1, "c"], [9401, 1, "d"], [9402, 1, "e"], [9403, 1, "f"], [9404, 1, "g"], [9405, 1, "h"], [9406, 1, "i"], [9407, 1, "j"], [9408, 1, "k"], [9409, 1, "l"], [9410, 1, "m"], [9411, 1, "n"], [9412, 1, "o"], [9413, 1, "p"], [9414, 1, "q"], [9415, 1, "r"], [9416, 1, "s"], [9417, 1, "t"], [9418, 1, "u"], [9419, 1, "v"], [9420, 1, "w"], [9421, 1, "x"], [9422, 1, "y"], [9423, 1, "z"], [9424, 1, "a"], [9425, 1, "b"], [9426, 1, "c"], [9427, 1, "d"], [9428, 1, "e"], [9429, 1, "f"], [9430, 1, "g"], [9431, 1, "h"], [9432, 1, "i"], [9433, 1, "j"], [9434, 1, "k"], [9435, 1, "l"], [9436, 1, "m"], [9437, 1, "n"], [9438, 1, "o"], [9439, 1, "p"], [9440, 1, "q"], [9441, 1, "r"], [9442, 1, "s"], [9443, 1, "t"], [9444, 1, "u"], [9445, 1, "v"], [9446, 1, "w"], [9447, 1, "x"], [9448, 1, "y"], [9449, 1, "z"], [9450, 1, "0"], [[9451, 9470], 2], [9471, 2], [[9472, 9621], 2], [[9622, 9631], 2], [[9632, 9711], 2], [[9712, 9719], 2], [[9720, 9727], 2], [[9728, 9747], 2], [[9748, 9749], 2], [[9750, 9751], 2], [9752, 2], [9753, 2], [[9754, 9839], 2], [[9840, 9841], 2], [[9842, 9853], 2], [[9854, 9855], 2], [[9856, 9865], 2], [[9866, 9873], 2], [[9874, 9884], 2], [9885, 2], [[9886, 9887], 2], [[9888, 9889], 2], [[9890, 9905], 2], [9906, 2], [[9907, 9916], 2], [[9917, 9919], 2], [[9920, 9923], 2], [[9924, 9933], 2], [9934, 2], [[9935, 9953], 2], [9954, 2], [9955, 2], [[9956, 9959], 2], [[9960, 9983], 2], [9984, 2], [[9985, 9988], 2], [9989, 2], [[9990, 9993], 2], [[9994, 9995], 2], [[9996, 10023], 2], [10024, 2], [[10025, 10059], 2], [10060, 2], [10061, 2], [10062, 2], [[10063, 10066], 2], [[10067, 10069], 2], [10070, 2], [10071, 2], [[10072, 10078], 2], [[10079, 10080], 2], [[10081, 10087], 2], [[10088, 10101], 2], [[10102, 10132], 2], [[10133, 10135], 2], [[10136, 10159], 2], [10160, 2], [[10161, 10174], 2], [10175, 2], [[10176, 10182], 2], [[10183, 10186], 2], [10187, 2], [10188, 2], [10189, 2], [[10190, 10191], 2], [[10192, 10219], 2], [[10220, 10223], 2], [[10224, 10239], 2], [[10240, 10495], 2], [[10496, 10763], 2], [10764, 1, "\u222B\u222B\u222B\u222B"], [[10765, 10867], 2], [10868, 1, "::="], [10869, 1, "=="], [10870, 1, "==="], [[10871, 10971], 2], [10972, 1, "\u2ADD\u0338"], [[10973, 11007], 2], [[11008, 11021], 2], [[11022, 11027], 2], [[11028, 11034], 2], [[11035, 11039], 2], [[11040, 11043], 2], [[11044, 11084], 2], [[11085, 11087], 2], [[11088, 11092], 2], [[11093, 11097], 2], [[11098, 11123], 2], [[11124, 11125], 3], [[11126, 11157], 2], [11158, 3], [11159, 2], [[11160, 11193], 2], [[11194, 11196], 2], [[11197, 11208], 2], [11209, 2], [[11210, 11217], 2], [11218, 2], [[11219, 11243], 2], [[11244, 11247], 2], [[11248, 11262], 2], [11263, 2], [11264, 1, "\u2C30"], [11265, 1, "\u2C31"], [11266, 1, "\u2C32"], [11267, 1, "\u2C33"], [11268, 1, "\u2C34"], [11269, 1, "\u2C35"], [11270, 1, "\u2C36"], [11271, 1, "\u2C37"], [11272, 1, "\u2C38"], [11273, 1, "\u2C39"], [11274, 1, "\u2C3A"], [11275, 1, "\u2C3B"], [11276, 1, "\u2C3C"], [11277, 1, "\u2C3D"], [11278, 1, "\u2C3E"], [11279, 1, "\u2C3F"], [11280, 1, "\u2C40"], [11281, 1, "\u2C41"], [11282, 1, "\u2C42"], [11283, 1, "\u2C43"], [11284, 1, "\u2C44"], [11285, 1, "\u2C45"], [11286, 1, "\u2C46"], [11287, 1, "\u2C47"], [11288, 1, "\u2C48"], [11289, 1, "\u2C49"], [11290, 1, "\u2C4A"], [11291, 1, "\u2C4B"], [11292, 1, "\u2C4C"], [11293, 1, "\u2C4D"], [11294, 1, "\u2C4E"], [11295, 1, "\u2C4F"], [11296, 1, "\u2C50"], [11297, 1, "\u2C51"], [11298, 1, "\u2C52"], [11299, 1, "\u2C53"], [11300, 1, "\u2C54"], [11301, 1, "\u2C55"], [11302, 1, "\u2C56"], [11303, 1, "\u2C57"], [11304, 1, "\u2C58"], [11305, 1, "\u2C59"], [11306, 1, "\u2C5A"], [11307, 1, "\u2C5B"], [11308, 1, "\u2C5C"], [11309, 1, "\u2C5D"], [11310, 1, "\u2C5E"], [11311, 1, "\u2C5F"], [[11312, 11358], 2], [11359, 2], [11360, 1, "\u2C61"], [11361, 2], [11362, 1, "\u026B"], [11363, 1, "\u1D7D"], [11364, 1, "\u027D"], [[11365, 11366], 2], [11367, 1, "\u2C68"], [11368, 2], [11369, 1, "\u2C6A"], [11370, 2], [11371, 1, "\u2C6C"], [11372, 2], [11373, 1, "\u0251"], [11374, 1, "\u0271"], [11375, 1, "\u0250"], [11376, 1, "\u0252"], [11377, 2], [11378, 1, "\u2C73"], [11379, 2], [11380, 2], [11381, 1, "\u2C76"], [[11382, 11383], 2], [[11384, 11387], 2], [11388, 1, "j"], [11389, 1, "v"], [11390, 1, "\u023F"], [11391, 1, "\u0240"], [11392, 1, "\u2C81"], [11393, 2], [11394, 1, "\u2C83"], [11395, 2], [11396, 1, "\u2C85"], [11397, 2], [11398, 1, "\u2C87"], [11399, 2], [11400, 1, "\u2C89"], [11401, 2], [11402, 1, "\u2C8B"], [11403, 2], [11404, 1, "\u2C8D"], [11405, 2], [11406, 1, "\u2C8F"], [11407, 2], [11408, 1, "\u2C91"], [11409, 2], [11410, 1, "\u2C93"], [11411, 2], [11412, 1, "\u2C95"], [11413, 2], [11414, 1, "\u2C97"], [11415, 2], [11416, 1, "\u2C99"], [11417, 2], [11418, 1, "\u2C9B"], [11419, 2], [11420, 1, "\u2C9D"], [11421, 2], [11422, 1, "\u2C9F"], [11423, 2], [11424, 1, "\u2CA1"], [11425, 2], [11426, 1, "\u2CA3"], [11427, 2], [11428, 1, "\u2CA5"], [11429, 2], [11430, 1, "\u2CA7"], [11431, 2], [11432, 1, "\u2CA9"], [11433, 2], [11434, 1, "\u2CAB"], [11435, 2], [11436, 1, "\u2CAD"], [11437, 2], [11438, 1, "\u2CAF"], [11439, 2], [11440, 1, "\u2CB1"], [11441, 2], [11442, 1, "\u2CB3"], [11443, 2], [11444, 1, "\u2CB5"], [11445, 2], [11446, 1, "\u2CB7"], [11447, 2], [11448, 1, "\u2CB9"], [11449, 2], [11450, 1, "\u2CBB"], [11451, 2], [11452, 1, "\u2CBD"], [11453, 2], [11454, 1, "\u2CBF"], [11455, 2], [11456, 1, "\u2CC1"], [11457, 2], [11458, 1, "\u2CC3"], [11459, 2], [11460, 1, "\u2CC5"], [11461, 2], [11462, 1, "\u2CC7"], [11463, 2], [11464, 1, "\u2CC9"], [11465, 2], [11466, 1, "\u2CCB"], [11467, 2], [11468, 1, "\u2CCD"], [11469, 2], [11470, 1, "\u2CCF"], [11471, 2], [11472, 1, "\u2CD1"], [11473, 2], [11474, 1, "\u2CD3"], [11475, 2], [11476, 1, "\u2CD5"], [11477, 2], [11478, 1, "\u2CD7"], [11479, 2], [11480, 1, "\u2CD9"], [11481, 2], [11482, 1, "\u2CDB"], [11483, 2], [11484, 1, "\u2CDD"], [11485, 2], [11486, 1, "\u2CDF"], [11487, 2], [11488, 1, "\u2CE1"], [11489, 2], [11490, 1, "\u2CE3"], [[11491, 11492], 2], [[11493, 11498], 2], [11499, 1, "\u2CEC"], [11500, 2], [11501, 1, "\u2CEE"], [[11502, 11505], 2], [11506, 1, "\u2CF3"], [11507, 2], [[11508, 11512], 3], [[11513, 11519], 2], [[11520, 11557], 2], [11558, 3], [11559, 2], [[11560, 11564], 3], [11565, 2], [[11566, 11567], 3], [[11568, 11621], 2], [[11622, 11623], 2], [[11624, 11630], 3], [11631, 1, "\u2D61"], [11632, 2], [[11633, 11646], 3], [11647, 2], [[11648, 11670], 2], [[11671, 11679], 3], [[11680, 11686], 2], [11687, 3], [[11688, 11694], 2], [11695, 3], [[11696, 11702], 2], [11703, 3], [[11704, 11710], 2], [11711, 3], [[11712, 11718], 2], [11719, 3], [[11720, 11726], 2], [11727, 3], [[11728, 11734], 2], [11735, 3], [[11736, 11742], 2], [11743, 3], [[11744, 11775], 2], [[11776, 11799], 2], [[11800, 11803], 2], [[11804, 11805], 2], [[11806, 11822], 2], [11823, 2], [11824, 2], [11825, 2], [[11826, 11835], 2], [[11836, 11842], 2], [[11843, 11844], 2], [[11845, 11849], 2], [[11850, 11854], 2], [11855, 2], [[11856, 11858], 2], [[11859, 11869], 2], [[11870, 11903], 3], [[11904, 11929], 2], [11930, 3], [[11931, 11934], 2], [11935, 1, "\u6BCD"], [[11936, 12018], 2], [12019, 1, "\u9F9F"], [[12020, 12031], 3], [12032, 1, "\u4E00"], [12033, 1, "\u4E28"], [12034, 1, "\u4E36"], [12035, 1, "\u4E3F"], [12036, 1, "\u4E59"], [12037, 1, "\u4E85"], [12038, 1, "\u4E8C"], [12039, 1, "\u4EA0"], [12040, 1, "\u4EBA"], [12041, 1, "\u513F"], [12042, 1, "\u5165"], [12043, 1, "\u516B"], [12044, 1, "\u5182"], [12045, 1, "\u5196"], [12046, 1, "\u51AB"], [12047, 1, "\u51E0"], [12048, 1, "\u51F5"], [12049, 1, "\u5200"], [12050, 1, "\u529B"], [12051, 1, "\u52F9"], [12052, 1, "\u5315"], [12053, 1, "\u531A"], [12054, 1, "\u5338"], [12055, 1, "\u5341"], [12056, 1, "\u535C"], [12057, 1, "\u5369"], [12058, 1, "\u5382"], [12059, 1, "\u53B6"], [12060, 1, "\u53C8"], [12061, 1, "\u53E3"], [12062, 1, "\u56D7"], [12063, 1, "\u571F"], [12064, 1, "\u58EB"], [12065, 1, "\u5902"], [12066, 1, "\u590A"], [12067, 1, "\u5915"], [12068, 1, "\u5927"], [12069, 1, "\u5973"], [12070, 1, "\u5B50"], [12071, 1, "\u5B80"], [12072, 1, "\u5BF8"], [12073, 1, "\u5C0F"], [12074, 1, "\u5C22"], [12075, 1, "\u5C38"], [12076, 1, "\u5C6E"], [12077, 1, "\u5C71"], [12078, 1, "\u5DDB"], [12079, 1, "\u5DE5"], [12080, 1, "\u5DF1"], [12081, 1, "\u5DFE"], [12082, 1, "\u5E72"], [12083, 1, "\u5E7A"], [12084, 1, "\u5E7F"], [12085, 1, "\u5EF4"], [12086, 1, "\u5EFE"], [12087, 1, "\u5F0B"], [12088, 1, "\u5F13"], [12089, 1, "\u5F50"], [12090, 1, "\u5F61"], [12091, 1, "\u5F73"], [12092, 1, "\u5FC3"], [12093, 1, "\u6208"], [12094, 1, "\u6236"], [12095, 1, "\u624B"], [12096, 1, "\u652F"], [12097, 1, "\u6534"], [12098, 1, "\u6587"], [12099, 1, "\u6597"], [12100, 1, "\u65A4"], [12101, 1, "\u65B9"], [12102, 1, "\u65E0"], [12103, 1, "\u65E5"], [12104, 1, "\u66F0"], [12105, 1, "\u6708"], [12106, 1, "\u6728"], [12107, 1, "\u6B20"], [12108, 1, "\u6B62"], [12109, 1, "\u6B79"], [12110, 1, "\u6BB3"], [12111, 1, "\u6BCB"], [12112, 1, "\u6BD4"], [12113, 1, "\u6BDB"], [12114, 1, "\u6C0F"], [12115, 1, "\u6C14"], [12116, 1, "\u6C34"], [12117, 1, "\u706B"], [12118, 1, "\u722A"], [12119, 1, "\u7236"], [12120, 1, "\u723B"], [12121, 1, "\u723F"], [12122, 1, "\u7247"], [12123, 1, "\u7259"], [12124, 1, "\u725B"], [12125, 1, "\u72AC"], [12126, 1, "\u7384"], [12127, 1, "\u7389"], [12128, 1, "\u74DC"], [12129, 1, "\u74E6"], [12130, 1, "\u7518"], [12131, 1, "\u751F"], [12132, 1, "\u7528"], [12133, 1, "\u7530"], [12134, 1, "\u758B"], [12135, 1, "\u7592"], [12136, 1, "\u7676"], [12137, 1, "\u767D"], [12138, 1, "\u76AE"], [12139, 1, "\u76BF"], [12140, 1, "\u76EE"], [12141, 1, "\u77DB"], [12142, 1, "\u77E2"], [12143, 1, "\u77F3"], [12144, 1, "\u793A"], [12145, 1, "\u79B8"], [12146, 1, "\u79BE"], [12147, 1, "\u7A74"], [12148, 1, "\u7ACB"], [12149, 1, "\u7AF9"], [12150, 1, "\u7C73"], [12151, 1, "\u7CF8"], [12152, 1, "\u7F36"], [12153, 1, "\u7F51"], [12154, 1, "\u7F8A"], [12155, 1, "\u7FBD"], [12156, 1, "\u8001"], [12157, 1, "\u800C"], [12158, 1, "\u8012"], [12159, 1, "\u8033"], [12160, 1, "\u807F"], [12161, 1, "\u8089"], [12162, 1, "\u81E3"], [12163, 1, "\u81EA"], [12164, 1, "\u81F3"], [12165, 1, "\u81FC"], [12166, 1, "\u820C"], [12167, 1, "\u821B"], [12168, 1, "\u821F"], [12169, 1, "\u826E"], [12170, 1, "\u8272"], [12171, 1, "\u8278"], [12172, 1, "\u864D"], [12173, 1, "\u866B"], [12174, 1, "\u8840"], [12175, 1, "\u884C"], [12176, 1, "\u8863"], [12177, 1, "\u897E"], [12178, 1, "\u898B"], [12179, 1, "\u89D2"], [12180, 1, "\u8A00"], [12181, 1, "\u8C37"], [12182, 1, "\u8C46"], [12183, 1, "\u8C55"], [12184, 1, "\u8C78"], [12185, 1, "\u8C9D"], [12186, 1, "\u8D64"], [12187, 1, "\u8D70"], [12188, 1, "\u8DB3"], [12189, 1, "\u8EAB"], [12190, 1, "\u8ECA"], [12191, 1, "\u8F9B"], [12192, 1, "\u8FB0"], [12193, 1, "\u8FB5"], [12194, 1, "\u9091"], [12195, 1, "\u9149"], [12196, 1, "\u91C6"], [12197, 1, "\u91CC"], [12198, 1, "\u91D1"], [12199, 1, "\u9577"], [12200, 1, "\u9580"], [12201, 1, "\u961C"], [12202, 1, "\u96B6"], [12203, 1, "\u96B9"], [12204, 1, "\u96E8"], [12205, 1, "\u9751"], [12206, 1, "\u975E"], [12207, 1, "\u9762"], [12208, 1, "\u9769"], [12209, 1, "\u97CB"], [12210, 1, "\u97ED"], [12211, 1, "\u97F3"], [12212, 1, "\u9801"], [12213, 1, "\u98A8"], [12214, 1, "\u98DB"], [12215, 1, "\u98DF"], [12216, 1, "\u9996"], [12217, 1, "\u9999"], [12218, 1, "\u99AC"], [12219, 1, "\u9AA8"], [12220, 1, "\u9AD8"], [12221, 1, "\u9ADF"], [12222, 1, "\u9B25"], [12223, 1, "\u9B2F"], [12224, 1, "\u9B32"], [12225, 1, "\u9B3C"], [12226, 1, "\u9B5A"], [12227, 1, "\u9CE5"], [12228, 1, "\u9E75"], [12229, 1, "\u9E7F"], [12230, 1, "\u9EA5"], [12231, 1, "\u9EBB"], [12232, 1, "\u9EC3"], [12233, 1, "\u9ECD"], [12234, 1, "\u9ED1"], [12235, 1, "\u9EF9"], [12236, 1, "\u9EFD"], [12237, 1, "\u9F0E"], [12238, 1, "\u9F13"], [12239, 1, "\u9F20"], [12240, 1, "\u9F3B"], [12241, 1, "\u9F4A"], [12242, 1, "\u9F52"], [12243, 1, "\u9F8D"], [12244, 1, "\u9F9C"], [12245, 1, "\u9FA0"], [[12246, 12271], 3], [[12272, 12283], 3], [[12284, 12287], 3], [12288, 1, " "], [12289, 2], [12290, 1, "."], [[12291, 12292], 2], [[12293, 12295], 2], [[12296, 12329], 2], [[12330, 12333], 2], [[12334, 12341], 2], [12342, 1, "\u3012"], [12343, 2], [12344, 1, "\u5341"], [12345, 1, "\u5344"], [12346, 1, "\u5345"], [12347, 2], [12348, 2], [12349, 2], [12350, 2], [12351, 2], [12352, 3], [[12353, 12436], 2], [[12437, 12438], 2], [[12439, 12440], 3], [[12441, 12442], 2], [12443, 1, " \u3099"], [12444, 1, " \u309A"], [[12445, 12446], 2], [12447, 1, "\u3088\u308A"], [12448, 2], [[12449, 12542], 2], [12543, 1, "\u30B3\u30C8"], [[12544, 12548], 3], [[12549, 12588], 2], [12589, 2], [12590, 2], [12591, 2], [12592, 3], [12593, 1, "\u1100"], [12594, 1, "\u1101"], [12595, 1, "\u11AA"], [12596, 1, "\u1102"], [12597, 1, "\u11AC"], [12598, 1, "\u11AD"], [12599, 1, "\u1103"], [12600, 1, "\u1104"], [12601, 1, "\u1105"], [12602, 1, "\u11B0"], [12603, 1, "\u11B1"], [12604, 1, "\u11B2"], [12605, 1, "\u11B3"], [12606, 1, "\u11B4"], [12607, 1, "\u11B5"], [12608, 1, "\u111A"], [12609, 1, "\u1106"], [12610, 1, "\u1107"], [12611, 1, "\u1108"], [12612, 1, "\u1121"], [12613, 1, "\u1109"], [12614, 1, "\u110A"], [12615, 1, "\u110B"], [12616, 1, "\u110C"], [12617, 1, "\u110D"], [12618, 1, "\u110E"], [12619, 1, "\u110F"], [12620, 1, "\u1110"], [12621, 1, "\u1111"], [12622, 1, "\u1112"], [12623, 1, "\u1161"], [12624, 1, "\u1162"], [12625, 1, "\u1163"], [12626, 1, "\u1164"], [12627, 1, "\u1165"], [12628, 1, "\u1166"], [12629, 1, "\u1167"], [12630, 1, "\u1168"], [12631, 1, "\u1169"], [12632, 1, "\u116A"], [12633, 1, "\u116B"], [12634, 1, "\u116C"], [12635, 1, "\u116D"], [12636, 1, "\u116E"], [12637, 1, "\u116F"], [12638, 1, "\u1170"], [12639, 1, "\u1171"], [12640, 1, "\u1172"], [12641, 1, "\u1173"], [12642, 1, "\u1174"], [12643, 1, "\u1175"], [12644, 7], [12645, 1, "\u1114"], [12646, 1, "\u1115"], [12647, 1, "\u11C7"], [12648, 1, "\u11C8"], [12649, 1, "\u11CC"], [12650, 1, "\u11CE"], [12651, 1, "\u11D3"], [12652, 1, "\u11D7"], [12653, 1, "\u11D9"], [12654, 1, "\u111C"], [12655, 1, "\u11DD"], [12656, 1, "\u11DF"], [12657, 1, "\u111D"], [12658, 1, "\u111E"], [12659, 1, "\u1120"], [12660, 1, "\u1122"], [12661, 1, "\u1123"], [12662, 1, "\u1127"], [12663, 1, "\u1129"], [12664, 1, "\u112B"], [12665, 1, "\u112C"], [12666, 1, "\u112D"], [12667, 1, "\u112E"], [12668, 1, "\u112F"], [12669, 1, "\u1132"], [12670, 1, "\u1136"], [12671, 1, "\u1140"], [12672, 1, "\u1147"], [12673, 1, "\u114C"], [12674, 1, "\u11F1"], [12675, 1, "\u11F2"], [12676, 1, "\u1157"], [12677, 1, "\u1158"], [12678, 1, "\u1159"], [12679, 1, "\u1184"], [12680, 1, "\u1185"], [12681, 1, "\u1188"], [12682, 1, "\u1191"], [12683, 1, "\u1192"], [12684, 1, "\u1194"], [12685, 1, "\u119E"], [12686, 1, "\u11A1"], [12687, 3], [[12688, 12689], 2], [12690, 1, "\u4E00"], [12691, 1, "\u4E8C"], [12692, 1, "\u4E09"], [12693, 1, "\u56DB"], [12694, 1, "\u4E0A"], [12695, 1, "\u4E2D"], [12696, 1, "\u4E0B"], [12697, 1, "\u7532"], [12698, 1, "\u4E59"], [12699, 1, "\u4E19"], [12700, 1, "\u4E01"], [12701, 1, "\u5929"], [12702, 1, "\u5730"], [12703, 1, "\u4EBA"], [[12704, 12727], 2], [[12728, 12730], 2], [[12731, 12735], 2], [[12736, 12751], 2], [[12752, 12771], 2], [[12772, 12773], 2], [[12774, 12782], 3], [12783, 3], [[12784, 12799], 2], [12800, 1, "(\u1100)"], [12801, 1, "(\u1102)"], [12802, 1, "(\u1103)"], [12803, 1, "(\u1105)"], [12804, 1, "(\u1106)"], [12805, 1, "(\u1107)"], [12806, 1, "(\u1109)"], [12807, 1, "(\u110B)"], [12808, 1, "(\u110C)"], [12809, 1, "(\u110E)"], [12810, 1, "(\u110F)"], [12811, 1, "(\u1110)"], [12812, 1, "(\u1111)"], [12813, 1, "(\u1112)"], [12814, 1, "(\uAC00)"], [12815, 1, "(\uB098)"], [12816, 1, "(\uB2E4)"], [12817, 1, "(\uB77C)"], [12818, 1, "(\uB9C8)"], [12819, 1, "(\uBC14)"], [12820, 1, "(\uC0AC)"], [12821, 1, "(\uC544)"], [12822, 1, "(\uC790)"], [12823, 1, "(\uCC28)"], [12824, 1, "(\uCE74)"], [12825, 1, "(\uD0C0)"], [12826, 1, "(\uD30C)"], [12827, 1, "(\uD558)"], [12828, 1, "(\uC8FC)"], [12829, 1, "(\uC624\uC804)"], [12830, 1, "(\uC624\uD6C4)"], [12831, 3], [12832, 1, "(\u4E00)"], [12833, 1, "(\u4E8C)"], [12834, 1, "(\u4E09)"], [12835, 1, "(\u56DB)"], [12836, 1, "(\u4E94)"], [12837, 1, "(\u516D)"], [12838, 1, "(\u4E03)"], [12839, 1, "(\u516B)"], [12840, 1, "(\u4E5D)"], [12841, 1, "(\u5341)"], [12842, 1, "(\u6708)"], [12843, 1, "(\u706B)"], [12844, 1, "(\u6C34)"], [12845, 1, "(\u6728)"], [12846, 1, "(\u91D1)"], [12847, 1, "(\u571F)"], [12848, 1, "(\u65E5)"], [12849, 1, "(\u682A)"], [12850, 1, "(\u6709)"], [12851, 1, "(\u793E)"], [12852, 1, "(\u540D)"], [12853, 1, "(\u7279)"], [12854, 1, "(\u8CA1)"], [12855, 1, "(\u795D)"], [12856, 1, "(\u52B4)"], [12857, 1, "(\u4EE3)"], [12858, 1, "(\u547C)"], [12859, 1, "(\u5B66)"], [12860, 1, "(\u76E3)"], [12861, 1, "(\u4F01)"], [12862, 1, "(\u8CC7)"], [12863, 1, "(\u5354)"], [12864, 1, "(\u796D)"], [12865, 1, "(\u4F11)"], [12866, 1, "(\u81EA)"], [12867, 1, "(\u81F3)"], [12868, 1, "\u554F"], [12869, 1, "\u5E7C"], [12870, 1, "\u6587"], [12871, 1, "\u7B8F"], [[12872, 12879], 2], [12880, 1, "pte"], [12881, 1, "21"], [12882, 1, "22"], [12883, 1, "23"], [12884, 1, "24"], [12885, 1, "25"], [12886, 1, "26"], [12887, 1, "27"], [12888, 1, "28"], [12889, 1, "29"], [12890, 1, "30"], [12891, 1, "31"], [12892, 1, "32"], [12893, 1, "33"], [12894, 1, "34"], [12895, 1, "35"], [12896, 1, "\u1100"], [12897, 1, "\u1102"], [12898, 1, "\u1103"], [12899, 1, "\u1105"], [12900, 1, "\u1106"], [12901, 1, "\u1107"], [12902, 1, "\u1109"], [12903, 1, "\u110B"], [12904, 1, "\u110C"], [12905, 1, "\u110E"], [12906, 1, "\u110F"], [12907, 1, "\u1110"], [12908, 1, "\u1111"], [12909, 1, "\u1112"], [12910, 1, "\uAC00"], [12911, 1, "\uB098"], [12912, 1, "\uB2E4"], [12913, 1, "\uB77C"], [12914, 1, "\uB9C8"], [12915, 1, "\uBC14"], [12916, 1, "\uC0AC"], [12917, 1, "\uC544"], [12918, 1, "\uC790"], [12919, 1, "\uCC28"], [12920, 1, "\uCE74"], [12921, 1, "\uD0C0"], [12922, 1, "\uD30C"], [12923, 1, "\uD558"], [12924, 1, "\uCC38\uACE0"], [12925, 1, "\uC8FC\uC758"], [12926, 1, "\uC6B0"], [12927, 2], [12928, 1, "\u4E00"], [12929, 1, "\u4E8C"], [12930, 1, "\u4E09"], [12931, 1, "\u56DB"], [12932, 1, "\u4E94"], [12933, 1, "\u516D"], [12934, 1, "\u4E03"], [12935, 1, "\u516B"], [12936, 1, "\u4E5D"], [12937, 1, "\u5341"], [12938, 1, "\u6708"], [12939, 1, "\u706B"], [12940, 1, "\u6C34"], [12941, 1, "\u6728"], [12942, 1, "\u91D1"], [12943, 1, "\u571F"], [12944, 1, "\u65E5"], [12945, 1, "\u682A"], [12946, 1, "\u6709"], [12947, 1, "\u793E"], [12948, 1, "\u540D"], [12949, 1, "\u7279"], [12950, 1, "\u8CA1"], [12951, 1, "\u795D"], [12952, 1, "\u52B4"], [12953, 1, "\u79D8"], [12954, 1, "\u7537"], [12955, 1, "\u5973"], [12956, 1, "\u9069"], [12957, 1, "\u512A"], [12958, 1, "\u5370"], [12959, 1, "\u6CE8"], [12960, 1, "\u9805"], [12961, 1, "\u4F11"], [12962, 1, "\u5199"], [12963, 1, "\u6B63"], [12964, 1, "\u4E0A"], [12965, 1, "\u4E2D"], [12966, 1, "\u4E0B"], [12967, 1, "\u5DE6"], [12968, 1, "\u53F3"], [12969, 1, "\u533B"], [12970, 1, "\u5B97"], [12971, 1, "\u5B66"], [12972, 1, "\u76E3"], [12973, 1, "\u4F01"], [12974, 1, "\u8CC7"], [12975, 1, "\u5354"], [12976, 1, "\u591C"], [12977, 1, "36"], [12978, 1, "37"], [12979, 1, "38"], [12980, 1, "39"], [12981, 1, "40"], [12982, 1, "41"], [12983, 1, "42"], [12984, 1, "43"], [12985, 1, "44"], [12986, 1, "45"], [12987, 1, "46"], [12988, 1, "47"], [12989, 1, "48"], [12990, 1, "49"], [12991, 1, "50"], [12992, 1, "1\u6708"], [12993, 1, "2\u6708"], [12994, 1, "3\u6708"], [12995, 1, "4\u6708"], [12996, 1, "5\u6708"], [12997, 1, "6\u6708"], [12998, 1, "7\u6708"], [12999, 1, "8\u6708"], [13e3, 1, "9\u6708"], [13001, 1, "10\u6708"], [13002, 1, "11\u6708"], [13003, 1, "12\u6708"], [13004, 1, "hg"], [13005, 1, "erg"], [13006, 1, "ev"], [13007, 1, "ltd"], [13008, 1, "\u30A2"], [13009, 1, "\u30A4"], [13010, 1, "\u30A6"], [13011, 1, "\u30A8"], [13012, 1, "\u30AA"], [13013, 1, "\u30AB"], [13014, 1, "\u30AD"], [13015, 1, "\u30AF"], [13016, 1, "\u30B1"], [13017, 1, "\u30B3"], [13018, 1, "\u30B5"], [13019, 1, "\u30B7"], [13020, 1, "\u30B9"], [13021, 1, "\u30BB"], [13022, 1, "\u30BD"], [13023, 1, "\u30BF"], [13024, 1, "\u30C1"], [13025, 1, "\u30C4"], [13026, 1, "\u30C6"], [13027, 1, "\u30C8"], [13028, 1, "\u30CA"], [13029, 1, "\u30CB"], [13030, 1, "\u30CC"], [13031, 1, "\u30CD"], [13032, 1, "\u30CE"], [13033, 1, "\u30CF"], [13034, 1, "\u30D2"], [13035, 1, "\u30D5"], [13036, 1, "\u30D8"], [13037, 1, "\u30DB"], [13038, 1, "\u30DE"], [13039, 1, "\u30DF"], [13040, 1, "\u30E0"], [13041, 1, "\u30E1"], [13042, 1, "\u30E2"], [13043, 1, "\u30E4"], [13044, 1, "\u30E6"], [13045, 1, "\u30E8"], [13046, 1, "\u30E9"], [13047, 1, "\u30EA"], [13048, 1, "\u30EB"], [13049, 1, "\u30EC"], [13050, 1, "\u30ED"], [13051, 1, "\u30EF"], [13052, 1, "\u30F0"], [13053, 1, "\u30F1"], [13054, 1, "\u30F2"], [13055, 1, "\u4EE4\u548C"], [13056, 1, "\u30A2\u30D1\u30FC\u30C8"], [13057, 1, "\u30A2\u30EB\u30D5\u30A1"], [13058, 1, "\u30A2\u30F3\u30DA\u30A2"], [13059, 1, "\u30A2\u30FC\u30EB"], [13060, 1, "\u30A4\u30CB\u30F3\u30B0"], [13061, 1, "\u30A4\u30F3\u30C1"], [13062, 1, "\u30A6\u30A9\u30F3"], [13063, 1, "\u30A8\u30B9\u30AF\u30FC\u30C9"], [13064, 1, "\u30A8\u30FC\u30AB\u30FC"], [13065, 1, "\u30AA\u30F3\u30B9"], [13066, 1, "\u30AA\u30FC\u30E0"], [13067, 1, "\u30AB\u30A4\u30EA"], [13068, 1, "\u30AB\u30E9\u30C3\u30C8"], [13069, 1, "\u30AB\u30ED\u30EA\u30FC"], [13070, 1, "\u30AC\u30ED\u30F3"], [13071, 1, "\u30AC\u30F3\u30DE"], [13072, 1, "\u30AE\u30AC"], [13073, 1, "\u30AE\u30CB\u30FC"], [13074, 1, "\u30AD\u30E5\u30EA\u30FC"], [13075, 1, "\u30AE\u30EB\u30C0\u30FC"], [13076, 1, "\u30AD\u30ED"], [13077, 1, "\u30AD\u30ED\u30B0\u30E9\u30E0"], [13078, 1, "\u30AD\u30ED\u30E1\u30FC\u30C8\u30EB"], [13079, 1, "\u30AD\u30ED\u30EF\u30C3\u30C8"], [13080, 1, "\u30B0\u30E9\u30E0"], [13081, 1, "\u30B0\u30E9\u30E0\u30C8\u30F3"], [13082, 1, "\u30AF\u30EB\u30BC\u30A4\u30ED"], [13083, 1, "\u30AF\u30ED\u30FC\u30CD"], [13084, 1, "\u30B1\u30FC\u30B9"], [13085, 1, "\u30B3\u30EB\u30CA"], [13086, 1, "\u30B3\u30FC\u30DD"], [13087, 1, "\u30B5\u30A4\u30AF\u30EB"], [13088, 1, "\u30B5\u30F3\u30C1\u30FC\u30E0"], [13089, 1, "\u30B7\u30EA\u30F3\u30B0"], [13090, 1, "\u30BB\u30F3\u30C1"], [13091, 1, "\u30BB\u30F3\u30C8"], [13092, 1, "\u30C0\u30FC\u30B9"], [13093, 1, "\u30C7\u30B7"], [13094, 1, "\u30C9\u30EB"], [13095, 1, "\u30C8\u30F3"], [13096, 1, "\u30CA\u30CE"], [13097, 1, "\u30CE\u30C3\u30C8"], [13098, 1, "\u30CF\u30A4\u30C4"], [13099, 1, "\u30D1\u30FC\u30BB\u30F3\u30C8"], [13100, 1, "\u30D1\u30FC\u30C4"], [13101, 1, "\u30D0\u30FC\u30EC\u30EB"], [13102, 1, "\u30D4\u30A2\u30B9\u30C8\u30EB"], [13103, 1, "\u30D4\u30AF\u30EB"], [13104, 1, "\u30D4\u30B3"], [13105, 1, "\u30D3\u30EB"], [13106, 1, "\u30D5\u30A1\u30E9\u30C3\u30C9"], [13107, 1, "\u30D5\u30A3\u30FC\u30C8"], [13108, 1, "\u30D6\u30C3\u30B7\u30A7\u30EB"], [13109, 1, "\u30D5\u30E9\u30F3"], [13110, 1, "\u30D8\u30AF\u30BF\u30FC\u30EB"], [13111, 1, "\u30DA\u30BD"], [13112, 1, "\u30DA\u30CB\u30D2"], [13113, 1, "\u30D8\u30EB\u30C4"], [13114, 1, "\u30DA\u30F3\u30B9"], [13115, 1, "\u30DA\u30FC\u30B8"], [13116, 1, "\u30D9\u30FC\u30BF"], [13117, 1, "\u30DD\u30A4\u30F3\u30C8"], [13118, 1, "\u30DC\u30EB\u30C8"], [13119, 1, "\u30DB\u30F3"], [13120, 1, "\u30DD\u30F3\u30C9"], [13121, 1, "\u30DB\u30FC\u30EB"], [13122, 1, "\u30DB\u30FC\u30F3"], [13123, 1, "\u30DE\u30A4\u30AF\u30ED"], [13124, 1, "\u30DE\u30A4\u30EB"], [13125, 1, "\u30DE\u30C3\u30CF"], [13126, 1, "\u30DE\u30EB\u30AF"], [13127, 1, "\u30DE\u30F3\u30B7\u30E7\u30F3"], [13128, 1, "\u30DF\u30AF\u30ED\u30F3"], [13129, 1, "\u30DF\u30EA"], [13130, 1, "\u30DF\u30EA\u30D0\u30FC\u30EB"], [13131, 1, "\u30E1\u30AC"], [13132, 1, "\u30E1\u30AC\u30C8\u30F3"], [13133, 1, "\u30E1\u30FC\u30C8\u30EB"], [13134, 1, "\u30E4\u30FC\u30C9"], [13135, 1, "\u30E4\u30FC\u30EB"], [13136, 1, "\u30E6\u30A2\u30F3"], [13137, 1, "\u30EA\u30C3\u30C8\u30EB"], [13138, 1, "\u30EA\u30E9"], [13139, 1, "\u30EB\u30D4\u30FC"], [13140, 1, "\u30EB\u30FC\u30D6\u30EB"], [13141, 1, "\u30EC\u30E0"], [13142, 1, "\u30EC\u30F3\u30C8\u30B2\u30F3"], [13143, 1, "\u30EF\u30C3\u30C8"], [13144, 1, "0\u70B9"], [13145, 1, "1\u70B9"], [13146, 1, "2\u70B9"], [13147, 1, "3\u70B9"], [13148, 1, "4\u70B9"], [13149, 1, "5\u70B9"], [13150, 1, "6\u70B9"], [13151, 1, "7\u70B9"], [13152, 1, "8\u70B9"], [13153, 1, "9\u70B9"], [13154, 1, "10\u70B9"], [13155, 1, "11\u70B9"], [13156, 1, "12\u70B9"], [13157, 1, "13\u70B9"], [13158, 1, "14\u70B9"], [13159, 1, "15\u70B9"], [13160, 1, "16\u70B9"], [13161, 1, "17\u70B9"], [13162, 1, "18\u70B9"], [13163, 1, "19\u70B9"], [13164, 1, "20\u70B9"], [13165, 1, "21\u70B9"], [13166, 1, "22\u70B9"], [13167, 1, "23\u70B9"], [13168, 1, "24\u70B9"], [13169, 1, "hpa"], [13170, 1, "da"], [13171, 1, "au"], [13172, 1, "bar"], [13173, 1, "ov"], [13174, 1, "pc"], [13175, 1, "dm"], [13176, 1, "dm2"], [13177, 1, "dm3"], [13178, 1, "iu"], [13179, 1, "\u5E73\u6210"], [13180, 1, "\u662D\u548C"], [13181, 1, "\u5927\u6B63"], [13182, 1, "\u660E\u6CBB"], [13183, 1, "\u682A\u5F0F\u4F1A\u793E"], [13184, 1, "pa"], [13185, 1, "na"], [13186, 1, "\u03BCa"], [13187, 1, "ma"], [13188, 1, "ka"], [13189, 1, "kb"], [13190, 1, "mb"], [13191, 1, "gb"], [13192, 1, "cal"], [13193, 1, "kcal"], [13194, 1, "pf"], [13195, 1, "nf"], [13196, 1, "\u03BCf"], [13197, 1, "\u03BCg"], [13198, 1, "mg"], [13199, 1, "kg"], [13200, 1, "hz"], [13201, 1, "khz"], [13202, 1, "mhz"], [13203, 1, "ghz"], [13204, 1, "thz"], [13205, 1, "\u03BCl"], [13206, 1, "ml"], [13207, 1, "dl"], [13208, 1, "kl"], [13209, 1, "fm"], [13210, 1, "nm"], [13211, 1, "\u03BCm"], [13212, 1, "mm"], [13213, 1, "cm"], [13214, 1, "km"], [13215, 1, "mm2"], [13216, 1, "cm2"], [13217, 1, "m2"], [13218, 1, "km2"], [13219, 1, "mm3"], [13220, 1, "cm3"], [13221, 1, "m3"], [13222, 1, "km3"], [13223, 1, "m\u2215s"], [13224, 1, "m\u2215s2"], [13225, 1, "pa"], [13226, 1, "kpa"], [13227, 1, "mpa"], [13228, 1, "gpa"], [13229, 1, "rad"], [13230, 1, "rad\u2215s"], [13231, 1, "rad\u2215s2"], [13232, 1, "ps"], [13233, 1, "ns"], [13234, 1, "\u03BCs"], [13235, 1, "ms"], [13236, 1, "pv"], [13237, 1, "nv"], [13238, 1, "\u03BCv"], [13239, 1, "mv"], [13240, 1, "kv"], [13241, 1, "mv"], [13242, 1, "pw"], [13243, 1, "nw"], [13244, 1, "\u03BCw"], [13245, 1, "mw"], [13246, 1, "kw"], [13247, 1, "mw"], [13248, 1, "k\u03C9"], [13249, 1, "m\u03C9"], [13250, 3], [13251, 1, "bq"], [13252, 1, "cc"], [13253, 1, "cd"], [13254, 1, "c\u2215kg"], [13255, 3], [13256, 1, "db"], [13257, 1, "gy"], [13258, 1, "ha"], [13259, 1, "hp"], [13260, 1, "in"], [13261, 1, "kk"], [13262, 1, "km"], [13263, 1, "kt"], [13264, 1, "lm"], [13265, 1, "ln"], [13266, 1, "log"], [13267, 1, "lx"], [13268, 1, "mb"], [13269, 1, "mil"], [13270, 1, "mol"], [13271, 1, "ph"], [13272, 3], [13273, 1, "ppm"], [13274, 1, "pr"], [13275, 1, "sr"], [13276, 1, "sv"], [13277, 1, "wb"], [13278, 1, "v\u2215m"], [13279, 1, "a\u2215m"], [13280, 1, "1\u65E5"], [13281, 1, "2\u65E5"], [13282, 1, "3\u65E5"], [13283, 1, "4\u65E5"], [13284, 1, "5\u65E5"], [13285, 1, "6\u65E5"], [13286, 1, "7\u65E5"], [13287, 1, "8\u65E5"], [13288, 1, "9\u65E5"], [13289, 1, "10\u65E5"], [13290, 1, "11\u65E5"], [13291, 1, "12\u65E5"], [13292, 1, "13\u65E5"], [13293, 1, "14\u65E5"], [13294, 1, "15\u65E5"], [13295, 1, "16\u65E5"], [13296, 1, "17\u65E5"], [13297, 1, "18\u65E5"], [13298, 1, "19\u65E5"], [13299, 1, "20\u65E5"], [13300, 1, "21\u65E5"], [13301, 1, "22\u65E5"], [13302, 1, "23\u65E5"], [13303, 1, "24\u65E5"], [13304, 1, "25\u65E5"], [13305, 1, "26\u65E5"], [13306, 1, "27\u65E5"], [13307, 1, "28\u65E5"], [13308, 1, "29\u65E5"], [13309, 1, "30\u65E5"], [13310, 1, "31\u65E5"], [13311, 1, "gal"], [[13312, 19893], 2], [[19894, 19903], 2], [[19904, 19967], 2], [[19968, 40869], 2], [[40870, 40891], 2], [[40892, 40899], 2], [[40900, 40907], 2], [40908, 2], [[40909, 40917], 2], [[40918, 40938], 2], [[40939, 40943], 2], [[40944, 40956], 2], [[40957, 40959], 2], [[40960, 42124], 2], [[42125, 42127], 3], [[42128, 42145], 2], [[42146, 42147], 2], [[42148, 42163], 2], [42164, 2], [[42165, 42176], 2], [42177, 2], [[42178, 42180], 2], [42181, 2], [42182, 2], [[42183, 42191], 3], [[42192, 42237], 2], [[42238, 42239], 2], [[42240, 42508], 2], [[42509, 42511], 2], [[42512, 42539], 2], [[42540, 42559], 3], [42560, 1, "\uA641"], [42561, 2], [42562, 1, "\uA643"], [42563, 2], [42564, 1, "\uA645"], [42565, 2], [42566, 1, "\uA647"], [42567, 2], [42568, 1, "\uA649"], [42569, 2], [42570, 1, "\uA64B"], [42571, 2], [42572, 1, "\uA64D"], [42573, 2], [42574, 1, "\uA64F"], [42575, 2], [42576, 1, "\uA651"], [42577, 2], [42578, 1, "\uA653"], [42579, 2], [42580, 1, "\uA655"], [42581, 2], [42582, 1, "\uA657"], [42583, 2], [42584, 1, "\uA659"], [42585, 2], [42586, 1, "\uA65B"], [42587, 2], [42588, 1, "\uA65D"], [42589, 2], [42590, 1, "\uA65F"], [42591, 2], [42592, 1, "\uA661"], [42593, 2], [42594, 1, "\uA663"], [42595, 2], [42596, 1, "\uA665"], [42597, 2], [42598, 1, "\uA667"], [42599, 2], [42600, 1, "\uA669"], [42601, 2], [42602, 1, "\uA66B"], [42603, 2], [42604, 1, "\uA66D"], [[42605, 42607], 2], [[42608, 42611], 2], [[42612, 42619], 2], [[42620, 42621], 2], [42622, 2], [42623, 2], [42624, 1, "\uA681"], [42625, 2], [42626, 1, "\uA683"], [42627, 2], [42628, 1, "\uA685"], [42629, 2], [42630, 1, "\uA687"], [42631, 2], [42632, 1, "\uA689"], [42633, 2], [42634, 1, "\uA68B"], [42635, 2], [42636, 1, "\uA68D"], [42637, 2], [42638, 1, "\uA68F"], [42639, 2], [42640, 1, "\uA691"], [42641, 2], [42642, 1, "\uA693"], [42643, 2], [42644, 1, "\uA695"], [42645, 2], [42646, 1, "\uA697"], [42647, 2], [42648, 1, "\uA699"], [42649, 2], [42650, 1, "\uA69B"], [42651, 2], [42652, 1, "\u044A"], [42653, 1, "\u044C"], [42654, 2], [42655, 2], [[42656, 42725], 2], [[42726, 42735], 2], [[42736, 42737], 2], [[42738, 42743], 2], [[42744, 42751], 3], [[42752, 42774], 2], [[42775, 42778], 2], [[42779, 42783], 2], [[42784, 42785], 2], [42786, 1, "\uA723"], [42787, 2], [42788, 1, "\uA725"], [42789, 2], [42790, 1, "\uA727"], [42791, 2], [42792, 1, "\uA729"], [42793, 2], [42794, 1, "\uA72B"], [42795, 2], [42796, 1, "\uA72D"], [42797, 2], [42798, 1, "\uA72F"], [[42799, 42801], 2], [42802, 1, "\uA733"], [42803, 2], [42804, 1, "\uA735"], [42805, 2], [42806, 1, "\uA737"], [42807, 2], [42808, 1, "\uA739"], [42809, 2], [42810, 1, "\uA73B"], [42811, 2], [42812, 1, "\uA73D"], [42813, 2], [42814, 1, "\uA73F"], [42815, 2], [42816, 1, "\uA741"], [42817, 2], [42818, 1, "\uA743"], [42819, 2], [42820, 1, "\uA745"], [42821, 2], [42822, 1, "\uA747"], [42823, 2], [42824, 1, "\uA749"], [42825, 2], [42826, 1, "\uA74B"], [42827, 2], [42828, 1, "\uA74D"], [42829, 2], [42830, 1, "\uA74F"], [42831, 2], [42832, 1, "\uA751"], [42833, 2], [42834, 1, "\uA753"], [42835, 2], [42836, 1, "\uA755"], [42837, 2], [42838, 1, "\uA757"], [42839, 2], [42840, 1, "\uA759"], [42841, 2], [42842, 1, "\uA75B"], [42843, 2], [42844, 1, "\uA75D"], [42845, 2], [42846, 1, "\uA75F"], [42847, 2], [42848, 1, "\uA761"], [42849, 2], [42850, 1, "\uA763"], [42851, 2], [42852, 1, "\uA765"], [42853, 2], [42854, 1, "\uA767"], [42855, 2], [42856, 1, "\uA769"], [42857, 2], [42858, 1, "\uA76B"], [42859, 2], [42860, 1, "\uA76D"], [42861, 2], [42862, 1, "\uA76F"], [42863, 2], [42864, 1, "\uA76F"], [[42865, 42872], 2], [42873, 1, "\uA77A"], [42874, 2], [42875, 1, "\uA77C"], [42876, 2], [42877, 1, "\u1D79"], [42878, 1, "\uA77F"], [42879, 2], [42880, 1, "\uA781"], [42881, 2], [42882, 1, "\uA783"], [42883, 2], [42884, 1, "\uA785"], [42885, 2], [42886, 1, "\uA787"], [[42887, 42888], 2], [[42889, 42890], 2], [42891, 1, "\uA78C"], [42892, 2], [42893, 1, "\u0265"], [42894, 2], [42895, 2], [42896, 1, "\uA791"], [42897, 2], [42898, 1, "\uA793"], [42899, 2], [[42900, 42901], 2], [42902, 1, "\uA797"], [42903, 2], [42904, 1, "\uA799"], [42905, 2], [42906, 1, "\uA79B"], [42907, 2], [42908, 1, "\uA79D"], [42909, 2], [42910, 1, "\uA79F"], [42911, 2], [42912, 1, "\uA7A1"], [42913, 2], [42914, 1, "\uA7A3"], [42915, 2], [42916, 1, "\uA7A5"], [42917, 2], [42918, 1, "\uA7A7"], [42919, 2], [42920, 1, "\uA7A9"], [42921, 2], [42922, 1, "\u0266"], [42923, 1, "\u025C"], [42924, 1, "\u0261"], [42925, 1, "\u026C"], [42926, 1, "\u026A"], [42927, 2], [42928, 1, "\u029E"], [42929, 1, "\u0287"], [42930, 1, "\u029D"], [42931, 1, "\uAB53"], [42932, 1, "\uA7B5"], [42933, 2], [42934, 1, "\uA7B7"], [42935, 2], [42936, 1, "\uA7B9"], [42937, 2], [42938, 1, "\uA7BB"], [42939, 2], [42940, 1, "\uA7BD"], [42941, 2], [42942, 1, "\uA7BF"], [42943, 2], [42944, 1, "\uA7C1"], [42945, 2], [42946, 1, "\uA7C3"], [42947, 2], [42948, 1, "\uA794"], [42949, 1, "\u0282"], [42950, 1, "\u1D8E"], [42951, 1, "\uA7C8"], [42952, 2], [42953, 1, "\uA7CA"], [42954, 2], [42955, 1, "\u0264"], [42956, 1, "\uA7CD"], [42957, 2], [[42958, 42959], 3], [42960, 1, "\uA7D1"], [42961, 2], [42962, 3], [42963, 2], [42964, 3], [42965, 2], [42966, 1, "\uA7D7"], [42967, 2], [42968, 1, "\uA7D9"], [42969, 2], [42970, 1, "\uA7DB"], [42971, 2], [42972, 1, "\u019B"], [[42973, 42993], 3], [42994, 1, "c"], [42995, 1, "f"], [42996, 1, "q"], [42997, 1, "\uA7F6"], [42998, 2], [42999, 2], [43e3, 1, "\u0127"], [43001, 1, "\u0153"], [43002, 2], [[43003, 43007], 2], [[43008, 43047], 2], [[43048, 43051], 2], [43052, 2], [[43053, 43055], 3], [[43056, 43065], 2], [[43066, 43071], 3], [[43072, 43123], 2], [[43124, 43127], 2], [[43128, 43135], 3], [[43136, 43204], 2], [43205, 2], [[43206, 43213], 3], [[43214, 43215], 2], [[43216, 43225], 2], [[43226, 43231], 3], [[43232, 43255], 2], [[43256, 43258], 2], [43259, 2], [43260, 2], [43261, 2], [[43262, 43263], 2], [[43264, 43309], 2], [[43310, 43311], 2], [[43312, 43347], 2], [[43348, 43358], 3], [43359, 2], [[43360, 43388], 2], [[43389, 43391], 3], [[43392, 43456], 2], [[43457, 43469], 2], [43470, 3], [[43471, 43481], 2], [[43482, 43485], 3], [[43486, 43487], 2], [[43488, 43518], 2], [43519, 3], [[43520, 43574], 2], [[43575, 43583], 3], [[43584, 43597], 2], [[43598, 43599], 3], [[43600, 43609], 2], [[43610, 43611], 3], [[43612, 43615], 2], [[43616, 43638], 2], [[43639, 43641], 2], [[43642, 43643], 2], [[43644, 43647], 2], [[43648, 43714], 2], [[43715, 43738], 3], [[43739, 43741], 2], [[43742, 43743], 2], [[43744, 43759], 2], [[43760, 43761], 2], [[43762, 43766], 2], [[43767, 43776], 3], [[43777, 43782], 2], [[43783, 43784], 3], [[43785, 43790], 2], [[43791, 43792], 3], [[43793, 43798], 2], [[43799, 43807], 3], [[43808, 43814], 2], [43815, 3], [[43816, 43822], 2], [43823, 3], [[43824, 43866], 2], [43867, 2], [43868, 1, "\uA727"], [43869, 1, "\uAB37"], [43870, 1, "\u026B"], [43871, 1, "\uAB52"], [[43872, 43875], 2], [[43876, 43877], 2], [[43878, 43879], 2], [43880, 2], [43881, 1, "\u028D"], [[43882, 43883], 2], [[43884, 43887], 3], [43888, 1, "\u13A0"], [43889, 1, "\u13A1"], [43890, 1, "\u13A2"], [43891, 1, "\u13A3"], [43892, 1, "\u13A4"], [43893, 1, "\u13A5"], [43894, 1, "\u13A6"], [43895, 1, "\u13A7"], [43896, 1, "\u13A8"], [43897, 1, "\u13A9"], [43898, 1, "\u13AA"], [43899, 1, "\u13AB"], [43900, 1, "\u13AC"], [43901, 1, "\u13AD"], [43902, 1, "\u13AE"], [43903, 1, "\u13AF"], [43904, 1, "\u13B0"], [43905, 1, "\u13B1"], [43906, 1, "\u13B2"], [43907, 1, "\u13B3"], [43908, 1, "\u13B4"], [43909, 1, "\u13B5"], [43910, 1, "\u13B6"], [43911, 1, "\u13B7"], [43912, 1, "\u13B8"], [43913, 1, "\u13B9"], [43914, 1, "\u13BA"], [43915, 1, "\u13BB"], [43916, 1, "\u13BC"], [43917, 1, "\u13BD"], [43918, 1, "\u13BE"], [43919, 1, "\u13BF"], [43920, 1, "\u13C0"], [43921, 1, "\u13C1"], [43922, 1, "\u13C2"], [43923, 1, "\u13C3"], [43924, 1, "\u13C4"], [43925, 1, "\u13C5"], [43926, 1, "\u13C6"], [43927, 1, "\u13C7"], [43928, 1, "\u13C8"], [43929, 1, "\u13C9"], [43930, 1, "\u13CA"], [43931, 1, "\u13CB"], [43932, 1, "\u13CC"], [43933, 1, "\u13CD"], [43934, 1, "\u13CE"], [43935, 1, "\u13CF"], [43936, 1, "\u13D0"], [43937, 1, "\u13D1"], [43938, 1, "\u13D2"], [43939, 1, "\u13D3"], [43940, 1, "\u13D4"], [43941, 1, "\u13D5"], [43942, 1, "\u13D6"], [43943, 1, "\u13D7"], [43944, 1, "\u13D8"], [43945, 1, "\u13D9"], [43946, 1, "\u13DA"], [43947, 1, "\u13DB"], [43948, 1, "\u13DC"], [43949, 1, "\u13DD"], [43950, 1, "\u13DE"], [43951, 1, "\u13DF"], [43952, 1, "\u13E0"], [43953, 1, "\u13E1"], [43954, 1, "\u13E2"], [43955, 1, "\u13E3"], [43956, 1, "\u13E4"], [43957, 1, "\u13E5"], [43958, 1, "\u13E6"], [43959, 1, "\u13E7"], [43960, 1, "\u13E8"], [43961, 1, "\u13E9"], [43962, 1, "\u13EA"], [43963, 1, "\u13EB"], [43964, 1, "\u13EC"], [43965, 1, "\u13ED"], [43966, 1, "\u13EE"], [43967, 1, "\u13EF"], [[43968, 44010], 2], [44011, 2], [[44012, 44013], 2], [[44014, 44015], 3], [[44016, 44025], 2], [[44026, 44031], 3], [[44032, 55203], 2], [[55204, 55215], 3], [[55216, 55238], 2], [[55239, 55242], 3], [[55243, 55291], 2], [[55292, 55295], 3], [[55296, 57343], 3], [[57344, 63743], 3], [63744, 1, "\u8C48"], [63745, 1, "\u66F4"], [63746, 1, "\u8ECA"], [63747, 1, "\u8CC8"], [63748, 1, "\u6ED1"], [63749, 1, "\u4E32"], [63750, 1, "\u53E5"], [[63751, 63752], 1, "\u9F9C"], [63753, 1, "\u5951"], [63754, 1, "\u91D1"], [63755, 1, "\u5587"], [63756, 1, "\u5948"], [63757, 1, "\u61F6"], [63758, 1, "\u7669"], [63759, 1, "\u7F85"], [63760, 1, "\u863F"], [63761, 1, "\u87BA"], [63762, 1, "\u88F8"], [63763, 1, "\u908F"], [63764, 1, "\u6A02"], [63765, 1, "\u6D1B"], [63766, 1, "\u70D9"], [63767, 1, "\u73DE"], [63768, 1, "\u843D"], [63769, 1, "\u916A"], [63770, 1, "\u99F1"], [63771, 1, "\u4E82"], [63772, 1, "\u5375"], [63773, 1, "\u6B04"], [63774, 1, "\u721B"], [63775, 1, "\u862D"], [63776, 1, "\u9E1E"], [63777, 1, "\u5D50"], [63778, 1, "\u6FEB"], [63779, 1, "\u85CD"], [63780, 1, "\u8964"], [63781, 1, "\u62C9"], [63782, 1, "\u81D8"], [63783, 1, "\u881F"], [63784, 1, "\u5ECA"], [63785, 1, "\u6717"], [63786, 1, "\u6D6A"], [63787, 1, "\u72FC"], [63788, 1, "\u90CE"], [63789, 1, "\u4F86"], [63790, 1, "\u51B7"], [63791, 1, "\u52DE"], [63792, 1, "\u64C4"], [63793, 1, "\u6AD3"], [63794, 1, "\u7210"], [63795, 1, "\u76E7"], [63796, 1, "\u8001"], [63797, 1, "\u8606"], [63798, 1, "\u865C"], [63799, 1, "\u8DEF"], [63800, 1, "\u9732"], [63801, 1, "\u9B6F"], [63802, 1, "\u9DFA"], [63803, 1, "\u788C"], [63804, 1, "\u797F"], [63805, 1, "\u7DA0"], [63806, 1, "\u83C9"], [63807, 1, "\u9304"], [63808, 1, "\u9E7F"], [63809, 1, "\u8AD6"], [63810, 1, "\u58DF"], [63811, 1, "\u5F04"], [63812, 1, "\u7C60"], [63813, 1, "\u807E"], [63814, 1, "\u7262"], [63815, 1, "\u78CA"], [63816, 1, "\u8CC2"], [63817, 1, "\u96F7"], [63818, 1, "\u58D8"], [63819, 1, "\u5C62"], [63820, 1, "\u6A13"], [63821, 1, "\u6DDA"], [63822, 1, "\u6F0F"], [63823, 1, "\u7D2F"], [63824, 1, "\u7E37"], [63825, 1, "\u964B"], [63826, 1, "\u52D2"], [63827, 1, "\u808B"], [63828, 1, "\u51DC"], [63829, 1, "\u51CC"], [63830, 1, "\u7A1C"], [63831, 1, "\u7DBE"], [63832, 1, "\u83F1"], [63833, 1, "\u9675"], [63834, 1, "\u8B80"], [63835, 1, "\u62CF"], [63836, 1, "\u6A02"], [63837, 1, "\u8AFE"], [63838, 1, "\u4E39"], [63839, 1, "\u5BE7"], [63840, 1, "\u6012"], [63841, 1, "\u7387"], [63842, 1, "\u7570"], [63843, 1, "\u5317"], [63844, 1, "\u78FB"], [63845, 1, "\u4FBF"], [63846, 1, "\u5FA9"], [63847, 1, "\u4E0D"], [63848, 1, "\u6CCC"], [63849, 1, "\u6578"], [63850, 1, "\u7D22"], [63851, 1, "\u53C3"], [63852, 1, "\u585E"], [63853, 1, "\u7701"], [63854, 1, "\u8449"], [63855, 1, "\u8AAA"], [63856, 1, "\u6BBA"], [63857, 1, "\u8FB0"], [63858, 1, "\u6C88"], [63859, 1, "\u62FE"], [63860, 1, "\u82E5"], [63861, 1, "\u63A0"], [63862, 1, "\u7565"], [63863, 1, "\u4EAE"], [63864, 1, "\u5169"], [63865, 1, "\u51C9"], [63866, 1, "\u6881"], [63867, 1, "\u7CE7"], [63868, 1, "\u826F"], [63869, 1, "\u8AD2"], [63870, 1, "\u91CF"], [63871, 1, "\u52F5"], [63872, 1, "\u5442"], [63873, 1, "\u5973"], [63874, 1, "\u5EEC"], [63875, 1, "\u65C5"], [63876, 1, "\u6FFE"], [63877, 1, "\u792A"], [63878, 1, "\u95AD"], [63879, 1, "\u9A6A"], [63880, 1, "\u9E97"], [63881, 1, "\u9ECE"], [63882, 1, "\u529B"], [63883, 1, "\u66C6"], [63884, 1, "\u6B77"], [63885, 1, "\u8F62"], [63886, 1, "\u5E74"], [63887, 1, "\u6190"], [63888, 1, "\u6200"], [63889, 1, "\u649A"], [63890, 1, "\u6F23"], [63891, 1, "\u7149"], [63892, 1, "\u7489"], [63893, 1, "\u79CA"], [63894, 1, "\u7DF4"], [63895, 1, "\u806F"], [63896, 1, "\u8F26"], [63897, 1, "\u84EE"], [63898, 1, "\u9023"], [63899, 1, "\u934A"], [63900, 1, "\u5217"], [63901, 1, "\u52A3"], [63902, 1, "\u54BD"], [63903, 1, "\u70C8"], [63904, 1, "\u88C2"], [63905, 1, "\u8AAA"], [63906, 1, "\u5EC9"], [63907, 1, "\u5FF5"], [63908, 1, "\u637B"], [63909, 1, "\u6BAE"], [63910, 1, "\u7C3E"], [63911, 1, "\u7375"], [63912, 1, "\u4EE4"], [63913, 1, "\u56F9"], [63914, 1, "\u5BE7"], [63915, 1, "\u5DBA"], [63916, 1, "\u601C"], [63917, 1, "\u73B2"], [63918, 1, "\u7469"], [63919, 1, "\u7F9A"], [63920, 1, "\u8046"], [63921, 1, "\u9234"], [63922, 1, "\u96F6"], [63923, 1, "\u9748"], [63924, 1, "\u9818"], [63925, 1, "\u4F8B"], [63926, 1, "\u79AE"], [63927, 1, "\u91B4"], [63928, 1, "\u96B8"], [63929, 1, "\u60E1"], [63930, 1, "\u4E86"], [63931, 1, "\u50DA"], [63932, 1, "\u5BEE"], [63933, 1, "\u5C3F"], [63934, 1, "\u6599"], [63935, 1, "\u6A02"], [63936, 1, "\u71CE"], [63937, 1, "\u7642"], [63938, 1, "\u84FC"], [63939, 1, "\u907C"], [63940, 1, "\u9F8D"], [63941, 1, "\u6688"], [63942, 1, "\u962E"], [63943, 1, "\u5289"], [63944, 1, "\u677B"], [63945, 1, "\u67F3"], [63946, 1, "\u6D41"], [63947, 1, "\u6E9C"], [63948, 1, "\u7409"], [63949, 1, "\u7559"], [63950, 1, "\u786B"], [63951, 1, "\u7D10"], [63952, 1, "\u985E"], [63953, 1, "\u516D"], [63954, 1, "\u622E"], [63955, 1, "\u9678"], [63956, 1, "\u502B"], [63957, 1, "\u5D19"], [63958, 1, "\u6DEA"], [63959, 1, "\u8F2A"], [63960, 1, "\u5F8B"], [63961, 1, "\u6144"], [63962, 1, "\u6817"], [63963, 1, "\u7387"], [63964, 1, "\u9686"], [63965, 1, "\u5229"], [63966, 1, "\u540F"], [63967, 1, "\u5C65"], [63968, 1, "\u6613"], [63969, 1, "\u674E"], [63970, 1, "\u68A8"], [63971, 1, "\u6CE5"], [63972, 1, "\u7406"], [63973, 1, "\u75E2"], [63974, 1, "\u7F79"], [63975, 1, "\u88CF"], [63976, 1, "\u88E1"], [63977, 1, "\u91CC"], [63978, 1, "\u96E2"], [63979, 1, "\u533F"], [63980, 1, "\u6EBA"], [63981, 1, "\u541D"], [63982, 1, "\u71D0"], [63983, 1, "\u7498"], [63984, 1, "\u85FA"], [63985, 1, "\u96A3"], [63986, 1, "\u9C57"], [63987, 1, "\u9E9F"], [63988, 1, "\u6797"], [63989, 1, "\u6DCB"], [63990, 1, "\u81E8"], [63991, 1, "\u7ACB"], [63992, 1, "\u7B20"], [63993, 1, "\u7C92"], [63994, 1, "\u72C0"], [63995, 1, "\u7099"], [63996, 1, "\u8B58"], [63997, 1, "\u4EC0"], [63998, 1, "\u8336"], [63999, 1, "\u523A"], [64e3, 1, "\u5207"], [64001, 1, "\u5EA6"], [64002, 1, "\u62D3"], [64003, 1, "\u7CD6"], [64004, 1, "\u5B85"], [64005, 1, "\u6D1E"], [64006, 1, "\u66B4"], [64007, 1, "\u8F3B"], [64008, 1, "\u884C"], [64009, 1, "\u964D"], [64010, 1, "\u898B"], [64011, 1, "\u5ED3"], [64012, 1, "\u5140"], [64013, 1, "\u55C0"], [[64014, 64015], 2], [64016, 1, "\u585A"], [64017, 2], [64018, 1, "\u6674"], [[64019, 64020], 2], [64021, 1, "\u51DE"], [64022, 1, "\u732A"], [64023, 1, "\u76CA"], [64024, 1, "\u793C"], [64025, 1, "\u795E"], [64026, 1, "\u7965"], [64027, 1, "\u798F"], [64028, 1, "\u9756"], [64029, 1, "\u7CBE"], [64030, 1, "\u7FBD"], [64031, 2], [64032, 1, "\u8612"], [64033, 2], [64034, 1, "\u8AF8"], [[64035, 64036], 2], [64037, 1, "\u9038"], [64038, 1, "\u90FD"], [[64039, 64041], 2], [64042, 1, "\u98EF"], [64043, 1, "\u98FC"], [64044, 1, "\u9928"], [64045, 1, "\u9DB4"], [64046, 1, "\u90DE"], [64047, 1, "\u96B7"], [64048, 1, "\u4FAE"], [64049, 1, "\u50E7"], [64050, 1, "\u514D"], [64051, 1, "\u52C9"], [64052, 1, "\u52E4"], [64053, 1, "\u5351"], [64054, 1, "\u559D"], [64055, 1, "\u5606"], [64056, 1, "\u5668"], [64057, 1, "\u5840"], [64058, 1, "\u58A8"], [64059, 1, "\u5C64"], [64060, 1, "\u5C6E"], [64061, 1, "\u6094"], [64062, 1, "\u6168"], [64063, 1, "\u618E"], [64064, 1, "\u61F2"], [64065, 1, "\u654F"], [64066, 1, "\u65E2"], [64067, 1, "\u6691"], [64068, 1, "\u6885"], [64069, 1, "\u6D77"], [64070, 1, "\u6E1A"], [64071, 1, "\u6F22"], [64072, 1, "\u716E"], [64073, 1, "\u722B"], [64074, 1, "\u7422"], [64075, 1, "\u7891"], [64076, 1, "\u793E"], [64077, 1, "\u7949"], [64078, 1, "\u7948"], [64079, 1, "\u7950"], [64080, 1, "\u7956"], [64081, 1, "\u795D"], [64082, 1, "\u798D"], [64083, 1, "\u798E"], [64084, 1, "\u7A40"], [64085, 1, "\u7A81"], [64086, 1, "\u7BC0"], [64087, 1, "\u7DF4"], [64088, 1, "\u7E09"], [64089, 1, "\u7E41"], [64090, 1, "\u7F72"], [64091, 1, "\u8005"], [64092, 1, "\u81ED"], [[64093, 64094], 1, "\u8279"], [64095, 1, "\u8457"], [64096, 1, "\u8910"], [64097, 1, "\u8996"], [64098, 1, "\u8B01"], [64099, 1, "\u8B39"], [64100, 1, "\u8CD3"], [64101, 1, "\u8D08"], [64102, 1, "\u8FB6"], [64103, 1, "\u9038"], [64104, 1, "\u96E3"], [64105, 1, "\u97FF"], [64106, 1, "\u983B"], [64107, 1, "\u6075"], [64108, 1, "\u{242EE}"], [64109, 1, "\u8218"], [[64110, 64111], 3], [64112, 1, "\u4E26"], [64113, 1, "\u51B5"], [64114, 1, "\u5168"], [64115, 1, "\u4F80"], [64116, 1, "\u5145"], [64117, 1, "\u5180"], [64118, 1, "\u52C7"], [64119, 1, "\u52FA"], [64120, 1, "\u559D"], [64121, 1, "\u5555"], [64122, 1, "\u5599"], [64123, 1, "\u55E2"], [64124, 1, "\u585A"], [64125, 1, "\u58B3"], [64126, 1, "\u5944"], [64127, 1, "\u5954"], [64128, 1, "\u5A62"], [64129, 1, "\u5B28"], [64130, 1, "\u5ED2"], [64131, 1, "\u5ED9"], [64132, 1, "\u5F69"], [64133, 1, "\u5FAD"], [64134, 1, "\u60D8"], [64135, 1, "\u614E"], [64136, 1, "\u6108"], [64137, 1, "\u618E"], [64138, 1, "\u6160"], [64139, 1, "\u61F2"], [64140, 1, "\u6234"], [64141, 1, "\u63C4"], [64142, 1, "\u641C"], [64143, 1, "\u6452"], [64144, 1, "\u6556"], [64145, 1, "\u6674"], [64146, 1, "\u6717"], [64147, 1, "\u671B"], [64148, 1, "\u6756"], [64149, 1, "\u6B79"], [64150, 1, "\u6BBA"], [64151, 1, "\u6D41"], [64152, 1, "\u6EDB"], [64153, 1, "\u6ECB"], [64154, 1, "\u6F22"], [64155, 1, "\u701E"], [64156, 1, "\u716E"], [64157, 1, "\u77A7"], [64158, 1, "\u7235"], [64159, 1, "\u72AF"], [64160, 1, "\u732A"], [64161, 1, "\u7471"], [64162, 1, "\u7506"], [64163, 1, "\u753B"], [64164, 1, "\u761D"], [64165, 1, "\u761F"], [64166, 1, "\u76CA"], [64167, 1, "\u76DB"], [64168, 1, "\u76F4"], [64169, 1, "\u774A"], [64170, 1, "\u7740"], [64171, 1, "\u78CC"], [64172, 1, "\u7AB1"], [64173, 1, "\u7BC0"], [64174, 1, "\u7C7B"], [64175, 1, "\u7D5B"], [64176, 1, "\u7DF4"], [64177, 1, "\u7F3E"], [64178, 1, "\u8005"], [64179, 1, "\u8352"], [64180, 1, "\u83EF"], [64181, 1, "\u8779"], [64182, 1, "\u8941"], [64183, 1, "\u8986"], [64184, 1, "\u8996"], [64185, 1, "\u8ABF"], [64186, 1, "\u8AF8"], [64187, 1, "\u8ACB"], [64188, 1, "\u8B01"], [64189, 1, "\u8AFE"], [64190, 1, "\u8AED"], [64191, 1, "\u8B39"], [64192, 1, "\u8B8A"], [64193, 1, "\u8D08"], [64194, 1, "\u8F38"], [64195, 1, "\u9072"], [64196, 1, "\u9199"], [64197, 1, "\u9276"], [64198, 1, "\u967C"], [64199, 1, "\u96E3"], [64200, 1, "\u9756"], [64201, 1, "\u97DB"], [64202, 1, "\u97FF"], [64203, 1, "\u980B"], [64204, 1, "\u983B"], [64205, 1, "\u9B12"], [64206, 1, "\u9F9C"], [64207, 1, "\u{2284A}"], [64208, 1, "\u{22844}"], [64209, 1, "\u{233D5}"], [64210, 1, "\u3B9D"], [64211, 1, "\u4018"], [64212, 1, "\u4039"], [64213, 1, "\u{25249}"], [64214, 1, "\u{25CD0}"], [64215, 1, "\u{27ED3}"], [64216, 1, "\u9F43"], [64217, 1, "\u9F8E"], [[64218, 64255], 3], [64256, 1, "ff"], [64257, 1, "fi"], [64258, 1, "fl"], [64259, 1, "ffi"], [64260, 1, "ffl"], [[64261, 64262], 1, "st"], [[64263, 64274], 3], [64275, 1, "\u0574\u0576"], [64276, 1, "\u0574\u0565"], [64277, 1, "\u0574\u056B"], [64278, 1, "\u057E\u0576"], [64279, 1, "\u0574\u056D"], [[64280, 64284], 3], [64285, 1, "\u05D9\u05B4"], [64286, 2], [64287, 1, "\u05F2\u05B7"], [64288, 1, "\u05E2"], [64289, 1, "\u05D0"], [64290, 1, "\u05D3"], [64291, 1, "\u05D4"], [64292, 1, "\u05DB"], [64293, 1, "\u05DC"], [64294, 1, "\u05DD"], [64295, 1, "\u05E8"], [64296, 1, "\u05EA"], [64297, 1, "+"], [64298, 1, "\u05E9\u05C1"], [64299, 1, "\u05E9\u05C2"], [64300, 1, "\u05E9\u05BC\u05C1"], [64301, 1, "\u05E9\u05BC\u05C2"], [64302, 1, "\u05D0\u05B7"], [64303, 1, "\u05D0\u05B8"], [64304, 1, "\u05D0\u05BC"], [64305, 1, "\u05D1\u05BC"], [64306, 1, "\u05D2\u05BC"], [64307, 1, "\u05D3\u05BC"], [64308, 1, "\u05D4\u05BC"], [64309, 1, "\u05D5\u05BC"], [64310, 1, "\u05D6\u05BC"], [64311, 3], [64312, 1, "\u05D8\u05BC"], [64313, 1, "\u05D9\u05BC"], [64314, 1, "\u05DA\u05BC"], [64315, 1, "\u05DB\u05BC"], [64316, 1, "\u05DC\u05BC"], [64317, 3], [64318, 1, "\u05DE\u05BC"], [64319, 3], [64320, 1, "\u05E0\u05BC"], [64321, 1, "\u05E1\u05BC"], [64322, 3], [64323, 1, "\u05E3\u05BC"], [64324, 1, "\u05E4\u05BC"], [64325, 3], [64326, 1, "\u05E6\u05BC"], [64327, 1, "\u05E7\u05BC"], [64328, 1, "\u05E8\u05BC"], [64329, 1, "\u05E9\u05BC"], [64330, 1, "\u05EA\u05BC"], [64331, 1, "\u05D5\u05B9"], [64332, 1, "\u05D1\u05BF"], [64333, 1, "\u05DB\u05BF"], [64334, 1, "\u05E4\u05BF"], [64335, 1, "\u05D0\u05DC"], [[64336, 64337], 1, "\u0671"], [[64338, 64341], 1, "\u067B"], [[64342, 64345], 1, "\u067E"], [[64346, 64349], 1, "\u0680"], [[64350, 64353], 1, "\u067A"], [[64354, 64357], 1, "\u067F"], [[64358, 64361], 1, "\u0679"], [[64362, 64365], 1, "\u06A4"], [[64366, 64369], 1, "\u06A6"], [[64370, 64373], 1, "\u0684"], [[64374, 64377], 1, "\u0683"], [[64378, 64381], 1, "\u0686"], [[64382, 64385], 1, "\u0687"], [[64386, 64387], 1, "\u068D"], [[64388, 64389], 1, "\u068C"], [[64390, 64391], 1, "\u068E"], [[64392, 64393], 1, "\u0688"], [[64394, 64395], 1, "\u0698"], [[64396, 64397], 1, "\u0691"], [[64398, 64401], 1, "\u06A9"], [[64402, 64405], 1, "\u06AF"], [[64406, 64409], 1, "\u06B3"], [[64410, 64413], 1, "\u06B1"], [[64414, 64415], 1, "\u06BA"], [[64416, 64419], 1, "\u06BB"], [[64420, 64421], 1, "\u06C0"], [[64422, 64425], 1, "\u06C1"], [[64426, 64429], 1, "\u06BE"], [[64430, 64431], 1, "\u06D2"], [[64432, 64433], 1, "\u06D3"], [[64434, 64449], 2], [64450, 2], [[64451, 64466], 3], [[64467, 64470], 1, "\u06AD"], [[64471, 64472], 1, "\u06C7"], [[64473, 64474], 1, "\u06C6"], [[64475, 64476], 1, "\u06C8"], [64477, 1, "\u06C7\u0674"], [[64478, 64479], 1, "\u06CB"], [[64480, 64481], 1, "\u06C5"], [[64482, 64483], 1, "\u06C9"], [[64484, 64487], 1, "\u06D0"], [[64488, 64489], 1, "\u0649"], [[64490, 64491], 1, "\u0626\u0627"], [[64492, 64493], 1, "\u0626\u06D5"], [[64494, 64495], 1, "\u0626\u0648"], [[64496, 64497], 1, "\u0626\u06C7"], [[64498, 64499], 1, "\u0626\u06C6"], [[64500, 64501], 1, "\u0626\u06C8"], [[64502, 64504], 1, "\u0626\u06D0"], [[64505, 64507], 1, "\u0626\u0649"], [[64508, 64511], 1, "\u06CC"], [64512, 1, "\u0626\u062C"], [64513, 1, "\u0626\u062D"], [64514, 1, "\u0626\u0645"], [64515, 1, "\u0626\u0649"], [64516, 1, "\u0626\u064A"], [64517, 1, "\u0628\u062C"], [64518, 1, "\u0628\u062D"], [64519, 1, "\u0628\u062E"], [64520, 1, "\u0628\u0645"], [64521, 1, "\u0628\u0649"], [64522, 1, "\u0628\u064A"], [64523, 1, "\u062A\u062C"], [64524, 1, "\u062A\u062D"], [64525, 1, "\u062A\u062E"], [64526, 1, "\u062A\u0645"], [64527, 1, "\u062A\u0649"], [64528, 1, "\u062A\u064A"], [64529, 1, "\u062B\u062C"], [64530, 1, "\u062B\u0645"], [64531, 1, "\u062B\u0649"], [64532, 1, "\u062B\u064A"], [64533, 1, "\u062C\u062D"], [64534, 1, "\u062C\u0645"], [64535, 1, "\u062D\u062C"], [64536, 1, "\u062D\u0645"], [64537, 1, "\u062E\u062C"], [64538, 1, "\u062E\u062D"], [64539, 1, "\u062E\u0645"], [64540, 1, "\u0633\u062C"], [64541, 1, "\u0633\u062D"], [64542, 1, "\u0633\u062E"], [64543, 1, "\u0633\u0645"], [64544, 1, "\u0635\u062D"], [64545, 1, "\u0635\u0645"], [64546, 1, "\u0636\u062C"], [64547, 1, "\u0636\u062D"], [64548, 1, "\u0636\u062E"], [64549, 1, "\u0636\u0645"], [64550, 1, "\u0637\u062D"], [64551, 1, "\u0637\u0645"], [64552, 1, "\u0638\u0645"], [64553, 1, "\u0639\u062C"], [64554, 1, "\u0639\u0645"], [64555, 1, "\u063A\u062C"], [64556, 1, "\u063A\u0645"], [64557, 1, "\u0641\u062C"], [64558, 1, "\u0641\u062D"], [64559, 1, "\u0641\u062E"], [64560, 1, "\u0641\u0645"], [64561, 1, "\u0641\u0649"], [64562, 1, "\u0641\u064A"], [64563, 1, "\u0642\u062D"], [64564, 1, "\u0642\u0645"], [64565, 1, "\u0642\u0649"], [64566, 1, "\u0642\u064A"], [64567, 1, "\u0643\u0627"], [64568, 1, "\u0643\u062C"], [64569, 1, "\u0643\u062D"], [64570, 1, "\u0643\u062E"], [64571, 1, "\u0643\u0644"], [64572, 1, "\u0643\u0645"], [64573, 1, "\u0643\u0649"], [64574, 1, "\u0643\u064A"], [64575, 1, "\u0644\u062C"], [64576, 1, "\u0644\u062D"], [64577, 1, "\u0644\u062E"], [64578, 1, "\u0644\u0645"], [64579, 1, "\u0644\u0649"], [64580, 1, "\u0644\u064A"], [64581, 1, "\u0645\u062C"], [64582, 1, "\u0645\u062D"], [64583, 1, "\u0645\u062E"], [64584, 1, "\u0645\u0645"], [64585, 1, "\u0645\u0649"], [64586, 1, "\u0645\u064A"], [64587, 1, "\u0646\u062C"], [64588, 1, "\u0646\u062D"], [64589, 1, "\u0646\u062E"], [64590, 1, "\u0646\u0645"], [64591, 1, "\u0646\u0649"], [64592, 1, "\u0646\u064A"], [64593, 1, "\u0647\u062C"], [64594, 1, "\u0647\u0645"], [64595, 1, "\u0647\u0649"], [64596, 1, "\u0647\u064A"], [64597, 1, "\u064A\u062C"], [64598, 1, "\u064A\u062D"], [64599, 1, "\u064A\u062E"], [64600, 1, "\u064A\u0645"], [64601, 1, "\u064A\u0649"], [64602, 1, "\u064A\u064A"], [64603, 1, "\u0630\u0670"], [64604, 1, "\u0631\u0670"], [64605, 1, "\u0649\u0670"], [64606, 1, " \u064C\u0651"], [64607, 1, " \u064D\u0651"], [64608, 1, " \u064E\u0651"], [64609, 1, " \u064F\u0651"], [64610, 1, " \u0650\u0651"], [64611, 1, " \u0651\u0670"], [64612, 1, "\u0626\u0631"], [64613, 1, "\u0626\u0632"], [64614, 1, "\u0626\u0645"], [64615, 1, "\u0626\u0646"], [64616, 1, "\u0626\u0649"], [64617, 1, "\u0626\u064A"], [64618, 1, "\u0628\u0631"], [64619, 1, "\u0628\u0632"], [64620, 1, "\u0628\u0645"], [64621, 1, "\u0628\u0646"], [64622, 1, "\u0628\u0649"], [64623, 1, "\u0628\u064A"], [64624, 1, "\u062A\u0631"], [64625, 1, "\u062A\u0632"], [64626, 1, "\u062A\u0645"], [64627, 1, "\u062A\u0646"], [64628, 1, "\u062A\u0649"], [64629, 1, "\u062A\u064A"], [64630, 1, "\u062B\u0631"], [64631, 1, "\u062B\u0632"], [64632, 1, "\u062B\u0645"], [64633, 1, "\u062B\u0646"], [64634, 1, "\u062B\u0649"], [64635, 1, "\u062B\u064A"], [64636, 1, "\u0641\u0649"], [64637, 1, "\u0641\u064A"], [64638, 1, "\u0642\u0649"], [64639, 1, "\u0642\u064A"], [64640, 1, "\u0643\u0627"], [64641, 1, "\u0643\u0644"], [64642, 1, "\u0643\u0645"], [64643, 1, "\u0643\u0649"], [64644, 1, "\u0643\u064A"], [64645, 1, "\u0644\u0645"], [64646, 1, "\u0644\u0649"], [64647, 1, "\u0644\u064A"], [64648, 1, "\u0645\u0627"], [64649, 1, "\u0645\u0645"], [64650, 1, "\u0646\u0631"], [64651, 1, "\u0646\u0632"], [64652, 1, "\u0646\u0645"], [64653, 1, "\u0646\u0646"], [64654, 1, "\u0646\u0649"], [64655, 1, "\u0646\u064A"], [64656, 1, "\u0649\u0670"], [64657, 1, "\u064A\u0631"], [64658, 1, "\u064A\u0632"], [64659, 1, "\u064A\u0645"], [64660, 1, "\u064A\u0646"], [64661, 1, "\u064A\u0649"], [64662, 1, "\u064A\u064A"], [64663, 1, "\u0626\u062C"], [64664, 1, "\u0626\u062D"], [64665, 1, "\u0626\u062E"], [64666, 1, "\u0626\u0645"], [64667, 1, "\u0626\u0647"], [64668, 1, "\u0628\u062C"], [64669, 1, "\u0628\u062D"], [64670, 1, "\u0628\u062E"], [64671, 1, "\u0628\u0645"], [64672, 1, "\u0628\u0647"], [64673, 1, "\u062A\u062C"], [64674, 1, "\u062A\u062D"], [64675, 1, "\u062A\u062E"], [64676, 1, "\u062A\u0645"], [64677, 1, "\u062A\u0647"], [64678, 1, "\u062B\u0645"], [64679, 1, "\u062C\u062D"], [64680, 1, "\u062C\u0645"], [64681, 1, "\u062D\u062C"], [64682, 1, "\u062D\u0645"], [64683, 1, "\u062E\u062C"], [64684, 1, "\u062E\u0645"], [64685, 1, "\u0633\u062C"], [64686, 1, "\u0633\u062D"], [64687, 1, "\u0633\u062E"], [64688, 1, "\u0633\u0645"], [64689, 1, "\u0635\u062D"], [64690, 1, "\u0635\u062E"], [64691, 1, "\u0635\u0645"], [64692, 1, "\u0636\u062C"], [64693, 1, "\u0636\u062D"], [64694, 1, "\u0636\u062E"], [64695, 1, "\u0636\u0645"], [64696, 1, "\u0637\u062D"], [64697, 1, "\u0638\u0645"], [64698, 1, "\u0639\u062C"], [64699, 1, "\u0639\u0645"], [64700, 1, "\u063A\u062C"], [64701, 1, "\u063A\u0645"], [64702, 1, "\u0641\u062C"], [64703, 1, "\u0641\u062D"], [64704, 1, "\u0641\u062E"], [64705, 1, "\u0641\u0645"], [64706, 1, "\u0642\u062D"], [64707, 1, "\u0642\u0645"], [64708, 1, "\u0643\u062C"], [64709, 1, "\u0643\u062D"], [64710, 1, "\u0643\u062E"], [64711, 1, "\u0643\u0644"], [64712, 1, "\u0643\u0645"], [64713, 1, "\u0644\u062C"], [64714, 1, "\u0644\u062D"], [64715, 1, "\u0644\u062E"], [64716, 1, "\u0644\u0645"], [64717, 1, "\u0644\u0647"], [64718, 1, "\u0645\u062C"], [64719, 1, "\u0645\u062D"], [64720, 1, "\u0645\u062E"], [64721, 1, "\u0645\u0645"], [64722, 1, "\u0646\u062C"], [64723, 1, "\u0646\u062D"], [64724, 1, "\u0646\u062E"], [64725, 1, "\u0646\u0645"], [64726, 1, "\u0646\u0647"], [64727, 1, "\u0647\u062C"], [64728, 1, "\u0647\u0645"], [64729, 1, "\u0647\u0670"], [64730, 1, "\u064A\u062C"], [64731, 1, "\u064A\u062D"], [64732, 1, "\u064A\u062E"], [64733, 1, "\u064A\u0645"], [64734, 1, "\u064A\u0647"], [64735, 1, "\u0626\u0645"], [64736, 1, "\u0626\u0647"], [64737, 1, "\u0628\u0645"], [64738, 1, "\u0628\u0647"], [64739, 1, "\u062A\u0645"], [64740, 1, "\u062A\u0647"], [64741, 1, "\u062B\u0645"], [64742, 1, "\u062B\u0647"], [64743, 1, "\u0633\u0645"], [64744, 1, "\u0633\u0647"], [64745, 1, "\u0634\u0645"], [64746, 1, "\u0634\u0647"], [64747, 1, "\u0643\u0644"], [64748, 1, "\u0643\u0645"], [64749, 1, "\u0644\u0645"], [64750, 1, "\u0646\u0645"], [64751, 1, "\u0646\u0647"], [64752, 1, "\u064A\u0645"], [64753, 1, "\u064A\u0647"], [64754, 1, "\u0640\u064E\u0651"], [64755, 1, "\u0640\u064F\u0651"], [64756, 1, "\u0640\u0650\u0651"], [64757, 1, "\u0637\u0649"], [64758, 1, "\u0637\u064A"], [64759, 1, "\u0639\u0649"], [64760, 1, "\u0639\u064A"], [64761, 1, "\u063A\u0649"], [64762, 1, "\u063A\u064A"], [64763, 1, "\u0633\u0649"], [64764, 1, "\u0633\u064A"], [64765, 1, "\u0634\u0649"], [64766, 1, "\u0634\u064A"], [64767, 1, "\u062D\u0649"], [64768, 1, "\u062D\u064A"], [64769, 1, "\u062C\u0649"], [64770, 1, "\u062C\u064A"], [64771, 1, "\u062E\u0649"], [64772, 1, "\u062E\u064A"], [64773, 1, "\u0635\u0649"], [64774, 1, "\u0635\u064A"], [64775, 1, "\u0636\u0649"], [64776, 1, "\u0636\u064A"], [64777, 1, "\u0634\u062C"], [64778, 1, "\u0634\u062D"], [64779, 1, "\u0634\u062E"], [64780, 1, "\u0634\u0645"], [64781, 1, "\u0634\u0631"], [64782, 1, "\u0633\u0631"], [64783, 1, "\u0635\u0631"], [64784, 1, "\u0636\u0631"], [64785, 1, "\u0637\u0649"], [64786, 1, "\u0637\u064A"], [64787, 1, "\u0639\u0649"], [64788, 1, "\u0639\u064A"], [64789, 1, "\u063A\u0649"], [64790, 1, "\u063A\u064A"], [64791, 1, "\u0633\u0649"], [64792, 1, "\u0633\u064A"], [64793, 1, "\u0634\u0649"], [64794, 1, "\u0634\u064A"], [64795, 1, "\u062D\u0649"], [64796, 1, "\u062D\u064A"], [64797, 1, "\u062C\u0649"], [64798, 1, "\u062C\u064A"], [64799, 1, "\u062E\u0649"], [64800, 1, "\u062E\u064A"], [64801, 1, "\u0635\u0649"], [64802, 1, "\u0635\u064A"], [64803, 1, "\u0636\u0649"], [64804, 1, "\u0636\u064A"], [64805, 1, "\u0634\u062C"], [64806, 1, "\u0634\u062D"], [64807, 1, "\u0634\u062E"], [64808, 1, "\u0634\u0645"], [64809, 1, "\u0634\u0631"], [64810, 1, "\u0633\u0631"], [64811, 1, "\u0635\u0631"], [64812, 1, "\u0636\u0631"], [64813, 1, "\u0634\u062C"], [64814, 1, "\u0634\u062D"], [64815, 1, "\u0634\u062E"], [64816, 1, "\u0634\u0645"], [64817, 1, "\u0633\u0647"], [64818, 1, "\u0634\u0647"], [64819, 1, "\u0637\u0645"], [64820, 1, "\u0633\u062C"], [64821, 1, "\u0633\u062D"], [64822, 1, "\u0633\u062E"], [64823, 1, "\u0634\u062C"], [64824, 1, "\u0634\u062D"], [64825, 1, "\u0634\u062E"], [64826, 1, "\u0637\u0645"], [64827, 1, "\u0638\u0645"], [[64828, 64829], 1, "\u0627\u064B"], [[64830, 64831], 2], [[64832, 64847], 2], [64848, 1, "\u062A\u062C\u0645"], [[64849, 64850], 1, "\u062A\u062D\u062C"], [64851, 1, "\u062A\u062D\u0645"], [64852, 1, "\u062A\u062E\u0645"], [64853, 1, "\u062A\u0645\u062C"], [64854, 1, "\u062A\u0645\u062D"], [64855, 1, "\u062A\u0645\u062E"], [[64856, 64857], 1, "\u062C\u0645\u062D"], [64858, 1, "\u062D\u0645\u064A"], [64859, 1, "\u062D\u0645\u0649"], [64860, 1, "\u0633\u062D\u062C"], [64861, 1, "\u0633\u062C\u062D"], [64862, 1, "\u0633\u062C\u0649"], [[64863, 64864], 1, "\u0633\u0645\u062D"], [64865, 1, "\u0633\u0645\u062C"], [[64866, 64867], 1, "\u0633\u0645\u0645"], [[64868, 64869], 1, "\u0635\u062D\u062D"], [64870, 1, "\u0635\u0645\u0645"], [[64871, 64872], 1, "\u0634\u062D\u0645"], [64873, 1, "\u0634\u062C\u064A"], [[64874, 64875], 1, "\u0634\u0645\u062E"], [[64876, 64877], 1, "\u0634\u0645\u0645"], [64878, 1, "\u0636\u062D\u0649"], [[64879, 64880], 1, "\u0636\u062E\u0645"], [[64881, 64882], 1, "\u0637\u0645\u062D"], [64883, 1, "\u0637\u0645\u0645"], [64884, 1, "\u0637\u0645\u064A"], [64885, 1, "\u0639\u062C\u0645"], [[64886, 64887], 1, "\u0639\u0645\u0645"], [64888, 1, "\u0639\u0645\u0649"], [64889, 1, "\u063A\u0645\u0645"], [64890, 1, "\u063A\u0645\u064A"], [64891, 1, "\u063A\u0645\u0649"], [[64892, 64893], 1, "\u0641\u062E\u0645"], [64894, 1, "\u0642\u0645\u062D"], [64895, 1, "\u0642\u0645\u0645"], [64896, 1, "\u0644\u062D\u0645"], [64897, 1, "\u0644\u062D\u064A"], [64898, 1, "\u0644\u062D\u0649"], [[64899, 64900], 1, "\u0644\u062C\u062C"], [[64901, 64902], 1, "\u0644\u062E\u0645"], [[64903, 64904], 1, "\u0644\u0645\u062D"], [64905, 1, "\u0645\u062D\u062C"], [64906, 1, "\u0645\u062D\u0645"], [64907, 1, "\u0645\u062D\u064A"], [64908, 1, "\u0645\u062C\u062D"], [64909, 1, "\u0645\u062C\u0645"], [64910, 1, "\u0645\u062E\u062C"], [64911, 1, "\u0645\u062E\u0645"], [[64912, 64913], 3], [64914, 1, "\u0645\u062C\u062E"], [64915, 1, "\u0647\u0645\u062C"], [64916, 1, "\u0647\u0645\u0645"], [64917, 1, "\u0646\u062D\u0645"], [64918, 1, "\u0646\u062D\u0649"], [[64919, 64920], 1, "\u0646\u062C\u0645"], [64921, 1, "\u0646\u062C\u0649"], [64922, 1, "\u0646\u0645\u064A"], [64923, 1, "\u0646\u0645\u0649"], [[64924, 64925], 1, "\u064A\u0645\u0645"], [64926, 1, "\u0628\u062E\u064A"], [64927, 1, "\u062A\u062C\u064A"], [64928, 1, "\u062A\u062C\u0649"], [64929, 1, "\u062A\u062E\u064A"], [64930, 1, "\u062A\u062E\u0649"], [64931, 1, "\u062A\u0645\u064A"], [64932, 1, "\u062A\u0645\u0649"], [64933, 1, "\u062C\u0645\u064A"], [64934, 1, "\u062C\u062D\u0649"], [64935, 1, "\u062C\u0645\u0649"], [64936, 1, "\u0633\u062E\u0649"], [64937, 1, "\u0635\u062D\u064A"], [64938, 1, "\u0634\u062D\u064A"], [64939, 1, "\u0636\u062D\u064A"], [64940, 1, "\u0644\u062C\u064A"], [64941, 1, "\u0644\u0645\u064A"], [64942, 1, "\u064A\u062D\u064A"], [64943, 1, "\u064A\u062C\u064A"], [64944, 1, "\u064A\u0645\u064A"], [64945, 1, "\u0645\u0645\u064A"], [64946, 1, "\u0642\u0645\u064A"], [64947, 1, "\u0646\u062D\u064A"], [64948, 1, "\u0642\u0645\u062D"], [64949, 1, "\u0644\u062D\u0645"], [64950, 1, "\u0639\u0645\u064A"], [64951, 1, "\u0643\u0645\u064A"], [64952, 1, "\u0646\u062C\u062D"], [64953, 1, "\u0645\u062E\u064A"], [64954, 1, "\u0644\u062C\u0645"], [64955, 1, "\u0643\u0645\u0645"], [64956, 1, "\u0644\u062C\u0645"], [64957, 1, "\u0646\u062C\u062D"], [64958, 1, "\u062C\u062D\u064A"], [64959, 1, "\u062D\u062C\u064A"], [64960, 1, "\u0645\u062C\u064A"], [64961, 1, "\u0641\u0645\u064A"], [64962, 1, "\u0628\u062D\u064A"], [64963, 1, "\u0643\u0645\u0645"], [64964, 1, "\u0639\u062C\u0645"], [64965, 1, "\u0635\u0645\u0645"], [64966, 1, "\u0633\u062E\u064A"], [64967, 1, "\u0646\u062C\u064A"], [[64968, 64974], 3], [64975, 2], [[64976, 65007], 3], [65008, 1, "\u0635\u0644\u06D2"], [65009, 1, "\u0642\u0644\u06D2"], [65010, 1, "\u0627\u0644\u0644\u0647"], [65011, 1, "\u0627\u0643\u0628\u0631"], [65012, 1, "\u0645\u062D\u0645\u062F"], [65013, 1, "\u0635\u0644\u0639\u0645"], [65014, 1, "\u0631\u0633\u0648\u0644"], [65015, 1, "\u0639\u0644\u064A\u0647"], [65016, 1, "\u0648\u0633\u0644\u0645"], [65017, 1, "\u0635\u0644\u0649"], [65018, 1, "\u0635\u0644\u0649 \u0627\u0644\u0644\u0647 \u0639\u0644\u064A\u0647 \u0648\u0633\u0644\u0645"], [65019, 1, "\u062C\u0644 \u062C\u0644\u0627\u0644\u0647"], [65020, 1, "\u0631\u06CC\u0627\u0644"], [65021, 2], [[65022, 65023], 2], [[65024, 65039], 7], [65040, 1, ","], [65041, 1, "\u3001"], [65042, 3], [65043, 1, ":"], [65044, 1, ";"], [65045, 1, "!"], [65046, 1, "?"], [65047, 1, "\u3016"], [65048, 1, "\u3017"], [65049, 3], [[65050, 65055], 3], [[65056, 65059], 2], [[65060, 65062], 2], [[65063, 65069], 2], [[65070, 65071], 2], [65072, 3], [65073, 1, "\u2014"], [65074, 1, "\u2013"], [[65075, 65076], 1, "_"], [65077, 1, "("], [65078, 1, ")"], [65079, 1, "{"], [65080, 1, "}"], [65081, 1, "\u3014"], [65082, 1, "\u3015"], [65083, 1, "\u3010"], [65084, 1, "\u3011"], [65085, 1, "\u300A"], [65086, 1, "\u300B"], [65087, 1, "\u3008"], [65088, 1, "\u3009"], [65089, 1, "\u300C"], [65090, 1, "\u300D"], [65091, 1, "\u300E"], [65092, 1, "\u300F"], [[65093, 65094], 2], [65095, 1, "["], [65096, 1, "]"], [[65097, 65100], 1, " \u0305"], [[65101, 65103], 1, "_"], [65104, 1, ","], [65105, 1, "\u3001"], [65106, 3], [65107, 3], [65108, 1, ";"], [65109, 1, ":"], [65110, 1, "?"], [65111, 1, "!"], [65112, 1, "\u2014"], [65113, 1, "("], [65114, 1, ")"], [65115, 1, "{"], [65116, 1, "}"], [65117, 1, "\u3014"], [65118, 1, "\u3015"], [65119, 1, "#"], [65120, 1, "&"], [65121, 1, "*"], [65122, 1, "+"], [65123, 1, "-"], [65124, 1, "<"], [65125, 1, ">"], [65126, 1, "="], [65127, 3], [65128, 1, "\\"], [65129, 1, "$"], [65130, 1, "%"], [65131, 1, "@"], [[65132, 65135], 3], [65136, 1, " \u064B"], [65137, 1, "\u0640\u064B"], [65138, 1, " \u064C"], [65139, 2], [65140, 1, " \u064D"], [65141, 3], [65142, 1, " \u064E"], [65143, 1, "\u0640\u064E"], [65144, 1, " \u064F"], [65145, 1, "\u0640\u064F"], [65146, 1, " \u0650"], [65147, 1, "\u0640\u0650"], [65148, 1, " \u0651"], [65149, 1, "\u0640\u0651"], [65150, 1, " \u0652"], [65151, 1, "\u0640\u0652"], [65152, 1, "\u0621"], [[65153, 65154], 1, "\u0622"], [[65155, 65156], 1, "\u0623"], [[65157, 65158], 1, "\u0624"], [[65159, 65160], 1, "\u0625"], [[65161, 65164], 1, "\u0626"], [[65165, 65166], 1, "\u0627"], [[65167, 65170], 1, "\u0628"], [[65171, 65172], 1, "\u0629"], [[65173, 65176], 1, "\u062A"], [[65177, 65180], 1, "\u062B"], [[65181, 65184], 1, "\u062C"], [[65185, 65188], 1, "\u062D"], [[65189, 65192], 1, "\u062E"], [[65193, 65194], 1, "\u062F"], [[65195, 65196], 1, "\u0630"], [[65197, 65198], 1, "\u0631"], [[65199, 65200], 1, "\u0632"], [[65201, 65204], 1, "\u0633"], [[65205, 65208], 1, "\u0634"], [[65209, 65212], 1, "\u0635"], [[65213, 65216], 1, "\u0636"], [[65217, 65220], 1, "\u0637"], [[65221, 65224], 1, "\u0638"], [[65225, 65228], 1, "\u0639"], [[65229, 65232], 1, "\u063A"], [[65233, 65236], 1, "\u0641"], [[65237, 65240], 1, "\u0642"], [[65241, 65244], 1, "\u0643"], [[65245, 65248], 1, "\u0644"], [[65249, 65252], 1, "\u0645"], [[65253, 65256], 1, "\u0646"], [[65257, 65260], 1, "\u0647"], [[65261, 65262], 1, "\u0648"], [[65263, 65264], 1, "\u0649"], [[65265, 65268], 1, "\u064A"], [[65269, 65270], 1, "\u0644\u0622"], [[65271, 65272], 1, "\u0644\u0623"], [[65273, 65274], 1, "\u0644\u0625"], [[65275, 65276], 1, "\u0644\u0627"], [[65277, 65278], 3], [65279, 7], [65280, 3], [65281, 1, "!"], [65282, 1, '"'], [65283, 1, "#"], [65284, 1, "$"], [65285, 1, "%"], [65286, 1, "&"], [65287, 1, "'"], [65288, 1, "("], [65289, 1, ")"], [65290, 1, "*"], [65291, 1, "+"], [65292, 1, ","], [65293, 1, "-"], [65294, 1, "."], [65295, 1, "/"], [65296, 1, "0"], [65297, 1, "1"], [65298, 1, "2"], [65299, 1, "3"], [65300, 1, "4"], [65301, 1, "5"], [65302, 1, "6"], [65303, 1, "7"], [65304, 1, "8"], [65305, 1, "9"], [65306, 1, ":"], [65307, 1, ";"], [65308, 1, "<"], [65309, 1, "="], [65310, 1, ">"], [65311, 1, "?"], [65312, 1, "@"], [65313, 1, "a"], [65314, 1, "b"], [65315, 1, "c"], [65316, 1, "d"], [65317, 1, "e"], [65318, 1, "f"], [65319, 1, "g"], [65320, 1, "h"], [65321, 1, "i"], [65322, 1, "j"], [65323, 1, "k"], [65324, 1, "l"], [65325, 1, "m"], [65326, 1, "n"], [65327, 1, "o"], [65328, 1, "p"], [65329, 1, "q"], [65330, 1, "r"], [65331, 1, "s"], [65332, 1, "t"], [65333, 1, "u"], [65334, 1, "v"], [65335, 1, "w"], [65336, 1, "x"], [65337, 1, "y"], [65338, 1, "z"], [65339, 1, "["], [65340, 1, "\\"], [65341, 1, "]"], [65342, 1, "^"], [65343, 1, "_"], [65344, 1, "`"], [65345, 1, "a"], [65346, 1, "b"], [65347, 1, "c"], [65348, 1, "d"], [65349, 1, "e"], [65350, 1, "f"], [65351, 1, "g"], [65352, 1, "h"], [65353, 1, "i"], [65354, 1, "j"], [65355, 1, "k"], [65356, 1, "l"], [65357, 1, "m"], [65358, 1, "n"], [65359, 1, "o"], [65360, 1, "p"], [65361, 1, "q"], [65362, 1, "r"], [65363, 1, "s"], [65364, 1, "t"], [65365, 1, "u"], [65366, 1, "v"], [65367, 1, "w"], [65368, 1, "x"], [65369, 1, "y"], [65370, 1, "z"], [65371, 1, "{"], [65372, 1, "|"], [65373, 1, "}"], [65374, 1, "~"], [65375, 1, "\u2985"], [65376, 1, "\u2986"], [65377, 1, "."], [65378, 1, "\u300C"], [65379, 1, "\u300D"], [65380, 1, "\u3001"], [65381, 1, "\u30FB"], [65382, 1, "\u30F2"], [65383, 1, "\u30A1"], [65384, 1, "\u30A3"], [65385, 1, "\u30A5"], [65386, 1, "\u30A7"], [65387, 1, "\u30A9"], [65388, 1, "\u30E3"], [65389, 1, "\u30E5"], [65390, 1, "\u30E7"], [65391, 1, "\u30C3"], [65392, 1, "\u30FC"], [65393, 1, "\u30A2"], [65394, 1, "\u30A4"], [65395, 1, "\u30A6"], [65396, 1, "\u30A8"], [65397, 1, "\u30AA"], [65398, 1, "\u30AB"], [65399, 1, "\u30AD"], [65400, 1, "\u30AF"], [65401, 1, "\u30B1"], [65402, 1, "\u30B3"], [65403, 1, "\u30B5"], [65404, 1, "\u30B7"], [65405, 1, "\u30B9"], [65406, 1, "\u30BB"], [65407, 1, "\u30BD"], [65408, 1, "\u30BF"], [65409, 1, "\u30C1"], [65410, 1, "\u30C4"], [65411, 1, "\u30C6"], [65412, 1, "\u30C8"], [65413, 1, "\u30CA"], [65414, 1, "\u30CB"], [65415, 1, "\u30CC"], [65416, 1, "\u30CD"], [65417, 1, "\u30CE"], [65418, 1, "\u30CF"], [65419, 1, "\u30D2"], [65420, 1, "\u30D5"], [65421, 1, "\u30D8"], [65422, 1, "\u30DB"], [65423, 1, "\u30DE"], [65424, 1, "\u30DF"], [65425, 1, "\u30E0"], [65426, 1, "\u30E1"], [65427, 1, "\u30E2"], [65428, 1, "\u30E4"], [65429, 1, "\u30E6"], [65430, 1, "\u30E8"], [65431, 1, "\u30E9"], [65432, 1, "\u30EA"], [65433, 1, "\u30EB"], [65434, 1, "\u30EC"], [65435, 1, "\u30ED"], [65436, 1, "\u30EF"], [65437, 1, "\u30F3"], [65438, 1, "\u3099"], [65439, 1, "\u309A"], [65440, 7], [65441, 1, "\u1100"], [65442, 1, "\u1101"], [65443, 1, "\u11AA"], [65444, 1, "\u1102"], [65445, 1, "\u11AC"], [65446, 1, "\u11AD"], [65447, 1, "\u1103"], [65448, 1, "\u1104"], [65449, 1, "\u1105"], [65450, 1, "\u11B0"], [65451, 1, "\u11B1"], [65452, 1, "\u11B2"], [65453, 1, "\u11B3"], [65454, 1, "\u11B4"], [65455, 1, "\u11B5"], [65456, 1, "\u111A"], [65457, 1, "\u1106"], [65458, 1, "\u1107"], [65459, 1, "\u1108"], [65460, 1, "\u1121"], [65461, 1, "\u1109"], [65462, 1, "\u110A"], [65463, 1, "\u110B"], [65464, 1, "\u110C"], [65465, 1, "\u110D"], [65466, 1, "\u110E"], [65467, 1, "\u110F"], [65468, 1, "\u1110"], [65469, 1, "\u1111"], [65470, 1, "\u1112"], [[65471, 65473], 3], [65474, 1, "\u1161"], [65475, 1, "\u1162"], [65476, 1, "\u1163"], [65477, 1, "\u1164"], [65478, 1, "\u1165"], [65479, 1, "\u1166"], [[65480, 65481], 3], [65482, 1, "\u1167"], [65483, 1, "\u1168"], [65484, 1, "\u1169"], [65485, 1, "\u116A"], [65486, 1, "\u116B"], [65487, 1, "\u116C"], [[65488, 65489], 3], [65490, 1, "\u116D"], [65491, 1, "\u116E"], [65492, 1, "\u116F"], [65493, 1, "\u1170"], [65494, 1, "\u1171"], [65495, 1, "\u1172"], [[65496, 65497], 3], [65498, 1, "\u1173"], [65499, 1, "\u1174"], [65500, 1, "\u1175"], [[65501, 65503], 3], [65504, 1, "\xA2"], [65505, 1, "\xA3"], [65506, 1, "\xAC"], [65507, 1, " \u0304"], [65508, 1, "\xA6"], [65509, 1, "\xA5"], [65510, 1, "\u20A9"], [65511, 3], [65512, 1, "\u2502"], [65513, 1, "\u2190"], [65514, 1, "\u2191"], [65515, 1, "\u2192"], [65516, 1, "\u2193"], [65517, 1, "\u25A0"], [65518, 1, "\u25CB"], [[65519, 65528], 3], [[65529, 65531], 3], [65532, 3], [65533, 3], [[65534, 65535], 3], [[65536, 65547], 2], [65548, 3], [[65549, 65574], 2], [65575, 3], [[65576, 65594], 2], [65595, 3], [[65596, 65597], 2], [65598, 3], [[65599, 65613], 2], [[65614, 65615], 3], [[65616, 65629], 2], [[65630, 65663], 3], [[65664, 65786], 2], [[65787, 65791], 3], [[65792, 65794], 2], [[65795, 65798], 3], [[65799, 65843], 2], [[65844, 65846], 3], [[65847, 65855], 2], [[65856, 65930], 2], [[65931, 65932], 2], [[65933, 65934], 2], [65935, 3], [[65936, 65947], 2], [65948, 2], [[65949, 65951], 3], [65952, 2], [[65953, 65999], 3], [[66e3, 66044], 2], [66045, 2], [[66046, 66175], 3], [[66176, 66204], 2], [[66205, 66207], 3], [[66208, 66256], 2], [[66257, 66271], 3], [66272, 2], [[66273, 66299], 2], [[66300, 66303], 3], [[66304, 66334], 2], [66335, 2], [[66336, 66339], 2], [[66340, 66348], 3], [[66349, 66351], 2], [[66352, 66368], 2], [66369, 2], [[66370, 66377], 2], [66378, 2], [[66379, 66383], 3], [[66384, 66426], 2], [[66427, 66431], 3], [[66432, 66461], 2], [66462, 3], [66463, 2], [[66464, 66499], 2], [[66500, 66503], 3], [[66504, 66511], 2], [[66512, 66517], 2], [[66518, 66559], 3], [66560, 1, "\u{10428}"], [66561, 1, "\u{10429}"], [66562, 1, "\u{1042A}"], [66563, 1, "\u{1042B}"], [66564, 1, "\u{1042C}"], [66565, 1, "\u{1042D}"], [66566, 1, "\u{1042E}"], [66567, 1, "\u{1042F}"], [66568, 1, "\u{10430}"], [66569, 1, "\u{10431}"], [66570, 1, "\u{10432}"], [66571, 1, "\u{10433}"], [66572, 1, "\u{10434}"], [66573, 1, "\u{10435}"], [66574, 1, "\u{10436}"], [66575, 1, "\u{10437}"], [66576, 1, "\u{10438}"], [66577, 1, "\u{10439}"], [66578, 1, "\u{1043A}"], [66579, 1, "\u{1043B}"], [66580, 1, "\u{1043C}"], [66581, 1, "\u{1043D}"], [66582, 1, "\u{1043E}"], [66583, 1, "\u{1043F}"], [66584, 1, "\u{10440}"], [66585, 1, "\u{10441}"], [66586, 1, "\u{10442}"], [66587, 1, "\u{10443}"], [66588, 1, "\u{10444}"], [66589, 1, "\u{10445}"], [66590, 1, "\u{10446}"], [66591, 1, "\u{10447}"], [66592, 1, "\u{10448}"], [66593, 1, "\u{10449}"], [66594, 1, "\u{1044A}"], [66595, 1, "\u{1044B}"], [66596, 1, "\u{1044C}"], [66597, 1, "\u{1044D}"], [66598, 1, "\u{1044E}"], [66599, 1, "\u{1044F}"], [[66600, 66637], 2], [[66638, 66717], 2], [[66718, 66719], 3], [[66720, 66729], 2], [[66730, 66735], 3], [66736, 1, "\u{104D8}"], [66737, 1, "\u{104D9}"], [66738, 1, "\u{104DA}"], [66739, 1, "\u{104DB}"], [66740, 1, "\u{104DC}"], [66741, 1, "\u{104DD}"], [66742, 1, "\u{104DE}"], [66743, 1, "\u{104DF}"], [66744, 1, "\u{104E0}"], [66745, 1, "\u{104E1}"], [66746, 1, "\u{104E2}"], [66747, 1, "\u{104E3}"], [66748, 1, "\u{104E4}"], [66749, 1, "\u{104E5}"], [66750, 1, "\u{104E6}"], [66751, 1, "\u{104E7}"], [66752, 1, "\u{104E8}"], [66753, 1, "\u{104E9}"], [66754, 1, "\u{104EA}"], [66755, 1, "\u{104EB}"], [66756, 1, "\u{104EC}"], [66757, 1, "\u{104ED}"], [66758, 1, "\u{104EE}"], [66759, 1, "\u{104EF}"], [66760, 1, "\u{104F0}"], [66761, 1, "\u{104F1}"], [66762, 1, "\u{104F2}"], [66763, 1, "\u{104F3}"], [66764, 1, "\u{104F4}"], [66765, 1, "\u{104F5}"], [66766, 1, "\u{104F6}"], [66767, 1, "\u{104F7}"], [66768, 1, "\u{104F8}"], [66769, 1, "\u{104F9}"], [66770, 1, "\u{104FA}"], [66771, 1, "\u{104FB}"], [[66772, 66775], 3], [[66776, 66811], 2], [[66812, 66815], 3], [[66816, 66855], 2], [[66856, 66863], 3], [[66864, 66915], 2], [[66916, 66926], 3], [66927, 2], [66928, 1, "\u{10597}"], [66929, 1, "\u{10598}"], [66930, 1, "\u{10599}"], [66931, 1, "\u{1059A}"], [66932, 1, "\u{1059B}"], [66933, 1, "\u{1059C}"], [66934, 1, "\u{1059D}"], [66935, 1, "\u{1059E}"], [66936, 1, "\u{1059F}"], [66937, 1, "\u{105A0}"], [66938, 1, "\u{105A1}"], [66939, 3], [66940, 1, "\u{105A3}"], [66941, 1, "\u{105A4}"], [66942, 1, "\u{105A5}"], [66943, 1, "\u{105A6}"], [66944, 1, "\u{105A7}"], [66945, 1, "\u{105A8}"], [66946, 1, "\u{105A9}"], [66947, 1, "\u{105AA}"], [66948, 1, "\u{105AB}"], [66949, 1, "\u{105AC}"], [66950, 1, "\u{105AD}"], [66951, 1, "\u{105AE}"], [66952, 1, "\u{105AF}"], [66953, 1, "\u{105B0}"], [66954, 1, "\u{105B1}"], [66955, 3], [66956, 1, "\u{105B3}"], [66957, 1, "\u{105B4}"], [66958, 1, "\u{105B5}"], [66959, 1, "\u{105B6}"], [66960, 1, "\u{105B7}"], [66961, 1, "\u{105B8}"], [66962, 1, "\u{105B9}"], [66963, 3], [66964, 1, "\u{105BB}"], [66965, 1, "\u{105BC}"], [66966, 3], [[66967, 66977], 2], [66978, 3], [[66979, 66993], 2], [66994, 3], [[66995, 67001], 2], [67002, 3], [[67003, 67004], 2], [[67005, 67007], 3], [[67008, 67059], 2], [[67060, 67071], 3], [[67072, 67382], 2], [[67383, 67391], 3], [[67392, 67413], 2], [[67414, 67423], 3], [[67424, 67431], 2], [[67432, 67455], 3], [67456, 2], [67457, 1, "\u02D0"], [67458, 1, "\u02D1"], [67459, 1, "\xE6"], [67460, 1, "\u0299"], [67461, 1, "\u0253"], [67462, 3], [67463, 1, "\u02A3"], [67464, 1, "\uAB66"], [67465, 1, "\u02A5"], [67466, 1, "\u02A4"], [67467, 1, "\u0256"], [67468, 1, "\u0257"], [67469, 1, "\u1D91"], [67470, 1, "\u0258"], [67471, 1, "\u025E"], [67472, 1, "\u02A9"], [67473, 1, "\u0264"], [67474, 1, "\u0262"], [67475, 1, "\u0260"], [67476, 1, "\u029B"], [67477, 1, "\u0127"], [67478, 1, "\u029C"], [67479, 1, "\u0267"], [67480, 1, "\u0284"], [67481, 1, "\u02AA"], [67482, 1, "\u02AB"], [67483, 1, "\u026C"], [67484, 1, "\u{1DF04}"], [67485, 1, "\uA78E"], [67486, 1, "\u026E"], [67487, 1, "\u{1DF05}"], [67488, 1, "\u028E"], [67489, 1, "\u{1DF06}"], [67490, 1, "\xF8"], [67491, 1, "\u0276"], [67492, 1, "\u0277"], [67493, 1, "q"], [67494, 1, "\u027A"], [67495, 1, "\u{1DF08}"], [67496, 1, "\u027D"], [67497, 1, "\u027E"], [67498, 1, "\u0280"], [67499, 1, "\u02A8"], [67500, 1, "\u02A6"], [67501, 1, "\uAB67"], [67502, 1, "\u02A7"], [67503, 1, "\u0288"], [67504, 1, "\u2C71"], [67505, 3], [67506, 1, "\u028F"], [67507, 1, "\u02A1"], [67508, 1, "\u02A2"], [67509, 1, "\u0298"], [67510, 1, "\u01C0"], [67511, 1, "\u01C1"], [67512, 1, "\u01C2"], [67513, 1, "\u{1DF0A}"], [67514, 1, "\u{1DF1E}"], [[67515, 67583], 3], [[67584, 67589], 2], [[67590, 67591], 3], [67592, 2], [67593, 3], [[67594, 67637], 2], [67638, 3], [[67639, 67640], 2], [[67641, 67643], 3], [67644, 2], [[67645, 67646], 3], [67647, 2], [[67648, 67669], 2], [67670, 3], [[67671, 67679], 2], [[67680, 67702], 2], [[67703, 67711], 2], [[67712, 67742], 2], [[67743, 67750], 3], [[67751, 67759], 2], [[67760, 67807], 3], [[67808, 67826], 2], [67827, 3], [[67828, 67829], 2], [[67830, 67834], 3], [[67835, 67839], 2], [[67840, 67861], 2], [[67862, 67865], 2], [[67866, 67867], 2], [[67868, 67870], 3], [67871, 2], [[67872, 67897], 2], [[67898, 67902], 3], [67903, 2], [[67904, 67967], 3], [[67968, 68023], 2], [[68024, 68027], 3], [[68028, 68029], 2], [[68030, 68031], 2], [[68032, 68047], 2], [[68048, 68049], 3], [[68050, 68095], 2], [[68096, 68099], 2], [68100, 3], [[68101, 68102], 2], [[68103, 68107], 3], [[68108, 68115], 2], [68116, 3], [[68117, 68119], 2], [68120, 3], [[68121, 68147], 2], [[68148, 68149], 2], [[68150, 68151], 3], [[68152, 68154], 2], [[68155, 68158], 3], [68159, 2], [[68160, 68167], 2], [68168, 2], [[68169, 68175], 3], [[68176, 68184], 2], [[68185, 68191], 3], [[68192, 68220], 2], [[68221, 68223], 2], [[68224, 68252], 2], [[68253, 68255], 2], [[68256, 68287], 3], [[68288, 68295], 2], [68296, 2], [[68297, 68326], 2], [[68327, 68330], 3], [[68331, 68342], 2], [[68343, 68351], 3], [[68352, 68405], 2], [[68406, 68408], 3], [[68409, 68415], 2], [[68416, 68437], 2], [[68438, 68439], 3], [[68440, 68447], 2], [[68448, 68466], 2], [[68467, 68471], 3], [[68472, 68479], 2], [[68480, 68497], 2], [[68498, 68504], 3], [[68505, 68508], 2], [[68509, 68520], 3], [[68521, 68527], 2], [[68528, 68607], 3], [[68608, 68680], 2], [[68681, 68735], 3], [68736, 1, "\u{10CC0}"], [68737, 1, "\u{10CC1}"], [68738, 1, "\u{10CC2}"], [68739, 1, "\u{10CC3}"], [68740, 1, "\u{10CC4}"], [68741, 1, "\u{10CC5}"], [68742, 1, "\u{10CC6}"], [68743, 1, "\u{10CC7}"], [68744, 1, "\u{10CC8}"], [68745, 1, "\u{10CC9}"], [68746, 1, "\u{10CCA}"], [68747, 1, "\u{10CCB}"], [68748, 1, "\u{10CCC}"], [68749, 1, "\u{10CCD}"], [68750, 1, "\u{10CCE}"], [68751, 1, "\u{10CCF}"], [68752, 1, "\u{10CD0}"], [68753, 1, "\u{10CD1}"], [68754, 1, "\u{10CD2}"], [68755, 1, "\u{10CD3}"], [68756, 1, "\u{10CD4}"], [68757, 1, "\u{10CD5}"], [68758, 1, "\u{10CD6}"], [68759, 1, "\u{10CD7}"], [68760, 1, "\u{10CD8}"], [68761, 1, "\u{10CD9}"], [68762, 1, "\u{10CDA}"], [68763, 1, "\u{10CDB}"], [68764, 1, "\u{10CDC}"], [68765, 1, "\u{10CDD}"], [68766, 1, "\u{10CDE}"], [68767, 1, "\u{10CDF}"], [68768, 1, "\u{10CE0}"], [68769, 1, "\u{10CE1}"], [68770, 1, "\u{10CE2}"], [68771, 1, "\u{10CE3}"], [68772, 1, "\u{10CE4}"], [68773, 1, "\u{10CE5}"], [68774, 1, "\u{10CE6}"], [68775, 1, "\u{10CE7}"], [68776, 1, "\u{10CE8}"], [68777, 1, "\u{10CE9}"], [68778, 1, "\u{10CEA}"], [68779, 1, "\u{10CEB}"], [68780, 1, "\u{10CEC}"], [68781, 1, "\u{10CED}"], [68782, 1, "\u{10CEE}"], [68783, 1, "\u{10CEF}"], [68784, 1, "\u{10CF0}"], [68785, 1, "\u{10CF1}"], [68786, 1, "\u{10CF2}"], [[68787, 68799], 3], [[68800, 68850], 2], [[68851, 68857], 3], [[68858, 68863], 2], [[68864, 68903], 2], [[68904, 68911], 3], [[68912, 68921], 2], [[68922, 68927], 3], [[68928, 68943], 2], [68944, 1, "\u{10D70}"], [68945, 1, "\u{10D71}"], [68946, 1, "\u{10D72}"], [68947, 1, "\u{10D73}"], [68948, 1, "\u{10D74}"], [68949, 1, "\u{10D75}"], [68950, 1, "\u{10D76}"], [68951, 1, "\u{10D77}"], [68952, 1, "\u{10D78}"], [68953, 1, "\u{10D79}"], [68954, 1, "\u{10D7A}"], [68955, 1, "\u{10D7B}"], [68956, 1, "\u{10D7C}"], [68957, 1, "\u{10D7D}"], [68958, 1, "\u{10D7E}"], [68959, 1, "\u{10D7F}"], [68960, 1, "\u{10D80}"], [68961, 1, "\u{10D81}"], [68962, 1, "\u{10D82}"], [68963, 1, "\u{10D83}"], [68964, 1, "\u{10D84}"], [68965, 1, "\u{10D85}"], [[68966, 68968], 3], [[68969, 68973], 2], [68974, 2], [[68975, 68997], 2], [[68998, 69005], 3], [[69006, 69007], 2], [[69008, 69215], 3], [[69216, 69246], 2], [69247, 3], [[69248, 69289], 2], [69290, 3], [[69291, 69292], 2], [69293, 2], [[69294, 69295], 3], [[69296, 69297], 2], [[69298, 69313], 3], [[69314, 69316], 2], [[69317, 69371], 3], [69372, 2], [[69373, 69375], 2], [[69376, 69404], 2], [[69405, 69414], 2], [69415, 2], [[69416, 69423], 3], [[69424, 69456], 2], [[69457, 69465], 2], [[69466, 69487], 3], [[69488, 69509], 2], [[69510, 69513], 2], [[69514, 69551], 3], [[69552, 69572], 2], [[69573, 69579], 2], [[69580, 69599], 3], [[69600, 69622], 2], [[69623, 69631], 3], [[69632, 69702], 2], [[69703, 69709], 2], [[69710, 69713], 3], [[69714, 69733], 2], [[69734, 69743], 2], [[69744, 69749], 2], [[69750, 69758], 3], [69759, 2], [[69760, 69818], 2], [[69819, 69820], 2], [69821, 3], [[69822, 69825], 2], [69826, 2], [[69827, 69836], 3], [69837, 3], [[69838, 69839], 3], [[69840, 69864], 2], [[69865, 69871], 3], [[69872, 69881], 2], [[69882, 69887], 3], [[69888, 69940], 2], [69941, 3], [[69942, 69951], 2], [[69952, 69955], 2], [[69956, 69958], 2], [69959, 2], [[69960, 69967], 3], [[69968, 70003], 2], [[70004, 70005], 2], [70006, 2], [[70007, 70015], 3], [[70016, 70084], 2], [[70085, 70088], 2], [[70089, 70092], 2], [70093, 2], [[70094, 70095], 2], [[70096, 70105], 2], [70106, 2], [70107, 2], [70108, 2], [[70109, 70111], 2], [70112, 3], [[70113, 70132], 2], [[70133, 70143], 3], [[70144, 70161], 2], [70162, 3], [[70163, 70199], 2], [[70200, 70205], 2], [70206, 2], [[70207, 70209], 2], [[70210, 70271], 3], [[70272, 70278], 2], [70279, 3], [70280, 2], [70281, 3], [[70282, 70285], 2], [70286, 3], [[70287, 70301], 2], [70302, 3], [[70303, 70312], 2], [70313, 2], [[70314, 70319], 3], [[70320, 70378], 2], [[70379, 70383], 3], [[70384, 70393], 2], [[70394, 70399], 3], [70400, 2], [[70401, 70403], 2], [70404, 3], [[70405, 70412], 2], [[70413, 70414], 3], [[70415, 70416], 2], [[70417, 70418], 3], [[70419, 70440], 2], [70441, 3], [[70442, 70448], 2], [70449, 3], [[70450, 70451], 2], [70452, 3], [[70453, 70457], 2], [70458, 3], [70459, 2], [[70460, 70468], 2], [[70469, 70470], 3], [[70471, 70472], 2], [[70473, 70474], 3], [[70475, 70477], 2], [[70478, 70479], 3], [70480, 2], [[70481, 70486], 3], [70487, 2], [[70488, 70492], 3], [[70493, 70499], 2], [[70500, 70501], 3], [[70502, 70508], 2], [[70509, 70511], 3], [[70512, 70516], 2], [[70517, 70527], 3], [[70528, 70537], 2], [70538, 3], [70539, 2], [[70540, 70541], 3], [70542, 2], [70543, 3], [[70544, 70581], 2], [70582, 3], [[70583, 70592], 2], [70593, 3], [70594, 2], [[70595, 70596], 3], [70597, 2], [70598, 3], [[70599, 70602], 2], [70603, 3], [[70604, 70611], 2], [[70612, 70613], 2], [70614, 3], [[70615, 70616], 2], [[70617, 70624], 3], [[70625, 70626], 2], [[70627, 70655], 3], [[70656, 70730], 2], [[70731, 70735], 2], [[70736, 70745], 2], [70746, 2], [70747, 2], [70748, 3], [70749, 2], [70750, 2], [70751, 2], [[70752, 70753], 2], [[70754, 70783], 3], [[70784, 70853], 2], [70854, 2], [70855, 2], [[70856, 70863], 3], [[70864, 70873], 2], [[70874, 71039], 3], [[71040, 71093], 2], [[71094, 71095], 3], [[71096, 71104], 2], [[71105, 71113], 2], [[71114, 71127], 2], [[71128, 71133], 2], [[71134, 71167], 3], [[71168, 71232], 2], [[71233, 71235], 2], [71236, 2], [[71237, 71247], 3], [[71248, 71257], 2], [[71258, 71263], 3], [[71264, 71276], 2], [[71277, 71295], 3], [[71296, 71351], 2], [71352, 2], [71353, 2], [[71354, 71359], 3], [[71360, 71369], 2], [[71370, 71375], 3], [[71376, 71395], 2], [[71396, 71423], 3], [[71424, 71449], 2], [71450, 2], [[71451, 71452], 3], [[71453, 71467], 2], [[71468, 71471], 3], [[71472, 71481], 2], [[71482, 71487], 2], [[71488, 71494], 2], [[71495, 71679], 3], [[71680, 71738], 2], [71739, 2], [[71740, 71839], 3], [71840, 1, "\u{118C0}"], [71841, 1, "\u{118C1}"], [71842, 1, "\u{118C2}"], [71843, 1, "\u{118C3}"], [71844, 1, "\u{118C4}"], [71845, 1, "\u{118C5}"], [71846, 1, "\u{118C6}"], [71847, 1, "\u{118C7}"], [71848, 1, "\u{118C8}"], [71849, 1, "\u{118C9}"], [71850, 1, "\u{118CA}"], [71851, 1, "\u{118CB}"], [71852, 1, "\u{118CC}"], [71853, 1, "\u{118CD}"], [71854, 1, "\u{118CE}"], [71855, 1, "\u{118CF}"], [71856, 1, "\u{118D0}"], [71857, 1, "\u{118D1}"], [71858, 1, "\u{118D2}"], [71859, 1, "\u{118D3}"], [71860, 1, "\u{118D4}"], [71861, 1, "\u{118D5}"], [71862, 1, "\u{118D6}"], [71863, 1, "\u{118D7}"], [71864, 1, "\u{118D8}"], [71865, 1, "\u{118D9}"], [71866, 1, "\u{118DA}"], [71867, 1, "\u{118DB}"], [71868, 1, "\u{118DC}"], [71869, 1, "\u{118DD}"], [71870, 1, "\u{118DE}"], [71871, 1, "\u{118DF}"], [[71872, 71913], 2], [[71914, 71922], 2], [[71923, 71934], 3], [71935, 2], [[71936, 71942], 2], [[71943, 71944], 3], [71945, 2], [[71946, 71947], 3], [[71948, 71955], 2], [71956, 3], [[71957, 71958], 2], [71959, 3], [[71960, 71989], 2], [71990, 3], [[71991, 71992], 2], [[71993, 71994], 3], [[71995, 72003], 2], [[72004, 72006], 2], [[72007, 72015], 3], [[72016, 72025], 2], [[72026, 72095], 3], [[72096, 72103], 2], [[72104, 72105], 3], [[72106, 72151], 2], [[72152, 72153], 3], [[72154, 72161], 2], [72162, 2], [[72163, 72164], 2], [[72165, 72191], 3], [[72192, 72254], 2], [[72255, 72262], 2], [72263, 2], [[72264, 72271], 3], [[72272, 72323], 2], [[72324, 72325], 2], [[72326, 72345], 2], [[72346, 72348], 2], [72349, 2], [[72350, 72354], 2], [[72355, 72367], 3], [[72368, 72383], 2], [[72384, 72440], 2], [[72441, 72447], 3], [[72448, 72457], 2], [[72458, 72639], 3], [[72640, 72672], 2], [72673, 2], [[72674, 72687], 3], [[72688, 72697], 2], [[72698, 72703], 3], [[72704, 72712], 2], [72713, 3], [[72714, 72758], 2], [72759, 3], [[72760, 72768], 2], [[72769, 72773], 2], [[72774, 72783], 3], [[72784, 72793], 2], [[72794, 72812], 2], [[72813, 72815], 3], [[72816, 72817], 2], [[72818, 72847], 2], [[72848, 72849], 3], [[72850, 72871], 2], [72872, 3], [[72873, 72886], 2], [[72887, 72959], 3], [[72960, 72966], 2], [72967, 3], [[72968, 72969], 2], [72970, 3], [[72971, 73014], 2], [[73015, 73017], 3], [73018, 2], [73019, 3], [[73020, 73021], 2], [73022, 3], [[73023, 73031], 2], [[73032, 73039], 3], [[73040, 73049], 2], [[73050, 73055], 3], [[73056, 73061], 2], [73062, 3], [[73063, 73064], 2], [73065, 3], [[73066, 73102], 2], [73103, 3], [[73104, 73105], 2], [73106, 3], [[73107, 73112], 2], [[73113, 73119], 3], [[73120, 73129], 2], [[73130, 73439], 3], [[73440, 73462], 2], [[73463, 73464], 2], [[73465, 73471], 3], [[73472, 73488], 2], [73489, 3], [[73490, 73530], 2], [[73531, 73533], 3], [[73534, 73538], 2], [[73539, 73551], 2], [[73552, 73561], 2], [73562, 2], [[73563, 73647], 3], [73648, 2], [[73649, 73663], 3], [[73664, 73713], 2], [[73714, 73726], 3], [73727, 2], [[73728, 74606], 2], [[74607, 74648], 2], [74649, 2], [[74650, 74751], 3], [[74752, 74850], 2], [[74851, 74862], 2], [74863, 3], [[74864, 74867], 2], [74868, 2], [[74869, 74879], 3], [[74880, 75075], 2], [[75076, 77711], 3], [[77712, 77808], 2], [[77809, 77810], 2], [[77811, 77823], 3], [[77824, 78894], 2], [78895, 2], [[78896, 78904], 3], [[78905, 78911], 3], [[78912, 78933], 2], [[78934, 78943], 3], [[78944, 82938], 2], [[82939, 82943], 3], [[82944, 83526], 2], [[83527, 90367], 3], [[90368, 90425], 2], [[90426, 92159], 3], [[92160, 92728], 2], [[92729, 92735], 3], [[92736, 92766], 2], [92767, 3], [[92768, 92777], 2], [[92778, 92781], 3], [[92782, 92783], 2], [[92784, 92862], 2], [92863, 3], [[92864, 92873], 2], [[92874, 92879], 3], [[92880, 92909], 2], [[92910, 92911], 3], [[92912, 92916], 2], [92917, 2], [[92918, 92927], 3], [[92928, 92982], 2], [[92983, 92991], 2], [[92992, 92995], 2], [[92996, 92997], 2], [[92998, 93007], 3], [[93008, 93017], 2], [93018, 3], [[93019, 93025], 2], [93026, 3], [[93027, 93047], 2], [[93048, 93052], 3], [[93053, 93071], 2], [[93072, 93503], 3], [[93504, 93548], 2], [[93549, 93551], 2], [[93552, 93561], 2], [[93562, 93759], 3], [93760, 1, "\u{16E60}"], [93761, 1, "\u{16E61}"], [93762, 1, "\u{16E62}"], [93763, 1, "\u{16E63}"], [93764, 1, "\u{16E64}"], [93765, 1, "\u{16E65}"], [93766, 1, "\u{16E66}"], [93767, 1, "\u{16E67}"], [93768, 1, "\u{16E68}"], [93769, 1, "\u{16E69}"], [93770, 1, "\u{16E6A}"], [93771, 1, "\u{16E6B}"], [93772, 1, "\u{16E6C}"], [93773, 1, "\u{16E6D}"], [93774, 1, "\u{16E6E}"], [93775, 1, "\u{16E6F}"], [93776, 1, "\u{16E70}"], [93777, 1, "\u{16E71}"], [93778, 1, "\u{16E72}"], [93779, 1, "\u{16E73}"], [93780, 1, "\u{16E74}"], [93781, 1, "\u{16E75}"], [93782, 1, "\u{16E76}"], [93783, 1, "\u{16E77}"], [93784, 1, "\u{16E78}"], [93785, 1, "\u{16E79}"], [93786, 1, "\u{16E7A}"], [93787, 1, "\u{16E7B}"], [93788, 1, "\u{16E7C}"], [93789, 1, "\u{16E7D}"], [93790, 1, "\u{16E7E}"], [93791, 1, "\u{16E7F}"], [[93792, 93823], 2], [[93824, 93850], 2], [[93851, 93951], 3], [[93952, 94020], 2], [[94021, 94026], 2], [[94027, 94030], 3], [94031, 2], [[94032, 94078], 2], [[94079, 94087], 2], [[94088, 94094], 3], [[94095, 94111], 2], [[94112, 94175], 3], [94176, 2], [94177, 2], [94178, 2], [94179, 2], [94180, 2], [[94181, 94191], 3], [[94192, 94193], 2], [[94194, 94207], 3], [[94208, 100332], 2], [[100333, 100337], 2], [[100338, 100343], 2], [[100344, 100351], 3], [[100352, 101106], 2], [[101107, 101589], 2], [[101590, 101630], 3], [101631, 2], [[101632, 101640], 2], [[101641, 110575], 3], [[110576, 110579], 2], [110580, 3], [[110581, 110587], 2], [110588, 3], [[110589, 110590], 2], [110591, 3], [[110592, 110593], 2], [[110594, 110878], 2], [[110879, 110882], 2], [[110883, 110897], 3], [110898, 2], [[110899, 110927], 3], [[110928, 110930], 2], [[110931, 110932], 3], [110933, 2], [[110934, 110947], 3], [[110948, 110951], 2], [[110952, 110959], 3], [[110960, 111355], 2], [[111356, 113663], 3], [[113664, 113770], 2], [[113771, 113775], 3], [[113776, 113788], 2], [[113789, 113791], 3], [[113792, 113800], 2], [[113801, 113807], 3], [[113808, 113817], 2], [[113818, 113819], 3], [113820, 2], [[113821, 113822], 2], [113823, 2], [[113824, 113827], 7], [[113828, 117759], 3], [[117760, 117973], 2], [117974, 1, "a"], [117975, 1, "b"], [117976, 1, "c"], [117977, 1, "d"], [117978, 1, "e"], [117979, 1, "f"], [117980, 1, "g"], [117981, 1, "h"], [117982, 1, "i"], [117983, 1, "j"], [117984, 1, "k"], [117985, 1, "l"], [117986, 1, "m"], [117987, 1, "n"], [117988, 1, "o"], [117989, 1, "p"], [117990, 1, "q"], [117991, 1, "r"], [117992, 1, "s"], [117993, 1, "t"], [117994, 1, "u"], [117995, 1, "v"], [117996, 1, "w"], [117997, 1, "x"], [117998, 1, "y"], [117999, 1, "z"], [118e3, 1, "0"], [118001, 1, "1"], [118002, 1, "2"], [118003, 1, "3"], [118004, 1, "4"], [118005, 1, "5"], [118006, 1, "6"], [118007, 1, "7"], [118008, 1, "8"], [118009, 1, "9"], [[118010, 118015], 3], [[118016, 118451], 2], [[118452, 118527], 3], [[118528, 118573], 2], [[118574, 118575], 3], [[118576, 118598], 2], [[118599, 118607], 3], [[118608, 118723], 2], [[118724, 118783], 3], [[118784, 119029], 2], [[119030, 119039], 3], [[119040, 119078], 2], [[119079, 119080], 3], [119081, 2], [[119082, 119133], 2], [119134, 1, "\u{1D157}\u{1D165}"], [119135, 1, "\u{1D158}\u{1D165}"], [119136, 1, "\u{1D158}\u{1D165}\u{1D16E}"], [119137, 1, "\u{1D158}\u{1D165}\u{1D16F}"], [119138, 1, "\u{1D158}\u{1D165}\u{1D170}"], [119139, 1, "\u{1D158}\u{1D165}\u{1D171}"], [119140, 1, "\u{1D158}\u{1D165}\u{1D172}"], [[119141, 119154], 2], [[119155, 119162], 7], [[119163, 119226], 2], [119227, 1, "\u{1D1B9}\u{1D165}"], [119228, 1, "\u{1D1BA}\u{1D165}"], [119229, 1, "\u{1D1B9}\u{1D165}\u{1D16E}"], [119230, 1, "\u{1D1BA}\u{1D165}\u{1D16E}"], [119231, 1, "\u{1D1B9}\u{1D165}\u{1D16F}"], [119232, 1, "\u{1D1BA}\u{1D165}\u{1D16F}"], [[119233, 119261], 2], [[119262, 119272], 2], [[119273, 119274], 2], [[119275, 119295], 3], [[119296, 119365], 2], [[119366, 119487], 3], [[119488, 119507], 2], [[119508, 119519], 3], [[119520, 119539], 2], [[119540, 119551], 3], [[119552, 119638], 2], [[119639, 119647], 3], [[119648, 119665], 2], [[119666, 119672], 2], [[119673, 119807], 3], [119808, 1, "a"], [119809, 1, "b"], [119810, 1, "c"], [119811, 1, "d"], [119812, 1, "e"], [119813, 1, "f"], [119814, 1, "g"], [119815, 1, "h"], [119816, 1, "i"], [119817, 1, "j"], [119818, 1, "k"], [119819, 1, "l"], [119820, 1, "m"], [119821, 1, "n"], [119822, 1, "o"], [119823, 1, "p"], [119824, 1, "q"], [119825, 1, "r"], [119826, 1, "s"], [119827, 1, "t"], [119828, 1, "u"], [119829, 1, "v"], [119830, 1, "w"], [119831, 1, "x"], [119832, 1, "y"], [119833, 1, "z"], [119834, 1, "a"], [119835, 1, "b"], [119836, 1, "c"], [119837, 1, "d"], [119838, 1, "e"], [119839, 1, "f"], [119840, 1, "g"], [119841, 1, "h"], [119842, 1, "i"], [119843, 1, "j"], [119844, 1, "k"], [119845, 1, "l"], [119846, 1, "m"], [119847, 1, "n"], [119848, 1, "o"], [119849, 1, "p"], [119850, 1, "q"], [119851, 1, "r"], [119852, 1, "s"], [119853, 1, "t"], [119854, 1, "u"], [119855, 1, "v"], [119856, 1, "w"], [119857, 1, "x"], [119858, 1, "y"], [119859, 1, "z"], [119860, 1, "a"], [119861, 1, "b"], [119862, 1, "c"], [119863, 1, "d"], [119864, 1, "e"], [119865, 1, "f"], [119866, 1, "g"], [119867, 1, "h"], [119868, 1, "i"], [119869, 1, "j"], [119870, 1, "k"], [119871, 1, "l"], [119872, 1, "m"], [119873, 1, "n"], [119874, 1, "o"], [119875, 1, "p"], [119876, 1, "q"], [119877, 1, "r"], [119878, 1, "s"], [119879, 1, "t"], [119880, 1, "u"], [119881, 1, "v"], [119882, 1, "w"], [119883, 1, "x"], [119884, 1, "y"], [119885, 1, "z"], [119886, 1, "a"], [119887, 1, "b"], [119888, 1, "c"], [119889, 1, "d"], [119890, 1, "e"], [119891, 1, "f"], [119892, 1, "g"], [119893, 3], [119894, 1, "i"], [119895, 1, "j"], [119896, 1, "k"], [119897, 1, "l"], [119898, 1, "m"], [119899, 1, "n"], [119900, 1, "o"], [119901, 1, "p"], [119902, 1, "q"], [119903, 1, "r"], [119904, 1, "s"], [119905, 1, "t"], [119906, 1, "u"], [119907, 1, "v"], [119908, 1, "w"], [119909, 1, "x"], [119910, 1, "y"], [119911, 1, "z"], [119912, 1, "a"], [119913, 1, "b"], [119914, 1, "c"], [119915, 1, "d"], [119916, 1, "e"], [119917, 1, "f"], [119918, 1, "g"], [119919, 1, "h"], [119920, 1, "i"], [119921, 1, "j"], [119922, 1, "k"], [119923, 1, "l"], [119924, 1, "m"], [119925, 1, "n"], [119926, 1, "o"], [119927, 1, "p"], [119928, 1, "q"], [119929, 1, "r"], [119930, 1, "s"], [119931, 1, "t"], [119932, 1, "u"], [119933, 1, "v"], [119934, 1, "w"], [119935, 1, "x"], [119936, 1, "y"], [119937, 1, "z"], [119938, 1, "a"], [119939, 1, "b"], [119940, 1, "c"], [119941, 1, "d"], [119942, 1, "e"], [119943, 1, "f"], [119944, 1, "g"], [119945, 1, "h"], [119946, 1, "i"], [119947, 1, "j"], [119948, 1, "k"], [119949, 1, "l"], [119950, 1, "m"], [119951, 1, "n"], [119952, 1, "o"], [119953, 1, "p"], [119954, 1, "q"], [119955, 1, "r"], [119956, 1, "s"], [119957, 1, "t"], [119958, 1, "u"], [119959, 1, "v"], [119960, 1, "w"], [119961, 1, "x"], [119962, 1, "y"], [119963, 1, "z"], [119964, 1, "a"], [119965, 3], [119966, 1, "c"], [119967, 1, "d"], [[119968, 119969], 3], [119970, 1, "g"], [[119971, 119972], 3], [119973, 1, "j"], [119974, 1, "k"], [[119975, 119976], 3], [119977, 1, "n"], [119978, 1, "o"], [119979, 1, "p"], [119980, 1, "q"], [119981, 3], [119982, 1, "s"], [119983, 1, "t"], [119984, 1, "u"], [119985, 1, "v"], [119986, 1, "w"], [119987, 1, "x"], [119988, 1, "y"], [119989, 1, "z"], [119990, 1, "a"], [119991, 1, "b"], [119992, 1, "c"], [119993, 1, "d"], [119994, 3], [119995, 1, "f"], [119996, 3], [119997, 1, "h"], [119998, 1, "i"], [119999, 1, "j"], [12e4, 1, "k"], [120001, 1, "l"], [120002, 1, "m"], [120003, 1, "n"], [120004, 3], [120005, 1, "p"], [120006, 1, "q"], [120007, 1, "r"], [120008, 1, "s"], [120009, 1, "t"], [120010, 1, "u"], [120011, 1, "v"], [120012, 1, "w"], [120013, 1, "x"], [120014, 1, "y"], [120015, 1, "z"], [120016, 1, "a"], [120017, 1, "b"], [120018, 1, "c"], [120019, 1, "d"], [120020, 1, "e"], [120021, 1, "f"], [120022, 1, "g"], [120023, 1, "h"], [120024, 1, "i"], [120025, 1, "j"], [120026, 1, "k"], [120027, 1, "l"], [120028, 1, "m"], [120029, 1, "n"], [120030, 1, "o"], [120031, 1, "p"], [120032, 1, "q"], [120033, 1, "r"], [120034, 1, "s"], [120035, 1, "t"], [120036, 1, "u"], [120037, 1, "v"], [120038, 1, "w"], [120039, 1, "x"], [120040, 1, "y"], [120041, 1, "z"], [120042, 1, "a"], [120043, 1, "b"], [120044, 1, "c"], [120045, 1, "d"], [120046, 1, "e"], [120047, 1, "f"], [120048, 1, "g"], [120049, 1, "h"], [120050, 1, "i"], [120051, 1, "j"], [120052, 1, "k"], [120053, 1, "l"], [120054, 1, "m"], [120055, 1, "n"], [120056, 1, "o"], [120057, 1, "p"], [120058, 1, "q"], [120059, 1, "r"], [120060, 1, "s"], [120061, 1, "t"], [120062, 1, "u"], [120063, 1, "v"], [120064, 1, "w"], [120065, 1, "x"], [120066, 1, "y"], [120067, 1, "z"], [120068, 1, "a"], [120069, 1, "b"], [120070, 3], [120071, 1, "d"], [120072, 1, "e"], [120073, 1, "f"], [120074, 1, "g"], [[120075, 120076], 3], [120077, 1, "j"], [120078, 1, "k"], [120079, 1, "l"], [120080, 1, "m"], [120081, 1, "n"], [120082, 1, "o"], [120083, 1, "p"], [120084, 1, "q"], [120085, 3], [120086, 1, "s"], [120087, 1, "t"], [120088, 1, "u"], [120089, 1, "v"], [120090, 1, "w"], [120091, 1, "x"], [120092, 1, "y"], [120093, 3], [120094, 1, "a"], [120095, 1, "b"], [120096, 1, "c"], [120097, 1, "d"], [120098, 1, "e"], [120099, 1, "f"], [120100, 1, "g"], [120101, 1, "h"], [120102, 1, "i"], [120103, 1, "j"], [120104, 1, "k"], [120105, 1, "l"], [120106, 1, "m"], [120107, 1, "n"], [120108, 1, "o"], [120109, 1, "p"], [120110, 1, "q"], [120111, 1, "r"], [120112, 1, "s"], [120113, 1, "t"], [120114, 1, "u"], [120115, 1, "v"], [120116, 1, "w"], [120117, 1, "x"], [120118, 1, "y"], [120119, 1, "z"], [120120, 1, "a"], [120121, 1, "b"], [120122, 3], [120123, 1, "d"], [120124, 1, "e"], [120125, 1, "f"], [120126, 1, "g"], [120127, 3], [120128, 1, "i"], [120129, 1, "j"], [120130, 1, "k"], [120131, 1, "l"], [120132, 1, "m"], [120133, 3], [120134, 1, "o"], [[120135, 120137], 3], [120138, 1, "s"], [120139, 1, "t"], [120140, 1, "u"], [120141, 1, "v"], [120142, 1, "w"], [120143, 1, "x"], [120144, 1, "y"], [120145, 3], [120146, 1, "a"], [120147, 1, "b"], [120148, 1, "c"], [120149, 1, "d"], [120150, 1, "e"], [120151, 1, "f"], [120152, 1, "g"], [120153, 1, "h"], [120154, 1, "i"], [120155, 1, "j"], [120156, 1, "k"], [120157, 1, "l"], [120158, 1, "m"], [120159, 1, "n"], [120160, 1, "o"], [120161, 1, "p"], [120162, 1, "q"], [120163, 1, "r"], [120164, 1, "s"], [120165, 1, "t"], [120166, 1, "u"], [120167, 1, "v"], [120168, 1, "w"], [120169, 1, "x"], [120170, 1, "y"], [120171, 1, "z"], [120172, 1, "a"], [120173, 1, "b"], [120174, 1, "c"], [120175, 1, "d"], [120176, 1, "e"], [120177, 1, "f"], [120178, 1, "g"], [120179, 1, "h"], [120180, 1, "i"], [120181, 1, "j"], [120182, 1, "k"], [120183, 1, "l"], [120184, 1, "m"], [120185, 1, "n"], [120186, 1, "o"], [120187, 1, "p"], [120188, 1, "q"], [120189, 1, "r"], [120190, 1, "s"], [120191, 1, "t"], [120192, 1, "u"], [120193, 1, "v"], [120194, 1, "w"], [120195, 1, "x"], [120196, 1, "y"], [120197, 1, "z"], [120198, 1, "a"], [120199, 1, "b"], [120200, 1, "c"], [120201, 1, "d"], [120202, 1, "e"], [120203, 1, "f"], [120204, 1, "g"], [120205, 1, "h"], [120206, 1, "i"], [120207, 1, "j"], [120208, 1, "k"], [120209, 1, "l"], [120210, 1, "m"], [120211, 1, "n"], [120212, 1, "o"], [120213, 1, "p"], [120214, 1, "q"], [120215, 1, "r"], [120216, 1, "s"], [120217, 1, "t"], [120218, 1, "u"], [120219, 1, "v"], [120220, 1, "w"], [120221, 1, "x"], [120222, 1, "y"], [120223, 1, "z"], [120224, 1, "a"], [120225, 1, "b"], [120226, 1, "c"], [120227, 1, "d"], [120228, 1, "e"], [120229, 1, "f"], [120230, 1, "g"], [120231, 1, "h"], [120232, 1, "i"], [120233, 1, "j"], [120234, 1, "k"], [120235, 1, "l"], [120236, 1, "m"], [120237, 1, "n"], [120238, 1, "o"], [120239, 1, "p"], [120240, 1, "q"], [120241, 1, "r"], [120242, 1, "s"], [120243, 1, "t"], [120244, 1, "u"], [120245, 1, "v"], [120246, 1, "w"], [120247, 1, "x"], [120248, 1, "y"], [120249, 1, "z"], [120250, 1, "a"], [120251, 1, "b"], [120252, 1, "c"], [120253, 1, "d"], [120254, 1, "e"], [120255, 1, "f"], [120256, 1, "g"], [120257, 1, "h"], [120258, 1, "i"], [120259, 1, "j"], [120260, 1, "k"], [120261, 1, "l"], [120262, 1, "m"], [120263, 1, "n"], [120264, 1, "o"], [120265, 1, "p"], [120266, 1, "q"], [120267, 1, "r"], [120268, 1, "s"], [120269, 1, "t"], [120270, 1, "u"], [120271, 1, "v"], [120272, 1, "w"], [120273, 1, "x"], [120274, 1, "y"], [120275, 1, "z"], [120276, 1, "a"], [120277, 1, "b"], [120278, 1, "c"], [120279, 1, "d"], [120280, 1, "e"], [120281, 1, "f"], [120282, 1, "g"], [120283, 1, "h"], [120284, 1, "i"], [120285, 1, "j"], [120286, 1, "k"], [120287, 1, "l"], [120288, 1, "m"], [120289, 1, "n"], [120290, 1, "o"], [120291, 1, "p"], [120292, 1, "q"], [120293, 1, "r"], [120294, 1, "s"], [120295, 1, "t"], [120296, 1, "u"], [120297, 1, "v"], [120298, 1, "w"], [120299, 1, "x"], [120300, 1, "y"], [120301, 1, "z"], [120302, 1, "a"], [120303, 1, "b"], [120304, 1, "c"], [120305, 1, "d"], [120306, 1, "e"], [120307, 1, "f"], [120308, 1, "g"], [120309, 1, "h"], [120310, 1, "i"], [120311, 1, "j"], [120312, 1, "k"], [120313, 1, "l"], [120314, 1, "m"], [120315, 1, "n"], [120316, 1, "o"], [120317, 1, "p"], [120318, 1, "q"], [120319, 1, "r"], [120320, 1, "s"], [120321, 1, "t"], [120322, 1, "u"], [120323, 1, "v"], [120324, 1, "w"], [120325, 1, "x"], [120326, 1, "y"], [120327, 1, "z"], [120328, 1, "a"], [120329, 1, "b"], [120330, 1, "c"], [120331, 1, "d"], [120332, 1, "e"], [120333, 1, "f"], [120334, 1, "g"], [120335, 1, "h"], [120336, 1, "i"], [120337, 1, "j"], [120338, 1, "k"], [120339, 1, "l"], [120340, 1, "m"], [120341, 1, "n"], [120342, 1, "o"], [120343, 1, "p"], [120344, 1, "q"], [120345, 1, "r"], [120346, 1, "s"], [120347, 1, "t"], [120348, 1, "u"], [120349, 1, "v"], [120350, 1, "w"], [120351, 1, "x"], [120352, 1, "y"], [120353, 1, "z"], [120354, 1, "a"], [120355, 1, "b"], [120356, 1, "c"], [120357, 1, "d"], [120358, 1, "e"], [120359, 1, "f"], [120360, 1, "g"], [120361, 1, "h"], [120362, 1, "i"], [120363, 1, "j"], [120364, 1, "k"], [120365, 1, "l"], [120366, 1, "m"], [120367, 1, "n"], [120368, 1, "o"], [120369, 1, "p"], [120370, 1, "q"], [120371, 1, "r"], [120372, 1, "s"], [120373, 1, "t"], [120374, 1, "u"], [120375, 1, "v"], [120376, 1, "w"], [120377, 1, "x"], [120378, 1, "y"], [120379, 1, "z"], [120380, 1, "a"], [120381, 1, "b"], [120382, 1, "c"], [120383, 1, "d"], [120384, 1, "e"], [120385, 1, "f"], [120386, 1, "g"], [120387, 1, "h"], [120388, 1, "i"], [120389, 1, "j"], [120390, 1, "k"], [120391, 1, "l"], [120392, 1, "m"], [120393, 1, "n"], [120394, 1, "o"], [120395, 1, "p"], [120396, 1, "q"], [120397, 1, "r"], [120398, 1, "s"], [120399, 1, "t"], [120400, 1, "u"], [120401, 1, "v"], [120402, 1, "w"], [120403, 1, "x"], [120404, 1, "y"], [120405, 1, "z"], [120406, 1, "a"], [120407, 1, "b"], [120408, 1, "c"], [120409, 1, "d"], [120410, 1, "e"], [120411, 1, "f"], [120412, 1, "g"], [120413, 1, "h"], [120414, 1, "i"], [120415, 1, "j"], [120416, 1, "k"], [120417, 1, "l"], [120418, 1, "m"], [120419, 1, "n"], [120420, 1, "o"], [120421, 1, "p"], [120422, 1, "q"], [120423, 1, "r"], [120424, 1, "s"], [120425, 1, "t"], [120426, 1, "u"], [120427, 1, "v"], [120428, 1, "w"], [120429, 1, "x"], [120430, 1, "y"], [120431, 1, "z"], [120432, 1, "a"], [120433, 1, "b"], [120434, 1, "c"], [120435, 1, "d"], [120436, 1, "e"], [120437, 1, "f"], [120438, 1, "g"], [120439, 1, "h"], [120440, 1, "i"], [120441, 1, "j"], [120442, 1, "k"], [120443, 1, "l"], [120444, 1, "m"], [120445, 1, "n"], [120446, 1, "o"], [120447, 1, "p"], [120448, 1, "q"], [120449, 1, "r"], [120450, 1, "s"], [120451, 1, "t"], [120452, 1, "u"], [120453, 1, "v"], [120454, 1, "w"], [120455, 1, "x"], [120456, 1, "y"], [120457, 1, "z"], [120458, 1, "a"], [120459, 1, "b"], [120460, 1, "c"], [120461, 1, "d"], [120462, 1, "e"], [120463, 1, "f"], [120464, 1, "g"], [120465, 1, "h"], [120466, 1, "i"], [120467, 1, "j"], [120468, 1, "k"], [120469, 1, "l"], [120470, 1, "m"], [120471, 1, "n"], [120472, 1, "o"], [120473, 1, "p"], [120474, 1, "q"], [120475, 1, "r"], [120476, 1, "s"], [120477, 1, "t"], [120478, 1, "u"], [120479, 1, "v"], [120480, 1, "w"], [120481, 1, "x"], [120482, 1, "y"], [120483, 1, "z"], [120484, 1, "\u0131"], [120485, 1, "\u0237"], [[120486, 120487], 3], [120488, 1, "\u03B1"], [120489, 1, "\u03B2"], [120490, 1, "\u03B3"], [120491, 1, "\u03B4"], [120492, 1, "\u03B5"], [120493, 1, "\u03B6"], [120494, 1, "\u03B7"], [120495, 1, "\u03B8"], [120496, 1, "\u03B9"], [120497, 1, "\u03BA"], [120498, 1, "\u03BB"], [120499, 1, "\u03BC"], [120500, 1, "\u03BD"], [120501, 1, "\u03BE"], [120502, 1, "\u03BF"], [120503, 1, "\u03C0"], [120504, 1, "\u03C1"], [120505, 1, "\u03B8"], [120506, 1, "\u03C3"], [120507, 1, "\u03C4"], [120508, 1, "\u03C5"], [120509, 1, "\u03C6"], [120510, 1, "\u03C7"], [120511, 1, "\u03C8"], [120512, 1, "\u03C9"], [120513, 1, "\u2207"], [120514, 1, "\u03B1"], [120515, 1, "\u03B2"], [120516, 1, "\u03B3"], [120517, 1, "\u03B4"], [120518, 1, "\u03B5"], [120519, 1, "\u03B6"], [120520, 1, "\u03B7"], [120521, 1, "\u03B8"], [120522, 1, "\u03B9"], [120523, 1, "\u03BA"], [120524, 1, "\u03BB"], [120525, 1, "\u03BC"], [120526, 1, "\u03BD"], [120527, 1, "\u03BE"], [120528, 1, "\u03BF"], [120529, 1, "\u03C0"], [120530, 1, "\u03C1"], [[120531, 120532], 1, "\u03C3"], [120533, 1, "\u03C4"], [120534, 1, "\u03C5"], [120535, 1, "\u03C6"], [120536, 1, "\u03C7"], [120537, 1, "\u03C8"], [120538, 1, "\u03C9"], [120539, 1, "\u2202"], [120540, 1, "\u03B5"], [120541, 1, "\u03B8"], [120542, 1, "\u03BA"], [120543, 1, "\u03C6"], [120544, 1, "\u03C1"], [120545, 1, "\u03C0"], [120546, 1, "\u03B1"], [120547, 1, "\u03B2"], [120548, 1, "\u03B3"], [120549, 1, "\u03B4"], [120550, 1, "\u03B5"], [120551, 1, "\u03B6"], [120552, 1, "\u03B7"], [120553, 1, "\u03B8"], [120554, 1, "\u03B9"], [120555, 1, "\u03BA"], [120556, 1, "\u03BB"], [120557, 1, "\u03BC"], [120558, 1, "\u03BD"], [120559, 1, "\u03BE"], [120560, 1, "\u03BF"], [120561, 1, "\u03C0"], [120562, 1, "\u03C1"], [120563, 1, "\u03B8"], [120564, 1, "\u03C3"], [120565, 1, "\u03C4"], [120566, 1, "\u03C5"], [120567, 1, "\u03C6"], [120568, 1, "\u03C7"], [120569, 1, "\u03C8"], [120570, 1, "\u03C9"], [120571, 1, "\u2207"], [120572, 1, "\u03B1"], [120573, 1, "\u03B2"], [120574, 1, "\u03B3"], [120575, 1, "\u03B4"], [120576, 1, "\u03B5"], [120577, 1, "\u03B6"], [120578, 1, "\u03B7"], [120579, 1, "\u03B8"], [120580, 1, "\u03B9"], [120581, 1, "\u03BA"], [120582, 1, "\u03BB"], [120583, 1, "\u03BC"], [120584, 1, "\u03BD"], [120585, 1, "\u03BE"], [120586, 1, "\u03BF"], [120587, 1, "\u03C0"], [120588, 1, "\u03C1"], [[120589, 120590], 1, "\u03C3"], [120591, 1, "\u03C4"], [120592, 1, "\u03C5"], [120593, 1, "\u03C6"], [120594, 1, "\u03C7"], [120595, 1, "\u03C8"], [120596, 1, "\u03C9"], [120597, 1, "\u2202"], [120598, 1, "\u03B5"], [120599, 1, "\u03B8"], [120600, 1, "\u03BA"], [120601, 1, "\u03C6"], [120602, 1, "\u03C1"], [120603, 1, "\u03C0"], [120604, 1, "\u03B1"], [120605, 1, "\u03B2"], [120606, 1, "\u03B3"], [120607, 1, "\u03B4"], [120608, 1, "\u03B5"], [120609, 1, "\u03B6"], [120610, 1, "\u03B7"], [120611, 1, "\u03B8"], [120612, 1, "\u03B9"], [120613, 1, "\u03BA"], [120614, 1, "\u03BB"], [120615, 1, "\u03BC"], [120616, 1, "\u03BD"], [120617, 1, "\u03BE"], [120618, 1, "\u03BF"], [120619, 1, "\u03C0"], [120620, 1, "\u03C1"], [120621, 1, "\u03B8"], [120622, 1, "\u03C3"], [120623, 1, "\u03C4"], [120624, 1, "\u03C5"], [120625, 1, "\u03C6"], [120626, 1, "\u03C7"], [120627, 1, "\u03C8"], [120628, 1, "\u03C9"], [120629, 1, "\u2207"], [120630, 1, "\u03B1"], [120631, 1, "\u03B2"], [120632, 1, "\u03B3"], [120633, 1, "\u03B4"], [120634, 1, "\u03B5"], [120635, 1, "\u03B6"], [120636, 1, "\u03B7"], [120637, 1, "\u03B8"], [120638, 1, "\u03B9"], [120639, 1, "\u03BA"], [120640, 1, "\u03BB"], [120641, 1, "\u03BC"], [120642, 1, "\u03BD"], [120643, 1, "\u03BE"], [120644, 1, "\u03BF"], [120645, 1, "\u03C0"], [120646, 1, "\u03C1"], [[120647, 120648], 1, "\u03C3"], [120649, 1, "\u03C4"], [120650, 1, "\u03C5"], [120651, 1, "\u03C6"], [120652, 1, "\u03C7"], [120653, 1, "\u03C8"], [120654, 1, "\u03C9"], [120655, 1, "\u2202"], [120656, 1, "\u03B5"], [120657, 1, "\u03B8"], [120658, 1, "\u03BA"], [120659, 1, "\u03C6"], [120660, 1, "\u03C1"], [120661, 1, "\u03C0"], [120662, 1, "\u03B1"], [120663, 1, "\u03B2"], [120664, 1, "\u03B3"], [120665, 1, "\u03B4"], [120666, 1, "\u03B5"], [120667, 1, "\u03B6"], [120668, 1, "\u03B7"], [120669, 1, "\u03B8"], [120670, 1, "\u03B9"], [120671, 1, "\u03BA"], [120672, 1, "\u03BB"], [120673, 1, "\u03BC"], [120674, 1, "\u03BD"], [120675, 1, "\u03BE"], [120676, 1, "\u03BF"], [120677, 1, "\u03C0"], [120678, 1, "\u03C1"], [120679, 1, "\u03B8"], [120680, 1, "\u03C3"], [120681, 1, "\u03C4"], [120682, 1, "\u03C5"], [120683, 1, "\u03C6"], [120684, 1, "\u03C7"], [120685, 1, "\u03C8"], [120686, 1, "\u03C9"], [120687, 1, "\u2207"], [120688, 1, "\u03B1"], [120689, 1, "\u03B2"], [120690, 1, "\u03B3"], [120691, 1, "\u03B4"], [120692, 1, "\u03B5"], [120693, 1, "\u03B6"], [120694, 1, "\u03B7"], [120695, 1, "\u03B8"], [120696, 1, "\u03B9"], [120697, 1, "\u03BA"], [120698, 1, "\u03BB"], [120699, 1, "\u03BC"], [120700, 1, "\u03BD"], [120701, 1, "\u03BE"], [120702, 1, "\u03BF"], [120703, 1, "\u03C0"], [120704, 1, "\u03C1"], [[120705, 120706], 1, "\u03C3"], [120707, 1, "\u03C4"], [120708, 1, "\u03C5"], [120709, 1, "\u03C6"], [120710, 1, "\u03C7"], [120711, 1, "\u03C8"], [120712, 1, "\u03C9"], [120713, 1, "\u2202"], [120714, 1, "\u03B5"], [120715, 1, "\u03B8"], [120716, 1, "\u03BA"], [120717, 1, "\u03C6"], [120718, 1, "\u03C1"], [120719, 1, "\u03C0"], [120720, 1, "\u03B1"], [120721, 1, "\u03B2"], [120722, 1, "\u03B3"], [120723, 1, "\u03B4"], [120724, 1, "\u03B5"], [120725, 1, "\u03B6"], [120726, 1, "\u03B7"], [120727, 1, "\u03B8"], [120728, 1, "\u03B9"], [120729, 1, "\u03BA"], [120730, 1, "\u03BB"], [120731, 1, "\u03BC"], [120732, 1, "\u03BD"], [120733, 1, "\u03BE"], [120734, 1, "\u03BF"], [120735, 1, "\u03C0"], [120736, 1, "\u03C1"], [120737, 1, "\u03B8"], [120738, 1, "\u03C3"], [120739, 1, "\u03C4"], [120740, 1, "\u03C5"], [120741, 1, "\u03C6"], [120742, 1, "\u03C7"], [120743, 1, "\u03C8"], [120744, 1, "\u03C9"], [120745, 1, "\u2207"], [120746, 1, "\u03B1"], [120747, 1, "\u03B2"], [120748, 1, "\u03B3"], [120749, 1, "\u03B4"], [120750, 1, "\u03B5"], [120751, 1, "\u03B6"], [120752, 1, "\u03B7"], [120753, 1, "\u03B8"], [120754, 1, "\u03B9"], [120755, 1, "\u03BA"], [120756, 1, "\u03BB"], [120757, 1, "\u03BC"], [120758, 1, "\u03BD"], [120759, 1, "\u03BE"], [120760, 1, "\u03BF"], [120761, 1, "\u03C0"], [120762, 1, "\u03C1"], [[120763, 120764], 1, "\u03C3"], [120765, 1, "\u03C4"], [120766, 1, "\u03C5"], [120767, 1, "\u03C6"], [120768, 1, "\u03C7"], [120769, 1, "\u03C8"], [120770, 1, "\u03C9"], [120771, 1, "\u2202"], [120772, 1, "\u03B5"], [120773, 1, "\u03B8"], [120774, 1, "\u03BA"], [120775, 1, "\u03C6"], [120776, 1, "\u03C1"], [120777, 1, "\u03C0"], [[120778, 120779], 1, "\u03DD"], [[120780, 120781], 3], [120782, 1, "0"], [120783, 1, "1"], [120784, 1, "2"], [120785, 1, "3"], [120786, 1, "4"], [120787, 1, "5"], [120788, 1, "6"], [120789, 1, "7"], [120790, 1, "8"], [120791, 1, "9"], [120792, 1, "0"], [120793, 1, "1"], [120794, 1, "2"], [120795, 1, "3"], [120796, 1, "4"], [120797, 1, "5"], [120798, 1, "6"], [120799, 1, "7"], [120800, 1, "8"], [120801, 1, "9"], [120802, 1, "0"], [120803, 1, "1"], [120804, 1, "2"], [120805, 1, "3"], [120806, 1, "4"], [120807, 1, "5"], [120808, 1, "6"], [120809, 1, "7"], [120810, 1, "8"], [120811, 1, "9"], [120812, 1, "0"], [120813, 1, "1"], [120814, 1, "2"], [120815, 1, "3"], [120816, 1, "4"], [120817, 1, "5"], [120818, 1, "6"], [120819, 1, "7"], [120820, 1, "8"], [120821, 1, "9"], [120822, 1, "0"], [120823, 1, "1"], [120824, 1, "2"], [120825, 1, "3"], [120826, 1, "4"], [120827, 1, "5"], [120828, 1, "6"], [120829, 1, "7"], [120830, 1, "8"], [120831, 1, "9"], [[120832, 121343], 2], [[121344, 121398], 2], [[121399, 121402], 2], [[121403, 121452], 2], [[121453, 121460], 2], [121461, 2], [[121462, 121475], 2], [121476, 2], [[121477, 121483], 2], [[121484, 121498], 3], [[121499, 121503], 2], [121504, 3], [[121505, 121519], 2], [[121520, 122623], 3], [[122624, 122654], 2], [[122655, 122660], 3], [[122661, 122666], 2], [[122667, 122879], 3], [[122880, 122886], 2], [122887, 3], [[122888, 122904], 2], [[122905, 122906], 3], [[122907, 122913], 2], [122914, 3], [[122915, 122916], 2], [122917, 3], [[122918, 122922], 2], [[122923, 122927], 3], [122928, 1, "\u0430"], [122929, 1, "\u0431"], [122930, 1, "\u0432"], [122931, 1, "\u0433"], [122932, 1, "\u0434"], [122933, 1, "\u0435"], [122934, 1, "\u0436"], [122935, 1, "\u0437"], [122936, 1, "\u0438"], [122937, 1, "\u043A"], [122938, 1, "\u043B"], [122939, 1, "\u043C"], [122940, 1, "\u043E"], [122941, 1, "\u043F"], [122942, 1, "\u0440"], [122943, 1, "\u0441"], [122944, 1, "\u0442"], [122945, 1, "\u0443"], [122946, 1, "\u0444"], [122947, 1, "\u0445"], [122948, 1, "\u0446"], [122949, 1, "\u0447"], [122950, 1, "\u0448"], [122951, 1, "\u044B"], [122952, 1, "\u044D"], [122953, 1, "\u044E"], [122954, 1, "\uA689"], [122955, 1, "\u04D9"], [122956, 1, "\u0456"], [122957, 1, "\u0458"], [122958, 1, "\u04E9"], [122959, 1, "\u04AF"], [122960, 1, "\u04CF"], [122961, 1, "\u0430"], [122962, 1, "\u0431"], [122963, 1, "\u0432"], [122964, 1, "\u0433"], [122965, 1, "\u0434"], [122966, 1, "\u0435"], [122967, 1, "\u0436"], [122968, 1, "\u0437"], [122969, 1, "\u0438"], [122970, 1, "\u043A"], [122971, 1, "\u043B"], [122972, 1, "\u043E"], [122973, 1, "\u043F"], [122974, 1, "\u0441"], [122975, 1, "\u0443"], [122976, 1, "\u0444"], [122977, 1, "\u0445"], [122978, 1, "\u0446"], [122979, 1, "\u0447"], [122980, 1, "\u0448"], [122981, 1, "\u044A"], [122982, 1, "\u044B"], [122983, 1, "\u0491"], [122984, 1, "\u0456"], [122985, 1, "\u0455"], [122986, 1, "\u045F"], [122987, 1, "\u04AB"], [122988, 1, "\uA651"], [122989, 1, "\u04B1"], [[122990, 123022], 3], [123023, 2], [[123024, 123135], 3], [[123136, 123180], 2], [[123181, 123183], 3], [[123184, 123197], 2], [[123198, 123199], 3], [[123200, 123209], 2], [[123210, 123213], 3], [123214, 2], [123215, 2], [[123216, 123535], 3], [[123536, 123566], 2], [[123567, 123583], 3], [[123584, 123641], 2], [[123642, 123646], 3], [123647, 2], [[123648, 124111], 3], [[124112, 124153], 2], [[124154, 124367], 3], [[124368, 124410], 2], [[124411, 124414], 3], [124415, 2], [[124416, 124895], 3], [[124896, 124902], 2], [124903, 3], [[124904, 124907], 2], [124908, 3], [[124909, 124910], 2], [124911, 3], [[124912, 124926], 2], [124927, 3], [[124928, 125124], 2], [[125125, 125126], 3], [[125127, 125135], 2], [[125136, 125142], 2], [[125143, 125183], 3], [125184, 1, "\u{1E922}"], [125185, 1, "\u{1E923}"], [125186, 1, "\u{1E924}"], [125187, 1, "\u{1E925}"], [125188, 1, "\u{1E926}"], [125189, 1, "\u{1E927}"], [125190, 1, "\u{1E928}"], [125191, 1, "\u{1E929}"], [125192, 1, "\u{1E92A}"], [125193, 1, "\u{1E92B}"], [125194, 1, "\u{1E92C}"], [125195, 1, "\u{1E92D}"], [125196, 1, "\u{1E92E}"], [125197, 1, "\u{1E92F}"], [125198, 1, "\u{1E930}"], [125199, 1, "\u{1E931}"], [125200, 1, "\u{1E932}"], [125201, 1, "\u{1E933}"], [125202, 1, "\u{1E934}"], [125203, 1, "\u{1E935}"], [125204, 1, "\u{1E936}"], [125205, 1, "\u{1E937}"], [125206, 1, "\u{1E938}"], [125207, 1, "\u{1E939}"], [125208, 1, "\u{1E93A}"], [125209, 1, "\u{1E93B}"], [125210, 1, "\u{1E93C}"], [125211, 1, "\u{1E93D}"], [125212, 1, "\u{1E93E}"], [125213, 1, "\u{1E93F}"], [125214, 1, "\u{1E940}"], [125215, 1, "\u{1E941}"], [125216, 1, "\u{1E942}"], [125217, 1, "\u{1E943}"], [[125218, 125258], 2], [125259, 2], [[125260, 125263], 3], [[125264, 125273], 2], [[125274, 125277], 3], [[125278, 125279], 2], [[125280, 126064], 3], [[126065, 126132], 2], [[126133, 126208], 3], [[126209, 126269], 2], [[126270, 126463], 3], [126464, 1, "\u0627"], [126465, 1, "\u0628"], [126466, 1, "\u062C"], [126467, 1, "\u062F"], [126468, 3], [126469, 1, "\u0648"], [126470, 1, "\u0632"], [126471, 1, "\u062D"], [126472, 1, "\u0637"], [126473, 1, "\u064A"], [126474, 1, "\u0643"], [126475, 1, "\u0644"], [126476, 1, "\u0645"], [126477, 1, "\u0646"], [126478, 1, "\u0633"], [126479, 1, "\u0639"], [126480, 1, "\u0641"], [126481, 1, "\u0635"], [126482, 1, "\u0642"], [126483, 1, "\u0631"], [126484, 1, "\u0634"], [126485, 1, "\u062A"], [126486, 1, "\u062B"], [126487, 1, "\u062E"], [126488, 1, "\u0630"], [126489, 1, "\u0636"], [126490, 1, "\u0638"], [126491, 1, "\u063A"], [126492, 1, "\u066E"], [126493, 1, "\u06BA"], [126494, 1, "\u06A1"], [126495, 1, "\u066F"], [126496, 3], [126497, 1, "\u0628"], [126498, 1, "\u062C"], [126499, 3], [126500, 1, "\u0647"], [[126501, 126502], 3], [126503, 1, "\u062D"], [126504, 3], [126505, 1, "\u064A"], [126506, 1, "\u0643"], [126507, 1, "\u0644"], [126508, 1, "\u0645"], [126509, 1, "\u0646"], [126510, 1, "\u0633"], [126511, 1, "\u0639"], [126512, 1, "\u0641"], [126513, 1, "\u0635"], [126514, 1, "\u0642"], [126515, 3], [126516, 1, "\u0634"], [126517, 1, "\u062A"], [126518, 1, "\u062B"], [126519, 1, "\u062E"], [126520, 3], [126521, 1, "\u0636"], [126522, 3], [126523, 1, "\u063A"], [[126524, 126529], 3], [126530, 1, "\u062C"], [[126531, 126534], 3], [126535, 1, "\u062D"], [126536, 3], [126537, 1, "\u064A"], [126538, 3], [126539, 1, "\u0644"], [126540, 3], [126541, 1, "\u0646"], [126542, 1, "\u0633"], [126543, 1, "\u0639"], [126544, 3], [126545, 1, "\u0635"], [126546, 1, "\u0642"], [126547, 3], [126548, 1, "\u0634"], [[126549, 126550], 3], [126551, 1, "\u062E"], [126552, 3], [126553, 1, "\u0636"], [126554, 3], [126555, 1, "\u063A"], [126556, 3], [126557, 1, "\u06BA"], [126558, 3], [126559, 1, "\u066F"], [126560, 3], [126561, 1, "\u0628"], [126562, 1, "\u062C"], [126563, 3], [126564, 1, "\u0647"], [[126565, 126566], 3], [126567, 1, "\u062D"], [126568, 1, "\u0637"], [126569, 1, "\u064A"], [126570, 1, "\u0643"], [126571, 3], [126572, 1, "\u0645"], [126573, 1, "\u0646"], [126574, 1, "\u0633"], [126575, 1, "\u0639"], [126576, 1, "\u0641"], [126577, 1, "\u0635"], [126578, 1, "\u0642"], [126579, 3], [126580, 1, "\u0634"], [126581, 1, "\u062A"], [126582, 1, "\u062B"], [126583, 1, "\u062E"], [126584, 3], [126585, 1, "\u0636"], [126586, 1, "\u0638"], [126587, 1, "\u063A"], [126588, 1, "\u066E"], [126589, 3], [126590, 1, "\u06A1"], [126591, 3], [126592, 1, "\u0627"], [126593, 1, "\u0628"], [126594, 1, "\u062C"], [126595, 1, "\u062F"], [126596, 1, "\u0647"], [126597, 1, "\u0648"], [126598, 1, "\u0632"], [126599, 1, "\u062D"], [126600, 1, "\u0637"], [126601, 1, "\u064A"], [126602, 3], [126603, 1, "\u0644"], [126604, 1, "\u0645"], [126605, 1, "\u0646"], [126606, 1, "\u0633"], [126607, 1, "\u0639"], [126608, 1, "\u0641"], [126609, 1, "\u0635"], [126610, 1, "\u0642"], [126611, 1, "\u0631"], [126612, 1, "\u0634"], [126613, 1, "\u062A"], [126614, 1, "\u062B"], [126615, 1, "\u062E"], [126616, 1, "\u0630"], [126617, 1, "\u0636"], [126618, 1, "\u0638"], [126619, 1, "\u063A"], [[126620, 126624], 3], [126625, 1, "\u0628"], [126626, 1, "\u062C"], [126627, 1, "\u062F"], [126628, 3], [126629, 1, "\u0648"], [126630, 1, "\u0632"], [126631, 1, "\u062D"], [126632, 1, "\u0637"], [126633, 1, "\u064A"], [126634, 3], [126635, 1, "\u0644"], [126636, 1, "\u0645"], [126637, 1, "\u0646"], [126638, 1, "\u0633"], [126639, 1, "\u0639"], [126640, 1, "\u0641"], [126641, 1, "\u0635"], [126642, 1, "\u0642"], [126643, 1, "\u0631"], [126644, 1, "\u0634"], [126645, 1, "\u062A"], [126646, 1, "\u062B"], [126647, 1, "\u062E"], [126648, 1, "\u0630"], [126649, 1, "\u0636"], [126650, 1, "\u0638"], [126651, 1, "\u063A"], [[126652, 126703], 3], [[126704, 126705], 2], [[126706, 126975], 3], [[126976, 127019], 2], [[127020, 127023], 3], [[127024, 127123], 2], [[127124, 127135], 3], [[127136, 127150], 2], [[127151, 127152], 3], [[127153, 127166], 2], [127167, 2], [127168, 3], [[127169, 127183], 2], [127184, 3], [[127185, 127199], 2], [[127200, 127221], 2], [[127222, 127231], 3], [127232, 3], [127233, 1, "0,"], [127234, 1, "1,"], [127235, 1, "2,"], [127236, 1, "3,"], [127237, 1, "4,"], [127238, 1, "5,"], [127239, 1, "6,"], [127240, 1, "7,"], [127241, 1, "8,"], [127242, 1, "9,"], [[127243, 127244], 2], [[127245, 127247], 2], [127248, 1, "(a)"], [127249, 1, "(b)"], [127250, 1, "(c)"], [127251, 1, "(d)"], [127252, 1, "(e)"], [127253, 1, "(f)"], [127254, 1, "(g)"], [127255, 1, "(h)"], [127256, 1, "(i)"], [127257, 1, "(j)"], [127258, 1, "(k)"], [127259, 1, "(l)"], [127260, 1, "(m)"], [127261, 1, "(n)"], [127262, 1, "(o)"], [127263, 1, "(p)"], [127264, 1, "(q)"], [127265, 1, "(r)"], [127266, 1, "(s)"], [127267, 1, "(t)"], [127268, 1, "(u)"], [127269, 1, "(v)"], [127270, 1, "(w)"], [127271, 1, "(x)"], [127272, 1, "(y)"], [127273, 1, "(z)"], [127274, 1, "\u3014s\u3015"], [127275, 1, "c"], [127276, 1, "r"], [127277, 1, "cd"], [127278, 1, "wz"], [127279, 2], [127280, 1, "a"], [127281, 1, "b"], [127282, 1, "c"], [127283, 1, "d"], [127284, 1, "e"], [127285, 1, "f"], [127286, 1, "g"], [127287, 1, "h"], [127288, 1, "i"], [127289, 1, "j"], [127290, 1, "k"], [127291, 1, "l"], [127292, 1, "m"], [127293, 1, "n"], [127294, 1, "o"], [127295, 1, "p"], [127296, 1, "q"], [127297, 1, "r"], [127298, 1, "s"], [127299, 1, "t"], [127300, 1, "u"], [127301, 1, "v"], [127302, 1, "w"], [127303, 1, "x"], [127304, 1, "y"], [127305, 1, "z"], [127306, 1, "hv"], [127307, 1, "mv"], [127308, 1, "sd"], [127309, 1, "ss"], [127310, 1, "ppv"], [127311, 1, "wc"], [[127312, 127318], 2], [127319, 2], [[127320, 127326], 2], [127327, 2], [[127328, 127337], 2], [127338, 1, "mc"], [127339, 1, "md"], [127340, 1, "mr"], [[127341, 127343], 2], [[127344, 127352], 2], [127353, 2], [127354, 2], [[127355, 127356], 2], [[127357, 127358], 2], [127359, 2], [[127360, 127369], 2], [[127370, 127373], 2], [[127374, 127375], 2], [127376, 1, "dj"], [[127377, 127386], 2], [[127387, 127404], 2], [127405, 2], [[127406, 127461], 3], [[127462, 127487], 2], [127488, 1, "\u307B\u304B"], [127489, 1, "\u30B3\u30B3"], [127490, 1, "\u30B5"], [[127491, 127503], 3], [127504, 1, "\u624B"], [127505, 1, "\u5B57"], [127506, 1, "\u53CC"], [127507, 1, "\u30C7"], [127508, 1, "\u4E8C"], [127509, 1, "\u591A"], [127510, 1, "\u89E3"], [127511, 1, "\u5929"], [127512, 1, "\u4EA4"], [127513, 1, "\u6620"], [127514, 1, "\u7121"], [127515, 1, "\u6599"], [127516, 1, "\u524D"], [127517, 1, "\u5F8C"], [127518, 1, "\u518D"], [127519, 1, "\u65B0"], [127520, 1, "\u521D"], [127521, 1, "\u7D42"], [127522, 1, "\u751F"], [127523, 1, "\u8CA9"], [127524, 1, "\u58F0"], [127525, 1, "\u5439"], [127526, 1, "\u6F14"], [127527, 1, "\u6295"], [127528, 1, "\u6355"], [127529, 1, "\u4E00"], [127530, 1, "\u4E09"], [127531, 1, "\u904A"], [127532, 1, "\u5DE6"], [127533, 1, "\u4E2D"], [127534, 1, "\u53F3"], [127535, 1, "\u6307"], [127536, 1, "\u8D70"], [127537, 1, "\u6253"], [127538, 1, "\u7981"], [127539, 1, "\u7A7A"], [127540, 1, "\u5408"], [127541, 1, "\u6E80"], [127542, 1, "\u6709"], [127543, 1, "\u6708"], [127544, 1, "\u7533"], [127545, 1, "\u5272"], [127546, 1, "\u55B6"], [127547, 1, "\u914D"], [[127548, 127551], 3], [127552, 1, "\u3014\u672C\u3015"], [127553, 1, "\u3014\u4E09\u3015"], [127554, 1, "\u3014\u4E8C\u3015"], [127555, 1, "\u3014\u5B89\u3015"], [127556, 1, "\u3014\u70B9\u3015"], [127557, 1, "\u3014\u6253\u3015"], [127558, 1, "\u3014\u76D7\u3015"], [127559, 1, "\u3014\u52DD\u3015"], [127560, 1, "\u3014\u6557\u3015"], [[127561, 127567], 3], [127568, 1, "\u5F97"], [127569, 1, "\u53EF"], [[127570, 127583], 3], [[127584, 127589], 2], [[127590, 127743], 3], [[127744, 127776], 2], [[127777, 127788], 2], [[127789, 127791], 2], [[127792, 127797], 2], [127798, 2], [[127799, 127868], 2], [127869, 2], [[127870, 127871], 2], [[127872, 127891], 2], [[127892, 127903], 2], [[127904, 127940], 2], [127941, 2], [[127942, 127946], 2], [[127947, 127950], 2], [[127951, 127955], 2], [[127956, 127967], 2], [[127968, 127984], 2], [[127985, 127991], 2], [[127992, 127999], 2], [[128e3, 128062], 2], [128063, 2], [128064, 2], [128065, 2], [[128066, 128247], 2], [128248, 2], [[128249, 128252], 2], [[128253, 128254], 2], [128255, 2], [[128256, 128317], 2], [[128318, 128319], 2], [[128320, 128323], 2], [[128324, 128330], 2], [[128331, 128335], 2], [[128336, 128359], 2], [[128360, 128377], 2], [128378, 2], [[128379, 128419], 2], [128420, 2], [[128421, 128506], 2], [[128507, 128511], 2], [128512, 2], [[128513, 128528], 2], [128529, 2], [[128530, 128532], 2], [128533, 2], [128534, 2], [128535, 2], [128536, 2], [128537, 2], [128538, 2], [128539, 2], [[128540, 128542], 2], [128543, 2], [[128544, 128549], 2], [[128550, 128551], 2], [[128552, 128555], 2], [128556, 2], [128557, 2], [[128558, 128559], 2], [[128560, 128563], 2], [128564, 2], [[128565, 128576], 2], [[128577, 128578], 2], [[128579, 128580], 2], [[128581, 128591], 2], [[128592, 128639], 2], [[128640, 128709], 2], [[128710, 128719], 2], [128720, 2], [[128721, 128722], 2], [[128723, 128724], 2], [128725, 2], [[128726, 128727], 2], [[128728, 128731], 3], [128732, 2], [[128733, 128735], 2], [[128736, 128748], 2], [[128749, 128751], 3], [[128752, 128755], 2], [[128756, 128758], 2], [[128759, 128760], 2], [128761, 2], [128762, 2], [[128763, 128764], 2], [[128765, 128767], 3], [[128768, 128883], 2], [[128884, 128886], 2], [[128887, 128890], 3], [[128891, 128895], 2], [[128896, 128980], 2], [[128981, 128984], 2], [128985, 2], [[128986, 128991], 3], [[128992, 129003], 2], [[129004, 129007], 3], [129008, 2], [[129009, 129023], 3], [[129024, 129035], 2], [[129036, 129039], 3], [[129040, 129095], 2], [[129096, 129103], 3], [[129104, 129113], 2], [[129114, 129119], 3], [[129120, 129159], 2], [[129160, 129167], 3], [[129168, 129197], 2], [[129198, 129199], 3], [[129200, 129201], 2], [[129202, 129211], 2], [[129212, 129215], 3], [[129216, 129217], 2], [[129218, 129279], 3], [[129280, 129291], 2], [129292, 2], [[129293, 129295], 2], [[129296, 129304], 2], [[129305, 129310], 2], [129311, 2], [[129312, 129319], 2], [[129320, 129327], 2], [129328, 2], [[129329, 129330], 2], [[129331, 129342], 2], [129343, 2], [[129344, 129355], 2], [129356, 2], [[129357, 129359], 2], [[129360, 129374], 2], [[129375, 129387], 2], [[129388, 129392], 2], [129393, 2], [129394, 2], [[129395, 129398], 2], [[129399, 129400], 2], [129401, 2], [129402, 2], [129403, 2], [[129404, 129407], 2], [[129408, 129412], 2], [[129413, 129425], 2], [[129426, 129431], 2], [[129432, 129442], 2], [[129443, 129444], 2], [[129445, 129450], 2], [[129451, 129453], 2], [[129454, 129455], 2], [[129456, 129465], 2], [[129466, 129471], 2], [129472, 2], [[129473, 129474], 2], [[129475, 129482], 2], [129483, 2], [129484, 2], [[129485, 129487], 2], [[129488, 129510], 2], [[129511, 129535], 2], [[129536, 129619], 2], [[129620, 129631], 3], [[129632, 129645], 2], [[129646, 129647], 3], [[129648, 129651], 2], [129652, 2], [[129653, 129655], 2], [[129656, 129658], 2], [[129659, 129660], 2], [[129661, 129663], 3], [[129664, 129666], 2], [[129667, 129670], 2], [[129671, 129672], 2], [129673, 2], [[129674, 129678], 3], [129679, 2], [[129680, 129685], 2], [[129686, 129704], 2], [[129705, 129708], 2], [[129709, 129711], 2], [[129712, 129718], 2], [[129719, 129722], 2], [[129723, 129725], 2], [129726, 2], [129727, 2], [[129728, 129730], 2], [[129731, 129733], 2], [129734, 2], [[129735, 129741], 3], [[129742, 129743], 2], [[129744, 129750], 2], [[129751, 129753], 2], [[129754, 129755], 2], [129756, 2], [[129757, 129758], 3], [129759, 2], [[129760, 129767], 2], [129768, 2], [129769, 2], [[129770, 129775], 3], [[129776, 129782], 2], [[129783, 129784], 2], [[129785, 129791], 3], [[129792, 129938], 2], [129939, 3], [[129940, 129994], 2], [[129995, 130031], 2], [130032, 1, "0"], [130033, 1, "1"], [130034, 1, "2"], [130035, 1, "3"], [130036, 1, "4"], [130037, 1, "5"], [130038, 1, "6"], [130039, 1, "7"], [130040, 1, "8"], [130041, 1, "9"], [[130042, 131069], 3], [[131070, 131071], 3], [[131072, 173782], 2], [[173783, 173789], 2], [[173790, 173791], 2], [[173792, 173823], 3], [[173824, 177972], 2], [[177973, 177976], 2], [177977, 2], [[177978, 177983], 3], [[177984, 178205], 2], [[178206, 178207], 3], [[178208, 183969], 2], [[183970, 183983], 3], [[183984, 191456], 2], [[191457, 191471], 3], [[191472, 192093], 2], [[192094, 194559], 3], [194560, 1, "\u4E3D"], [194561, 1, "\u4E38"], [194562, 1, "\u4E41"], [194563, 1, "\u{20122}"], [194564, 1, "\u4F60"], [194565, 1, "\u4FAE"], [194566, 1, "\u4FBB"], [194567, 1, "\u5002"], [194568, 1, "\u507A"], [194569, 1, "\u5099"], [194570, 1, "\u50E7"], [194571, 1, "\u50CF"], [194572, 1, "\u349E"], [194573, 1, "\u{2063A}"], [194574, 1, "\u514D"], [194575, 1, "\u5154"], [194576, 1, "\u5164"], [194577, 1, "\u5177"], [194578, 1, "\u{2051C}"], [194579, 1, "\u34B9"], [194580, 1, "\u5167"], [194581, 1, "\u518D"], [194582, 1, "\u{2054B}"], [194583, 1, "\u5197"], [194584, 1, "\u51A4"], [194585, 1, "\u4ECC"], [194586, 1, "\u51AC"], [194587, 1, "\u51B5"], [194588, 1, "\u{291DF}"], [194589, 1, "\u51F5"], [194590, 1, "\u5203"], [194591, 1, "\u34DF"], [194592, 1, "\u523B"], [194593, 1, "\u5246"], [194594, 1, "\u5272"], [194595, 1, "\u5277"], [194596, 1, "\u3515"], [194597, 1, "\u52C7"], [194598, 1, "\u52C9"], [194599, 1, "\u52E4"], [194600, 1, "\u52FA"], [194601, 1, "\u5305"], [194602, 1, "\u5306"], [194603, 1, "\u5317"], [194604, 1, "\u5349"], [194605, 1, "\u5351"], [194606, 1, "\u535A"], [194607, 1, "\u5373"], [194608, 1, "\u537D"], [[194609, 194611], 1, "\u537F"], [194612, 1, "\u{20A2C}"], [194613, 1, "\u7070"], [194614, 1, "\u53CA"], [194615, 1, "\u53DF"], [194616, 1, "\u{20B63}"], [194617, 1, "\u53EB"], [194618, 1, "\u53F1"], [194619, 1, "\u5406"], [194620, 1, "\u549E"], [194621, 1, "\u5438"], [194622, 1, "\u5448"], [194623, 1, "\u5468"], [194624, 1, "\u54A2"], [194625, 1, "\u54F6"], [194626, 1, "\u5510"], [194627, 1, "\u5553"], [194628, 1, "\u5563"], [[194629, 194630], 1, "\u5584"], [194631, 1, "\u5599"], [194632, 1, "\u55AB"], [194633, 1, "\u55B3"], [194634, 1, "\u55C2"], [194635, 1, "\u5716"], [194636, 1, "\u5606"], [194637, 1, "\u5717"], [194638, 1, "\u5651"], [194639, 1, "\u5674"], [194640, 1, "\u5207"], [194641, 1, "\u58EE"], [194642, 1, "\u57CE"], [194643, 1, "\u57F4"], [194644, 1, "\u580D"], [194645, 1, "\u578B"], [194646, 1, "\u5832"], [194647, 1, "\u5831"], [194648, 1, "\u58AC"], [194649, 1, "\u{214E4}"], [194650, 1, "\u58F2"], [194651, 1, "\u58F7"], [194652, 1, "\u5906"], [194653, 1, "\u591A"], [194654, 1, "\u5922"], [194655, 1, "\u5962"], [194656, 1, "\u{216A8}"], [194657, 1, "\u{216EA}"], [194658, 1, "\u59EC"], [194659, 1, "\u5A1B"], [194660, 1, "\u5A27"], [194661, 1, "\u59D8"], [194662, 1, "\u5A66"], [194663, 1, "\u36EE"], [194664, 1, "\u36FC"], [194665, 1, "\u5B08"], [[194666, 194667], 1, "\u5B3E"], [194668, 1, "\u{219C8}"], [194669, 1, "\u5BC3"], [194670, 1, "\u5BD8"], [194671, 1, "\u5BE7"], [194672, 1, "\u5BF3"], [194673, 1, "\u{21B18}"], [194674, 1, "\u5BFF"], [194675, 1, "\u5C06"], [194676, 1, "\u5F53"], [194677, 1, "\u5C22"], [194678, 1, "\u3781"], [194679, 1, "\u5C60"], [194680, 1, "\u5C6E"], [194681, 1, "\u5CC0"], [194682, 1, "\u5C8D"], [194683, 1, "\u{21DE4}"], [194684, 1, "\u5D43"], [194685, 1, "\u{21DE6}"], [194686, 1, "\u5D6E"], [194687, 1, "\u5D6B"], [194688, 1, "\u5D7C"], [194689, 1, "\u5DE1"], [194690, 1, "\u5DE2"], [194691, 1, "\u382F"], [194692, 1, "\u5DFD"], [194693, 1, "\u5E28"], [194694, 1, "\u5E3D"], [194695, 1, "\u5E69"], [194696, 1, "\u3862"], [194697, 1, "\u{22183}"], [194698, 1, "\u387C"], [194699, 1, "\u5EB0"], [194700, 1, "\u5EB3"], [194701, 1, "\u5EB6"], [194702, 1, "\u5ECA"], [194703, 1, "\u{2A392}"], [194704, 1, "\u5EFE"], [[194705, 194706], 1, "\u{22331}"], [194707, 1, "\u8201"], [[194708, 194709], 1, "\u5F22"], [194710, 1, "\u38C7"], [194711, 1, "\u{232B8}"], [194712, 1, "\u{261DA}"], [194713, 1, "\u5F62"], [194714, 1, "\u5F6B"], [194715, 1, "\u38E3"], [194716, 1, "\u5F9A"], [194717, 1, "\u5FCD"], [194718, 1, "\u5FD7"], [194719, 1, "\u5FF9"], [194720, 1, "\u6081"], [194721, 1, "\u393A"], [194722, 1, "\u391C"], [194723, 1, "\u6094"], [194724, 1, "\u{226D4}"], [194725, 1, "\u60C7"], [194726, 1, "\u6148"], [194727, 1, "\u614C"], [194728, 1, "\u614E"], [194729, 1, "\u614C"], [194730, 1, "\u617A"], [194731, 1, "\u618E"], [194732, 1, "\u61B2"], [194733, 1, "\u61A4"], [194734, 1, "\u61AF"], [194735, 1, "\u61DE"], [194736, 1, "\u61F2"], [194737, 1, "\u61F6"], [194738, 1, "\u6210"], [194739, 1, "\u621B"], [194740, 1, "\u625D"], [194741, 1, "\u62B1"], [194742, 1, "\u62D4"], [194743, 1, "\u6350"], [194744, 1, "\u{22B0C}"], [194745, 1, "\u633D"], [194746, 1, "\u62FC"], [194747, 1, "\u6368"], [194748, 1, "\u6383"], [194749, 1, "\u63E4"], [194750, 1, "\u{22BF1}"], [194751, 1, "\u6422"], [194752, 1, "\u63C5"], [194753, 1, "\u63A9"], [194754, 1, "\u3A2E"], [194755, 1, "\u6469"], [194756, 1, "\u647E"], [194757, 1, "\u649D"], [194758, 1, "\u6477"], [194759, 1, "\u3A6C"], [194760, 1, "\u654F"], [194761, 1, "\u656C"], [194762, 1, "\u{2300A}"], [194763, 1, "\u65E3"], [194764, 1, "\u66F8"], [194765, 1, "\u6649"], [194766, 1, "\u3B19"], [194767, 1, "\u6691"], [194768, 1, "\u3B08"], [194769, 1, "\u3AE4"], [194770, 1, "\u5192"], [194771, 1, "\u5195"], [194772, 1, "\u6700"], [194773, 1, "\u669C"], [194774, 1, "\u80AD"], [194775, 1, "\u43D9"], [194776, 1, "\u6717"], [194777, 1, "\u671B"], [194778, 1, "\u6721"], [194779, 1, "\u675E"], [194780, 1, "\u6753"], [194781, 1, "\u{233C3}"], [194782, 1, "\u3B49"], [194783, 1, "\u67FA"], [194784, 1, "\u6785"], [194785, 1, "\u6852"], [194786, 1, "\u6885"], [194787, 1, "\u{2346D}"], [194788, 1, "\u688E"], [194789, 1, "\u681F"], [194790, 1, "\u6914"], [194791, 1, "\u3B9D"], [194792, 1, "\u6942"], [194793, 1, "\u69A3"], [194794, 1, "\u69EA"], [194795, 1, "\u6AA8"], [194796, 1, "\u{236A3}"], [194797, 1, "\u6ADB"], [194798, 1, "\u3C18"], [194799, 1, "\u6B21"], [194800, 1, "\u{238A7}"], [194801, 1, "\u6B54"], [194802, 1, "\u3C4E"], [194803, 1, "\u6B72"], [194804, 1, "\u6B9F"], [194805, 1, "\u6BBA"], [194806, 1, "\u6BBB"], [194807, 1, "\u{23A8D}"], [194808, 1, "\u{21D0B}"], [194809, 1, "\u{23AFA}"], [194810, 1, "\u6C4E"], [194811, 1, "\u{23CBC}"], [194812, 1, "\u6CBF"], [194813, 1, "\u6CCD"], [194814, 1, "\u6C67"], [194815, 1, "\u6D16"], [194816, 1, "\u6D3E"], [194817, 1, "\u6D77"], [194818, 1, "\u6D41"], [194819, 1, "\u6D69"], [194820, 1, "\u6D78"], [194821, 1, "\u6D85"], [194822, 1, "\u{23D1E}"], [194823, 1, "\u6D34"], [194824, 1, "\u6E2F"], [194825, 1, "\u6E6E"], [194826, 1, "\u3D33"], [194827, 1, "\u6ECB"], [194828, 1, "\u6EC7"], [194829, 1, "\u{23ED1}"], [194830, 1, "\u6DF9"], [194831, 1, "\u6F6E"], [194832, 1, "\u{23F5E}"], [194833, 1, "\u{23F8E}"], [194834, 1, "\u6FC6"], [194835, 1, "\u7039"], [194836, 1, "\u701E"], [194837, 1, "\u701B"], [194838, 1, "\u3D96"], [194839, 1, "\u704A"], [194840, 1, "\u707D"], [194841, 1, "\u7077"], [194842, 1, "\u70AD"], [194843, 1, "\u{20525}"], [194844, 1, "\u7145"], [194845, 1, "\u{24263}"], [194846, 1, "\u719C"], [194847, 1, "\u{243AB}"], [194848, 1, "\u7228"], [194849, 1, "\u7235"], [194850, 1, "\u7250"], [194851, 1, "\u{24608}"], [194852, 1, "\u7280"], [194853, 1, "\u7295"], [194854, 1, "\u{24735}"], [194855, 1, "\u{24814}"], [194856, 1, "\u737A"], [194857, 1, "\u738B"], [194858, 1, "\u3EAC"], [194859, 1, "\u73A5"], [[194860, 194861], 1, "\u3EB8"], [194862, 1, "\u7447"], [194863, 1, "\u745C"], [194864, 1, "\u7471"], [194865, 1, "\u7485"], [194866, 1, "\u74CA"], [194867, 1, "\u3F1B"], [194868, 1, "\u7524"], [194869, 1, "\u{24C36}"], [194870, 1, "\u753E"], [194871, 1, "\u{24C92}"], [194872, 1, "\u7570"], [194873, 1, "\u{2219F}"], [194874, 1, "\u7610"], [194875, 1, "\u{24FA1}"], [194876, 1, "\u{24FB8}"], [194877, 1, "\u{25044}"], [194878, 1, "\u3FFC"], [194879, 1, "\u4008"], [194880, 1, "\u76F4"], [194881, 1, "\u{250F3}"], [194882, 1, "\u{250F2}"], [194883, 1, "\u{25119}"], [194884, 1, "\u{25133}"], [194885, 1, "\u771E"], [[194886, 194887], 1, "\u771F"], [194888, 1, "\u774A"], [194889, 1, "\u4039"], [194890, 1, "\u778B"], [194891, 1, "\u4046"], [194892, 1, "\u4096"], [194893, 1, "\u{2541D}"], [194894, 1, "\u784E"], [194895, 1, "\u788C"], [194896, 1, "\u78CC"], [194897, 1, "\u40E3"], [194898, 1, "\u{25626}"], [194899, 1, "\u7956"], [194900, 1, "\u{2569A}"], [194901, 1, "\u{256C5}"], [194902, 1, "\u798F"], [194903, 1, "\u79EB"], [194904, 1, "\u412F"], [194905, 1, "\u7A40"], [194906, 1, "\u7A4A"], [194907, 1, "\u7A4F"], [194908, 1, "\u{2597C}"], [[194909, 194910], 1, "\u{25AA7}"], [194911, 1, "\u7AEE"], [194912, 1, "\u4202"], [194913, 1, "\u{25BAB}"], [194914, 1, "\u7BC6"], [194915, 1, "\u7BC9"], [194916, 1, "\u4227"], [194917, 1, "\u{25C80}"], [194918, 1, "\u7CD2"], [194919, 1, "\u42A0"], [194920, 1, "\u7CE8"], [194921, 1, "\u7CE3"], [194922, 1, "\u7D00"], [194923, 1, "\u{25F86}"], [194924, 1, "\u7D63"], [194925, 1, "\u4301"], [194926, 1, "\u7DC7"], [194927, 1, "\u7E02"], [194928, 1, "\u7E45"], [194929, 1, "\u4334"], [194930, 1, "\u{26228}"], [194931, 1, "\u{26247}"], [194932, 1, "\u4359"], [194933, 1, "\u{262D9}"], [194934, 1, "\u7F7A"], [194935, 1, "\u{2633E}"], [194936, 1, "\u7F95"], [194937, 1, "\u7FFA"], [194938, 1, "\u8005"], [194939, 1, "\u{264DA}"], [194940, 1, "\u{26523}"], [194941, 1, "\u8060"], [194942, 1, "\u{265A8}"], [194943, 1, "\u8070"], [194944, 1, "\u{2335F}"], [194945, 1, "\u43D5"], [194946, 1, "\u80B2"], [194947, 1, "\u8103"], [194948, 1, "\u440B"], [194949, 1, "\u813E"], [194950, 1, "\u5AB5"], [194951, 1, "\u{267A7}"], [194952, 1, "\u{267B5}"], [194953, 1, "\u{23393}"], [194954, 1, "\u{2339C}"], [194955, 1, "\u8201"], [194956, 1, "\u8204"], [194957, 1, "\u8F9E"], [194958, 1, "\u446B"], [194959, 1, "\u8291"], [194960, 1, "\u828B"], [194961, 1, "\u829D"], [194962, 1, "\u52B3"], [194963, 1, "\u82B1"], [194964, 1, "\u82B3"], [194965, 1, "\u82BD"], [194966, 1, "\u82E6"], [194967, 1, "\u{26B3C}"], [194968, 1, "\u82E5"], [194969, 1, "\u831D"], [194970, 1, "\u8363"], [194971, 1, "\u83AD"], [194972, 1, "\u8323"], [194973, 1, "\u83BD"], [194974, 1, "\u83E7"], [194975, 1, "\u8457"], [194976, 1, "\u8353"], [194977, 1, "\u83CA"], [194978, 1, "\u83CC"], [194979, 1, "\u83DC"], [194980, 1, "\u{26C36}"], [194981, 1, "\u{26D6B}"], [194982, 1, "\u{26CD5}"], [194983, 1, "\u452B"], [194984, 1, "\u84F1"], [194985, 1, "\u84F3"], [194986, 1, "\u8516"], [194987, 1, "\u{273CA}"], [194988, 1, "\u8564"], [194989, 1, "\u{26F2C}"], [194990, 1, "\u455D"], [194991, 1, "\u4561"], [194992, 1, "\u{26FB1}"], [194993, 1, "\u{270D2}"], [194994, 1, "\u456B"], [194995, 1, "\u8650"], [194996, 1, "\u865C"], [194997, 1, "\u8667"], [194998, 1, "\u8669"], [194999, 1, "\u86A9"], [195e3, 1, "\u8688"], [195001, 1, "\u870E"], [195002, 1, "\u86E2"], [195003, 1, "\u8779"], [195004, 1, "\u8728"], [195005, 1, "\u876B"], [195006, 1, "\u8786"], [195007, 1, "\u45D7"], [195008, 1, "\u87E1"], [195009, 1, "\u8801"], [195010, 1, "\u45F9"], [195011, 1, "\u8860"], [195012, 1, "\u8863"], [195013, 1, "\u{27667}"], [195014, 1, "\u88D7"], [195015, 1, "\u88DE"], [195016, 1, "\u4635"], [195017, 1, "\u88FA"], [195018, 1, "\u34BB"], [195019, 1, "\u{278AE}"], [195020, 1, "\u{27966}"], [195021, 1, "\u46BE"], [195022, 1, "\u46C7"], [195023, 1, "\u8AA0"], [195024, 1, "\u8AED"], [195025, 1, "\u8B8A"], [195026, 1, "\u8C55"], [195027, 1, "\u{27CA8}"], [195028, 1, "\u8CAB"], [195029, 1, "\u8CC1"], [195030, 1, "\u8D1B"], [195031, 1, "\u8D77"], [195032, 1, "\u{27F2F}"], [195033, 1, "\u{20804}"], [195034, 1, "\u8DCB"], [195035, 1, "\u8DBC"], [195036, 1, "\u8DF0"], [195037, 1, "\u{208DE}"], [195038, 1, "\u8ED4"], [195039, 1, "\u8F38"], [195040, 1, "\u{285D2}"], [195041, 1, "\u{285ED}"], [195042, 1, "\u9094"], [195043, 1, "\u90F1"], [195044, 1, "\u9111"], [195045, 1, "\u{2872E}"], [195046, 1, "\u911B"], [195047, 1, "\u9238"], [195048, 1, "\u92D7"], [195049, 1, "\u92D8"], [195050, 1, "\u927C"], [195051, 1, "\u93F9"], [195052, 1, "\u9415"], [195053, 1, "\u{28BFA}"], [195054, 1, "\u958B"], [195055, 1, "\u4995"], [195056, 1, "\u95B7"], [195057, 1, "\u{28D77}"], [195058, 1, "\u49E6"], [195059, 1, "\u96C3"], [195060, 1, "\u5DB2"], [195061, 1, "\u9723"], [195062, 1, "\u{29145}"], [195063, 1, "\u{2921A}"], [195064, 1, "\u4A6E"], [195065, 1, "\u4A76"], [195066, 1, "\u97E0"], [195067, 1, "\u{2940A}"], [195068, 1, "\u4AB2"], [195069, 1, "\u{29496}"], [[195070, 195071], 1, "\u980B"], [195072, 1, "\u9829"], [195073, 1, "\u{295B6}"], [195074, 1, "\u98E2"], [195075, 1, "\u4B33"], [195076, 1, "\u9929"], [195077, 1, "\u99A7"], [195078, 1, "\u99C2"], [195079, 1, "\u99FE"], [195080, 1, "\u4BCE"], [195081, 1, "\u{29B30}"], [195082, 1, "\u9B12"], [195083, 1, "\u9C40"], [195084, 1, "\u9CFD"], [195085, 1, "\u4CCE"], [195086, 1, "\u4CED"], [195087, 1, "\u9D67"], [195088, 1, "\u{2A0CE}"], [195089, 1, "\u4CF8"], [195090, 1, "\u{2A105}"], [195091, 1, "\u{2A20E}"], [195092, 1, "\u{2A291}"], [195093, 1, "\u9EBB"], [195094, 1, "\u4D56"], [195095, 1, "\u9EF9"], [195096, 1, "\u9EFE"], [195097, 1, "\u9F05"], [195098, 1, "\u9F0F"], [195099, 1, "\u9F16"], [195100, 1, "\u9F3B"], [195101, 1, "\u{2A600}"], [[195102, 196605], 3], [[196606, 196607], 3], [[196608, 201546], 2], [[201547, 201551], 3], [[201552, 205743], 2], [[205744, 262141], 3], [[262142, 262143], 3], [[262144, 327677], 3], [[327678, 327679], 3], [[327680, 393213], 3], [[393214, 393215], 3], [[393216, 458749], 3], [[458750, 458751], 3], [[458752, 524285], 3], [[524286, 524287], 3], [[524288, 589821], 3], [[589822, 589823], 3], [[589824, 655357], 3], [[655358, 655359], 3], [[655360, 720893], 3], [[720894, 720895], 3], [[720896, 786429], 3], [[786430, 786431], 3], [[786432, 851965], 3], [[851966, 851967], 3], [[851968, 917501], 3], [[917502, 917503], 3], [917504, 3], [917505, 3], [[917506, 917535], 3], [[917536, 917631], 3], [[917632, 917759], 3], [[917760, 917999], 7], [[918e3, 983037], 3], [[983038, 983039], 3], [[983040, 1048573], 3], [[1048574, 1048575], 3], [[1048576, 1114109], 3], [[1114110, 1114111], 3]];
  }
});

// node_modules/mongodb-connection-string-url/node_modules/tr46/lib/statusMapping.js
var require_statusMapping = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/tr46/lib/statusMapping.js"(exports2, module2) {
    "use strict";
    module2.exports.STATUS_MAPPING = {
      mapped: 1,
      valid: 2,
      disallowed: 3,
      deviation: 6,
      ignored: 7
    };
  }
});

// node_modules/mongodb-connection-string-url/node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/tr46/index.js"(exports2, module2) {
    "use strict";
    var punycode2 = (init_punycode_es6(), __toCommonJS(punycode_es6_exports));
    var regexes = require_regexes();
    var mappingTable = require_mappingTable();
    var { STATUS_MAPPING } = require_statusMapping();
    function containsNonASCII(str) {
      return /[^\x00-\x7F]/u.test(str);
    }
    function findStatus(val) {
      let start = 0;
      let end = mappingTable.length - 1;
      while (start <= end) {
        const mid = Math.floor((start + end) / 2);
        const target = mappingTable[mid];
        const min = Array.isArray(target[0]) ? target[0][0] : target[0];
        const max = Array.isArray(target[0]) ? target[0][1] : target[0];
        if (min <= val && max >= val) {
          return target.slice(1);
        } else if (min > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    function mapChars(domainName, { transitionalProcessing }) {
      let processed = "";
      for (const ch of domainName) {
        const [status, mapping] = findStatus(ch.codePointAt(0));
        switch (status) {
          case STATUS_MAPPING.disallowed:
            processed += ch;
            break;
          case STATUS_MAPPING.ignored:
            break;
          case STATUS_MAPPING.mapped:
            if (transitionalProcessing && ch === "\u1E9E") {
              processed += "ss";
            } else {
              processed += mapping;
            }
            break;
          case STATUS_MAPPING.deviation:
            if (transitionalProcessing) {
              processed += mapping;
            } else {
              processed += ch;
            }
            break;
          case STATUS_MAPPING.valid:
            processed += ch;
            break;
        }
      }
      return processed;
    }
    function validateLabel(label, {
      checkHyphens,
      checkBidi,
      checkJoiners,
      transitionalProcessing,
      useSTD3ASCIIRules,
      isBidi
    }) {
      if (label.length === 0) {
        return true;
      }
      if (label.normalize("NFC") !== label) {
        return false;
      }
      const codePoints = Array.from(label);
      if (checkHyphens) {
        if (codePoints[2] === "-" && codePoints[3] === "-" || (label.startsWith("-") || label.endsWith("-"))) {
          return false;
        }
      }
      if (!checkHyphens) {
        if (label.startsWith("xn--")) {
          return false;
        }
      }
      if (label.includes(".")) {
        return false;
      }
      if (regexes.combiningMarks.test(codePoints[0])) {
        return false;
      }
      for (const ch of codePoints) {
        const codePoint = ch.codePointAt(0);
        const [status] = findStatus(codePoint);
        if (transitionalProcessing) {
          if (status !== STATUS_MAPPING.valid) {
            return false;
          }
        } else if (status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {
          return false;
        }
        if (useSTD3ASCIIRules && codePoint <= 127) {
          if (!/^(?:[a-z]|[0-9]|-)$/u.test(ch)) {
            return false;
          }
        }
      }
      if (checkJoiners) {
        let last = 0;
        for (const [i, ch] of codePoints.entries()) {
          if (ch === "\u200C" || ch === "\u200D") {
            if (i > 0) {
              if (regexes.combiningClassVirama.test(codePoints[i - 1])) {
                continue;
              }
              if (ch === "\u200C") {
                const next = codePoints.indexOf("\u200C", i + 1);
                const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);
                if (regexes.validZWNJ.test(test.join(""))) {
                  last = i + 1;
                  continue;
                }
              }
            }
            return false;
          }
        }
      }
      if (checkBidi && isBidi) {
        let rtl;
        if (regexes.bidiS1LTR.test(codePoints[0])) {
          rtl = false;
        } else if (regexes.bidiS1RTL.test(codePoints[0])) {
          rtl = true;
        } else {
          return false;
        }
        if (rtl) {
          if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {
            return false;
          }
        } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {
          return false;
        }
      }
      return true;
    }
    function isBidiDomain(labels) {
      const domain = labels.map((label) => {
        if (label.startsWith("xn--")) {
          try {
            return punycode2.decode(label.substring(4));
          } catch {
            return "";
          }
        }
        return label;
      }).join(".");
      return regexes.bidiDomain.test(domain);
    }
    function processing(domainName, options2) {
      let string = mapChars(domainName, options2);
      string = string.normalize("NFC");
      const labels = string.split(".");
      const isBidi = isBidiDomain(labels);
      let error2 = false;
      for (const [i, origLabel] of labels.entries()) {
        let label = origLabel;
        let transitionalProcessingForThisLabel = options2.transitionalProcessing;
        if (label.startsWith("xn--")) {
          if (containsNonASCII(label)) {
            error2 = true;
            continue;
          }
          try {
            label = punycode2.decode(label.substring(4));
          } catch {
            if (!options2.ignoreInvalidPunycode) {
              error2 = true;
              continue;
            }
          }
          labels[i] = label;
          if (label === "" || !containsNonASCII(label)) {
            error2 = true;
          }
          transitionalProcessingForThisLabel = false;
        }
        if (error2) {
          continue;
        }
        const validation = validateLabel(label, {
          ...options2,
          transitionalProcessing: transitionalProcessingForThisLabel,
          isBidi
        });
        if (!validation) {
          error2 = true;
        }
      }
      return {
        string: labels.join("."),
        error: error2
      };
    }
    function toASCII2(domainName, {
      checkHyphens = false,
      checkBidi = false,
      checkJoiners = false,
      useSTD3ASCIIRules = false,
      verifyDNSLength = false,
      transitionalProcessing = false,
      ignoreInvalidPunycode = false
    } = {}) {
      const result = processing(domainName, {
        checkHyphens,
        checkBidi,
        checkJoiners,
        useSTD3ASCIIRules,
        transitionalProcessing,
        ignoreInvalidPunycode
      });
      let labels = result.string.split(".");
      labels = labels.map((l) => {
        if (containsNonASCII(l)) {
          try {
            return `xn--${punycode2.encode(l)}`;
          } catch {
            result.error = true;
          }
        }
        return l;
      });
      if (verifyDNSLength) {
        const total = labels.join(".").length;
        if (total > 253 || total === 0) {
          result.error = true;
        }
        for (let i = 0; i < labels.length; ++i) {
          if (labels[i].length > 63 || labels[i].length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) {
        return null;
      }
      return labels.join(".");
    }
    function toUnicode2(domainName, {
      checkHyphens = false,
      checkBidi = false,
      checkJoiners = false,
      useSTD3ASCIIRules = false,
      transitionalProcessing = false,
      ignoreInvalidPunycode = false
    } = {}) {
      const result = processing(domainName, {
        checkHyphens,
        checkBidi,
        checkJoiners,
        useSTD3ASCIIRules,
        transitionalProcessing,
        ignoreInvalidPunycode
      });
      return {
        domain: result.string,
        error: result.error
      };
    }
    module2.exports = {
      toASCII: toASCII2,
      toUnicode: toUnicode2
    };
  }
});

// node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/infra.js
var require_infra = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/infra.js"(exports2, module2) {
    "use strict";
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    module2.exports = {
      isASCIIDigit,
      isASCIIAlpha,
      isASCIIAlphanumeric,
      isASCIIHex
    };
  }
});

// node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/encoding.js
var require_encoding = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/encoding.js"(exports2, module2) {
    "use strict";
    var utf8Encoder = new TextEncoder();
    var utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true });
    function utf8Encode(string) {
      return utf8Encoder.encode(string);
    }
    function utf8DecodeWithoutBOM(bytes) {
      return utf8Decoder.decode(bytes);
    }
    module2.exports = {
      utf8Encode,
      utf8DecodeWithoutBOM
    };
  }
});

// node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/percent-encoding.js
var require_percent_encoding = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/percent-encoding.js"(exports2, module2) {
    "use strict";
    var { isASCIIHex } = require_infra();
    var { utf8Encode } = require_encoding();
    function p(char) {
      return char.codePointAt(0);
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = `0${hex}`;
      }
      return `%${hex}`;
    }
    function percentDecodeBytes(input) {
      const output = new Uint8Array(input.byteLength);
      let outputIndex = 0;
      for (let i = 0; i < input.byteLength; ++i) {
        const byte = input[i];
        if (byte !== 37) {
          output[outputIndex++] = byte;
        } else if (byte === 37 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {
          output[outputIndex++] = byte;
        } else {
          const bytePoint = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);
          output[outputIndex++] = bytePoint;
          i += 2;
        }
      }
      return output.slice(0, outputIndex);
    }
    function percentDecodeString(input) {
      const bytes = utf8Encode(input);
      return percentDecodeBytes(bytes);
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraFragmentPercentEncodeSet = /* @__PURE__ */ new Set([p(" "), p('"'), p("<"), p(">"), p("`")]);
    function isFragmentPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraFragmentPercentEncodeSet.has(c);
    }
    var extraQueryPercentEncodeSet = /* @__PURE__ */ new Set([p(" "), p('"'), p("#"), p("<"), p(">")]);
    function isQueryPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraQueryPercentEncodeSet.has(c);
    }
    function isSpecialQueryPercentEncode(c) {
      return isQueryPercentEncode(c) || c === p("'");
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([p("?"), p("`"), p("{"), p("}"), p("^")]);
    function isPathPercentEncode(c) {
      return isQueryPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([p("/"), p(":"), p(";"), p("="), p("@"), p("["), p("\\"), p("]"), p("|")]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    var extraComponentPercentEncodeSet = /* @__PURE__ */ new Set([p("$"), p("%"), p("&"), p("+"), p(",")]);
    function isComponentPercentEncode(c) {
      return isUserinfoPercentEncode(c) || extraComponentPercentEncodeSet.has(c);
    }
    var extraURLEncodedPercentEncodeSet = /* @__PURE__ */ new Set([p("!"), p("'"), p("("), p(")"), p("~")]);
    function isURLEncodedPercentEncode(c) {
      return isComponentPercentEncode(c) || extraURLEncodedPercentEncodeSet.has(c);
    }
    function utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate) {
      const bytes = utf8Encode(codePoint);
      let output = "";
      for (const byte of bytes) {
        if (!percentEncodePredicate(byte)) {
          output += String.fromCharCode(byte);
        } else {
          output += percentEncode(byte);
        }
      }
      return output;
    }
    function utf8PercentEncodeCodePoint(codePoint, percentEncodePredicate) {
      return utf8PercentEncodeCodePointInternal(String.fromCodePoint(codePoint), percentEncodePredicate);
    }
    function utf8PercentEncodeString(input, percentEncodePredicate, spaceAsPlus = false) {
      let output = "";
      for (const codePoint of input) {
        if (spaceAsPlus && codePoint === " ") {
          output += "+";
        } else {
          output += utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate);
        }
      }
      return output;
    }
    module2.exports = {
      isC0ControlPercentEncode,
      isFragmentPercentEncode,
      isQueryPercentEncode,
      isSpecialQueryPercentEncode,
      isPathPercentEncode,
      isUserinfoPercentEncode,
      isURLEncodedPercentEncode,
      percentDecodeString,
      percentDecodeBytes,
      utf8PercentEncodeString,
      utf8PercentEncodeCodePoint
    };
  }
});

// node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module2) {
    "use strict";
    var tr46 = require_tr46();
    var infra = require_infra();
    var { utf8DecodeWithoutBOM } = require_encoding();
    var {
      percentDecodeString,
      utf8PercentEncodeCodePoint,
      utf8PercentEncodeString,
      isC0ControlPercentEncode,
      isFragmentPercentEncode,
      isQueryPercentEncode,
      isSpecialQueryPercentEncode,
      isPathPercentEncode,
      isUserinfoPercentEncode
    } = require_percent_encoding();
    function p(char) {
      return char.codePointAt(0);
    }
    var specialSchemes = {
      ftp: 21,
      file: null,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return [...str].length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return infra.isASCIIAlpha(cp1) && (cp2 === p(":") || cp2 === p("|"));
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1;
    }
    function containsForbiddenDomainCodePoint(string) {
      return containsForbiddenHostCodePoint(string) || string.search(/[\u0000-\u001F]|%|\u007F/u) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function isNotSpecial(url) {
      return !isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function parseIPv4Number(input) {
      if (input === "") {
        return failure;
      }
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      let regex = /[^0-7]/u;
      if (R === 10) {
        regex = /[^0-9]/u;
      }
      if (R === 16) {
        regex = /[^0-9A-Fa-f]/u;
      }
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return failure;
      }
      const numbers = [];
      for (const part of parts) {
        const n = parseIPv4Number(part);
        if (n === failure) {
          return failure;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= 256 ** (5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * 256 ** (3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = `.${output}`;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = Array.from(input, (c) => c.codePointAt(0));
      if (input[pointer] === p(":")) {
        if (input[pointer + 1] !== p(":")) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === p(":")) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && infra.isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === p(".")) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === p(".") && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!infra.isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (infra.isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === p(":")) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const compress = findTheIPv6AddressCompressedPieceIndex(address);
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isOpaque = false) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (isOpaque) {
        return parseOpaqueHost(input);
      }
      const domain = utf8DecodeWithoutBOM(percentDecodeString(input));
      const asciiDomain = domainToASCII(domain);
      if (asciiDomain === failure) {
        return failure;
      }
      if (endsInANumber(asciiDomain)) {
        return parseIPv4(asciiDomain);
      }
      return asciiDomain;
    }
    function endsInANumber(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length === 1) {
          return false;
        }
        parts.pop();
      }
      const last = parts[parts.length - 1];
      if (parseIPv4Number(last) !== failure) {
        return true;
      }
      if (/^[0-9]+$/u.test(last)) {
        return true;
      }
      return false;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePoint(input)) {
        return failure;
      }
      return utf8PercentEncodeString(input, isC0ControlPercentEncode);
    }
    function findTheIPv6AddressCompressedPieceIndex(address) {
      let longestIndex = null;
      let longestSize = 1;
      let foundIndex = null;
      let foundSize = 0;
      for (let pieceIndex = 0; pieceIndex < address.length; ++pieceIndex) {
        if (address[pieceIndex] !== 0) {
          if (foundSize > longestSize) {
            longestIndex = foundIndex;
            longestSize = foundSize;
          }
          foundIndex = null;
          foundSize = 0;
        } else {
          if (foundIndex === null) {
            foundIndex = pieceIndex;
          }
          ++foundSize;
        }
      }
      if (foundSize > longestSize) {
        return foundIndex;
      }
      return longestIndex;
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return `[${serializeIPv6(host)}]`;
      }
      return host;
    }
    function domainToASCII(domain, beStrict = false) {
      const result = tr46.toASCII(domain, {
        checkHyphens: beStrict,
        checkBidi: true,
        checkJoiners: true,
        useSTD3ASCIIRules: beStrict,
        transitionalProcessing: false,
        verifyDNSLength: beStrict,
        ignoreInvalidPunycode: false
      });
      if (result === null) {
        return failure;
      }
      if (!beStrict) {
        if (result === "") {
          return failure;
        }
        if (containsForbiddenDomainCodePoint(result)) {
          return failure;
        }
      }
      return result;
    }
    function trimControlChars(string) {
      let start = 0;
      let end = string.length;
      for (; start < end; ++start) {
        if (string.charCodeAt(start) > 32) {
          break;
        }
      }
      for (; end > start; --end) {
        if (string.charCodeAt(end - 1) > 32) {
          break;
        }
      }
      return string.substring(start, end);
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/ug, "");
    }
    function shortenPath(url) {
      const { path } = url;
      if (path.length === 0) {
        return;
      }
      if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
      }
      path.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.scheme === "file";
    }
    function hasAnOpaquePath(url) {
      return typeof url.path === "string";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/u.test(string);
    }
    function URLStateMachine(input, base2, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base2 || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = Array.from(this.input, (c) => c.codePointAt(0));
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this[`parse ${this.state}`](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (infra.isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (infra.isASCIIAlphanumeric(c) || c === p("+") || c === p("-") || c === p(".")) {
        this.buffer += cStr.toLowerCase();
      } else if (c === p(":")) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && this.url.host === "") {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        if (this.stateOverride) {
          if (this.url.port === defaultPort(this.url.scheme)) {
            this.url.port = null;
          }
          return false;
        }
        this.buffer = "";
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== p("/") || this.input[this.pointer + 2] !== p("/")) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === p("/")) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.path = "";
          this.state = "opaque path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || hasAnOpaquePath(this.base) && c !== p("#")) {
        return failure;
      } else if (hasAnOpaquePath(this.base) && c === p("#")) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path;
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === p("/")) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (c === p("/")) {
        this.state = "relative slash";
      } else if (isSpecial(this.url) && c === p("\\")) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        if (c === p("?")) {
          this.url.query = "";
          this.state = "query";
        } else if (c === p("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        } else if (!isNaN(c)) {
          this.url.query = null;
          this.url.path.pop();
          this.state = "path";
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === p("/") || c === p("\\"))) {
        if (c === p("\\")) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === p("/")) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== p("/") && c !== p("\\")) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === p("@")) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = `%40${this.buffer}`;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === p(":") && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = utf8PercentEncodeCodePoint(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\")) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === p(":") && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        if (this.stateOverride === "hostname") {
          return false;
        }
        const host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
      } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\")) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === p("[")) {
          this.arrFlag = true;
        } else if (c === p("]")) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (infra.isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\") || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > 2 ** 16 - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([p("/"), p("\\"), p("?"), p("#")]);
    function startsWithWindowsDriveLetter(input, pointer) {
      const length = input.length - pointer;
      return length >= 2 && isWindowsDriveLetterCodePoints(input[pointer], input[pointer + 1]) && (length === 2 || fileOtherwiseCodePoints.has(input[pointer + 2]));
    }
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      this.url.host = "";
      if (c === p("/") || c === p("\\")) {
        if (c === p("\\")) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        if (c === p("?")) {
          this.url.query = "";
          this.state = "query";
        } else if (c === p("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        } else if (!isNaN(c)) {
          this.url.query = null;
          if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
            shortenPath(this.url);
          } else {
            this.parseError = true;
            this.url.path = [];
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === p("/") || c === p("\\")) {
        if (c === p("\\")) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (!startsWithWindowsDriveLetter(this.input, this.pointer) && isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          }
          this.url.host = this.base.host;
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === p("/") || c === p("\\") || c === p("?") || c === p("#")) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isNotSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === p("\\")) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== p("/") && c !== p("\\")) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === p("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== p("/")) {
          --this.pointer;
        }
      } else if (this.stateOverride && this.url.host === null) {
        this.url.path.push("");
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === p("/") || isSpecial(this.url) && c === p("\\") || !this.stateOverride && (c === p("?") || c === p("#"))) {
        if (isSpecial(this.url) && c === p("\\")) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            this.buffer = `${this.buffer[0]}:`;
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (c === p("?")) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === p("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += utf8PercentEncodeCodePoint(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse opaque path"] = function parseOpaquePath(c) {
      if (c === p("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c === p(" ")) {
        const remaining = this.input[this.pointer + 1];
        if (remaining === p("?") || remaining === p("#")) {
          this.url.path += "%20";
        } else {
          this.url.path += " ";
        }
      } else {
        if (!isNaN(c) && c !== p("%")) {
          this.parseError = true;
        }
        if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path += utf8PercentEncodeCodePoint(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
        this.encodingOverride = "utf-8";
      }
      if (!this.stateOverride && c === p("#") || isNaN(c)) {
        const queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode : isQueryPercentEncode;
        this.url.query += utf8PercentEncodeString(this.buffer, queryPercentEncodePredicate);
        this.buffer = "";
        if (c === p("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else if (!isNaN(c)) {
        if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (!isNaN(c)) {
        if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += utf8PercentEncodeCodePoint(c, isFragmentPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = `${url.scheme}:`;
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += `:${url.password}`;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += `:${url.port}`;
        }
      }
      if (url.host === null && !hasAnOpaquePath(url) && url.path.length > 1 && url.path[0] === "") {
        output += "/.";
      }
      output += serializePath(url);
      if (url.query !== null) {
        output += `?${url.query}`;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += `#${url.fragment}`;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = `${tuple.scheme}://`;
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += `:${tuple.port}`;
      }
      return result;
    }
    function serializePath(url) {
      if (hasAnOpaquePath(url)) {
        return url.path;
      }
      let output = "";
      for (const segment of url.path) {
        output += `/${segment}`;
      }
      return output;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializePath = serializePath;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob": {
          const pathURL = module2.exports.parseURL(serializePath(url));
          if (pathURL === null) {
            return "null";
          }
          if (pathURL.scheme !== "http" && pathURL.scheme !== "https") {
            return "null";
          }
          return module2.exports.serializeURLOrigin(pathURL);
        }
        case "ftp":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "null";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      const usm = new URLStateMachine(input, options2.baseURL, options2.encodingOverride, options2.url, options2.stateOverride);
      if (usm.failure) {
        return null;
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = utf8PercentEncodeString(username, isUserinfoPercentEncode);
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = utf8PercentEncodeString(password, isUserinfoPercentEncode);
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.hasAnOpaquePath = hasAnOpaquePath;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options2.baseURL, encodingOverride: options2.encodingOverride });
    };
  }
});

// node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/urlencoded.js
var require_urlencoded2 = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/urlencoded.js"(exports2, module2) {
    "use strict";
    var { utf8Encode, utf8DecodeWithoutBOM } = require_encoding();
    var { percentDecodeBytes, utf8PercentEncodeString, isURLEncodedPercentEncode } = require_percent_encoding();
    function p(char) {
      return char.codePointAt(0);
    }
    function parseUrlencoded(input) {
      const sequences = strictlySplitByteSequence(input, p("&"));
      const output = [];
      for (const bytes of sequences) {
        if (bytes.length === 0) {
          continue;
        }
        let name, value;
        const indexOfEqual = bytes.indexOf(p("="));
        if (indexOfEqual >= 0) {
          name = bytes.slice(0, indexOfEqual);
          value = bytes.slice(indexOfEqual + 1);
        } else {
          name = bytes;
          value = new Uint8Array(0);
        }
        name = replaceByteInByteSequence(name, 43, 32);
        value = replaceByteInByteSequence(value, 43, 32);
        const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));
        const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));
        output.push([nameString, valueString]);
      }
      return output;
    }
    function parseUrlencodedString(input) {
      return parseUrlencoded(utf8Encode(input));
    }
    function serializeUrlencoded(tuples) {
      let output = "";
      for (const [i, tuple] of tuples.entries()) {
        const name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);
        const value = utf8PercentEncodeString(tuple[1], isURLEncodedPercentEncode, true);
        if (i !== 0) {
          output += "&";
        }
        output += `${name}=${value}`;
      }
      return output;
    }
    function strictlySplitByteSequence(buf, cp) {
      const list = [];
      let last = 0;
      let i = buf.indexOf(cp);
      while (i >= 0) {
        list.push(buf.slice(last, i));
        last = i + 1;
        i = buf.indexOf(cp, last);
      }
      if (last !== buf.length) {
        list.push(buf.slice(last));
      }
      return list;
    }
    function replaceByteInByteSequence(buf, from, to) {
      let i = buf.indexOf(from);
      while (i >= 0) {
        buf[i] = to;
        i = buf.indexOf(from, i + 1);
      }
      return buf;
    }
    module2.exports = {
      parseUrlencodedString,
      serializeUrlencoded
    };
  }
});

// node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/Function.js
var require_Function = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/Function.js"(exports2) {
    "use strict";
    var conversions = require_lib4();
    var utils = require_utils6();
    exports2.convert = (globalObject, value, { context = "The provided value" } = {}) => {
      if (typeof value !== "function") {
        throw new globalObject.TypeError(context + " is not a function");
      }
      function invokeTheCallbackFunction(...args) {
        const thisArg = utils.tryWrapperForImpl(this);
        let callResult;
        for (let i = 0; i < args.length; i++) {
          args[i] = utils.tryWrapperForImpl(args[i]);
        }
        callResult = Reflect.apply(value, thisArg, args);
        callResult = conversions["any"](callResult, { context, globals: globalObject });
        return callResult;
      }
      invokeTheCallbackFunction.construct = (...args) => {
        for (let i = 0; i < args.length; i++) {
          args[i] = utils.tryWrapperForImpl(args[i]);
        }
        let callResult = Reflect.construct(value, args);
        callResult = conversions["any"](callResult, { context, globals: globalObject });
        return callResult;
      };
      invokeTheCallbackFunction[utils.wrapperSymbol] = value;
      invokeTheCallbackFunction.objectReference = value;
      return invokeTheCallbackFunction;
    };
  }
});

// node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/URLSearchParams-impl.js
var require_URLSearchParams_impl = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/URLSearchParams-impl.js"(exports2) {
    "use strict";
    var urlencoded = require_urlencoded2();
    exports2.implementation = class URLSearchParamsImpl {
      constructor(globalObject, constructorArgs, { doNotStripQMark = false }) {
        let init = constructorArgs[0];
        this._list = [];
        this._url = null;
        if (!doNotStripQMark && typeof init === "string" && init[0] === "?") {
          init = init.slice(1);
        }
        if (Array.isArray(init)) {
          for (const pair of init) {
            if (pair.length !== 2) {
              throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not contain exactly two elements.");
            }
            this._list.push([pair[0], pair[1]]);
          }
        } else if (typeof init === "object" && Object.getPrototypeOf(init) === null) {
          for (const name of Object.keys(init)) {
            const value = init[name];
            this._list.push([name, value]);
          }
        } else {
          this._list = urlencoded.parseUrlencodedString(init);
        }
      }
      _updateSteps() {
        if (this._url !== null) {
          let serializedQuery = urlencoded.serializeUrlencoded(this._list);
          if (serializedQuery === "") {
            serializedQuery = null;
          }
          this._url._url.query = serializedQuery;
        }
      }
      get size() {
        return this._list.length;
      }
      append(name, value) {
        this._list.push([name, value]);
        this._updateSteps();
      }
      delete(name, value) {
        let i = 0;
        while (i < this._list.length) {
          if (this._list[i][0] === name && (value === void 0 || this._list[i][1] === value)) {
            this._list.splice(i, 1);
          } else {
            i++;
          }
        }
        this._updateSteps();
      }
      get(name) {
        for (const tuple of this._list) {
          if (tuple[0] === name) {
            return tuple[1];
          }
        }
        return null;
      }
      getAll(name) {
        const output = [];
        for (const tuple of this._list) {
          if (tuple[0] === name) {
            output.push(tuple[1]);
          }
        }
        return output;
      }
      has(name, value) {
        for (const tuple of this._list) {
          if (tuple[0] === name && (value === void 0 || tuple[1] === value)) {
            return true;
          }
        }
        return false;
      }
      set(name, value) {
        let found = false;
        let i = 0;
        while (i < this._list.length) {
          if (this._list[i][0] === name) {
            if (found) {
              this._list.splice(i, 1);
            } else {
              found = true;
              this._list[i][1] = value;
              i++;
            }
          } else {
            i++;
          }
        }
        if (!found) {
          this._list.push([name, value]);
        }
        this._updateSteps();
      }
      sort() {
        this._list.sort((a, b) => {
          if (a[0] < b[0]) {
            return -1;
          }
          if (a[0] > b[0]) {
            return 1;
          }
          return 0;
        });
        this._updateSteps();
      }
      [Symbol.iterator]() {
        return this._list[Symbol.iterator]();
      }
      toString() {
        return urlencoded.serializeUrlencoded(this._list);
      }
    };
  }
});

// node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/URLSearchParams.js
var require_URLSearchParams = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/URLSearchParams.js"(exports2) {
    "use strict";
    var conversions = require_lib4();
    var utils = require_utils6();
    var Function2 = require_Function();
    var newObjectInRealm = utils.newObjectInRealm;
    var implSymbol = utils.implSymbol;
    var ctorRegistrySymbol = utils.ctorRegistrySymbol;
    var interfaceName = "URLSearchParams";
    exports2.is = (value) => {
      return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
    };
    exports2.isImpl = (value) => {
      return utils.isObject(value) && value instanceof Impl.implementation;
    };
    exports2.convert = (globalObject, value, { context = "The provided value" } = {}) => {
      if (exports2.is(value)) {
        return utils.implForWrapper(value);
      }
      throw new globalObject.TypeError(`${context} is not of type 'URLSearchParams'.`);
    };
    exports2.createDefaultIterator = (globalObject, target, kind) => {
      const ctorRegistry = globalObject[ctorRegistrySymbol];
      const iteratorPrototype = ctorRegistry["URLSearchParams Iterator"];
      const iterator = Object.create(iteratorPrototype);
      Object.defineProperty(iterator, utils.iterInternalSymbol, {
        value: { target, kind, index: 0 },
        configurable: true
      });
      return iterator;
    };
    function makeWrapper(globalObject, newTarget) {
      let proto;
      if (newTarget !== void 0) {
        proto = newTarget.prototype;
      }
      if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["URLSearchParams"].prototype;
      }
      return Object.create(proto);
    }
    exports2.create = (globalObject, constructorArgs, privateData) => {
      const wrapper = makeWrapper(globalObject);
      return exports2.setup(wrapper, globalObject, constructorArgs, privateData);
    };
    exports2.createImpl = (globalObject, constructorArgs, privateData) => {
      const wrapper = exports2.create(globalObject, constructorArgs, privateData);
      return utils.implForWrapper(wrapper);
    };
    exports2._internalSetup = (wrapper, globalObject) => {
    };
    exports2.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
      privateData.wrapper = wrapper;
      exports2._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
      });
      wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper;
    };
    exports2.new = (globalObject, newTarget) => {
      const wrapper = makeWrapper(globalObject, newTarget);
      exports2._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
      });
      wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper[implSymbol];
    };
    var exposed = /* @__PURE__ */ new Set(["Window", "Worker"]);
    exports2.install = (globalObject, globalNames) => {
      if (!globalNames.some((globalName) => exposed.has(globalName))) {
        return;
      }
      const ctorRegistry = utils.initCtorRegistry(globalObject);
      class URLSearchParams2 {
        constructor() {
          const args = [];
          {
            let curArg = arguments[0];
            if (curArg !== void 0) {
              if (utils.isObject(curArg)) {
                if (curArg[Symbol.iterator] !== void 0) {
                  if (!utils.isObject(curArg)) {
                    throw new globalObject.TypeError(
                      "Failed to construct 'URLSearchParams': parameter 1 sequence is not an iterable object."
                    );
                  } else {
                    const V = [];
                    const tmp = curArg;
                    for (let nextItem of tmp) {
                      if (!utils.isObject(nextItem)) {
                        throw new globalObject.TypeError(
                          "Failed to construct 'URLSearchParams': parameter 1 sequence's element is not an iterable object."
                        );
                      } else {
                        const V2 = [];
                        const tmp2 = nextItem;
                        for (let nextItem2 of tmp2) {
                          nextItem2 = conversions["USVString"](nextItem2, {
                            context: "Failed to construct 'URLSearchParams': parameter 1 sequence's element's element",
                            globals: globalObject
                          });
                          V2.push(nextItem2);
                        }
                        nextItem = V2;
                      }
                      V.push(nextItem);
                    }
                    curArg = V;
                  }
                } else {
                  if (!utils.isObject(curArg)) {
                    throw new globalObject.TypeError(
                      "Failed to construct 'URLSearchParams': parameter 1 record is not an object."
                    );
                  } else {
                    const result = /* @__PURE__ */ Object.create(null);
                    for (const key of Reflect.ownKeys(curArg)) {
                      const desc = Object.getOwnPropertyDescriptor(curArg, key);
                      if (desc && desc.enumerable) {
                        let typedKey = key;
                        typedKey = conversions["USVString"](typedKey, {
                          context: "Failed to construct 'URLSearchParams': parameter 1 record's key",
                          globals: globalObject
                        });
                        let typedValue = curArg[key];
                        typedValue = conversions["USVString"](typedValue, {
                          context: "Failed to construct 'URLSearchParams': parameter 1 record's value",
                          globals: globalObject
                        });
                        result[typedKey] = typedValue;
                      }
                    }
                    curArg = result;
                  }
                }
              } else {
                curArg = conversions["USVString"](curArg, {
                  context: "Failed to construct 'URLSearchParams': parameter 1",
                  globals: globalObject
                });
              }
            } else {
              curArg = "";
            }
            args.push(curArg);
          }
          return exports2.setup(Object.create(new.target.prototype), globalObject, args);
        }
        append(name, value) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError(
              "'append' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 2) {
            throw new globalObject.TypeError(
              `Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'append' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'append' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
            args.push(curArg);
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].append(...args));
        }
        delete(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError(
              "'delete' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'delete' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'delete' on 'URLSearchParams': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].delete(...args));
        }
        get(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get' called on an object that is not a valid instance of URLSearchParams.");
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'get' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          return esValue[implSymbol].get(...args);
        }
        getAll(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError(
              "'getAll' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'getAll' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].getAll(...args));
        }
        has(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'has' called on an object that is not a valid instance of URLSearchParams.");
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'has' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'has' on 'URLSearchParams': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return esValue[implSymbol].has(...args);
        }
        set(name, value) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set' called on an object that is not a valid instance of URLSearchParams.");
          }
          if (arguments.length < 2) {
            throw new globalObject.TypeError(
              `Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'set' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'set' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
            args.push(curArg);
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].set(...args));
        }
        sort() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'sort' called on an object that is not a valid instance of URLSearchParams.");
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].sort());
        }
        toString() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError(
              "'toString' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return esValue[implSymbol].toString();
        }
        keys() {
          if (!exports2.is(this)) {
            throw new globalObject.TypeError("'keys' called on an object that is not a valid instance of URLSearchParams.");
          }
          return exports2.createDefaultIterator(globalObject, this, "key");
        }
        values() {
          if (!exports2.is(this)) {
            throw new globalObject.TypeError(
              "'values' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return exports2.createDefaultIterator(globalObject, this, "value");
        }
        entries() {
          if (!exports2.is(this)) {
            throw new globalObject.TypeError(
              "'entries' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return exports2.createDefaultIterator(globalObject, this, "key+value");
        }
        forEach(callback) {
          if (!exports2.is(this)) {
            throw new globalObject.TypeError(
              "'forEach' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              "Failed to execute 'forEach' on 'iterable': 1 argument required, but only 0 present."
            );
          }
          callback = Function2.convert(globalObject, callback, {
            context: "Failed to execute 'forEach' on 'iterable': The callback provided as parameter 1"
          });
          const thisArg = arguments[1];
          let pairs = Array.from(this[implSymbol]);
          let i = 0;
          while (i < pairs.length) {
            const [key, value] = pairs[i].map(utils.tryWrapperForImpl);
            callback.call(thisArg, value, key, this);
            pairs = Array.from(this[implSymbol]);
            i++;
          }
        }
        get size() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError(
              "'get size' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return esValue[implSymbol]["size"];
        }
      }
      Object.defineProperties(URLSearchParams2.prototype, {
        append: { enumerable: true },
        delete: { enumerable: true },
        get: { enumerable: true },
        getAll: { enumerable: true },
        has: { enumerable: true },
        set: { enumerable: true },
        sort: { enumerable: true },
        toString: { enumerable: true },
        keys: { enumerable: true },
        values: { enumerable: true },
        entries: { enumerable: true },
        forEach: { enumerable: true },
        size: { enumerable: true },
        [Symbol.toStringTag]: { value: "URLSearchParams", configurable: true },
        [Symbol.iterator]: { value: URLSearchParams2.prototype.entries, configurable: true, writable: true }
      });
      ctorRegistry[interfaceName] = URLSearchParams2;
      ctorRegistry["URLSearchParams Iterator"] = Object.create(ctorRegistry["%IteratorPrototype%"], {
        [Symbol.toStringTag]: {
          configurable: true,
          value: "URLSearchParams Iterator"
        }
      });
      utils.define(ctorRegistry["URLSearchParams Iterator"], {
        next() {
          const internal = this && this[utils.iterInternalSymbol];
          if (!internal) {
            throw new globalObject.TypeError("next() called on a value that is not a URLSearchParams iterator object");
          }
          const { target, kind, index } = internal;
          const values = Array.from(target[implSymbol]);
          const len = values.length;
          if (index >= len) {
            return newObjectInRealm(globalObject, { value: void 0, done: true });
          }
          const pair = values[index];
          internal.index = index + 1;
          return newObjectInRealm(globalObject, utils.iteratorResult(pair.map(utils.tryWrapperForImpl), kind));
        }
      });
      Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: URLSearchParams2
      });
    };
    var Impl = require_URLSearchParams_impl();
  }
});

// node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    var usm = require_url_state_machine();
    var urlencoded = require_urlencoded2();
    var URLSearchParams2 = require_URLSearchParams();
    exports2.implementation = class URLImpl {
      // Unlike the spec, we duplicate some code between the constructor and canParse, because we want to give useful error
      // messages in the constructor that distinguish between the different causes of failure.
      constructor(globalObject, [url, base2]) {
        let parsedBase = null;
        if (base2 !== void 0) {
          parsedBase = usm.basicURLParse(base2);
          if (parsedBase === null) {
            throw new TypeError(`Invalid base URL: ${base2}`);
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === null) {
          throw new TypeError(`Invalid URL: ${url}`);
        }
        const query = parsedURL.query !== null ? parsedURL.query : "";
        this._url = parsedURL;
        this._query = URLSearchParams2.createImpl(globalObject, [query], { doNotStripQMark: true });
        this._query._url = this;
      }
      static parse(globalObject, input, base2) {
        try {
          return new URLImpl(globalObject, [input, base2]);
        } catch {
          return null;
        }
      }
      static canParse(url, base2) {
        let parsedBase = null;
        if (base2 !== void 0) {
          parsedBase = usm.basicURLParse(base2);
          if (parsedBase === null) {
            return false;
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === null) {
          return false;
        }
        return true;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === null) {
          throw new TypeError(`Invalid URL: ${v}`);
        }
        this._url = parsedURL;
        this._query._list.splice(0);
        const { query } = parsedURL;
        if (query !== null) {
          this._query._list = urlencoded.parseUrlencodedString(query);
        }
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return `${this._url.scheme}:`;
      }
      set protocol(v) {
        usm.basicURLParse(`${v}:`, { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return `${usm.serializeHost(url.host)}:${usm.serializeInteger(url.port)}`;
      }
      set host(v) {
        if (usm.hasAnOpaquePath(this._url)) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (usm.hasAnOpaquePath(this._url)) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        return usm.serializePath(this._url);
      }
      set pathname(v) {
        if (usm.hasAnOpaquePath(this._url)) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return `?${this._url.query}`;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          this._query._list = [];
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
        this._query._list = urlencoded.parseUrlencodedString(input);
      }
      get searchParams() {
        return this._query;
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return `#${this._url.fragment}`;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/whatwg-url/lib/URL.js"(exports2) {
    "use strict";
    var conversions = require_lib4();
    var utils = require_utils6();
    var implSymbol = utils.implSymbol;
    var ctorRegistrySymbol = utils.ctorRegistrySymbol;
    var interfaceName = "URL";
    exports2.is = (value) => {
      return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
    };
    exports2.isImpl = (value) => {
      return utils.isObject(value) && value instanceof Impl.implementation;
    };
    exports2.convert = (globalObject, value, { context = "The provided value" } = {}) => {
      if (exports2.is(value)) {
        return utils.implForWrapper(value);
      }
      throw new globalObject.TypeError(`${context} is not of type 'URL'.`);
    };
    function makeWrapper(globalObject, newTarget) {
      let proto;
      if (newTarget !== void 0) {
        proto = newTarget.prototype;
      }
      if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["URL"].prototype;
      }
      return Object.create(proto);
    }
    exports2.create = (globalObject, constructorArgs, privateData) => {
      const wrapper = makeWrapper(globalObject);
      return exports2.setup(wrapper, globalObject, constructorArgs, privateData);
    };
    exports2.createImpl = (globalObject, constructorArgs, privateData) => {
      const wrapper = exports2.create(globalObject, constructorArgs, privateData);
      return utils.implForWrapper(wrapper);
    };
    exports2._internalSetup = (wrapper, globalObject) => {
    };
    exports2.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
      privateData.wrapper = wrapper;
      exports2._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
      });
      wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper;
    };
    exports2.new = (globalObject, newTarget) => {
      const wrapper = makeWrapper(globalObject, newTarget);
      exports2._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
      });
      wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper[implSymbol];
    };
    var exposed = /* @__PURE__ */ new Set(["Window", "Worker"]);
    exports2.install = (globalObject, globalNames) => {
      if (!globalNames.some((globalName) => exposed.has(globalName))) {
        return;
      }
      const ctorRegistry = utils.initCtorRegistry(globalObject);
      class URL2 {
        constructor(url) {
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to construct 'URL': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to construct 'URL': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to construct 'URL': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return exports2.setup(Object.create(new.target.prototype), globalObject, args);
        }
        toJSON() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'toJSON' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol].toJSON();
        }
        get href() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["href"];
        }
        set href(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'href' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["href"] = V;
        }
        toString() {
          const esValue = this;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["href"];
        }
        get origin() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["origin"];
        }
        get protocol() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["protocol"];
        }
        set protocol(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set protocol' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'protocol' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["protocol"] = V;
        }
        get username() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get username' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["username"];
        }
        set username(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set username' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'username' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["username"] = V;
        }
        get password() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get password' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["password"];
        }
        set password(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set password' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'password' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["password"] = V;
        }
        get host() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["host"];
        }
        set host(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set host' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'host' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["host"] = V;
        }
        get hostname() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get hostname' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["hostname"];
        }
        set hostname(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set hostname' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'hostname' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["hostname"] = V;
        }
        get port() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get port' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["port"];
        }
        set port(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set port' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'port' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["port"] = V;
        }
        get pathname() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get pathname' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["pathname"];
        }
        set pathname(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set pathname' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'pathname' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["pathname"] = V;
        }
        get search() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get search' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["search"];
        }
        set search(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set search' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'search' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["search"] = V;
        }
        get searchParams() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get searchParams' called on an object that is not a valid instance of URL.");
          }
          return utils.getSameObject(this, "searchParams", () => {
            return utils.tryWrapperForImpl(esValue[implSymbol]["searchParams"]);
          });
        }
        get hash() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'get hash' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["hash"];
        }
        set hash(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports2.is(esValue)) {
            throw new globalObject.TypeError("'set hash' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'hash' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["hash"] = V;
        }
        static parse(url) {
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'parse' on 'URL': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'parse' on 'URL': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'parse' on 'URL': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return utils.tryWrapperForImpl(Impl.implementation.parse(globalObject, ...args));
        }
        static canParse(url) {
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'canParse' on 'URL': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'canParse' on 'URL': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'canParse' on 'URL': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return Impl.implementation.canParse(...args);
        }
      }
      Object.defineProperties(URL2.prototype, {
        toJSON: { enumerable: true },
        href: { enumerable: true },
        toString: { enumerable: true },
        origin: { enumerable: true },
        protocol: { enumerable: true },
        username: { enumerable: true },
        password: { enumerable: true },
        host: { enumerable: true },
        hostname: { enumerable: true },
        port: { enumerable: true },
        pathname: { enumerable: true },
        search: { enumerable: true },
        searchParams: { enumerable: true },
        hash: { enumerable: true },
        [Symbol.toStringTag]: { value: "URL", configurable: true }
      });
      Object.defineProperties(URL2, { parse: { enumerable: true }, canParse: { enumerable: true } });
      ctorRegistry[interfaceName] = URL2;
      Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: URL2
      });
      if (globalNames.includes("Window")) {
        Object.defineProperty(globalObject, "webkitURL", {
          configurable: true,
          writable: true,
          value: URL2
        });
      }
    };
    var Impl = require_URL_impl();
  }
});

// node_modules/mongodb-connection-string-url/node_modules/whatwg-url/webidl2js-wrapper.js
var require_webidl2js_wrapper = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/whatwg-url/webidl2js-wrapper.js"(exports2) {
    "use strict";
    var URL2 = require_URL();
    var URLSearchParams2 = require_URLSearchParams();
    exports2.URL = URL2;
    exports2.URLSearchParams = URLSearchParams2;
  }
});

// node_modules/mongodb-connection-string-url/node_modules/whatwg-url/index.js
var require_whatwg_url = __commonJS({
  "node_modules/mongodb-connection-string-url/node_modules/whatwg-url/index.js"(exports2) {
    "use strict";
    var { URL: URL2, URLSearchParams: URLSearchParams2 } = require_webidl2js_wrapper();
    var urlStateMachine = require_url_state_machine();
    var percentEncoding = require_percent_encoding();
    var sharedGlobalObject = { Array, Object, Promise, String, TypeError };
    URL2.install(sharedGlobalObject, ["Window"]);
    URLSearchParams2.install(sharedGlobalObject, ["Window"]);
    exports2.URL = sharedGlobalObject.URL;
    exports2.URLSearchParams = sharedGlobalObject.URLSearchParams;
    exports2.parseURL = urlStateMachine.parseURL;
    exports2.basicURLParse = urlStateMachine.basicURLParse;
    exports2.serializeURL = urlStateMachine.serializeURL;
    exports2.serializePath = urlStateMachine.serializePath;
    exports2.serializeHost = urlStateMachine.serializeHost;
    exports2.serializeInteger = urlStateMachine.serializeInteger;
    exports2.serializeURLOrigin = urlStateMachine.serializeURLOrigin;
    exports2.setTheUsername = urlStateMachine.setTheUsername;
    exports2.setThePassword = urlStateMachine.setThePassword;
    exports2.cannotHaveAUsernamePasswordPort = urlStateMachine.cannotHaveAUsernamePasswordPort;
    exports2.hasAnOpaquePath = urlStateMachine.hasAnOpaquePath;
    exports2.percentDecodeString = percentEncoding.percentDecodeString;
    exports2.percentDecodeBytes = percentEncoding.percentDecodeBytes;
  }
});

// node_modules/mongodb-connection-string-url/lib/redact.js
var require_redact = __commonJS({
  "node_modules/mongodb-connection-string-url/lib/redact.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.redactConnectionString = exports2.redactValidConnectionString = void 0;
    var index_1 = __importStar2(require_lib5());
    function redactValidConnectionString(inputUrl, options2) {
      var _a, _b;
      const url = inputUrl.clone();
      const replacementString = (_a = options2 === null || options2 === void 0 ? void 0 : options2.replacementString) !== null && _a !== void 0 ? _a : "_credentials_";
      const redactUsernames = (_b = options2 === null || options2 === void 0 ? void 0 : options2.redactUsernames) !== null && _b !== void 0 ? _b : true;
      if ((url.username || url.password) && redactUsernames) {
        url.username = replacementString;
        url.password = "";
      } else if (url.password) {
        url.password = replacementString;
      }
      if (url.searchParams.has("authMechanismProperties")) {
        const props = new index_1.CommaAndColonSeparatedRecord(url.searchParams.get("authMechanismProperties"));
        if (props.get("AWS_SESSION_TOKEN")) {
          props.set("AWS_SESSION_TOKEN", replacementString);
          url.searchParams.set("authMechanismProperties", props.toString());
        }
      }
      if (url.searchParams.has("tlsCertificateKeyFilePassword")) {
        url.searchParams.set("tlsCertificateKeyFilePassword", replacementString);
      }
      if (url.searchParams.has("proxyUsername") && redactUsernames) {
        url.searchParams.set("proxyUsername", replacementString);
      }
      if (url.searchParams.has("proxyPassword")) {
        url.searchParams.set("proxyPassword", replacementString);
      }
      return url;
    }
    exports2.redactValidConnectionString = redactValidConnectionString;
    function redactConnectionString(uri, options2) {
      var _a, _b;
      const replacementString = (_a = options2 === null || options2 === void 0 ? void 0 : options2.replacementString) !== null && _a !== void 0 ? _a : "<credentials>";
      const redactUsernames = (_b = options2 === null || options2 === void 0 ? void 0 : options2.redactUsernames) !== null && _b !== void 0 ? _b : true;
      let parsed;
      try {
        parsed = new index_1.default(uri);
      } catch (_c) {
      }
      if (parsed) {
        options2 = { ...options2, replacementString: "___credentials___" };
        return parsed.redact(options2).toString().replace(/___credentials___/g, replacementString);
      }
      const R = replacementString;
      const replacements = [
        (uri2) => uri2.replace(redactUsernames ? /(\/\/)(.*)(@)/g : /(\/\/[^@]*:)(.*)(@)/g, `$1${R}$3`),
        (uri2) => uri2.replace(/(AWS_SESSION_TOKEN(:|%3A))([^,&]+)/gi, `$1${R}`),
        (uri2) => uri2.replace(/(tlsCertificateKeyFilePassword=)([^&]+)/gi, `$1${R}`),
        (uri2) => redactUsernames ? uri2.replace(/(proxyUsername=)([^&]+)/gi, `$1${R}`) : uri2,
        (uri2) => uri2.replace(/(proxyPassword=)([^&]+)/gi, `$1${R}`)
      ];
      for (const replacer of replacements) {
        uri = replacer(uri);
      }
      return uri;
    }
    exports2.redactConnectionString = redactConnectionString;
  }
});

// node_modules/mongodb-connection-string-url/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/mongodb-connection-string-url/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommaAndColonSeparatedRecord = exports2.ConnectionString = exports2.redactConnectionString = void 0;
    var whatwg_url_1 = require_whatwg_url();
    var redact_1 = require_redact();
    Object.defineProperty(exports2, "redactConnectionString", { enumerable: true, get: function() {
      return redact_1.redactConnectionString;
    } });
    var DUMMY_HOSTNAME = "__this_is_a_placeholder__";
    function connectionStringHasValidScheme(connectionString) {
      return connectionString.startsWith("mongodb://") || connectionString.startsWith("mongodb+srv://");
    }
    var HOSTS_REGEX = /^(?<protocol>[^/]+):\/\/(?:(?<username>[^:@]*)(?::(?<password>[^@]*))?@)?(?<hosts>(?!:)[^/?@]*)(?<rest>.*)/;
    var CaseInsensitiveMap = class extends Map {
      delete(name) {
        return super.delete(this._normalizeKey(name));
      }
      get(name) {
        return super.get(this._normalizeKey(name));
      }
      has(name) {
        return super.has(this._normalizeKey(name));
      }
      set(name, value) {
        return super.set(this._normalizeKey(name), value);
      }
      _normalizeKey(name) {
        name = `${name}`;
        for (const key of this.keys()) {
          if (key.toLowerCase() === name.toLowerCase()) {
            name = key;
            break;
          }
        }
        return name;
      }
    };
    function caseInsenstiveURLSearchParams(Ctor) {
      return class CaseInsenstiveURLSearchParams extends Ctor {
        append(name, value) {
          return super.append(this._normalizeKey(name), value);
        }
        delete(name) {
          return super.delete(this._normalizeKey(name));
        }
        get(name) {
          return super.get(this._normalizeKey(name));
        }
        getAll(name) {
          return super.getAll(this._normalizeKey(name));
        }
        has(name) {
          return super.has(this._normalizeKey(name));
        }
        set(name, value) {
          return super.set(this._normalizeKey(name), value);
        }
        keys() {
          return super.keys();
        }
        values() {
          return super.values();
        }
        entries() {
          return super.entries();
        }
        [Symbol.iterator]() {
          return super[Symbol.iterator]();
        }
        _normalizeKey(name) {
          return CaseInsensitiveMap.prototype._normalizeKey.call(this, name);
        }
      };
    }
    var URLWithoutHost = class extends whatwg_url_1.URL {
    };
    var MongoParseError = class extends Error {
      get name() {
        return "MongoParseError";
      }
    };
    var ConnectionString = class _ConnectionString extends URLWithoutHost {
      constructor(uri, options2 = {}) {
        var _a;
        const { looseValidation } = options2;
        if (!looseValidation && !connectionStringHasValidScheme(uri)) {
          throw new MongoParseError('Invalid scheme, expected connection string to start with "mongodb://" or "mongodb+srv://"');
        }
        const match = uri.match(HOSTS_REGEX);
        if (!match) {
          throw new MongoParseError(`Invalid connection string "${uri}"`);
        }
        const { protocol, username, password, hosts, rest } = (_a = match.groups) !== null && _a !== void 0 ? _a : {};
        if (!looseValidation) {
          if (!protocol || !hosts) {
            throw new MongoParseError(`Protocol and host list are required in "${uri}"`);
          }
          try {
            decodeURIComponent(username !== null && username !== void 0 ? username : "");
            decodeURIComponent(password !== null && password !== void 0 ? password : "");
          } catch (err) {
            throw new MongoParseError(err.message);
          }
          const illegalCharacters = /[:/?#[\]@]/gi;
          if (username === null || username === void 0 ? void 0 : username.match(illegalCharacters)) {
            throw new MongoParseError(`Username contains unescaped characters ${username}`);
          }
          if (!username || !password) {
            const uriWithoutProtocol = uri.replace(`${protocol}://`, "");
            if (uriWithoutProtocol.startsWith("@") || uriWithoutProtocol.startsWith(":")) {
              throw new MongoParseError("URI contained empty userinfo section");
            }
          }
          if (password === null || password === void 0 ? void 0 : password.match(illegalCharacters)) {
            throw new MongoParseError("Password contains unescaped characters");
          }
        }
        let authString = "";
        if (typeof username === "string")
          authString += username;
        if (typeof password === "string")
          authString += `:${password}`;
        if (authString)
          authString += "@";
        try {
          super(`${protocol.toLowerCase()}://${authString}${DUMMY_HOSTNAME}${rest}`);
        } catch (err) {
          if (looseValidation) {
            new _ConnectionString(uri, {
              ...options2,
              looseValidation: false
            });
          }
          if (typeof err.message === "string") {
            err.message = err.message.replace(DUMMY_HOSTNAME, hosts);
          }
          throw err;
        }
        this._hosts = hosts.split(",");
        if (!looseValidation) {
          if (this.isSRV && this.hosts.length !== 1) {
            throw new MongoParseError("mongodb+srv URI cannot have multiple service names");
          }
          if (this.isSRV && this.hosts.some((host) => host.includes(":"))) {
            throw new MongoParseError("mongodb+srv URI cannot have port number");
          }
        }
        if (!this.pathname) {
          this.pathname = "/";
        }
        Object.setPrototypeOf(this.searchParams, caseInsenstiveURLSearchParams(this.searchParams.constructor).prototype);
      }
      get host() {
        return DUMMY_HOSTNAME;
      }
      set host(_ignored) {
        throw new Error("No single host for connection string");
      }
      get hostname() {
        return DUMMY_HOSTNAME;
      }
      set hostname(_ignored) {
        throw new Error("No single host for connection string");
      }
      get port() {
        return "";
      }
      set port(_ignored) {
        throw new Error("No single host for connection string");
      }
      get href() {
        return this.toString();
      }
      set href(_ignored) {
        throw new Error("Cannot set href for connection strings");
      }
      get isSRV() {
        return this.protocol.includes("srv");
      }
      get hosts() {
        return this._hosts;
      }
      set hosts(list) {
        this._hosts = list;
      }
      toString() {
        return super.toString().replace(DUMMY_HOSTNAME, this.hosts.join(","));
      }
      clone() {
        return new _ConnectionString(this.toString(), {
          looseValidation: true
        });
      }
      redact(options2) {
        return (0, redact_1.redactValidConnectionString)(this, options2);
      }
      typedSearchParams() {
        const sametype = false;
        return this.searchParams;
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        const { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash } = this;
        return { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash };
      }
    };
    exports2.ConnectionString = ConnectionString;
    var CommaAndColonSeparatedRecord = class extends CaseInsensitiveMap {
      constructor(from) {
        super();
        for (const entry of (from !== null && from !== void 0 ? from : "").split(",")) {
          if (!entry)
            continue;
          const colonIndex = entry.indexOf(":");
          if (colonIndex === -1) {
            this.set(entry, "");
          } else {
            this.set(entry.slice(0, colonIndex), entry.slice(colonIndex + 1));
          }
        }
      }
      toString() {
        return [...this].map((entry) => entry.join(":")).join(",");
      }
    };
    exports2.CommaAndColonSeparatedRecord = CommaAndColonSeparatedRecord;
    exports2.default = ConnectionString;
  }
});

// node_modules/mongodb/package.json
var require_package = __commonJS({
  "node_modules/mongodb/package.json"(exports2, module2) {
    module2.exports = {
      name: "mongodb",
      version: "6.17.0",
      description: "The official MongoDB driver for Node.js",
      main: "lib/index.js",
      files: [
        "lib",
        "src",
        "etc/prepare.js",
        "mongodb.d.ts",
        "tsconfig.json"
      ],
      types: "mongodb.d.ts",
      repository: {
        type: "git",
        url: "git@github.com:mongodb/node-mongodb-native.git"
      },
      keywords: [
        "mongodb",
        "driver",
        "official"
      ],
      author: {
        name: "The MongoDB NodeJS Team",
        email: "dbx-node@mongodb.com"
      },
      dependencies: {
        "@mongodb-js/saslprep": "^1.1.9",
        bson: "^6.10.4",
        "mongodb-connection-string-url": "^3.0.0"
      },
      peerDependencies: {
        "@aws-sdk/credential-providers": "^3.188.0",
        "@mongodb-js/zstd": "^1.1.0 || ^2.0.0",
        "gcp-metadata": "^5.2.0",
        kerberos: "^2.0.1",
        "mongodb-client-encryption": ">=6.0.0 <7",
        snappy: "^7.2.2",
        socks: "^2.7.1"
      },
      peerDependenciesMeta: {
        "@aws-sdk/credential-providers": {
          optional: true
        },
        "@mongodb-js/zstd": {
          optional: true
        },
        kerberos: {
          optional: true
        },
        snappy: {
          optional: true
        },
        "mongodb-client-encryption": {
          optional: true
        },
        "gcp-metadata": {
          optional: true
        },
        socks: {
          optional: true
        }
      },
      devDependencies: {
        "@aws-sdk/credential-providers": "^3.632.0",
        "@iarna/toml": "^2.2.5",
        "@istanbuljs/nyc-config-typescript": "^1.0.2",
        "@microsoft/api-extractor": "^7.52.5",
        "@microsoft/tsdoc-config": "^0.17.1",
        "@mongodb-js/zstd": "^2.0.1",
        "@types/chai": "^4.3.17",
        "@types/chai-subset": "^1.3.5",
        "@types/express": "^5.0.1",
        "@types/kerberos": "^1.1.5",
        "@types/mocha": "^10.0.9",
        "@types/node": "^22.15.3",
        "@types/saslprep": "^1.0.3",
        "@types/semver": "^7.7.0",
        "@types/sinon": "^17.0.4",
        "@types/sinon-chai": "^4.0.0",
        "@types/whatwg-url": "^13.0.0",
        "@typescript-eslint/eslint-plugin": "^8.31.1",
        "@typescript-eslint/parser": "^8.31.1",
        chai: "^4.4.1",
        "chai-subset": "^1.6.0",
        chalk: "^4.1.2",
        eslint: "^9.25.1",
        "eslint-config-prettier": "^10.1.2",
        "eslint-plugin-mocha": "^10.4.1",
        "eslint-plugin-prettier": "^5.2.3",
        "eslint-plugin-simple-import-sort": "^12.1.1",
        "eslint-plugin-tsdoc": "^0.4.0",
        "eslint-plugin-unused-imports": "^4.1.4",
        express: "^5.1.0",
        "gcp-metadata": "^5.3.0",
        "js-yaml": "^4.1.0",
        mocha: "^10.8.2",
        "mocha-sinon": "^2.1.2",
        "mongodb-client-encryption": "^6.4.0",
        "mongodb-legacy": "^6.1.3",
        nyc: "^15.1.0",
        prettier: "^3.5.3",
        semver: "^7.7.0",
        sinon: "^18.0.1",
        "sinon-chai": "^3.7.0",
        snappy: "^7.2.2",
        socks: "^2.8.1",
        "source-map-support": "^0.5.21",
        "ts-node": "^10.9.2",
        tsd: "^0.31.2",
        typescript: "5.5",
        "typescript-cached-transpile": "^0.0.6",
        "v8-heapsnapshot": "^1.3.1",
        yargs: "^17.7.2"
      },
      license: "Apache-2.0",
      engines: {
        node: ">=16.20.1"
      },
      bugs: {
        url: "https://jira.mongodb.org/projects/NODE/issues/"
      },
      homepage: "https://github.com/mongodb/node-mongodb-native",
      scripts: {
        "build:evergreen": "node .evergreen/generate_evergreen_tasks.js",
        "build:ts": "node ./node_modules/typescript/bin/tsc",
        "build:dts": "npm run build:ts && api-extractor run && node etc/clean_definition_files.cjs && ESLINT_USE_FLAT_CONFIG=false eslint --no-ignore --fix mongodb.d.ts lib/beta.d.ts",
        "build:docs": "./etc/docs/build.ts",
        "build:typedoc": "typedoc",
        "build:nightly": "node ./.github/scripts/nightly.mjs",
        "check:bench": "npm --prefix test/benchmarks/driver_bench start",
        "check:coverage": "nyc npm run test:all",
        "check:integration-coverage": "nyc npm run check:test",
        "check:lambda": "nyc mocha --config test/mocha_lambda.js test/integration/node-specific/examples/handler.test.js",
        "check:lambda:aws": "nyc mocha --config test/mocha_lambda.js test/integration/node-specific/examples/aws_handler.test.js",
        "check:lint": "npm run build:dts && npm run check:dts && npm run check:eslint && npm run check:tsd",
        "check:eslint": "npm run build:dts && ESLINT_USE_FLAT_CONFIG=false eslint -v && ESLINT_USE_FLAT_CONFIG=false eslint --max-warnings=0 --ext '.js,.ts' src test",
        "check:tsd": "tsd --version && tsd",
        "check:dependencies": "mocha test/action/dependency.test.ts",
        "check:dts": "node ./node_modules/typescript/bin/tsc --noEmit mongodb.d.ts && tsd",
        "check:search-indexes": "nyc mocha --config test/mocha_mongodb.js test/manual/search-index-management.prose.test.ts",
        "check:test": "mocha --config test/mocha_mongodb.js test/integration",
        "check:unit": "nyc mocha test/unit",
        "check:ts": "node ./node_modules/typescript/bin/tsc -v && node ./node_modules/typescript/bin/tsc --noEmit",
        "check:atlas": "nyc mocha --config test/manual/mocharc.js test/manual/atlas_connectivity.test.ts",
        "check:resource-management": "nyc mocha --config test/manual/mocharc.js test/manual/resource_management.test.ts",
        "check:drivers-atlas-testing": "nyc mocha --config test/mocha_mongodb.js test/atlas/drivers_atlas_testing.test.ts",
        "check:adl": "nyc mocha --config test/mocha_mongodb.js test/manual/atlas-data-lake-testing",
        "check:aws": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_aws.test.ts",
        "check:oidc-auth": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/auth.spec.test.ts",
        "check:oidc-test": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_oidc.prose.test.ts",
        "check:oidc-azure": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_oidc_azure.prose.05.test.ts",
        "check:oidc-gcp": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_oidc_gcp.prose.06.test.ts",
        "check:oidc-k8s": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_oidc_k8s.prose.07.test.ts",
        "check:kerberos": "nyc mocha --config test/manual/mocharc.js test/manual/kerberos.test.ts",
        "check:tls": "nyc mocha --config test/manual/mocharc.js test/manual/tls_support.test.ts",
        "check:ldap": "nyc mocha --config test/manual/mocharc.js test/manual/ldap.test.ts",
        "check:socks5": "nyc mocha --config test/manual/mocharc.js test/manual/socks5.test.ts",
        "check:csfle": "nyc mocha --config test/mocha_mongodb.js test/integration/client-side-encryption",
        "check:snappy": "nyc mocha test/unit/assorted/snappy.test.js",
        "check:x509": "nyc mocha test/manual/x509_auth.test.ts",
        "fix:eslint": "npm run check:eslint -- --fix",
        prepare: "node etc/prepare.js",
        "preview:docs": "ts-node etc/docs/preview.ts",
        test: "npm run check:lint && npm run test:all",
        "test:all": "npm run check:unit && npm run check:test",
        "update:docs": "npm run build:docs -- --yes"
      },
      tsd: {
        directory: "test/types",
        compilerOptions: {
          strict: true,
          target: "esnext",
          module: "commonjs",
          moduleResolution: "node"
        }
      }
    };
  }
});

// node_modules/mongodb/lib/cmap/handshake/client_metadata.js
var require_client_metadata = __commonJS({
  "node_modules/mongodb/lib/cmap/handshake/client_metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LimitedSizeDocument = void 0;
    exports2.makeClientMetadata = makeClientMetadata;
    exports2.addContainerMetadata = addContainerMetadata;
    exports2.getFAASEnv = getFAASEnv;
    var os = require("os");
    var process2 = require("process");
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var NODE_DRIVER_VERSION = require_package().version;
    var LimitedSizeDocument = class {
      constructor(maxSize) {
        this.maxSize = maxSize;
        this.document = /* @__PURE__ */ new Map();
        this.documentSize = 5;
      }
      /** Only adds key/value if the bsonByteLength is less than MAX_SIZE */
      ifItFitsItSits(key, value) {
        const newElementSize = bson_1.BSON.serialize((/* @__PURE__ */ new Map()).set(key, value)).byteLength - 5;
        if (newElementSize + this.documentSize > this.maxSize) {
          return false;
        }
        this.documentSize += newElementSize;
        this.document.set(key, value);
        return true;
      }
      toObject() {
        return bson_1.BSON.deserialize(bson_1.BSON.serialize(this.document), {
          promoteLongs: false,
          promoteBuffers: false,
          promoteValues: false,
          useBigInt64: false
        });
      }
    };
    exports2.LimitedSizeDocument = LimitedSizeDocument;
    function makeClientMetadata(options2) {
      const metadataDocument = new LimitedSizeDocument(512);
      const { appName = "" } = options2;
      if (appName.length > 0) {
        const name2 = Buffer.byteLength(appName, "utf8") <= 128 ? options2.appName : Buffer.from(appName, "utf8").subarray(0, 128).toString("utf8");
        metadataDocument.ifItFitsItSits("application", { name: name2 });
      }
      const { name = "", version = "", platform = "" } = options2.driverInfo;
      const driverInfo = {
        name: name.length > 0 ? `nodejs|${name}` : "nodejs",
        version: version.length > 0 ? `${NODE_DRIVER_VERSION}|${version}` : NODE_DRIVER_VERSION
      };
      if (!metadataDocument.ifItFitsItSits("driver", driverInfo)) {
        throw new error_1.MongoInvalidArgumentError("Unable to include driverInfo name and version, metadata cannot exceed 512 bytes");
      }
      let runtimeInfo = getRuntimeInfo();
      if (platform.length > 0) {
        runtimeInfo = `${runtimeInfo}|${platform}`;
      }
      if (!metadataDocument.ifItFitsItSits("platform", runtimeInfo)) {
        throw new error_1.MongoInvalidArgumentError("Unable to include driverInfo platform, metadata cannot exceed 512 bytes");
      }
      const osInfo = (/* @__PURE__ */ new Map()).set("name", process2.platform).set("architecture", process2.arch).set("version", os.release()).set("type", os.type());
      if (!metadataDocument.ifItFitsItSits("os", osInfo)) {
        for (const key of osInfo.keys()) {
          osInfo.delete(key);
          if (osInfo.size === 0)
            break;
          if (metadataDocument.ifItFitsItSits("os", osInfo))
            break;
        }
      }
      const faasEnv = getFAASEnv();
      if (faasEnv != null) {
        if (!metadataDocument.ifItFitsItSits("env", faasEnv)) {
          for (const key of faasEnv.keys()) {
            faasEnv.delete(key);
            if (faasEnv.size === 0)
              break;
            if (metadataDocument.ifItFitsItSits("env", faasEnv))
              break;
          }
        }
      }
      return metadataDocument.toObject();
    }
    var dockerPromise;
    async function getContainerMetadata() {
      const containerMetadata = {};
      dockerPromise ??= (0, utils_1.fileIsAccessible)("/.dockerenv");
      const isDocker = await dockerPromise;
      const { KUBERNETES_SERVICE_HOST = "" } = process2.env;
      const isKubernetes = KUBERNETES_SERVICE_HOST.length > 0 ? true : false;
      if (isDocker)
        containerMetadata.runtime = "docker";
      if (isKubernetes)
        containerMetadata.orchestrator = "kubernetes";
      return containerMetadata;
    }
    async function addContainerMetadata(originalMetadata) {
      const containerMetadata = await getContainerMetadata();
      if (Object.keys(containerMetadata).length === 0)
        return originalMetadata;
      const extendedMetadata = new LimitedSizeDocument(512);
      const extendedEnvMetadata = { ...originalMetadata?.env, container: containerMetadata };
      for (const [key, val] of Object.entries(originalMetadata)) {
        if (key !== "env") {
          extendedMetadata.ifItFitsItSits(key, val);
        } else {
          if (!extendedMetadata.ifItFitsItSits("env", extendedEnvMetadata)) {
            extendedMetadata.ifItFitsItSits("env", val);
          }
        }
      }
      if (!("env" in originalMetadata)) {
        extendedMetadata.ifItFitsItSits("env", extendedEnvMetadata);
      }
      return extendedMetadata.toObject();
    }
    function getFAASEnv() {
      const { AWS_EXECUTION_ENV = "", AWS_LAMBDA_RUNTIME_API = "", FUNCTIONS_WORKER_RUNTIME = "", K_SERVICE = "", FUNCTION_NAME = "", VERCEL = "", AWS_LAMBDA_FUNCTION_MEMORY_SIZE = "", AWS_REGION = "", FUNCTION_MEMORY_MB = "", FUNCTION_REGION = "", FUNCTION_TIMEOUT_SEC = "", VERCEL_REGION = "" } = process2.env;
      const isAWSFaaS = AWS_EXECUTION_ENV.startsWith("AWS_Lambda_") || AWS_LAMBDA_RUNTIME_API.length > 0;
      const isAzureFaaS = FUNCTIONS_WORKER_RUNTIME.length > 0;
      const isGCPFaaS = K_SERVICE.length > 0 || FUNCTION_NAME.length > 0;
      const isVercelFaaS = VERCEL.length > 0;
      const faasEnv = /* @__PURE__ */ new Map();
      if (isVercelFaaS && !(isAzureFaaS || isGCPFaaS)) {
        if (VERCEL_REGION.length > 0) {
          faasEnv.set("region", VERCEL_REGION);
        }
        faasEnv.set("name", "vercel");
        return faasEnv;
      }
      if (isAWSFaaS && !(isAzureFaaS || isGCPFaaS || isVercelFaaS)) {
        if (AWS_REGION.length > 0) {
          faasEnv.set("region", AWS_REGION);
        }
        if (AWS_LAMBDA_FUNCTION_MEMORY_SIZE.length > 0 && Number.isInteger(+AWS_LAMBDA_FUNCTION_MEMORY_SIZE)) {
          faasEnv.set("memory_mb", new bson_1.Int32(AWS_LAMBDA_FUNCTION_MEMORY_SIZE));
        }
        faasEnv.set("name", "aws.lambda");
        return faasEnv;
      }
      if (isAzureFaaS && !(isGCPFaaS || isAWSFaaS || isVercelFaaS)) {
        faasEnv.set("name", "azure.func");
        return faasEnv;
      }
      if (isGCPFaaS && !(isAzureFaaS || isAWSFaaS || isVercelFaaS)) {
        if (FUNCTION_REGION.length > 0) {
          faasEnv.set("region", FUNCTION_REGION);
        }
        if (FUNCTION_MEMORY_MB.length > 0 && Number.isInteger(+FUNCTION_MEMORY_MB)) {
          faasEnv.set("memory_mb", new bson_1.Int32(FUNCTION_MEMORY_MB));
        }
        if (FUNCTION_TIMEOUT_SEC.length > 0 && Number.isInteger(+FUNCTION_TIMEOUT_SEC)) {
          faasEnv.set("timeout_sec", new bson_1.Int32(FUNCTION_TIMEOUT_SEC));
        }
        faasEnv.set("name", "gcp.func");
        return faasEnv;
      }
      return null;
    }
    function getRuntimeInfo() {
      if ("Deno" in globalThis) {
        const version = typeof Deno?.version?.deno === "string" ? Deno?.version?.deno : "0.0.0-unknown";
        return `Deno v${version}, ${os.endianness()}`;
      }
      if ("Bun" in globalThis) {
        const version = typeof Bun?.version === "string" ? Bun?.version : "0.0.0-unknown";
        return `Bun v${version}, ${os.endianness()}`;
      }
      return `Node.js ${process2.version}, ${os.endianness()}`;
    }
  }
});

// node_modules/mongodb/lib/cmap/commands.js
var require_commands = __commonJS({
  "node_modules/mongodb/lib/cmap/commands.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OpCompressedRequest = exports2.OpMsgResponse = exports2.OpMsgRequest = exports2.DocumentSequence = exports2.OpReply = exports2.OpQueryRequest = void 0;
    var BSON = require_bson2();
    var error_1 = require_error();
    var compression_1 = require_compression();
    var constants_1 = require_constants3();
    var _requestId = 0;
    var OPTS_TAILABLE_CURSOR = 2;
    var OPTS_SECONDARY = 4;
    var OPTS_OPLOG_REPLAY = 8;
    var OPTS_NO_CURSOR_TIMEOUT = 16;
    var OPTS_AWAIT_DATA = 32;
    var OPTS_EXHAUST = 64;
    var OPTS_PARTIAL = 128;
    var CURSOR_NOT_FOUND = 1;
    var QUERY_FAILURE = 2;
    var SHARD_CONFIG_STALE = 4;
    var AWAIT_CAPABLE = 8;
    var encodeUTF8Into = BSON.BSON.onDemand.ByteUtils.encodeUTF8Into;
    var OpQueryRequest = class _OpQueryRequest {
      constructor(databaseName, query, options2) {
        this.databaseName = databaseName;
        this.query = query;
        this.moreToCome = false;
        const ns = `${databaseName}.$cmd`;
        if (typeof databaseName !== "string") {
          throw new error_1.MongoRuntimeError("Database name must be a string for a query");
        }
        if (query == null)
          throw new error_1.MongoRuntimeError("A query document must be specified for query");
        if (ns.indexOf("\0") !== -1) {
          throw new error_1.MongoRuntimeError("Namespace cannot contain a null character");
        }
        this.ns = ns;
        this.numberToSkip = options2.numberToSkip || 0;
        this.numberToReturn = options2.numberToReturn || 0;
        this.returnFieldSelector = options2.returnFieldSelector || void 0;
        this.requestId = options2.requestId ?? _OpQueryRequest.getRequestId();
        this.pre32Limit = options2.pre32Limit;
        this.serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
        this.ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : false;
        this.maxBsonSize = options2.maxBsonSize || 1024 * 1024 * 16;
        this.checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
        this.batchSize = this.numberToReturn;
        this.tailable = false;
        this.secondaryOk = typeof options2.secondaryOk === "boolean" ? options2.secondaryOk : false;
        this.oplogReplay = false;
        this.noCursorTimeout = false;
        this.awaitData = false;
        this.exhaust = false;
        this.partial = false;
      }
      /** Assign next request Id. */
      incRequestId() {
        this.requestId = _requestId++;
      }
      /** Peek next request Id. */
      nextRequestId() {
        return _requestId + 1;
      }
      /** Increment then return next request Id. */
      static getRequestId() {
        return ++_requestId;
      }
      // Uses a single allocated buffer for the process, avoiding multiple memory allocations
      toBin() {
        const buffers = [];
        let projection = null;
        let flags = 0;
        if (this.tailable) {
          flags |= OPTS_TAILABLE_CURSOR;
        }
        if (this.secondaryOk) {
          flags |= OPTS_SECONDARY;
        }
        if (this.oplogReplay) {
          flags |= OPTS_OPLOG_REPLAY;
        }
        if (this.noCursorTimeout) {
          flags |= OPTS_NO_CURSOR_TIMEOUT;
        }
        if (this.awaitData) {
          flags |= OPTS_AWAIT_DATA;
        }
        if (this.exhaust) {
          flags |= OPTS_EXHAUST;
        }
        if (this.partial) {
          flags |= OPTS_PARTIAL;
        }
        if (this.batchSize !== this.numberToReturn)
          this.numberToReturn = this.batchSize;
        const header = Buffer.alloc(
          4 * 4 + // Header
          4 + // Flags
          Buffer.byteLength(this.ns) + 1 + // namespace
          4 + // numberToSkip
          4
          // numberToReturn
        );
        buffers.push(header);
        const query = BSON.serialize(this.query, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
        buffers.push(query);
        if (this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {
          projection = BSON.serialize(this.returnFieldSelector, {
            checkKeys: this.checkKeys,
            serializeFunctions: this.serializeFunctions,
            ignoreUndefined: this.ignoreUndefined
          });
          buffers.push(projection);
        }
        const totalLength = header.length + query.length + (projection ? projection.length : 0);
        let index = 4;
        header[3] = totalLength >> 24 & 255;
        header[2] = totalLength >> 16 & 255;
        header[1] = totalLength >> 8 & 255;
        header[0] = totalLength & 255;
        header[index + 3] = this.requestId >> 24 & 255;
        header[index + 2] = this.requestId >> 16 & 255;
        header[index + 1] = this.requestId >> 8 & 255;
        header[index] = this.requestId & 255;
        index = index + 4;
        header[index + 3] = 0 >> 24 & 255;
        header[index + 2] = 0 >> 16 & 255;
        header[index + 1] = 0 >> 8 & 255;
        header[index] = 0 & 255;
        index = index + 4;
        header[index + 3] = constants_1.OP_QUERY >> 24 & 255;
        header[index + 2] = constants_1.OP_QUERY >> 16 & 255;
        header[index + 1] = constants_1.OP_QUERY >> 8 & 255;
        header[index] = constants_1.OP_QUERY & 255;
        index = index + 4;
        header[index + 3] = flags >> 24 & 255;
        header[index + 2] = flags >> 16 & 255;
        header[index + 1] = flags >> 8 & 255;
        header[index] = flags & 255;
        index = index + 4;
        index = index + header.write(this.ns, index, "utf8") + 1;
        header[index - 1] = 0;
        header[index + 3] = this.numberToSkip >> 24 & 255;
        header[index + 2] = this.numberToSkip >> 16 & 255;
        header[index + 1] = this.numberToSkip >> 8 & 255;
        header[index] = this.numberToSkip & 255;
        index = index + 4;
        header[index + 3] = this.numberToReturn >> 24 & 255;
        header[index + 2] = this.numberToReturn >> 16 & 255;
        header[index + 1] = this.numberToReturn >> 8 & 255;
        header[index] = this.numberToReturn & 255;
        index = index + 4;
        return buffers;
      }
    };
    exports2.OpQueryRequest = OpQueryRequest;
    var OpReply = class {
      constructor(message, msgHeader, msgBody, opts) {
        this.index = 0;
        this.sections = [];
        this.moreToCome = false;
        this.parsed = false;
        this.raw = message;
        this.data = msgBody;
        this.opts = opts ?? {
          useBigInt64: false,
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: false,
          bsonRegExp: false
        };
        this.length = msgHeader.length;
        this.requestId = msgHeader.requestId;
        this.responseTo = msgHeader.responseTo;
        this.opCode = msgHeader.opCode;
        this.fromCompressed = msgHeader.fromCompressed;
        this.useBigInt64 = typeof this.opts.useBigInt64 === "boolean" ? this.opts.useBigInt64 : false;
        this.promoteLongs = typeof this.opts.promoteLongs === "boolean" ? this.opts.promoteLongs : true;
        this.promoteValues = typeof this.opts.promoteValues === "boolean" ? this.opts.promoteValues : true;
        this.promoteBuffers = typeof this.opts.promoteBuffers === "boolean" ? this.opts.promoteBuffers : false;
        this.bsonRegExp = typeof this.opts.bsonRegExp === "boolean" ? this.opts.bsonRegExp : false;
      }
      isParsed() {
        return this.parsed;
      }
      parse() {
        if (this.parsed)
          return this.sections[0];
        this.index = 20;
        this.responseFlags = this.data.readInt32LE(0);
        this.cursorId = new BSON.Long(this.data.readInt32LE(4), this.data.readInt32LE(8));
        this.startingFrom = this.data.readInt32LE(12);
        this.numberReturned = this.data.readInt32LE(16);
        if (this.numberReturned < 0 || this.numberReturned > 2 ** 32 - 1) {
          throw new RangeError(`OP_REPLY numberReturned is an invalid array length ${this.numberReturned}`);
        }
        this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
        this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
        this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
        this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
        for (let i = 0; i < this.numberReturned; i++) {
          const bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
          const section = this.data.subarray(this.index, this.index + bsonSize);
          this.sections.push(section);
          this.index = this.index + bsonSize;
        }
        this.parsed = true;
        return this.sections[0];
      }
    };
    exports2.OpReply = OpReply;
    var OPTS_CHECKSUM_PRESENT = 1;
    var OPTS_MORE_TO_COME = 2;
    var OPTS_EXHAUST_ALLOWED = 1 << 16;
    var DocumentSequence = class {
      /**
       * Create a new document sequence for the provided field.
       * @param field - The field it will replace.
       */
      constructor(field, documents) {
        this.field = field;
        this.documents = [];
        this.chunks = [];
        this.serializedDocumentsLength = 0;
        const buffer = Buffer.allocUnsafe(1 + 4 + this.field.length + 1);
        buffer[0] = 1;
        encodeUTF8Into(buffer, `${this.field}\0`, 5);
        this.chunks.push(buffer);
        this.header = buffer;
        if (documents) {
          for (const doc of documents) {
            this.push(doc, BSON.serialize(doc));
          }
        }
      }
      /**
       * Push a document to the document sequence. Will serialize the document
       * as well and return the current serialized length of all documents.
       * @param document - The document to add.
       * @param buffer - The serialized document in raw BSON.
       * @returns The new total document sequence length.
       */
      push(document2, buffer) {
        this.serializedDocumentsLength += buffer.length;
        this.documents.push(document2);
        this.chunks.push(buffer);
        this.header?.writeInt32LE(4 + this.field.length + 1 + this.serializedDocumentsLength, 1);
        return this.serializedDocumentsLength + this.header.length;
      }
      /**
       * Get the fully serialized bytes for the document sequence section.
       * @returns The section bytes.
       */
      toBin() {
        return Buffer.concat(this.chunks);
      }
    };
    exports2.DocumentSequence = DocumentSequence;
    var OpMsgRequest = class _OpMsgRequest {
      constructor(databaseName, command, options2) {
        this.databaseName = databaseName;
        this.command = command;
        this.options = options2;
        if (command == null)
          throw new error_1.MongoInvalidArgumentError("Query document must be specified for query");
        this.command.$db = databaseName;
        this.options = options2 ?? {};
        this.requestId = options2.requestId ? options2.requestId : _OpMsgRequest.getRequestId();
        this.serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
        this.ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : false;
        this.checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
        this.maxBsonSize = options2.maxBsonSize || 1024 * 1024 * 16;
        this.checksumPresent = false;
        this.moreToCome = options2.moreToCome ?? command.writeConcern?.w === 0;
        this.exhaustAllowed = typeof options2.exhaustAllowed === "boolean" ? options2.exhaustAllowed : false;
      }
      toBin() {
        const buffers = [];
        let flags = 0;
        if (this.checksumPresent) {
          flags |= OPTS_CHECKSUM_PRESENT;
        }
        if (this.moreToCome) {
          flags |= OPTS_MORE_TO_COME;
        }
        if (this.exhaustAllowed) {
          flags |= OPTS_EXHAUST_ALLOWED;
        }
        const header = Buffer.alloc(
          4 * 4 + // Header
          4
          // Flags
        );
        buffers.push(header);
        let totalLength = header.length;
        const command = this.command;
        totalLength += this.makeSections(buffers, command);
        header.writeInt32LE(totalLength, 0);
        header.writeInt32LE(this.requestId, 4);
        header.writeInt32LE(0, 8);
        header.writeInt32LE(constants_1.OP_MSG, 12);
        header.writeUInt32LE(flags, 16);
        return buffers;
      }
      /**
       * Add the sections to the OP_MSG request's buffers and returns the length.
       */
      makeSections(buffers, document2) {
        const sequencesBuffer = this.extractDocumentSequences(document2);
        const payloadTypeBuffer = Buffer.allocUnsafe(1);
        payloadTypeBuffer[0] = 0;
        const documentBuffer = this.serializeBson(document2);
        buffers.push(payloadTypeBuffer);
        buffers.push(documentBuffer);
        buffers.push(sequencesBuffer);
        return payloadTypeBuffer.length + documentBuffer.length + sequencesBuffer.length;
      }
      /**
       * Extracts the document sequences from the command document and returns
       * a buffer to be added as multiple sections after the initial type 0
       * section in the message.
       */
      extractDocumentSequences(document2) {
        const chunks = [];
        for (const [key, value] of Object.entries(document2)) {
          if (value instanceof DocumentSequence) {
            chunks.push(value.toBin());
            delete document2[key];
          }
        }
        if (chunks.length > 0) {
          return Buffer.concat(chunks);
        }
        return Buffer.alloc(0);
      }
      serializeBson(document2) {
        return BSON.serialize(document2, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
      }
      static getRequestId() {
        _requestId = _requestId + 1 & 2147483647;
        return _requestId;
      }
    };
    exports2.OpMsgRequest = OpMsgRequest;
    var OpMsgResponse = class {
      constructor(message, msgHeader, msgBody, opts) {
        this.index = 0;
        this.sections = [];
        this.parsed = false;
        this.raw = message;
        this.data = msgBody;
        this.opts = opts ?? {
          useBigInt64: false,
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: false,
          bsonRegExp: false
        };
        this.length = msgHeader.length;
        this.requestId = msgHeader.requestId;
        this.responseTo = msgHeader.responseTo;
        this.opCode = msgHeader.opCode;
        this.fromCompressed = msgHeader.fromCompressed;
        this.responseFlags = msgBody.readInt32LE(0);
        this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
        this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
        this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
        this.useBigInt64 = typeof this.opts.useBigInt64 === "boolean" ? this.opts.useBigInt64 : false;
        this.promoteLongs = typeof this.opts.promoteLongs === "boolean" ? this.opts.promoteLongs : true;
        this.promoteValues = typeof this.opts.promoteValues === "boolean" ? this.opts.promoteValues : true;
        this.promoteBuffers = typeof this.opts.promoteBuffers === "boolean" ? this.opts.promoteBuffers : false;
        this.bsonRegExp = typeof this.opts.bsonRegExp === "boolean" ? this.opts.bsonRegExp : false;
      }
      isParsed() {
        return this.parsed;
      }
      parse() {
        if (this.parsed)
          return this.sections[0];
        this.index = 4;
        while (this.index < this.data.length) {
          const payloadType = this.data.readUInt8(this.index++);
          if (payloadType === 0) {
            const bsonSize = this.data.readUInt32LE(this.index);
            const bin = this.data.subarray(this.index, this.index + bsonSize);
            this.sections.push(bin);
            this.index += bsonSize;
          } else if (payloadType === 1) {
            throw new error_1.MongoRuntimeError("OP_MSG Payload Type 1 detected unsupported protocol");
          }
        }
        this.parsed = true;
        return this.sections[0];
      }
    };
    exports2.OpMsgResponse = OpMsgResponse;
    var MESSAGE_HEADER_SIZE = 16;
    var COMPRESSION_DETAILS_SIZE = 9;
    var OpCompressedRequest = class {
      constructor(command, options2) {
        this.command = command;
        this.options = options2;
      }
      // Return whether a command contains an uncompressible command term
      // Will return true if command contains no uncompressible command terms
      static canCompress(command) {
        const commandDoc = command instanceof OpMsgRequest ? command.command : command.query;
        const commandName = Object.keys(commandDoc)[0];
        return !compression_1.uncompressibleCommands.has(commandName);
      }
      async toBin() {
        const concatenatedOriginalCommandBuffer = Buffer.concat(this.command.toBin());
        const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
        const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
        const compressedMessage = await (0, compression_1.compress)(this.options, messageToBeCompressed);
        const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
        msgHeader.writeInt32LE(this.command.requestId, 4);
        msgHeader.writeInt32LE(0, 8);
        msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12);
        const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0);
        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
        compressionDetails.writeUInt8(compression_1.Compressor[this.options.agreedCompressor], 8);
        return [msgHeader, compressionDetails, compressedMessage];
      }
    };
    exports2.OpCompressedRequest = OpCompressedRequest;
  }
});

// node_modules/mongodb/lib/cmap/wire_protocol/compression.js
var require_compression = __commonJS({
  "node_modules/mongodb/lib/cmap/wire_protocol/compression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uncompressibleCommands = exports2.Compressor = void 0;
    exports2.compress = compress;
    exports2.decompress = decompress;
    exports2.compressCommand = compressCommand;
    exports2.decompressResponse = decompressResponse;
    var util_1 = require("util");
    var zlib = require("zlib");
    var constants_1 = require_constants4();
    var deps_1 = require_deps();
    var error_1 = require_error();
    var commands_1 = require_commands();
    var constants_2 = require_constants3();
    exports2.Compressor = Object.freeze({
      none: 0,
      snappy: 1,
      zlib: 2,
      zstd: 3
    });
    exports2.uncompressibleCommands = /* @__PURE__ */ new Set([
      constants_1.LEGACY_HELLO_COMMAND,
      "saslStart",
      "saslContinue",
      "getnonce",
      "authenticate",
      "createUser",
      "updateUser",
      "copydbSaslStart",
      "copydbgetnonce",
      "copydb"
    ]);
    var ZSTD_COMPRESSION_LEVEL = 3;
    var zlibInflate = (0, util_1.promisify)(zlib.inflate.bind(zlib));
    var zlibDeflate = (0, util_1.promisify)(zlib.deflate.bind(zlib));
    var zstd;
    var Snappy = null;
    function loadSnappy() {
      if (Snappy == null) {
        const snappyImport = (0, deps_1.getSnappy)();
        if ("kModuleError" in snappyImport) {
          throw snappyImport.kModuleError;
        }
        Snappy = snappyImport;
      }
      return Snappy;
    }
    async function compress(options2, dataToBeCompressed) {
      const zlibOptions = {};
      switch (options2.agreedCompressor) {
        case "snappy": {
          Snappy ??= loadSnappy();
          return await Snappy.compress(dataToBeCompressed);
        }
        case "zstd": {
          loadZstd();
          if ("kModuleError" in zstd) {
            throw zstd["kModuleError"];
          }
          return await zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);
        }
        case "zlib": {
          if (options2.zlibCompressionLevel) {
            zlibOptions.level = options2.zlibCompressionLevel;
          }
          return await zlibDeflate(dataToBeCompressed, zlibOptions);
        }
        default: {
          throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${options2.agreedCompressor} failed to compress`);
        }
      }
    }
    async function decompress(compressorID, compressedData) {
      if (compressorID !== exports2.Compressor.snappy && compressorID !== exports2.Compressor.zstd && compressorID !== exports2.Compressor.zlib && compressorID !== exports2.Compressor.none) {
        throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);
      }
      switch (compressorID) {
        case exports2.Compressor.snappy: {
          Snappy ??= loadSnappy();
          return await Snappy.uncompress(compressedData, { asBuffer: true });
        }
        case exports2.Compressor.zstd: {
          loadZstd();
          if ("kModuleError" in zstd) {
            throw zstd["kModuleError"];
          }
          return await zstd.decompress(compressedData);
        }
        case exports2.Compressor.zlib: {
          return await zlibInflate(compressedData);
        }
        default: {
          return compressedData;
        }
      }
    }
    function loadZstd() {
      if (!zstd) {
        zstd = (0, deps_1.getZstdLibrary)();
      }
    }
    var MESSAGE_HEADER_SIZE = 16;
    async function compressCommand(command, description) {
      const finalCommand = description.agreedCompressor === "none" || !commands_1.OpCompressedRequest.canCompress(command) ? command : new commands_1.OpCompressedRequest(command, {
        agreedCompressor: description.agreedCompressor ?? "none",
        zlibCompressionLevel: description.zlibCompressionLevel ?? 0
      });
      const data = await finalCommand.toBin();
      return Buffer.concat(data);
    }
    async function decompressResponse(message) {
      const messageHeader = {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
      if (messageHeader.opCode !== constants_2.OP_COMPRESSED) {
        const ResponseType2 = messageHeader.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpReply;
        const messageBody2 = message.subarray(MESSAGE_HEADER_SIZE);
        return new ResponseType2(message, messageHeader, messageBody2);
      }
      const header = {
        ...messageHeader,
        fromCompressed: true,
        opCode: message.readInt32LE(MESSAGE_HEADER_SIZE),
        length: message.readInt32LE(MESSAGE_HEADER_SIZE + 4)
      };
      const compressorID = message[MESSAGE_HEADER_SIZE + 8];
      const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
      const ResponseType = header.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpReply;
      const messageBody = await decompress(compressorID, compressedBuffer);
      if (messageBody.length !== header.length) {
        throw new error_1.MongoDecompressionError("Message body and message header must be the same length");
      }
      return new ResponseType(message, header, messageBody);
    }
  }
});

// node_modules/mongodb/lib/client-side-encryption/crypto_callbacks.js
var require_crypto_callbacks = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/crypto_callbacks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hmacSha256Hook = exports2.hmacSha512Hook = exports2.aes256CtrDecryptHook = exports2.aes256CtrEncryptHook = exports2.aes256CbcDecryptHook = exports2.aes256CbcEncryptHook = void 0;
    exports2.makeAES256Hook = makeAES256Hook;
    exports2.randomHook = randomHook;
    exports2.sha256Hook = sha256Hook;
    exports2.makeHmacHook = makeHmacHook;
    exports2.signRsaSha256Hook = signRsaSha256Hook;
    var crypto = require("crypto");
    function makeAES256Hook(method, mode) {
      return function(key, iv, input, output) {
        let result;
        try {
          const cipher = crypto[method](mode, key, iv);
          cipher.setAutoPadding(false);
          result = cipher.update(input);
          const final = cipher.final();
          if (final.length > 0) {
            result = Buffer.concat([result, final]);
          }
        } catch (e) {
          return e;
        }
        result.copy(output);
        return result.length;
      };
    }
    function randomHook(buffer, count) {
      try {
        crypto.randomFillSync(buffer, 0, count);
      } catch (e) {
        return e;
      }
      return count;
    }
    function sha256Hook(input, output) {
      let result;
      try {
        result = crypto.createHash("sha256").update(input).digest();
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    function makeHmacHook(algorithm) {
      return (key, input, output) => {
        let result;
        try {
          result = crypto.createHmac(algorithm, key).update(input).digest();
        } catch (e) {
          return e;
        }
        result.copy(output);
        return result.length;
      };
    }
    function signRsaSha256Hook(key, input, output) {
      let result;
      try {
        const signer = crypto.createSign("sha256WithRSAEncryption");
        const privateKey = Buffer.from(`-----BEGIN PRIVATE KEY-----
${key.toString("base64")}
-----END PRIVATE KEY-----
`);
        result = signer.update(input).end().sign(privateKey);
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    exports2.aes256CbcEncryptHook = makeAES256Hook("createCipheriv", "aes-256-cbc");
    exports2.aes256CbcDecryptHook = makeAES256Hook("createDecipheriv", "aes-256-cbc");
    exports2.aes256CtrEncryptHook = makeAES256Hook("createCipheriv", "aes-256-ctr");
    exports2.aes256CtrDecryptHook = makeAES256Hook("createDecipheriv", "aes-256-ctr");
    exports2.hmacSha512Hook = makeHmacHook("sha512");
    exports2.hmacSha256Hook = makeHmacHook("sha256");
  }
});

// node_modules/mongodb/lib/client-side-encryption/errors.js
var require_errors3 = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoCryptKMSRequestNetworkTimeoutError = exports2.MongoCryptAzureKMSRequestError = exports2.MongoCryptCreateEncryptedCollectionError = exports2.MongoCryptCreateDataKeyError = exports2.MongoCryptInvalidArgumentError = exports2.MongoCryptError = void 0;
    var error_1 = require_error();
    var MongoCryptError = class extends error_1.MongoError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options2 = {}) {
        super(message, options2);
      }
      get name() {
        return "MongoCryptError";
      }
    };
    exports2.MongoCryptError = MongoCryptError;
    var MongoCryptInvalidArgumentError = class extends MongoCryptError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoCryptInvalidArgumentError";
      }
    };
    exports2.MongoCryptInvalidArgumentError = MongoCryptInvalidArgumentError;
    var MongoCryptCreateDataKeyError = class extends MongoCryptError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(encryptedFields, { cause }) {
        super(`Unable to complete creating data keys: ${cause.message}`, { cause });
        this.encryptedFields = encryptedFields;
      }
      get name() {
        return "MongoCryptCreateDataKeyError";
      }
    };
    exports2.MongoCryptCreateDataKeyError = MongoCryptCreateDataKeyError;
    var MongoCryptCreateEncryptedCollectionError = class extends MongoCryptError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(encryptedFields, { cause }) {
        super(`Unable to create collection: ${cause.message}`, { cause });
        this.encryptedFields = encryptedFields;
      }
      get name() {
        return "MongoCryptCreateEncryptedCollectionError";
      }
    };
    exports2.MongoCryptCreateEncryptedCollectionError = MongoCryptCreateEncryptedCollectionError;
    var MongoCryptAzureKMSRequestError = class extends MongoCryptError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, body) {
        super(message);
        this.body = body;
      }
      get name() {
        return "MongoCryptAzureKMSRequestError";
      }
    };
    exports2.MongoCryptAzureKMSRequestError = MongoCryptAzureKMSRequestError;
    var MongoCryptKMSRequestNetworkTimeoutError = class extends MongoCryptError {
      get name() {
        return "MongoCryptKMSRequestNetworkTimeoutError";
      }
    };
    exports2.MongoCryptKMSRequestNetworkTimeoutError = MongoCryptKMSRequestNetworkTimeoutError;
  }
});

// node_modules/mongodb/lib/cmap/auth/aws_temporary_credentials.js
var require_aws_temporary_credentials = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/aws_temporary_credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LegacyAWSTemporaryCredentialProvider = exports2.AWSSDKCredentialProvider = exports2.AWSTemporaryCredentialProvider = void 0;
    var deps_1 = require_deps();
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var AWS_RELATIVE_URI = "http://169.254.170.2";
    var AWS_EC2_URI = "http://169.254.169.254";
    var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";
    var AWSTemporaryCredentialProvider = class _AWSTemporaryCredentialProvider {
      static get awsSDK() {
        _AWSTemporaryCredentialProvider._awsSDK ??= (0, deps_1.getAwsCredentialProvider)();
        return _AWSTemporaryCredentialProvider._awsSDK;
      }
      static get isAWSSDKInstalled() {
        return !("kModuleError" in _AWSTemporaryCredentialProvider.awsSDK);
      }
    };
    exports2.AWSTemporaryCredentialProvider = AWSTemporaryCredentialProvider;
    var AWSSDKCredentialProvider = class extends AWSTemporaryCredentialProvider {
      /**
       * Create the SDK credentials provider.
       * @param credentialsProvider - The credentials provider.
       */
      constructor(credentialsProvider) {
        super();
        if (credentialsProvider) {
          this._provider = credentialsProvider;
        }
      }
      /**
       * The AWS SDK caches credentials automatically and handles refresh when the credentials have expired.
       * To ensure this occurs, we need to cache the `provider` returned by the AWS sdk and re-use it when fetching credentials.
       */
      get provider() {
        if ("kModuleError" in AWSTemporaryCredentialProvider.awsSDK) {
          throw AWSTemporaryCredentialProvider.awsSDK.kModuleError;
        }
        if (this._provider) {
          return this._provider;
        }
        let { AWS_STS_REGIONAL_ENDPOINTS = "", AWS_REGION = "" } = process.env;
        AWS_STS_REGIONAL_ENDPOINTS = AWS_STS_REGIONAL_ENDPOINTS.toLowerCase();
        AWS_REGION = AWS_REGION.toLowerCase();
        const awsRegionSettingsExist = AWS_REGION.length !== 0 && AWS_STS_REGIONAL_ENDPOINTS.length !== 0;
        const LEGACY_REGIONS = /* @__PURE__ */ new Set([
          "ap-northeast-1",
          "ap-south-1",
          "ap-southeast-1",
          "ap-southeast-2",
          "aws-global",
          "ca-central-1",
          "eu-central-1",
          "eu-north-1",
          "eu-west-1",
          "eu-west-2",
          "eu-west-3",
          "sa-east-1",
          "us-east-1",
          "us-east-2",
          "us-west-1",
          "us-west-2"
        ]);
        const useRegionalSts = AWS_STS_REGIONAL_ENDPOINTS === "regional" || AWS_STS_REGIONAL_ENDPOINTS === "legacy" && !LEGACY_REGIONS.has(AWS_REGION);
        this._provider = awsRegionSettingsExist && useRegionalSts ? AWSTemporaryCredentialProvider.awsSDK.fromNodeProviderChain({
          clientConfig: { region: AWS_REGION }
        }) : AWSTemporaryCredentialProvider.awsSDK.fromNodeProviderChain();
        return this._provider;
      }
      async getCredentials() {
        try {
          const creds = await this.provider();
          return {
            AccessKeyId: creds.accessKeyId,
            SecretAccessKey: creds.secretAccessKey,
            Token: creds.sessionToken,
            Expiration: creds.expiration
          };
        } catch (error2) {
          throw new error_1.MongoAWSError(error2.message, { cause: error2 });
        }
      }
    };
    exports2.AWSSDKCredentialProvider = AWSSDKCredentialProvider;
    var LegacyAWSTemporaryCredentialProvider = class extends AWSTemporaryCredentialProvider {
      async getCredentials() {
        if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
          return await (0, utils_1.request)(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`);
        }
        const token = await (0, utils_1.request)(`${AWS_EC2_URI}/latest/api/token`, {
          method: "PUT",
          json: false,
          headers: { "X-aws-ec2-metadata-token-ttl-seconds": 30 }
        });
        const roleName = await (0, utils_1.request)(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {
          json: false,
          headers: { "X-aws-ec2-metadata-token": token }
        });
        const creds = await (0, utils_1.request)(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {
          headers: { "X-aws-ec2-metadata-token": token }
        });
        return creds;
      }
    };
    exports2.LegacyAWSTemporaryCredentialProvider = LegacyAWSTemporaryCredentialProvider;
  }
});

// node_modules/mongodb/lib/client-side-encryption/providers/aws.js
var require_aws = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/providers/aws.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadAWSCredentials = loadAWSCredentials;
    var aws_temporary_credentials_1 = require_aws_temporary_credentials();
    async function loadAWSCredentials(kmsProviders, provider) {
      const credentialProvider = new aws_temporary_credentials_1.AWSSDKCredentialProvider(provider);
      const { SecretAccessKey = "", AccessKeyId = "", Token } = await credentialProvider.getCredentials();
      const aws = {
        secretAccessKey: SecretAccessKey,
        accessKeyId: AccessKeyId
      };
      Token != null && (aws.sessionToken = Token);
      return { ...kmsProviders, aws };
    }
  }
});

// node_modules/mongodb/lib/client-side-encryption/providers/azure.js
var require_azure = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/providers/azure.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenCache = exports2.AzureCredentialCache = exports2.AZURE_BASE_URL = void 0;
    exports2.addAzureParams = addAzureParams;
    exports2.prepareRequest = prepareRequest;
    exports2.fetchAzureKMSToken = fetchAzureKMSToken;
    exports2.loadAzureCredentials = loadAzureCredentials;
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var errors_1 = require_errors3();
    var MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS = 6e3;
    exports2.AZURE_BASE_URL = "http://169.254.169.254/metadata/identity/oauth2/token?";
    var AzureCredentialCache = class {
      constructor() {
        this.cachedToken = null;
      }
      async getToken() {
        if (this.cachedToken == null || this.needsRefresh(this.cachedToken)) {
          this.cachedToken = await this._getToken();
        }
        return { accessToken: this.cachedToken.accessToken };
      }
      needsRefresh(token) {
        const timeUntilExpirationMS = token.expiresOnTimestamp - Date.now();
        return timeUntilExpirationMS <= MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS;
      }
      /**
       * exposed for testing
       */
      resetCache() {
        this.cachedToken = null;
      }
      /**
       * exposed for testing
       */
      _getToken() {
        return fetchAzureKMSToken();
      }
    };
    exports2.AzureCredentialCache = AzureCredentialCache;
    exports2.tokenCache = new AzureCredentialCache();
    async function parseResponse(response) {
      const { status, body: rawBody } = response;
      const body = (() => {
        try {
          return JSON.parse(rawBody);
        } catch {
          throw new errors_1.MongoCryptAzureKMSRequestError("Malformed JSON body in GET request.");
        }
      })();
      if (status !== 200) {
        throw new errors_1.MongoCryptAzureKMSRequestError("Unable to complete request.", body);
      }
      if (!body.access_token) {
        throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - missing field `access_token`.");
      }
      if (!body.expires_in) {
        throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - missing field `expires_in`.");
      }
      const expiresInMS = Number(body.expires_in) * 1e3;
      if (Number.isNaN(expiresInMS)) {
        throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - unable to parse int from `expires_in` field.");
      }
      return {
        accessToken: body.access_token,
        expiresOnTimestamp: Date.now() + expiresInMS
      };
    }
    function addAzureParams(url, resource, username) {
      url.searchParams.append("api-version", "2018-02-01");
      url.searchParams.append("resource", resource);
      if (username) {
        url.searchParams.append("client_id", username);
      }
      return url;
    }
    function prepareRequest(options2) {
      const url = new URL(options2.url?.toString() ?? exports2.AZURE_BASE_URL);
      addAzureParams(url, "https://vault.azure.net");
      const headers = { ...options2.headers, "Content-Type": "application/json", Metadata: true };
      return { headers, url };
    }
    async function fetchAzureKMSToken(options2 = {}) {
      const { headers, url } = prepareRequest(options2);
      try {
        const response = await (0, utils_1.get)(url, { headers });
        return await parseResponse(response);
      } catch (error2) {
        if (error2 instanceof error_1.MongoNetworkTimeoutError) {
          throw new errors_1.MongoCryptAzureKMSRequestError(`[Azure KMS] ${error2.message}`);
        }
        throw error2;
      }
    }
    async function loadAzureCredentials(kmsProviders) {
      const azure = await exports2.tokenCache.getToken();
      return { ...kmsProviders, azure };
    }
  }
});

// node_modules/mongodb/lib/client-side-encryption/providers/gcp.js
var require_gcp = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/providers/gcp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadGCPCredentials = loadGCPCredentials;
    var deps_1 = require_deps();
    async function loadGCPCredentials(kmsProviders) {
      const gcpMetadata = (0, deps_1.getGcpMetadata)();
      if ("kModuleError" in gcpMetadata) {
        return kmsProviders;
      }
      const { access_token: accessToken } = await gcpMetadata.instance({
        property: "service-accounts/default/token"
      });
      return { ...kmsProviders, gcp: { accessToken } };
    }
  }
});

// node_modules/mongodb/lib/client-side-encryption/providers/index.js
var require_providers2 = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/providers/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmptyCredentials = isEmptyCredentials;
    exports2.refreshKMSCredentials = refreshKMSCredentials;
    var aws_1 = require_aws();
    var azure_1 = require_azure();
    var gcp_1 = require_gcp();
    function isEmptyCredentials(providerName, kmsProviders) {
      const provider = kmsProviders[providerName];
      if (provider == null) {
        return false;
      }
      return typeof provider === "object" && Object.keys(provider).length === 0;
    }
    async function refreshKMSCredentials(kmsProviders, credentialProviders) {
      let finalKMSProviders = kmsProviders;
      if (isEmptyCredentials("aws", kmsProviders)) {
        finalKMSProviders = await (0, aws_1.loadAWSCredentials)(finalKMSProviders, credentialProviders?.aws);
      }
      if (isEmptyCredentials("gcp", kmsProviders)) {
        finalKMSProviders = await (0, gcp_1.loadGCPCredentials)(finalKMSProviders);
      }
      if (isEmptyCredentials("azure", kmsProviders)) {
        finalKMSProviders = await (0, azure_1.loadAzureCredentials)(finalKMSProviders);
      }
      return finalKMSProviders;
    }
  }
});

// node_modules/mongodb/lib/client-side-encryption/state_machine.js
var require_state_machine = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/state_machine.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StateMachine = void 0;
    var fs = require("fs/promises");
    var net = require("net");
    var tls = require("tls");
    var bson_1 = require_bson2();
    var abstract_cursor_1 = require_abstract_cursor();
    var deps_1 = require_deps();
    var error_1 = require_error();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils5();
    var client_encryption_1 = require_client_encryption();
    var errors_1 = require_errors3();
    var socks = null;
    function loadSocks() {
      if (socks == null) {
        const socksImport = (0, deps_1.getSocks)();
        if ("kModuleError" in socksImport) {
          throw socksImport.kModuleError;
        }
        socks = socksImport;
      }
      return socks;
    }
    var MONGOCRYPT_CTX_ERROR = 0;
    var MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;
    var MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;
    var MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;
    var MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS = 7;
    var MONGOCRYPT_CTX_NEED_KMS = 4;
    var MONGOCRYPT_CTX_READY = 5;
    var MONGOCRYPT_CTX_DONE = 6;
    var HTTPS_PORT = 443;
    var stateToString = /* @__PURE__ */ new Map([
      [MONGOCRYPT_CTX_ERROR, "MONGOCRYPT_CTX_ERROR"],
      [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, "MONGOCRYPT_CTX_NEED_MONGO_COLLINFO"],
      [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, "MONGOCRYPT_CTX_NEED_MONGO_MARKINGS"],
      [MONGOCRYPT_CTX_NEED_MONGO_KEYS, "MONGOCRYPT_CTX_NEED_MONGO_KEYS"],
      [MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS, "MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS"],
      [MONGOCRYPT_CTX_NEED_KMS, "MONGOCRYPT_CTX_NEED_KMS"],
      [MONGOCRYPT_CTX_READY, "MONGOCRYPT_CTX_READY"],
      [MONGOCRYPT_CTX_DONE, "MONGOCRYPT_CTX_DONE"]
    ]);
    var INSECURE_TLS_OPTIONS = [
      "tlsInsecure",
      "tlsAllowInvalidCertificates",
      "tlsAllowInvalidHostnames",
      // These options are disallowed by the spec, so we explicitly filter them out if provided, even
      // though the StateMachine does not declare support for these options.
      "tlsDisableOCSPEndpointCheck",
      "tlsDisableCertificateRevocationCheck"
    ];
    function debug(msg) {
      if (process.env.MONGODB_CRYPT_DEBUG) {
        console.error(msg);
      }
    }
    var EMPTY_V;
    var StateMachine = class {
      constructor(options2, bsonOptions = (0, bson_1.pluckBSONSerializeOptions)(options2)) {
        this.options = options2;
        this.bsonOptions = bsonOptions;
      }
      /**
       * Executes the state machine according to the specification
       */
      async execute(executor, context, options2) {
        const keyVaultNamespace = executor._keyVaultNamespace;
        const keyVaultClient = executor._keyVaultClient;
        const metaDataClient = executor._metaDataClient;
        const mongocryptdClient = executor._mongocryptdClient;
        const mongocryptdManager = executor._mongocryptdManager;
        let result = null;
        const getStatus = () => context.status;
        const getState = () => context.state;
        while (getState() !== MONGOCRYPT_CTX_DONE && getState() !== MONGOCRYPT_CTX_ERROR) {
          options2.signal?.throwIfAborted();
          debug(`[context#${context.id}] ${stateToString.get(getState()) || getState()}`);
          switch (getState()) {
            case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {
              const filter = (0, bson_1.deserialize)(context.nextMongoOperation());
              if (!metaDataClient) {
                throw new errors_1.MongoCryptError("unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_COLLINFO but metadata client is undefined");
              }
              const collInfoCursor = this.fetchCollectionInfo(metaDataClient, context.ns, filter, options2);
              for await (const collInfo of collInfoCursor) {
                context.addMongoOperationResponse((0, bson_1.serialize)(collInfo));
                if (getState() === MONGOCRYPT_CTX_ERROR)
                  break;
              }
              if (getState() === MONGOCRYPT_CTX_ERROR)
                break;
              context.finishMongoOperation();
              break;
            }
            case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: {
              const command = context.nextMongoOperation();
              if (getState() === MONGOCRYPT_CTX_ERROR)
                break;
              if (!mongocryptdClient) {
                throw new errors_1.MongoCryptError("unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_MARKINGS but mongocryptdClient is undefined");
              }
              const markedCommand = mongocryptdManager ? await mongocryptdManager.withRespawn(this.markCommand.bind(this, mongocryptdClient, context.ns, command, options2)) : await this.markCommand(mongocryptdClient, context.ns, command, options2);
              context.addMongoOperationResponse(markedCommand);
              context.finishMongoOperation();
              break;
            }
            case MONGOCRYPT_CTX_NEED_MONGO_KEYS: {
              const filter = context.nextMongoOperation();
              const keys = await this.fetchKeys(keyVaultClient, keyVaultNamespace, filter, options2);
              if (keys.length === 0) {
                result = EMPTY_V ??= (0, bson_1.serialize)({ v: [] });
              }
              for (const key of keys) {
                context.addMongoOperationResponse((0, bson_1.serialize)(key));
              }
              context.finishMongoOperation();
              break;
            }
            case MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS: {
              const kmsProviders = await executor.askForKMSCredentials();
              context.provideKMSProviders((0, bson_1.serialize)(kmsProviders));
              break;
            }
            case MONGOCRYPT_CTX_NEED_KMS: {
              await Promise.all(this.requests(context, options2));
              context.finishKMSRequests();
              break;
            }
            case MONGOCRYPT_CTX_READY: {
              const finalizedContext = context.finalize();
              if (getState() === MONGOCRYPT_CTX_ERROR) {
                const message = getStatus().message || "Finalization error";
                throw new errors_1.MongoCryptError(message);
              }
              result = finalizedContext;
              break;
            }
            default:
              throw new errors_1.MongoCryptError(`Unknown state: ${getState()}`);
          }
        }
        if (getState() === MONGOCRYPT_CTX_ERROR || result == null) {
          const message = getStatus().message;
          if (!message) {
            debug(`unidentifiable error in MongoCrypt - received an error status from \`libmongocrypt\` but received no error message.`);
          }
          throw new errors_1.MongoCryptError(message ?? "unidentifiable error in MongoCrypt - received an error status from `libmongocrypt` but received no error message.");
        }
        return result;
      }
      /**
       * Handles the request to the KMS service. Exposed for testing purposes. Do not directly invoke.
       * @param kmsContext - A C++ KMS context returned from the bindings
       * @returns A promise that resolves when the KMS reply has be fully parsed
       */
      async kmsRequest(request2, options2) {
        const parsedUrl = request2.endpoint.split(":");
        const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;
        const socketOptions = {
          host: parsedUrl[0],
          servername: parsedUrl[0],
          port,
          ...(0, client_encryption_1.autoSelectSocketOptions)(this.options.socketOptions || {})
        };
        const message = request2.message;
        const buffer = new utils_1.BufferPool();
        let netSocket;
        let socket;
        function destroySockets() {
          for (const sock of [socket, netSocket]) {
            if (sock) {
              sock.destroy();
            }
          }
        }
        function onerror(cause) {
          return new errors_1.MongoCryptError("KMS request failed", { cause });
        }
        function onclose() {
          return new errors_1.MongoCryptError("KMS request closed");
        }
        const tlsOptions = this.options.tlsOptions;
        if (tlsOptions) {
          const kmsProvider = request2.kmsProvider;
          const providerTlsOptions = tlsOptions[kmsProvider];
          if (providerTlsOptions) {
            const error2 = this.validateTlsOptions(kmsProvider, providerTlsOptions);
            if (error2) {
              throw error2;
            }
            try {
              await this.setTlsOptions(providerTlsOptions, socketOptions);
            } catch (err) {
              throw onerror(err);
            }
          }
        }
        let abortListener;
        try {
          if (this.options.proxyOptions && this.options.proxyOptions.proxyHost) {
            netSocket = new net.Socket();
            const { promise: willConnect, reject: rejectOnNetSocketError, resolve: resolveOnNetSocketConnect } = (0, utils_1.promiseWithResolvers)();
            netSocket.once("error", (err) => rejectOnNetSocketError(onerror(err))).once("close", () => rejectOnNetSocketError(onclose())).once("connect", () => resolveOnNetSocketConnect());
            const netSocketOptions = {
              ...socketOptions,
              host: this.options.proxyOptions.proxyHost,
              port: this.options.proxyOptions.proxyPort || 1080
            };
            netSocket.connect(netSocketOptions);
            await willConnect;
            try {
              socks ??= loadSocks();
              socketOptions.socket = (await socks.SocksClient.createConnection({
                existing_socket: netSocket,
                command: "connect",
                destination: { host: socketOptions.host, port: socketOptions.port },
                proxy: {
                  // host and port are ignored because we pass existing_socket
                  host: "iLoveJavaScript",
                  port: 0,
                  type: 5,
                  userId: this.options.proxyOptions.proxyUsername,
                  password: this.options.proxyOptions.proxyPassword
                }
              })).socket;
            } catch (err) {
              throw onerror(err);
            }
          }
          socket = tls.connect(socketOptions, () => {
            socket.write(message);
          });
          const { promise: willResolveKmsRequest, reject: rejectOnTlsSocketError, resolve } = (0, utils_1.promiseWithResolvers)();
          abortListener = (0, utils_1.addAbortListener)(options2?.signal, function() {
            destroySockets();
            rejectOnTlsSocketError(this.reason);
          });
          socket.once("error", (err) => rejectOnTlsSocketError(onerror(err))).once("close", () => rejectOnTlsSocketError(onclose())).on("data", (data) => {
            buffer.append(data);
            while (request2.bytesNeeded > 0 && buffer.length) {
              const bytesNeeded = Math.min(request2.bytesNeeded, buffer.length);
              request2.addResponse(buffer.read(bytesNeeded));
            }
            if (request2.bytesNeeded <= 0) {
              resolve();
            }
          });
          await (options2?.timeoutContext?.csotEnabled() ? Promise.all([
            willResolveKmsRequest,
            timeout_1.Timeout.expires(options2.timeoutContext?.remainingTimeMS)
          ]) : willResolveKmsRequest);
        } catch (error2) {
          if (error2 instanceof timeout_1.TimeoutError)
            throw new error_1.MongoOperationTimeoutError("KMS request timed out");
          throw error2;
        } finally {
          destroySockets();
          abortListener?.[utils_1.kDispose]();
        }
      }
      *requests(context, options2) {
        for (let request2 = context.nextKMSRequest(); request2 != null; request2 = context.nextKMSRequest()) {
          yield this.kmsRequest(request2, options2);
        }
      }
      /**
       * Validates the provided TLS options are secure.
       *
       * @param kmsProvider - The KMS provider name.
       * @param tlsOptions - The client TLS options for the provider.
       *
       * @returns An error if any option is invalid.
       */
      validateTlsOptions(kmsProvider, tlsOptions) {
        const tlsOptionNames = Object.keys(tlsOptions);
        for (const option of INSECURE_TLS_OPTIONS) {
          if (tlsOptionNames.includes(option)) {
            return new errors_1.MongoCryptError(`Insecure TLS options prohibited for ${kmsProvider}: ${option}`);
          }
        }
      }
      /**
       * Sets only the valid secure TLS options.
       *
       * @param tlsOptions - The client TLS options for the provider.
       * @param options - The existing connection options.
       */
      async setTlsOptions(tlsOptions, options2) {
        if (tlsOptions.tlsCertificateKeyFile) {
          const cert = await fs.readFile(tlsOptions.tlsCertificateKeyFile);
          options2.cert = options2.key = cert;
        }
        if (tlsOptions.tlsCAFile) {
          options2.ca = await fs.readFile(tlsOptions.tlsCAFile);
        }
        if (tlsOptions.tlsCertificateKeyFilePassword) {
          options2.passphrase = tlsOptions.tlsCertificateKeyFilePassword;
        }
      }
      /**
       * Fetches collection info for a provided namespace, when libmongocrypt
       * enters the `MONGOCRYPT_CTX_NEED_MONGO_COLLINFO` state. The result is
       * used to inform libmongocrypt of the schema associated with this
       * namespace. Exposed for testing purposes. Do not directly invoke.
       *
       * @param client - A MongoClient connected to the topology
       * @param ns - The namespace to list collections from
       * @param filter - A filter for the listCollections command
       * @param callback - Invoked with the info of the requested collection, or with an error
       */
      fetchCollectionInfo(client, ns, filter, options2) {
        const { db } = utils_1.MongoDBCollectionNamespace.fromString(ns);
        const cursor = client.db(db).listCollections(filter, {
          promoteLongs: false,
          promoteValues: false,
          timeoutContext: options2?.timeoutContext && new abstract_cursor_1.CursorTimeoutContext(options2?.timeoutContext, Symbol()),
          signal: options2?.signal,
          nameOnly: false
        });
        return cursor;
      }
      /**
       * Calls to the mongocryptd to provide markings for a command.
       * Exposed for testing purposes. Do not directly invoke.
       * @param client - A MongoClient connected to a mongocryptd
       * @param ns - The namespace (database.collection) the command is being executed on
       * @param command - The command to execute.
       * @param callback - Invoked with the serialized and marked bson command, or with an error
       */
      async markCommand(client, ns, command, options2) {
        const { db } = utils_1.MongoDBCollectionNamespace.fromString(ns);
        const bsonOptions = { promoteLongs: false, promoteValues: false };
        const rawCommand = (0, bson_1.deserialize)(command, bsonOptions);
        const commandOptions = {
          timeoutMS: void 0,
          signal: void 0
        };
        if (options2?.timeoutContext?.csotEnabled()) {
          commandOptions.timeoutMS = options2.timeoutContext.remainingTimeMS;
        }
        if (options2?.signal) {
          commandOptions.signal = options2.signal;
        }
        const response = await client.db(db).command(rawCommand, {
          ...bsonOptions,
          ...commandOptions
        });
        return (0, bson_1.serialize)(response, this.bsonOptions);
      }
      /**
       * Requests keys from the keyVault collection on the topology.
       * Exposed for testing purposes. Do not directly invoke.
       * @param client - A MongoClient connected to the topology
       * @param keyVaultNamespace - The namespace (database.collection) of the keyVault Collection
       * @param filter - The filter for the find query against the keyVault Collection
       * @param callback - Invoked with the found keys, or with an error
       */
      fetchKeys(client, keyVaultNamespace, filter, options2) {
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(keyVaultNamespace);
        const commandOptions = {
          timeoutContext: void 0,
          signal: void 0
        };
        if (options2?.timeoutContext != null) {
          commandOptions.timeoutContext = new abstract_cursor_1.CursorTimeoutContext(options2.timeoutContext, Symbol());
        }
        if (options2?.signal != null) {
          commandOptions.signal = options2.signal;
        }
        return client.db(dbName).collection(collectionName, { readConcern: { level: "majority" } }).find((0, bson_1.deserialize)(filter), commandOptions).toArray();
      }
    };
    exports2.StateMachine = StateMachine;
  }
});

// node_modules/mongodb/lib/client-side-encryption/client_encryption.js
var require_client_encryption = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/client_encryption.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientEncryption = void 0;
    exports2.autoSelectSocketOptions = autoSelectSocketOptions;
    var bson_1 = require_bson2();
    var deps_1 = require_deps();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils5();
    var cryptoCallbacks = require_crypto_callbacks();
    var errors_1 = require_errors3();
    var index_1 = require_providers2();
    var state_machine_1 = require_state_machine();
    var ClientEncryption = class _ClientEncryption {
      /** @internal */
      static getMongoCrypt() {
        const encryption = (0, deps_1.getMongoDBClientEncryption)();
        if ("kModuleError" in encryption) {
          throw encryption.kModuleError;
        }
        return encryption.MongoCrypt;
      }
      /**
       * Create a new encryption instance
       *
       * @example
       * ```ts
       * new ClientEncryption(mongoClient, {
       *   keyVaultNamespace: 'client.encryption',
       *   kmsProviders: {
       *     local: {
       *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer
       *     }
       *   }
       * });
       * ```
       *
       * @example
       * ```ts
       * new ClientEncryption(mongoClient, {
       *   keyVaultNamespace: 'client.encryption',
       *   kmsProviders: {
       *     aws: {
       *       accessKeyId: AWS_ACCESS_KEY,
       *       secretAccessKey: AWS_SECRET_KEY
       *     }
       *   }
       * });
       * ```
       */
      constructor(client, options2) {
        this._client = client;
        this._proxyOptions = options2.proxyOptions ?? {};
        this._tlsOptions = options2.tlsOptions ?? {};
        this._kmsProviders = options2.kmsProviders || {};
        const { timeoutMS } = (0, utils_1.resolveTimeoutOptions)(client, options2);
        this._timeoutMS = timeoutMS;
        this._credentialProviders = options2.credentialProviders;
        if (options2.credentialProviders?.aws && !(0, index_1.isEmptyCredentials)("aws", this._kmsProviders)) {
          throw new errors_1.MongoCryptInvalidArgumentError("Can only provide a custom AWS credential provider when the state machine is configured for automatic AWS credential fetching");
        }
        if (options2.keyVaultNamespace == null) {
          throw new errors_1.MongoCryptInvalidArgumentError("Missing required option `keyVaultNamespace`");
        }
        const mongoCryptOptions = {
          ...options2,
          cryptoCallbacks,
          kmsProviders: !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders
        };
        this._keyVaultNamespace = options2.keyVaultNamespace;
        this._keyVaultClient = options2.keyVaultClient || client;
        const MongoCrypt = _ClientEncryption.getMongoCrypt();
        this._mongoCrypt = new MongoCrypt(mongoCryptOptions);
      }
      /**
       * Creates a data key used for explicit encryption and inserts it into the key vault namespace
       *
       * @example
       * ```ts
       * // Using async/await to create a local key
       * const dataKeyId = await clientEncryption.createDataKey('local');
       * ```
       *
       * @example
       * ```ts
       * // Using async/await to create an aws key
       * const dataKeyId = await clientEncryption.createDataKey('aws', {
       *   masterKey: {
       *     region: 'us-east-1',
       *     key: 'xxxxxxxxxxxxxx' // CMK ARN here
       *   }
       * });
       * ```
       *
       * @example
       * ```ts
       * // Using async/await to create an aws key with a keyAltName
       * const dataKeyId = await clientEncryption.createDataKey('aws', {
       *   masterKey: {
       *     region: 'us-east-1',
       *     key: 'xxxxxxxxxxxxxx' // CMK ARN here
       *   },
       *   keyAltNames: [ 'mySpecialKey' ]
       * });
       * ```
       */
      async createDataKey(provider, options2 = {}) {
        if (options2.keyAltNames && !Array.isArray(options2.keyAltNames)) {
          throw new errors_1.MongoCryptInvalidArgumentError(`Option "keyAltNames" must be an array of strings, but was of type ${typeof options2.keyAltNames}.`);
        }
        let keyAltNames = void 0;
        if (options2.keyAltNames && options2.keyAltNames.length > 0) {
          keyAltNames = options2.keyAltNames.map((keyAltName, i) => {
            if (typeof keyAltName !== "string") {
              throw new errors_1.MongoCryptInvalidArgumentError(`Option "keyAltNames" must be an array of strings, but item at index ${i} was of type ${typeof keyAltName}`);
            }
            return (0, bson_1.serialize)({ keyAltName });
          });
        }
        let keyMaterial = void 0;
        if (options2.keyMaterial) {
          keyMaterial = (0, bson_1.serialize)({ keyMaterial: options2.keyMaterial });
        }
        const dataKeyBson = (0, bson_1.serialize)({
          provider,
          ...options2.masterKey
        });
        const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, {
          keyAltNames,
          keyMaterial
        });
        const stateMachine = new state_machine_1.StateMachine({
          proxyOptions: this._proxyOptions,
          tlsOptions: this._tlsOptions,
          socketOptions: autoSelectSocketOptions(this._client.s.options)
        });
        const timeoutContext = options2?.timeoutContext ?? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS }));
        const dataKey = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        const { insertedId } = await this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey, {
          writeConcern: { w: "majority" },
          timeoutMS: timeoutContext?.csotEnabled() ? timeoutContext?.getRemainingTimeMSOrThrow() : void 0
        });
        return insertedId;
      }
      /**
       * Searches the keyvault for any data keys matching the provided filter.  If there are matches, rewrapManyDataKey then attempts to re-wrap the data keys using the provided options.
       *
       * If no matches are found, then no bulk write is performed.
       *
       * @example
       * ```ts
       * // rewrapping all data data keys (using a filter that matches all documents)
       * const filter = {};
       *
       * const result = await clientEncryption.rewrapManyDataKey(filter);
       * if (result.bulkWriteResult != null) {
       *  // keys were re-wrapped, results will be available in the bulkWrite object.
       * }
       * ```
       *
       * @example
       * ```ts
       * // attempting to rewrap all data keys with no matches
       * const filter = { _id: new Binary() } // assume _id matches no documents in the database
       * const result = await clientEncryption.rewrapManyDataKey(filter);
       *
       * if (result.bulkWriteResult == null) {
       *  // no keys matched, `bulkWriteResult` does not exist on the result object
       * }
       * ```
       */
      async rewrapManyDataKey(filter, options2) {
        let keyEncryptionKeyBson = void 0;
        if (options2) {
          const keyEncryptionKey = Object.assign({ provider: options2.provider }, options2.masterKey);
          keyEncryptionKeyBson = (0, bson_1.serialize)(keyEncryptionKey);
        }
        const filterBson = (0, bson_1.serialize)(filter);
        const context = this._mongoCrypt.makeRewrapManyDataKeyContext(filterBson, keyEncryptionKeyBson);
        const stateMachine = new state_machine_1.StateMachine({
          proxyOptions: this._proxyOptions,
          tlsOptions: this._tlsOptions,
          socketOptions: autoSelectSocketOptions(this._client.s.options)
        });
        const timeoutContext = timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS }));
        const { v: dataKeys } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
        if (dataKeys.length === 0) {
          return {};
        }
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        const replacements = dataKeys.map((key) => ({
          updateOne: {
            filter: { _id: key._id },
            update: {
              $set: {
                masterKey: key.masterKey,
                keyMaterial: key.keyMaterial
              },
              $currentDate: {
                updateDate: true
              }
            }
          }
        }));
        const result = await this._keyVaultClient.db(dbName).collection(collectionName).bulkWrite(replacements, {
          writeConcern: { w: "majority" },
          timeoutMS: timeoutContext.csotEnabled() ? timeoutContext?.remainingTimeMS : void 0
        });
        return { bulkWriteResult: result };
      }
      /**
       * Deletes the key with the provided id from the keyvault, if it exists.
       *
       * @example
       * ```ts
       * // delete a key by _id
       * const id = new Binary(); // id is a bson binary subtype 4 object
       * const { deletedCount } = await clientEncryption.deleteKey(id);
       *
       * if (deletedCount != null && deletedCount > 0) {
       *   // successful deletion
       * }
       * ```
       *
       */
      async deleteKey(_id) {
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        return await this._keyVaultClient.db(dbName).collection(collectionName).deleteOne({ _id }, { writeConcern: { w: "majority" }, timeoutMS: this._timeoutMS });
      }
      /**
       * Finds all the keys currently stored in the keyvault.
       *
       * This method will not throw.
       *
       * @returns a FindCursor over all keys in the keyvault.
       * @example
       * ```ts
       * // fetching all keys
       * const keys = await clientEncryption.getKeys().toArray();
       * ```
       */
      getKeys() {
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        return this._keyVaultClient.db(dbName).collection(collectionName).find({}, { readConcern: { level: "majority" }, timeoutMS: this._timeoutMS });
      }
      /**
       * Finds a key in the keyvault with the specified _id.
       *
       * Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents
       * match the id.  The promise rejects with an error if an error is thrown.
       * @example
       * ```ts
       * // getting a key by id
       * const id = new Binary(); // id is a bson binary subtype 4 object
       * const key = await clientEncryption.getKey(id);
       * if (!key) {
       *  // key is null if there was no matching key
       * }
       * ```
       */
      async getKey(_id) {
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        return await this._keyVaultClient.db(dbName).collection(collectionName).findOne({ _id }, { readConcern: { level: "majority" }, timeoutMS: this._timeoutMS });
      }
      /**
       * Finds a key in the keyvault which has the specified keyAltName.
       *
       * @param keyAltName - a keyAltName to search for a key
       * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents
       * match the keyAltName.  The promise rejects with an error if an error is thrown.
       * @example
       * ```ts
       * // get a key by alt name
       * const keyAltName = 'keyAltName';
       * const key = await clientEncryption.getKeyByAltName(keyAltName);
       * if (!key) {
       *  // key is null if there is no matching key
       * }
       * ```
       */
      async getKeyByAltName(keyAltName) {
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        return await this._keyVaultClient.db(dbName).collection(collectionName).findOne({ keyAltNames: keyAltName }, { readConcern: { level: "majority" }, timeoutMS: this._timeoutMS });
      }
      /**
       * Adds a keyAltName to a key identified by the provided _id.
       *
       * This method resolves to/returns the *old* key value (prior to adding the new altKeyName).
       *
       * @param _id - The id of the document to update.
       * @param keyAltName - a keyAltName to search for a key
       * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents
       * match the id.  The promise rejects with an error if an error is thrown.
       * @example
       * ```ts
       * // adding an keyAltName to a data key
       * const id = new Binary();  // id is a bson binary subtype 4 object
       * const keyAltName = 'keyAltName';
       * const oldKey = await clientEncryption.addKeyAltName(id, keyAltName);
       * if (!oldKey) {
       *  // null is returned if there is no matching document with an id matching the supplied id
       * }
       * ```
       */
      async addKeyAltName(_id, keyAltName) {
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        const value = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({ _id }, { $addToSet: { keyAltNames: keyAltName } }, { writeConcern: { w: "majority" }, returnDocument: "before", timeoutMS: this._timeoutMS });
        return value;
      }
      /**
       * Adds a keyAltName to a key identified by the provided _id.
       *
       * This method resolves to/returns the *old* key value (prior to removing the new altKeyName).
       *
       * If the removed keyAltName is the last keyAltName for that key, the `altKeyNames` property is unset from the document.
       *
       * @param _id - The id of the document to update.
       * @param keyAltName - a keyAltName to search for a key
       * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents
       * match the id.  The promise rejects with an error if an error is thrown.
       * @example
       * ```ts
       * // removing a key alt name from a data key
       * const id = new Binary();  // id is a bson binary subtype 4 object
       * const keyAltName = 'keyAltName';
       * const oldKey = await clientEncryption.removeKeyAltName(id, keyAltName);
       *
       * if (!oldKey) {
       *  // null is returned if there is no matching document with an id matching the supplied id
       * }
       * ```
       */
      async removeKeyAltName(_id, keyAltName) {
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        const pipeline = [
          {
            $set: {
              keyAltNames: {
                $cond: [
                  {
                    $eq: ["$keyAltNames", [keyAltName]]
                  },
                  "$$REMOVE",
                  {
                    $filter: {
                      input: "$keyAltNames",
                      cond: {
                        $ne: ["$$this", keyAltName]
                      }
                    }
                  }
                ]
              }
            }
          }
        ];
        const value = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({ _id }, pipeline, {
          writeConcern: { w: "majority" },
          returnDocument: "before",
          timeoutMS: this._timeoutMS
        });
        return value;
      }
      /**
       * A convenience method for creating an encrypted collection.
       * This method will create data keys for any encryptedFields that do not have a `keyId` defined
       * and then create a new collection with the full set of encryptedFields.
       *
       * @param db - A Node.js driver Db object with which to create the collection
       * @param name - The name of the collection to be created
       * @param options - Options for createDataKey and for createCollection
       * @returns created collection and generated encryptedFields
       * @throws MongoCryptCreateDataKeyError - If part way through the process a createDataKey invocation fails, an error will be rejected that has the partial `encryptedFields` that were created.
       * @throws MongoCryptCreateEncryptedCollectionError - If creating the collection fails, an error will be rejected that has the entire `encryptedFields` that were created.
       */
      async createEncryptedCollection(db, name, options2) {
        const { provider, masterKey, createCollectionOptions: { encryptedFields: { ...encryptedFields }, ...createCollectionOptions } } = options2;
        const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS })) : void 0;
        if (Array.isArray(encryptedFields.fields)) {
          const createDataKeyPromises = encryptedFields.fields.map(async (field) => field == null || typeof field !== "object" || field.keyId != null ? field : {
            ...field,
            keyId: await this.createDataKey(provider, {
              masterKey,
              // clone the timeoutContext
              // in order to avoid sharing the same timeout for server selection and connection checkout across different concurrent operations
              timeoutContext: timeoutContext?.csotEnabled() ? timeoutContext?.clone() : void 0
            })
          });
          const createDataKeyResolutions = await Promise.allSettled(createDataKeyPromises);
          encryptedFields.fields = createDataKeyResolutions.map((resolution, index) => resolution.status === "fulfilled" ? resolution.value : encryptedFields.fields[index]);
          const rejection = createDataKeyResolutions.find((result) => result.status === "rejected");
          if (rejection != null) {
            throw new errors_1.MongoCryptCreateDataKeyError(encryptedFields, { cause: rejection.reason });
          }
        }
        try {
          const collection = await db.createCollection(name, {
            ...createCollectionOptions,
            encryptedFields,
            timeoutMS: timeoutContext?.csotEnabled() ? timeoutContext?.getRemainingTimeMSOrThrow() : void 0
          });
          return { collection, encryptedFields };
        } catch (cause) {
          throw new errors_1.MongoCryptCreateEncryptedCollectionError(encryptedFields, { cause });
        }
      }
      /**
       * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must
       * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.
       *
       * @param value - The value that you wish to serialize. Must be of a type that can be serialized into BSON
       * @param options -
       * @returns a Promise that either resolves with the encrypted value, or rejects with an error.
       *
       * @example
       * ```ts
       * // Encryption with async/await api
       * async function encryptMyData(value) {
       *   const keyId = await clientEncryption.createDataKey('local');
       *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });
       * }
       * ```
       *
       * @example
       * ```ts
       * // Encryption using a keyAltName
       * async function encryptMyData(value) {
       *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });
       *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });
       * }
       * ```
       */
      async encrypt(value, options2) {
        return await this._encrypt(value, false, options2);
      }
      /**
       * Encrypts a Match Expression or Aggregate Expression to query a range index.
       *
       * Only supported when queryType is "range" and algorithm is "Range".
       *
       * @param expression - a BSON document of one of the following forms:
       *  1. A Match Expression of this form:
       *      `{$and: [{<field>: {$gt: <value1>}}, {<field>: {$lt: <value2> }}]}`
       *  2. An Aggregate Expression of this form:
       *      `{$and: [{$gt: [<fieldpath>, <value1>]}, {$lt: [<fieldpath>, <value2>]}]}`
       *
       *    `$gt` may also be `$gte`. `$lt` may also be `$lte`.
       *
       * @param options -
       * @returns Returns a Promise that either resolves with the encrypted value or rejects with an error.
       */
      async encryptExpression(expression, options2) {
        return await this._encrypt(expression, true, options2);
      }
      /**
       * Explicitly decrypt a provided encrypted value
       *
       * @param value - An encrypted value
       * @returns a Promise that either resolves with the decrypted value, or rejects with an error
       *
       * @example
       * ```ts
       * // Decrypting value with async/await API
       * async function decryptMyValue(value) {
       *   return clientEncryption.decrypt(value);
       * }
       * ```
       */
      async decrypt(value) {
        const valueBuffer = (0, bson_1.serialize)({ v: value });
        const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);
        const stateMachine = new state_machine_1.StateMachine({
          proxyOptions: this._proxyOptions,
          tlsOptions: this._tlsOptions,
          socketOptions: autoSelectSocketOptions(this._client.s.options)
        });
        const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS })) : void 0;
        const { v } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
        return v;
      }
      /**
       * @internal
       * Ask the user for KMS credentials.
       *
       * This returns anything that looks like the kmsProviders original input
       * option. It can be empty, and any provider specified here will override
       * the original ones.
       */
      async askForKMSCredentials() {
        return await (0, index_1.refreshKMSCredentials)(this._kmsProviders, this._credentialProviders);
      }
      static get libmongocryptVersion() {
        return _ClientEncryption.getMongoCrypt().libmongocryptVersion;
      }
      /**
       * @internal
       * A helper that perform explicit encryption of values and expressions.
       * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must
       * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.
       *
       * @param value - The value that you wish to encrypt. Must be of a type that can be serialized into BSON
       * @param expressionMode - a boolean that indicates whether or not to encrypt the value as an expression
       * @param options - options to pass to encrypt
       * @returns the raw result of the call to stateMachine.execute().  When expressionMode is set to true, the return
       *          value will be a bson document.  When false, the value will be a BSON Binary.
       *
       */
      async _encrypt(value, expressionMode, options2) {
        const { algorithm, keyId, keyAltName, contentionFactor, queryType, rangeOptions } = options2;
        const contextOptions = {
          expressionMode,
          algorithm
        };
        if (keyId) {
          contextOptions.keyId = keyId.buffer;
        }
        if (keyAltName) {
          if (keyId) {
            throw new errors_1.MongoCryptInvalidArgumentError(`"options" cannot contain both "keyId" and "keyAltName"`);
          }
          if (typeof keyAltName !== "string") {
            throw new errors_1.MongoCryptInvalidArgumentError(`"options.keyAltName" must be of type string, but was of type ${typeof keyAltName}`);
          }
          contextOptions.keyAltName = (0, bson_1.serialize)({ keyAltName });
        }
        if (typeof contentionFactor === "number" || typeof contentionFactor === "bigint") {
          contextOptions.contentionFactor = contentionFactor;
        }
        if (typeof queryType === "string") {
          contextOptions.queryType = queryType;
        }
        if (typeof rangeOptions === "object") {
          contextOptions.rangeOptions = (0, bson_1.serialize)(rangeOptions);
        }
        const valueBuffer = (0, bson_1.serialize)({ v: value });
        const stateMachine = new state_machine_1.StateMachine({
          proxyOptions: this._proxyOptions,
          tlsOptions: this._tlsOptions,
          socketOptions: autoSelectSocketOptions(this._client.s.options)
        });
        const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);
        const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS })) : void 0;
        const { v } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
        return v;
      }
    };
    exports2.ClientEncryption = ClientEncryption;
    function autoSelectSocketOptions(baseOptions) {
      const options2 = { autoSelectFamily: true };
      if ("autoSelectFamily" in baseOptions) {
        options2.autoSelectFamily = baseOptions.autoSelectFamily;
      }
      if ("autoSelectFamilyAttemptTimeout" in baseOptions) {
        options2.autoSelectFamilyAttemptTimeout = baseOptions.autoSelectFamilyAttemptTimeout;
      }
      return options2;
    }
  }
});

// node_modules/mongodb/lib/client-side-encryption/mongocryptd_manager.js
var require_mongocryptd_manager = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/mongocryptd_manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongocryptdManager = void 0;
    var error_1 = require_error();
    var MongocryptdManager = class _MongocryptdManager {
      constructor(extraOptions = {}) {
        this.spawnPath = "";
        this.spawnArgs = [];
        this.uri = typeof extraOptions.mongocryptdURI === "string" && extraOptions.mongocryptdURI.length > 0 ? extraOptions.mongocryptdURI : _MongocryptdManager.DEFAULT_MONGOCRYPTD_URI;
        this.bypassSpawn = !!extraOptions.mongocryptdBypassSpawn;
        if (Object.hasOwn(extraOptions, "mongocryptdSpawnPath") && extraOptions.mongocryptdSpawnPath) {
          this.spawnPath = extraOptions.mongocryptdSpawnPath;
        }
        if (Object.hasOwn(extraOptions, "mongocryptdSpawnArgs") && Array.isArray(extraOptions.mongocryptdSpawnArgs)) {
          this.spawnArgs = this.spawnArgs.concat(extraOptions.mongocryptdSpawnArgs);
        }
        if (this.spawnArgs.filter((arg) => typeof arg === "string").every((arg) => arg.indexOf("--idleShutdownTimeoutSecs") < 0)) {
          this.spawnArgs.push("--idleShutdownTimeoutSecs", "60");
        }
      }
      /**
       * Will check to see if a mongocryptd is up. If it is not up, it will attempt
       * to spawn a mongocryptd in a detached process, and then wait for it to be up.
       */
      async spawn() {
        const cmdName = this.spawnPath || "mongocryptd";
        const { spawn } = require("child_process");
        this._child = spawn(cmdName, this.spawnArgs, {
          stdio: "ignore",
          detached: true
        });
        this._child.on("error", () => {
        });
        this._child.unref();
      }
      /**
       * @returns the result of `fn` or rejects with an error.
       */
      async withRespawn(fn) {
        try {
          const result2 = await fn();
          return result2;
        } catch (err) {
          const shouldSpawn = err instanceof error_1.MongoNetworkTimeoutError && !this.bypassSpawn;
          if (!shouldSpawn) {
            throw err;
          }
        }
        await this.spawn();
        const result = await fn();
        return result;
      }
    };
    exports2.MongocryptdManager = MongocryptdManager;
    MongocryptdManager.DEFAULT_MONGOCRYPTD_URI = "mongodb://localhost:27020";
  }
});

// node_modules/mongodb/lib/client-side-encryption/auto_encrypter.js
var require_auto_encrypter = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/auto_encrypter.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AutoEncrypter = exports2.AutoEncryptionLoggerLevel = void 0;
    var net = require("net");
    var bson_1 = require_bson2();
    var constants_1 = require_constants4();
    var deps_1 = require_deps();
    var error_1 = require_error();
    var mongo_client_1 = require_mongo_client();
    var utils_1 = require_utils5();
    var client_encryption_1 = require_client_encryption();
    var cryptoCallbacks = require_crypto_callbacks();
    var errors_1 = require_errors3();
    var mongocryptd_manager_1 = require_mongocryptd_manager();
    var providers_1 = require_providers2();
    var state_machine_1 = require_state_machine();
    exports2.AutoEncryptionLoggerLevel = Object.freeze({
      FatalError: 0,
      Error: 1,
      Warning: 2,
      Info: 3,
      Trace: 4
    });
    var AutoEncrypter = class _AutoEncrypter {
      /** @internal */
      static getMongoCrypt() {
        const encryption = (0, deps_1.getMongoDBClientEncryption)();
        if ("kModuleError" in encryption) {
          throw encryption.kModuleError;
        }
        return encryption.MongoCrypt;
      }
      /**
       * Create an AutoEncrypter
       *
       * **Note**: Do not instantiate this class directly. Rather, supply the relevant options to a MongoClient
       *
       * **Note**: Supplying `options.schemaMap` provides more security than relying on JSON Schemas obtained from the server.
       * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending unencrypted data that should be encrypted.
       * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.
       * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.
       *
       * @example <caption>Create an AutoEncrypter that makes use of mongocryptd</caption>
       * ```ts
       * // Enabling autoEncryption via a MongoClient using mongocryptd
       * const { MongoClient } = require('mongodb');
       * const client = new MongoClient(URL, {
       *   autoEncryption: {
       *     kmsProviders: {
       *       aws: {
       *         accessKeyId: AWS_ACCESS_KEY,
       *         secretAccessKey: AWS_SECRET_KEY
       *       }
       *     }
       *   }
       * });
       * ```
       *
       * await client.connect();
       * // From here on, the client will be encrypting / decrypting automatically
       * @example <caption>Create an AutoEncrypter that makes use of libmongocrypt's CSFLE shared library</caption>
       * ```ts
       * // Enabling autoEncryption via a MongoClient using CSFLE shared library
       * const { MongoClient } = require('mongodb');
       * const client = new MongoClient(URL, {
       *   autoEncryption: {
       *     kmsProviders: {
       *       aws: {}
       *     },
       *     extraOptions: {
       *       cryptSharedLibPath: '/path/to/local/crypt/shared/lib',
       *       cryptSharedLibRequired: true
       *     }
       *   }
       * });
       * ```
       *
       * await client.connect();
       * // From here on, the client will be encrypting / decrypting automatically
       */
      constructor(client, options2) {
        this[_a] = false;
        this._client = client;
        this._bypassEncryption = options2.bypassAutoEncryption === true;
        this._keyVaultNamespace = options2.keyVaultNamespace || "admin.datakeys";
        this._keyVaultClient = options2.keyVaultClient || client;
        this._metaDataClient = options2.metadataClient || client;
        this._proxyOptions = options2.proxyOptions || {};
        this._tlsOptions = options2.tlsOptions || {};
        this._kmsProviders = options2.kmsProviders || {};
        this._credentialProviders = options2.credentialProviders;
        if (options2.credentialProviders?.aws && !(0, providers_1.isEmptyCredentials)("aws", this._kmsProviders)) {
          throw new errors_1.MongoCryptInvalidArgumentError("Can only provide a custom AWS credential provider when the state machine is configured for automatic AWS credential fetching");
        }
        const mongoCryptOptions = {
          enableMultipleCollinfo: true,
          cryptoCallbacks
        };
        if (options2.schemaMap) {
          mongoCryptOptions.schemaMap = Buffer.isBuffer(options2.schemaMap) ? options2.schemaMap : (0, bson_1.serialize)(options2.schemaMap);
        }
        if (options2.encryptedFieldsMap) {
          mongoCryptOptions.encryptedFieldsMap = Buffer.isBuffer(options2.encryptedFieldsMap) ? options2.encryptedFieldsMap : (0, bson_1.serialize)(options2.encryptedFieldsMap);
        }
        mongoCryptOptions.kmsProviders = !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders;
        if (options2.options?.logger) {
          mongoCryptOptions.logger = options2.options.logger;
        }
        if (options2.extraOptions && options2.extraOptions.cryptSharedLibPath) {
          mongoCryptOptions.cryptSharedLibPath = options2.extraOptions.cryptSharedLibPath;
        }
        if (options2.bypassQueryAnalysis) {
          mongoCryptOptions.bypassQueryAnalysis = options2.bypassQueryAnalysis;
        }
        if (options2.keyExpirationMS != null) {
          mongoCryptOptions.keyExpirationMS = options2.keyExpirationMS;
        }
        this._bypassMongocryptdAndCryptShared = this._bypassEncryption || !!options2.bypassQueryAnalysis;
        if (options2.extraOptions && options2.extraOptions.cryptSharedLibSearchPaths) {
          mongoCryptOptions.cryptSharedLibSearchPaths = options2.extraOptions.cryptSharedLibSearchPaths;
        } else if (!this._bypassMongocryptdAndCryptShared) {
          mongoCryptOptions.cryptSharedLibSearchPaths = ["$SYSTEM"];
        }
        const MongoCrypt = _AutoEncrypter.getMongoCrypt();
        this._mongocrypt = new MongoCrypt(mongoCryptOptions);
        this._contextCounter = 0;
        if (options2.extraOptions && options2.extraOptions.cryptSharedLibRequired && !this.cryptSharedLibVersionInfo) {
          throw new errors_1.MongoCryptInvalidArgumentError("`cryptSharedLibRequired` set but no crypt_shared library loaded");
        }
        if (!this._bypassMongocryptdAndCryptShared && !this.cryptSharedLibVersionInfo) {
          this._mongocryptdManager = new mongocryptd_manager_1.MongocryptdManager(options2.extraOptions);
          const clientOptions = {
            serverSelectionTimeoutMS: 1e4
          };
          if ((options2.extraOptions == null || typeof options2.extraOptions.mongocryptdURI !== "string") && !net.getDefaultAutoSelectFamily) {
            clientOptions.family = 4;
          }
          if (net.getDefaultAutoSelectFamily) {
            Object.assign(clientOptions, (0, client_encryption_1.autoSelectSocketOptions)(this._client.s?.options ?? {}));
          }
          this._mongocryptdClient = new mongo_client_1.MongoClient(this._mongocryptdManager.uri, clientOptions);
        }
      }
      /**
       * Initializes the auto encrypter by spawning a mongocryptd and connecting to it.
       *
       * This function is a no-op when bypassSpawn is set or the crypt shared library is used.
       */
      async init() {
        if (this._bypassMongocryptdAndCryptShared || this.cryptSharedLibVersionInfo) {
          return;
        }
        if (!this._mongocryptdManager) {
          throw new error_1.MongoRuntimeError("Reached impossible state: mongocryptdManager is undefined when neither bypassSpawn nor the shared lib are specified.");
        }
        if (!this._mongocryptdClient) {
          throw new error_1.MongoRuntimeError("Reached impossible state: mongocryptdClient is undefined when neither bypassSpawn nor the shared lib are specified.");
        }
        if (!this._mongocryptdManager.bypassSpawn) {
          await this._mongocryptdManager.spawn();
        }
        try {
          const client = await this._mongocryptdClient.connect();
          return client;
        } catch (error2) {
          throw new error_1.MongoRuntimeError("Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn", { cause: error2 });
        }
      }
      /**
       * Cleans up the `_mongocryptdClient`, if present.
       */
      async close() {
        await this._mongocryptdClient?.close();
      }
      /**
       * Encrypt a command for a given namespace.
       */
      async encrypt(ns, cmd, options2 = {}) {
        options2.signal?.throwIfAborted();
        if (this._bypassEncryption) {
          return cmd;
        }
        const commandBuffer = Buffer.isBuffer(cmd) ? cmd : (0, bson_1.serialize)(cmd, options2);
        const context = this._mongocrypt.makeEncryptionContext(utils_1.MongoDBCollectionNamespace.fromString(ns).db, commandBuffer);
        context.id = this._contextCounter++;
        context.ns = ns;
        context.document = cmd;
        const stateMachine = new state_machine_1.StateMachine({
          promoteValues: false,
          promoteLongs: false,
          proxyOptions: this._proxyOptions,
          tlsOptions: this._tlsOptions,
          socketOptions: (0, client_encryption_1.autoSelectSocketOptions)(this._client.s.options)
        });
        return (0, bson_1.deserialize)(await stateMachine.execute(this, context, options2), {
          promoteValues: false,
          promoteLongs: false
        });
      }
      /**
       * Decrypt a command response
       */
      async decrypt(response, options2 = {}) {
        options2.signal?.throwIfAborted();
        const context = this._mongocrypt.makeDecryptionContext(response);
        context.id = this._contextCounter++;
        const stateMachine = new state_machine_1.StateMachine({
          ...options2,
          proxyOptions: this._proxyOptions,
          tlsOptions: this._tlsOptions,
          socketOptions: (0, client_encryption_1.autoSelectSocketOptions)(this._client.s.options)
        });
        return await stateMachine.execute(this, context, options2);
      }
      /**
       * Ask the user for KMS credentials.
       *
       * This returns anything that looks like the kmsProviders original input
       * option. It can be empty, and any provider specified here will override
       * the original ones.
       */
      async askForKMSCredentials() {
        return await (0, providers_1.refreshKMSCredentials)(this._kmsProviders, this._credentialProviders);
      }
      /**
       * Return the current libmongocrypt's CSFLE shared library version
       * as `{ version: bigint, versionStr: string }`, or `null` if no CSFLE
       * shared library was loaded.
       */
      get cryptSharedLibVersionInfo() {
        return this._mongocrypt.cryptSharedLibVersionInfo;
      }
      static get libmongocryptVersion() {
        return _AutoEncrypter.getMongoCrypt().libmongocryptVersion;
      }
    };
    exports2.AutoEncrypter = AutoEncrypter;
    _a = constants_1.kDecorateResult;
  }
});

// node_modules/mongodb/lib/encrypter.js
var require_encrypter = __commonJS({
  "node_modules/mongodb/lib/encrypter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Encrypter = void 0;
    var auto_encrypter_1 = require_auto_encrypter();
    var constants_1 = require_constants4();
    var deps_1 = require_deps();
    var error_1 = require_error();
    var mongo_client_1 = require_mongo_client();
    var Encrypter = class {
      constructor(client, uri, options2) {
        if (typeof options2.autoEncryption !== "object") {
          throw new error_1.MongoInvalidArgumentError('Option "autoEncryption" must be specified');
        }
        this.internalClient = null;
        this.bypassAutoEncryption = !!options2.autoEncryption.bypassAutoEncryption;
        this.needsConnecting = false;
        if (options2.maxPoolSize === 0 && options2.autoEncryption.keyVaultClient == null) {
          options2.autoEncryption.keyVaultClient = client;
        } else if (options2.autoEncryption.keyVaultClient == null) {
          options2.autoEncryption.keyVaultClient = this.getInternalClient(client, uri, options2);
        }
        if (this.bypassAutoEncryption) {
          options2.autoEncryption.metadataClient = void 0;
        } else if (options2.maxPoolSize === 0) {
          options2.autoEncryption.metadataClient = client;
        } else {
          options2.autoEncryption.metadataClient = this.getInternalClient(client, uri, options2);
        }
        if (options2.proxyHost) {
          options2.autoEncryption.proxyOptions = {
            proxyHost: options2.proxyHost,
            proxyPort: options2.proxyPort,
            proxyUsername: options2.proxyUsername,
            proxyPassword: options2.proxyPassword
          };
        }
        this.autoEncrypter = new auto_encrypter_1.AutoEncrypter(client, options2.autoEncryption);
      }
      getInternalClient(client, uri, options2) {
        let internalClient = this.internalClient;
        if (internalClient == null) {
          const clonedOptions = {};
          for (const key of [
            ...Object.getOwnPropertyNames(options2),
            ...Object.getOwnPropertySymbols(options2)
          ]) {
            if (["autoEncryption", "minPoolSize", "servers", "caseTranslate", "dbName"].includes(key))
              continue;
            Reflect.set(clonedOptions, key, Reflect.get(options2, key));
          }
          clonedOptions.minPoolSize = 0;
          internalClient = new mongo_client_1.MongoClient(uri, clonedOptions);
          this.internalClient = internalClient;
          for (const eventName of constants_1.MONGO_CLIENT_EVENTS) {
            for (const listener of client.listeners(eventName)) {
              internalClient.on(eventName, listener);
            }
          }
          client.on("newListener", (eventName, listener) => {
            internalClient?.on(eventName, listener);
          });
          this.needsConnecting = true;
        }
        return internalClient;
      }
      async connectInternalClient() {
        const internalClient = this.internalClient;
        if (this.needsConnecting && internalClient != null) {
          this.needsConnecting = false;
          await internalClient.connect();
        }
      }
      async close(client) {
        let error2;
        try {
          await this.autoEncrypter.close();
        } catch (autoEncrypterError) {
          error2 = autoEncrypterError;
        }
        const internalClient = this.internalClient;
        if (internalClient != null && client !== internalClient) {
          return await internalClient.close();
        }
        if (error2 != null) {
          throw error2;
        }
      }
      static checkForMongoCrypt() {
        const mongodbClientEncryption = (0, deps_1.getMongoDBClientEncryption)();
        if ("kModuleError" in mongodbClientEncryption) {
          throw new error_1.MongoMissingDependencyError("Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project", {
            cause: mongodbClientEncryption["kModuleError"],
            dependencyName: "mongodb-client-encryption"
          });
        }
      }
    };
    exports2.Encrypter = Encrypter;
  }
});

// node_modules/mongodb/lib/cmap/metrics.js
var require_metrics = __commonJS({
  "node_modules/mongodb/lib/cmap/metrics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionPoolMetrics = void 0;
    var ConnectionPoolMetrics = class _ConnectionPoolMetrics {
      constructor() {
        this.txnConnections = 0;
        this.cursorConnections = 0;
        this.otherConnections = 0;
      }
      /**
       * Mark a connection as pinned for a specific operation.
       */
      markPinned(pinType) {
        if (pinType === _ConnectionPoolMetrics.TXN) {
          this.txnConnections += 1;
        } else if (pinType === _ConnectionPoolMetrics.CURSOR) {
          this.cursorConnections += 1;
        } else {
          this.otherConnections += 1;
        }
      }
      /**
       * Unmark a connection as pinned for an operation.
       */
      markUnpinned(pinType) {
        if (pinType === _ConnectionPoolMetrics.TXN) {
          this.txnConnections -= 1;
        } else if (pinType === _ConnectionPoolMetrics.CURSOR) {
          this.cursorConnections -= 1;
        } else {
          this.otherConnections -= 1;
        }
      }
      /**
       * Return information about the cmap metrics as a string.
       */
      info(maxPoolSize) {
        return `Timed out while checking out a connection from connection pool: maxPoolSize: ${maxPoolSize}, connections in use by cursors: ${this.cursorConnections}, connections in use by transactions: ${this.txnConnections}, connections in use by other operations: ${this.otherConnections}`;
      }
      /**
       * Reset the metrics to the initial values.
       */
      reset() {
        this.txnConnections = 0;
        this.cursorConnections = 0;
        this.otherConnections = 0;
      }
    };
    exports2.ConnectionPoolMetrics = ConnectionPoolMetrics;
    ConnectionPoolMetrics.TXN = "txn";
    ConnectionPoolMetrics.CURSOR = "cursor";
    ConnectionPoolMetrics.OTHER = "other";
  }
});

// node_modules/mongodb/lib/sdam/server_description.js
var require_server_description = __commonJS({
  "node_modules/mongodb/lib/sdam/server_description.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerDescription = void 0;
    exports2.parseServerType = parseServerType;
    exports2.compareTopologyVersion = compareTopologyVersion;
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var common_1 = require_common2();
    var WRITABLE_SERVER_TYPES = /* @__PURE__ */ new Set([
      common_1.ServerType.RSPrimary,
      common_1.ServerType.Standalone,
      common_1.ServerType.Mongos,
      common_1.ServerType.LoadBalancer
    ]);
    var DATA_BEARING_SERVER_TYPES = /* @__PURE__ */ new Set([
      common_1.ServerType.RSPrimary,
      common_1.ServerType.RSSecondary,
      common_1.ServerType.Mongos,
      common_1.ServerType.Standalone,
      common_1.ServerType.LoadBalancer
    ]);
    var ServerDescription = class {
      /**
       * Create a ServerDescription
       * @internal
       *
       * @param address - The address of the server
       * @param hello - An optional hello response for this server
       */
      constructor(address, hello, options2 = {}) {
        if (address == null || address === "") {
          throw new error_1.MongoRuntimeError("ServerDescription must be provided with a non-empty address");
        }
        this.address = typeof address === "string" ? utils_1.HostAddress.fromString(address).toString() : address.toString();
        this.type = parseServerType(hello, options2);
        this.hosts = hello?.hosts?.map((host) => host.toLowerCase()) ?? [];
        this.passives = hello?.passives?.map((host) => host.toLowerCase()) ?? [];
        this.arbiters = hello?.arbiters?.map((host) => host.toLowerCase()) ?? [];
        this.tags = hello?.tags ?? {};
        this.minWireVersion = hello?.minWireVersion ?? 0;
        this.maxWireVersion = hello?.maxWireVersion ?? 0;
        this.roundTripTime = options2?.roundTripTime ?? -1;
        this.minRoundTripTime = options2?.minRoundTripTime ?? 0;
        this.lastUpdateTime = (0, utils_1.now)();
        this.lastWriteDate = hello?.lastWrite?.lastWriteDate ?? 0;
        this.error = options2.error ?? null;
        this.error?.stack;
        this.topologyVersion = this.error?.topologyVersion ?? hello?.topologyVersion ?? null;
        this.setName = hello?.setName ?? null;
        this.setVersion = hello?.setVersion ?? null;
        this.electionId = hello?.electionId ?? null;
        this.logicalSessionTimeoutMinutes = hello?.logicalSessionTimeoutMinutes ?? null;
        this.maxMessageSizeBytes = hello?.maxMessageSizeBytes ?? null;
        this.maxWriteBatchSize = hello?.maxWriteBatchSize ?? null;
        this.maxBsonObjectSize = hello?.maxBsonObjectSize ?? null;
        this.primary = hello?.primary ?? null;
        this.me = hello?.me?.toLowerCase() ?? null;
        this.$clusterTime = hello?.$clusterTime ?? null;
        this.iscryptd = Boolean(hello?.iscryptd);
      }
      get hostAddress() {
        return utils_1.HostAddress.fromString(this.address);
      }
      get allHosts() {
        return this.hosts.concat(this.arbiters).concat(this.passives);
      }
      /** Is this server available for reads*/
      get isReadable() {
        return this.type === common_1.ServerType.RSSecondary || this.isWritable;
      }
      /** Is this server data bearing */
      get isDataBearing() {
        return DATA_BEARING_SERVER_TYPES.has(this.type);
      }
      /** Is this server available for writes */
      get isWritable() {
        return WRITABLE_SERVER_TYPES.has(this.type);
      }
      get host() {
        const chopLength = `:${this.port}`.length;
        return this.address.slice(0, -chopLength);
      }
      get port() {
        const port = this.address.split(":").pop();
        return port ? Number.parseInt(port, 10) : 27017;
      }
      /**
       * Determines if another `ServerDescription` is equal to this one per the rules defined in the SDAM specification.
       * @see https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.md
       */
      equals(other) {
        const topologyVersionsEqual = this.topologyVersion === other?.topologyVersion || compareTopologyVersion(this.topologyVersion, other?.topologyVersion) === 0;
        const electionIdsEqual = this.electionId != null && other?.electionId != null ? (0, utils_1.compareObjectId)(this.electionId, other.electionId) === 0 : this.electionId === other?.electionId;
        return other != null && other.iscryptd === this.iscryptd && (0, utils_1.errorStrictEqual)(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && (0, utils_1.arrayStrictEqual)(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && electionIdsEqual && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
      }
    };
    exports2.ServerDescription = ServerDescription;
    function parseServerType(hello, options2) {
      if (options2?.loadBalanced) {
        return common_1.ServerType.LoadBalancer;
      }
      if (!hello || !hello.ok) {
        return common_1.ServerType.Unknown;
      }
      if (hello.isreplicaset) {
        return common_1.ServerType.RSGhost;
      }
      if (hello.msg && hello.msg === "isdbgrid") {
        return common_1.ServerType.Mongos;
      }
      if (hello.setName) {
        if (hello.hidden) {
          return common_1.ServerType.RSOther;
        } else if (hello.isWritablePrimary) {
          return common_1.ServerType.RSPrimary;
        } else if (hello.secondary) {
          return common_1.ServerType.RSSecondary;
        } else if (hello.arbiterOnly) {
          return common_1.ServerType.RSArbiter;
        } else {
          return common_1.ServerType.RSOther;
        }
      }
      return common_1.ServerType.Standalone;
    }
    function tagsStrictEqual(tags, tags2) {
      const tagsKeys = Object.keys(tags);
      const tags2Keys = Object.keys(tags2);
      return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags2[key] === tags[key]);
    }
    function compareTopologyVersion(currentTv, newTv) {
      if (currentTv == null || newTv == null) {
        return -1;
      }
      if (!currentTv.processId.equals(newTv.processId)) {
        return -1;
      }
      const currentCounter = typeof currentTv.counter === "bigint" ? bson_1.Long.fromBigInt(currentTv.counter) : bson_1.Long.isLong(currentTv.counter) ? currentTv.counter : bson_1.Long.fromNumber(currentTv.counter);
      const newCounter = typeof newTv.counter === "bigint" ? bson_1.Long.fromBigInt(newTv.counter) : bson_1.Long.isLong(newTv.counter) ? newTv.counter : bson_1.Long.fromNumber(newTv.counter);
      return currentCounter.compare(newCounter);
    }
  }
});

// node_modules/mongodb/lib/sdam/topology_description.js
var require_topology_description = __commonJS({
  "node_modules/mongodb/lib/sdam/topology_description.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TopologyDescription = void 0;
    var bson_1 = require_bson2();
    var WIRE_CONSTANTS = require_constants3();
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var common_1 = require_common2();
    var server_description_1 = require_server_description();
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var MONGOS_OR_UNKNOWN = /* @__PURE__ */ new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);
    var MONGOS_OR_STANDALONE = /* @__PURE__ */ new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);
    var NON_PRIMARY_RS_MEMBERS = /* @__PURE__ */ new Set([
      common_1.ServerType.RSSecondary,
      common_1.ServerType.RSArbiter,
      common_1.ServerType.RSOther
    ]);
    var TopologyDescription = class _TopologyDescription {
      /**
       * Create a TopologyDescription
       */
      constructor(topologyType, serverDescriptions = null, setName = null, maxSetVersion = null, maxElectionId = null, commonWireVersion = null, options2 = null) {
        options2 = options2 ?? {};
        this.type = topologyType ?? common_1.TopologyType.Unknown;
        this.servers = serverDescriptions ?? /* @__PURE__ */ new Map();
        this.stale = false;
        this.compatible = true;
        this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS ?? 0;
        this.localThresholdMS = options2.localThresholdMS ?? 15;
        this.setName = setName ?? null;
        this.maxElectionId = maxElectionId ?? null;
        this.maxSetVersion = maxSetVersion ?? null;
        this.commonWireVersion = commonWireVersion ?? 0;
        for (const serverDescription of this.servers.values()) {
          if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {
            continue;
          }
          if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
          }
          if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
            break;
          }
        }
        this.logicalSessionTimeoutMinutes = null;
        for (const [, server] of this.servers) {
          if (server.isReadable) {
            if (server.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = null;
              break;
            }
            if (this.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
              continue;
            }
            this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
          }
        }
      }
      /**
       * Returns a new TopologyDescription based on the SrvPollingEvent
       * @internal
       */
      updateFromSrvPollingEvent(ev, srvMaxHosts = 0) {
        const incomingHostnames = ev.hostnames();
        const currentHostnames = new Set(this.servers.keys());
        const hostnamesToAdd = new Set(incomingHostnames);
        const hostnamesToRemove = /* @__PURE__ */ new Set();
        for (const hostname of currentHostnames) {
          hostnamesToAdd.delete(hostname);
          if (!incomingHostnames.has(hostname)) {
            hostnamesToRemove.add(hostname);
          }
        }
        if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {
          return this;
        }
        const serverDescriptions = new Map(this.servers);
        for (const removedHost of hostnamesToRemove) {
          serverDescriptions.delete(removedHost);
        }
        if (hostnamesToAdd.size > 0) {
          if (srvMaxHosts === 0) {
            for (const hostToAdd of hostnamesToAdd) {
              serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));
            }
          } else if (serverDescriptions.size < srvMaxHosts) {
            const selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);
            for (const selectedHostToAdd of selectedHosts) {
              serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));
            }
          }
        }
        return new _TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
      }
      /**
       * Returns a copy of this description updated with a given ServerDescription
       * @internal
       */
      update(serverDescription) {
        const address = serverDescription.address;
        let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;
        const serverType = serverDescription.type;
        const serverDescriptions = new Map(this.servers);
        if (serverDescription.maxWireVersion !== 0) {
          if (commonWireVersion == null) {
            commonWireVersion = serverDescription.maxWireVersion;
          } else {
            commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
          }
        }
        if (typeof serverDescription.setName === "string" && typeof setName === "string" && serverDescription.setName !== setName) {
          if (topologyType === common_1.TopologyType.Single) {
            serverDescription = new server_description_1.ServerDescription(address);
          } else {
            serverDescriptions.delete(address);
          }
        }
        serverDescriptions.set(address, serverDescription);
        if (topologyType === common_1.TopologyType.Single) {
          return new _TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
        }
        if (topologyType === common_1.TopologyType.Unknown) {
          if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {
            serverDescriptions.delete(address);
          } else {
            topologyType = topologyTypeForServerType(serverType);
          }
        }
        if (topologyType === common_1.TopologyType.Sharded) {
          if (!MONGOS_OR_UNKNOWN.has(serverType)) {
            serverDescriptions.delete(address);
          }
        }
        if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {
          if (MONGOS_OR_STANDALONE.has(serverType)) {
            serverDescriptions.delete(address);
          }
          if (serverType === common_1.ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
            topologyType = result[0];
            setName = result[1];
            maxSetVersion = result[2];
            maxElectionId = result[3];
          } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
            const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);
            topologyType = result[0];
            setName = result[1];
          }
        }
        if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {
          if (MONGOS_OR_STANDALONE.has(serverType)) {
            serverDescriptions.delete(address);
            topologyType = checkHasPrimary(serverDescriptions);
          } else if (serverType === common_1.ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
            topologyType = result[0];
            setName = result[1];
            maxSetVersion = result[2];
            maxElectionId = result[3];
          } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
            topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);
          } else {
            topologyType = checkHasPrimary(serverDescriptions);
          }
        }
        return new _TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
      }
      get error() {
        const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
        if (descriptionsWithError.length > 0) {
          return descriptionsWithError[0].error;
        }
        return null;
      }
      /**
       * Determines if the topology description has any known servers
       */
      get hasKnownServers() {
        return Array.from(this.servers.values()).some((sd) => sd.type !== common_1.ServerType.Unknown);
      }
      /**
       * Determines if this topology description has a data-bearing server available.
       */
      get hasDataBearingServers() {
        return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
      }
      /**
       * Determines if the topology has a definition for the provided address
       * @internal
       */
      hasServer(address) {
        return this.servers.has(address);
      }
      /**
       * Returns a JSON-serializable representation of the TopologyDescription.  This is primarily
       * intended for use with JSON.stringify().
       *
       * This method will not throw.
       */
      toJSON() {
        return bson_1.EJSON.serialize(this);
      }
    };
    exports2.TopologyDescription = TopologyDescription;
    function topologyTypeForServerType(serverType) {
      switch (serverType) {
        case common_1.ServerType.Standalone:
          return common_1.TopologyType.Single;
        case common_1.ServerType.Mongos:
          return common_1.TopologyType.Sharded;
        case common_1.ServerType.RSPrimary:
          return common_1.TopologyType.ReplicaSetWithPrimary;
        case common_1.ServerType.RSOther:
        case common_1.ServerType.RSSecondary:
          return common_1.TopologyType.ReplicaSetNoPrimary;
        default:
          return common_1.TopologyType.Unknown;
      }
    }
    function updateRsFromPrimary(serverDescriptions, serverDescription, setName = null, maxSetVersion = null, maxElectionId = null) {
      const setVersionElectionIdMismatch = (serverDescription2, maxSetVersion2, maxElectionId2) => {
        return `primary marked stale due to electionId/setVersion mismatch: server setVersion: ${serverDescription2.setVersion}, server electionId: ${serverDescription2.electionId}, topology setVersion: ${maxSetVersion2}, topology electionId: ${maxElectionId2}`;
      };
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
      if (serverDescription.maxWireVersion >= 17) {
        const electionIdComparison = (0, utils_1.compareObjectId)(maxElectionId, serverDescription.electionId);
        const maxElectionIdIsEqual = electionIdComparison === 0;
        const maxElectionIdIsLess = electionIdComparison === -1;
        const maxSetVersionIsLessOrEqual = (maxSetVersion ?? -1) <= (serverDescription.setVersion ?? -1);
        if (maxElectionIdIsLess || maxElectionIdIsEqual && maxSetVersionIsLessOrEqual) {
          maxElectionId = serverDescription.electionId;
          maxSetVersion = serverDescription.setVersion;
        } else {
          serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address, void 0, {
            error: new error_1.MongoStalePrimaryError(setVersionElectionIdMismatch(serverDescription, maxSetVersion, maxElectionId))
          }));
          return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
        }
      } else {
        const electionId = serverDescription.electionId ? serverDescription.electionId : null;
        if (serverDescription.setVersion && electionId) {
          if (maxSetVersion && maxElectionId) {
            if (maxSetVersion > serverDescription.setVersion || (0, utils_1.compareObjectId)(maxElectionId, electionId) > 0) {
              serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address, void 0, {
                error: new error_1.MongoStalePrimaryError(setVersionElectionIdMismatch(serverDescription, maxSetVersion, maxElectionId))
              }));
              return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
            }
          }
          maxElectionId = serverDescription.electionId;
        }
        if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
          maxSetVersion = serverDescription.setVersion;
        }
      }
      for (const [address, server] of serverDescriptions) {
        if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {
          serverDescriptions.set(address, new server_description_1.ServerDescription(server.address, void 0, {
            error: new error_1.MongoStalePrimaryError("primary marked stale due to discovery of newer primary")
          }));
          break;
        }
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new server_description_1.ServerDescription(address));
        }
      });
      const currentAddresses = Array.from(serverDescriptions.keys());
      const responseAddresses = serverDescription.allHosts;
      currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
        serverDescriptions.delete(address);
      });
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    function updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName = null) {
      if (setName == null) {
        throw new error_1.MongoRuntimeError('Argument "setName" is required if connected to a replica set');
      }
      if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return checkHasPrimary(serverDescriptions);
    }
    function updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName = null) {
      const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;
      setName = setName ?? serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [topologyType, setName];
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new server_description_1.ServerDescription(address));
        }
      });
      if (serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return [topologyType, setName];
    }
    function checkHasPrimary(serverDescriptions) {
      for (const serverDescription of serverDescriptions.values()) {
        if (serverDescription.type === common_1.ServerType.RSPrimary) {
          return common_1.TopologyType.ReplicaSetWithPrimary;
        }
      }
      return common_1.TopologyType.ReplicaSetNoPrimary;
    }
  }
});

// node_modules/mongodb/lib/cmap/wire_protocol/shared.js
var require_shared = __commonJS({
  "node_modules/mongodb/lib/cmap/wire_protocol/shared.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getReadPreference = getReadPreference;
    exports2.isSharded = isSharded;
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var common_1 = require_common2();
    var topology_description_1 = require_topology_description();
    function getReadPreference(options2) {
      let readPreference = options2?.readPreference ?? read_preference_1.ReadPreference.primary;
      if (typeof readPreference === "string") {
        readPreference = read_preference_1.ReadPreference.fromString(readPreference);
      }
      if (!(readPreference instanceof read_preference_1.ReadPreference)) {
        throw new error_1.MongoInvalidArgumentError('Option "readPreference" must be a ReadPreference instance');
      }
      return readPreference;
    }
    function isSharded(topologyOrServer) {
      if (topologyOrServer == null) {
        return false;
      }
      if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {
        return true;
      }
      if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {
        const servers = Array.from(topologyOrServer.description.servers.values());
        return servers.some((server) => server.type === common_1.ServerType.Mongos);
      }
      return false;
    }
  }
});

// node_modules/mongodb/lib/transactions.js
var require_transactions = __commonJS({
  "node_modules/mongodb/lib/transactions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Transaction = exports2.TxnState = void 0;
    exports2.isTransactionCommand = isTransactionCommand;
    var error_1 = require_error();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var write_concern_1 = require_write_concern();
    exports2.TxnState = Object.freeze({
      NO_TRANSACTION: "NO_TRANSACTION",
      STARTING_TRANSACTION: "STARTING_TRANSACTION",
      TRANSACTION_IN_PROGRESS: "TRANSACTION_IN_PROGRESS",
      TRANSACTION_COMMITTED: "TRANSACTION_COMMITTED",
      TRANSACTION_COMMITTED_EMPTY: "TRANSACTION_COMMITTED_EMPTY",
      TRANSACTION_ABORTED: "TRANSACTION_ABORTED"
    });
    var stateMachine = {
      [exports2.TxnState.NO_TRANSACTION]: [exports2.TxnState.NO_TRANSACTION, exports2.TxnState.STARTING_TRANSACTION],
      [exports2.TxnState.STARTING_TRANSACTION]: [
        exports2.TxnState.TRANSACTION_IN_PROGRESS,
        exports2.TxnState.TRANSACTION_COMMITTED,
        exports2.TxnState.TRANSACTION_COMMITTED_EMPTY,
        exports2.TxnState.TRANSACTION_ABORTED
      ],
      [exports2.TxnState.TRANSACTION_IN_PROGRESS]: [
        exports2.TxnState.TRANSACTION_IN_PROGRESS,
        exports2.TxnState.TRANSACTION_COMMITTED,
        exports2.TxnState.TRANSACTION_ABORTED
      ],
      [exports2.TxnState.TRANSACTION_COMMITTED]: [
        exports2.TxnState.TRANSACTION_COMMITTED,
        exports2.TxnState.TRANSACTION_COMMITTED_EMPTY,
        exports2.TxnState.STARTING_TRANSACTION,
        exports2.TxnState.NO_TRANSACTION
      ],
      [exports2.TxnState.TRANSACTION_ABORTED]: [exports2.TxnState.STARTING_TRANSACTION, exports2.TxnState.NO_TRANSACTION],
      [exports2.TxnState.TRANSACTION_COMMITTED_EMPTY]: [
        exports2.TxnState.TRANSACTION_COMMITTED_EMPTY,
        exports2.TxnState.NO_TRANSACTION
      ]
    };
    var ACTIVE_STATES = /* @__PURE__ */ new Set([
      exports2.TxnState.STARTING_TRANSACTION,
      exports2.TxnState.TRANSACTION_IN_PROGRESS
    ]);
    var COMMITTED_STATES = /* @__PURE__ */ new Set([
      exports2.TxnState.TRANSACTION_COMMITTED,
      exports2.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports2.TxnState.TRANSACTION_ABORTED
    ]);
    var Transaction = class {
      /** Create a transaction @internal */
      constructor(options2) {
        options2 = options2 ?? {};
        this.state = exports2.TxnState.NO_TRANSACTION;
        this.options = {};
        const writeConcern = write_concern_1.WriteConcern.fromOptions(options2);
        if (writeConcern) {
          if (writeConcern.w === 0) {
            throw new error_1.MongoTransactionError("Transactions do not support unacknowledged write concern");
          }
          this.options.writeConcern = writeConcern;
        }
        if (options2.readConcern) {
          this.options.readConcern = read_concern_1.ReadConcern.fromOptions(options2);
        }
        if (options2.readPreference) {
          this.options.readPreference = read_preference_1.ReadPreference.fromOptions(options2);
        }
        if (options2.maxCommitTimeMS) {
          this.options.maxTimeMS = options2.maxCommitTimeMS;
        }
        this._pinnedServer = void 0;
        this._recoveryToken = void 0;
      }
      /** @internal */
      get server() {
        return this._pinnedServer;
      }
      get recoveryToken() {
        return this._recoveryToken;
      }
      get isPinned() {
        return !!this.server;
      }
      /** @returns Whether the transaction has started */
      get isStarting() {
        return this.state === exports2.TxnState.STARTING_TRANSACTION;
      }
      /**
       * @returns Whether this session is presently in a transaction
       */
      get isActive() {
        return ACTIVE_STATES.has(this.state);
      }
      get isCommitted() {
        return COMMITTED_STATES.has(this.state);
      }
      /**
       * Transition the transaction in the state machine
       * @internal
       * @param nextState - The new state to transition to
       */
      transition(nextState) {
        const nextStates = stateMachine[this.state];
        if (nextStates && nextStates.includes(nextState)) {
          this.state = nextState;
          if (this.state === exports2.TxnState.NO_TRANSACTION || this.state === exports2.TxnState.STARTING_TRANSACTION || this.state === exports2.TxnState.TRANSACTION_ABORTED) {
            this.unpinServer();
          }
          return;
        }
        throw new error_1.MongoRuntimeError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
      }
      /** @internal */
      pinServer(server) {
        if (this.isActive) {
          this._pinnedServer = server;
        }
      }
      /** @internal */
      unpinServer() {
        this._pinnedServer = void 0;
      }
    };
    exports2.Transaction = Transaction;
    function isTransactionCommand(command) {
      return !!(command.commitTransaction || command.abortTransaction);
    }
  }
});

// node_modules/mongodb/lib/sessions.js
var require_sessions = __commonJS({
  "node_modules/mongodb/lib/sessions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerSessionPool = exports2.ServerSession = exports2.ClientSession = void 0;
    exports2.maybeClearPinnedConnection = maybeClearPinnedConnection;
    exports2.applySession = applySession;
    exports2.updateSessionFromResponse = updateSessionFromResponse;
    var bson_1 = require_bson2();
    var metrics_1 = require_metrics();
    var shared_1 = require_shared();
    var constants_1 = require_constants4();
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var execute_operation_1 = require_execute_operation();
    var run_command_1 = require_run_command();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var resource_management_1 = require_resource_management();
    var common_1 = require_common2();
    var timeout_1 = require_timeout();
    var transactions_1 = require_transactions();
    var utils_1 = require_utils5();
    var write_concern_1 = require_write_concern();
    var minWireVersionForShardedTransactions = 8;
    var ClientSession = class _ClientSession extends mongo_types_1.TypedEventEmitter {
      /**
       * Create a client session.
       * @internal
       * @param client - The current client
       * @param sessionPool - The server session pool (Internal Class)
       * @param options - Optional settings
       * @param clientOptions - Optional settings provided when creating a MongoClient
       */
      constructor(client, sessionPool, options2, clientOptions) {
        super();
        this.timeoutContext = null;
        this.on("error", utils_1.noop);
        if (client == null) {
          throw new error_1.MongoRuntimeError("ClientSession requires a MongoClient");
        }
        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
          throw new error_1.MongoRuntimeError("ClientSession requires a ServerSessionPool");
        }
        options2 = options2 ?? {};
        this.snapshotEnabled = options2.snapshot === true;
        if (options2.causalConsistency === true && this.snapshotEnabled) {
          throw new error_1.MongoInvalidArgumentError('Properties "causalConsistency" and "snapshot" are mutually exclusive');
        }
        this.client = client;
        this.sessionPool = sessionPool;
        this.hasEnded = false;
        this.clientOptions = clientOptions;
        this.timeoutMS = options2.defaultTimeoutMS ?? client.s.options?.timeoutMS;
        this.explicit = !!options2.explicit;
        this._serverSession = this.explicit ? this.sessionPool.acquire() : null;
        this.txnNumberIncrement = 0;
        const defaultCausalConsistencyValue = this.explicit && options2.snapshot !== true;
        this.supports = {
          // if we can enable causal consistency, do so by default
          causalConsistency: options2.causalConsistency ?? defaultCausalConsistencyValue
        };
        this.clusterTime = options2.initialClusterTime;
        this.operationTime = void 0;
        this.owner = options2.owner;
        this.defaultTransactionOptions = { ...options2.defaultTransactionOptions };
        this.transaction = new transactions_1.Transaction();
      }
      /** The server id associated with this session */
      get id() {
        return this.serverSession?.id;
      }
      get serverSession() {
        let serverSession = this._serverSession;
        if (serverSession == null) {
          if (this.explicit) {
            throw new error_1.MongoRuntimeError("Unexpected null serverSession for an explicit session");
          }
          if (this.hasEnded) {
            throw new error_1.MongoRuntimeError("Unexpected null serverSession for an ended implicit session");
          }
          serverSession = this.sessionPool.acquire();
          this._serverSession = serverSession;
        }
        return serverSession;
      }
      get loadBalanced() {
        return this.client.topology?.description.type === common_1.TopologyType.LoadBalanced;
      }
      /** @internal */
      pin(conn) {
        if (this.pinnedConnection) {
          throw TypeError("Cannot pin multiple connections to the same session");
        }
        this.pinnedConnection = conn;
        conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
      }
      /** @internal */
      unpin(options2) {
        if (this.loadBalanced) {
          return maybeClearPinnedConnection(this, options2);
        }
        this.transaction.unpinServer();
      }
      get isPinned() {
        return this.loadBalanced ? !!this.pinnedConnection : this.transaction.isPinned;
      }
      /**
       * Frees any client-side resources held by the current session.  If a session is in a transaction,
       * the transaction is aborted.
       *
       * Does not end the session on the server.
       *
       * @param options - Optional settings. Currently reserved for future use
       */
      async endSession(options2) {
        try {
          if (this.inTransaction()) {
            await this.abortTransaction({ ...options2, throwTimeout: true });
          }
        } catch (error2) {
          if (error2.name === "MongoOperationTimeoutError")
            throw error2;
          (0, utils_1.squashError)(error2);
        } finally {
          if (!this.hasEnded) {
            const serverSession = this.serverSession;
            if (serverSession != null) {
              this.sessionPool.release(serverSession);
              this._serverSession = new ServerSession(serverSession);
            }
            this.hasEnded = true;
            this.emit("ended", this);
          }
          maybeClearPinnedConnection(this, { force: true, ...options2 });
        }
      }
      /** @internal */
      async asyncDispose() {
        await this.endSession({ force: true });
      }
      /**
       * Advances the operationTime for a ClientSession.
       *
       * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to
       */
      advanceOperationTime(operationTime) {
        if (this.operationTime == null) {
          this.operationTime = operationTime;
          return;
        }
        if (operationTime.greaterThan(this.operationTime)) {
          this.operationTime = operationTime;
        }
      }
      /**
       * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession
       *
       * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature
       */
      advanceClusterTime(clusterTime) {
        if (!clusterTime || typeof clusterTime !== "object") {
          throw new error_1.MongoInvalidArgumentError("input cluster time must be an object");
        }
        if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== "Timestamp") {
          throw new error_1.MongoInvalidArgumentError('input cluster time "clusterTime" property must be a valid BSON Timestamp');
        }
        if (!clusterTime.signature || clusterTime.signature.hash?._bsontype !== "Binary" || typeof clusterTime.signature.keyId !== "bigint" && typeof clusterTime.signature.keyId !== "number" && clusterTime.signature.keyId?._bsontype !== "Long") {
          throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid "signature" property with BSON Binary hash and BSON Long keyId');
        }
        (0, common_1._advanceClusterTime)(this, clusterTime);
      }
      /**
       * Used to determine if this session equals another
       *
       * @param session - The session to compare to
       */
      equals(session) {
        if (!(session instanceof _ClientSession)) {
          return false;
        }
        if (this.id == null || session.id == null) {
          return false;
        }
        return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);
      }
      /**
       * Increment the transaction number on the internal ServerSession
       *
       * @privateRemarks
       * This helper increments a value stored on the client session that will be
       * added to the serverSession's txnNumber upon applying it to a command.
       * This is because the serverSession is lazily acquired after a connection is obtained
       */
      incrementTransactionNumber() {
        this.txnNumberIncrement += 1;
      }
      /** @returns whether this session is currently in a transaction or not */
      inTransaction() {
        return this.transaction.isActive;
      }
      /**
       * Starts a new transaction with the given options.
       *
       * @remarks
       * **IMPORTANT**: Running operations in parallel is not supported during a transaction. The use of `Promise.all`,
       * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is
       * undefined behaviour.
       *
       * @param options - Options for the transaction
       */
      startTransaction(options2) {
        if (this.snapshotEnabled) {
          throw new error_1.MongoCompatibilityError("Transactions are not supported in snapshot sessions");
        }
        if (this.inTransaction()) {
          throw new error_1.MongoTransactionError("Transaction already in progress");
        }
        if (this.isPinned && this.transaction.isCommitted) {
          this.unpin();
        }
        const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);
        if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
          throw new error_1.MongoCompatibilityError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
        }
        this.commitAttempted = false;
        this.incrementTransactionNumber();
        this.transaction = new transactions_1.Transaction({
          readConcern: options2?.readConcern ?? this.defaultTransactionOptions.readConcern ?? this.clientOptions?.readConcern,
          writeConcern: options2?.writeConcern ?? this.defaultTransactionOptions.writeConcern ?? this.clientOptions?.writeConcern,
          readPreference: options2?.readPreference ?? this.defaultTransactionOptions.readPreference ?? this.clientOptions?.readPreference,
          maxCommitTimeMS: options2?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS
        });
        this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);
      }
      /**
       * Commits the currently active transaction in this session.
       *
       * @param options - Optional options, can be used to override `defaultTimeoutMS`.
       */
      async commitTransaction(options2) {
        if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION) {
          throw new error_1.MongoTransactionError("No transaction started");
        }
        if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
          this.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);
          return;
        }
        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
          throw new error_1.MongoTransactionError("Cannot call commitTransaction after calling abortTransaction");
        }
        const command = { commitTransaction: 1 };
        const timeoutMS = typeof options2?.timeoutMS === "number" ? options2.timeoutMS : typeof this.timeoutMS === "number" ? this.timeoutMS : null;
        const wc = this.transaction.options.writeConcern ?? this.clientOptions?.writeConcern;
        if (wc != null) {
          if (timeoutMS == null && this.timeoutContext == null) {
            write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, w: "majority", ...wc });
          } else {
            const wcKeys = Object.keys(wc);
            if (wcKeys.length > 2 || !wcKeys.includes("wtimeoutMS") && !wcKeys.includes("wTimeoutMS"))
              write_concern_1.WriteConcern.apply(command, { ...wc, wtimeoutMS: void 0 });
          }
        }
        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.commitAttempted) {
          if (timeoutMS == null && this.timeoutContext == null) {
            write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, ...wc, w: "majority" });
          } else {
            write_concern_1.WriteConcern.apply(command, { w: "majority", ...wc, wtimeoutMS: void 0 });
          }
        }
        if (typeof this.transaction.options.maxTimeMS === "number") {
          command.maxTimeMS = this.transaction.options.maxTimeMS;
        }
        if (this.transaction.recoveryToken) {
          command.recoveryToken = this.transaction.recoveryToken;
        }
        const operation = new run_command_1.RunAdminCommandOperation(command, {
          session: this,
          readPreference: read_preference_1.ReadPreference.primary,
          bypassPinningCheck: true
        });
        const timeoutContext = this.timeoutContext ?? (typeof timeoutMS === "number" ? timeout_1.TimeoutContext.create({
          serverSelectionTimeoutMS: this.clientOptions.serverSelectionTimeoutMS,
          socketTimeoutMS: this.clientOptions.socketTimeoutMS,
          timeoutMS
        }) : null);
        try {
          await (0, execute_operation_1.executeOperation)(this.client, operation, timeoutContext);
          this.commitAttempted = void 0;
          return;
        } catch (firstCommitError) {
          this.commitAttempted = true;
          if (firstCommitError instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(firstCommitError)) {
            write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, ...wc, w: "majority" });
            this.unpin({ force: true });
            try {
              await (0, execute_operation_1.executeOperation)(this.client, new run_command_1.RunAdminCommandOperation(command, {
                session: this,
                readPreference: read_preference_1.ReadPreference.primary,
                bypassPinningCheck: true
              }), timeoutContext);
              return;
            } catch (retryCommitError) {
              if (shouldAddUnknownTransactionCommitResultLabel(retryCommitError)) {
                retryCommitError.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
              }
              if (shouldUnpinAfterCommitError(retryCommitError)) {
                this.unpin({ error: retryCommitError });
              }
              throw retryCommitError;
            }
          }
          if (shouldAddUnknownTransactionCommitResultLabel(firstCommitError)) {
            firstCommitError.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
          }
          if (shouldUnpinAfterCommitError(firstCommitError)) {
            this.unpin({ error: firstCommitError });
          }
          throw firstCommitError;
        } finally {
          this.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);
        }
      }
      async abortTransaction(options2) {
        if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION) {
          throw new error_1.MongoTransactionError("No transaction started");
        }
        if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
          this.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
          return;
        }
        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
          throw new error_1.MongoTransactionError("Cannot call abortTransaction twice");
        }
        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
          throw new error_1.MongoTransactionError("Cannot call abortTransaction after calling commitTransaction");
        }
        const command = { abortTransaction: 1 };
        const timeoutMS = typeof options2?.timeoutMS === "number" ? options2.timeoutMS : this.timeoutContext?.csotEnabled() ? this.timeoutContext.timeoutMS : typeof this.timeoutMS === "number" ? this.timeoutMS : null;
        const timeoutContext = timeoutMS != null ? timeout_1.TimeoutContext.create({
          timeoutMS,
          serverSelectionTimeoutMS: this.clientOptions.serverSelectionTimeoutMS,
          socketTimeoutMS: this.clientOptions.socketTimeoutMS
        }) : null;
        const wc = this.transaction.options.writeConcern ?? this.clientOptions?.writeConcern;
        if (wc != null && timeoutMS == null) {
          write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, w: "majority", ...wc });
        }
        if (this.transaction.recoveryToken) {
          command.recoveryToken = this.transaction.recoveryToken;
        }
        const operation = new run_command_1.RunAdminCommandOperation(command, {
          session: this,
          readPreference: read_preference_1.ReadPreference.primary,
          bypassPinningCheck: true
        });
        try {
          await (0, execute_operation_1.executeOperation)(this.client, operation, timeoutContext);
          this.unpin();
          return;
        } catch (firstAbortError) {
          this.unpin();
          if (firstAbortError.name === "MongoRuntimeError")
            throw firstAbortError;
          if (options2?.throwTimeout && firstAbortError.name === "MongoOperationTimeoutError") {
            throw firstAbortError;
          }
          if (firstAbortError instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(firstAbortError)) {
            try {
              await (0, execute_operation_1.executeOperation)(this.client, operation, timeoutContext);
              return;
            } catch (secondAbortError) {
              if (secondAbortError.name === "MongoRuntimeError")
                throw secondAbortError;
              if (options2?.throwTimeout && secondAbortError.name === "MongoOperationTimeoutError") {
                throw secondAbortError;
              }
            }
          }
        } finally {
          this.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
          if (this.loadBalanced) {
            maybeClearPinnedConnection(this, { force: false });
          }
        }
      }
      /**
       * This is here to ensure that ClientSession is never serialized to BSON.
       */
      toBSON() {
        throw new error_1.MongoRuntimeError("ClientSession cannot be serialized to BSON.");
      }
      /**
       * Starts a transaction and runs a provided function, ensuring the commitTransaction is always attempted when all operations run in the function have completed.
       *
       * **IMPORTANT:** This method requires the function passed in to return a Promise. That promise must be made by `await`-ing all operations in such a way that rejections are propagated to the returned promise.
       *
       * **IMPORTANT:** Running operations in parallel is not supported during a transaction. The use of `Promise.all`,
       * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is
       * undefined behaviour.
       *
       * **IMPORTANT:** When running an operation inside a `withTransaction` callback, if it is not
       * provided the explicit session in its options, it will not be part of the transaction and it will not respect timeoutMS.
       *
       *
       * @remarks
       * - If all operations successfully complete and the `commitTransaction` operation is successful, then the provided function will return the result of the provided function.
       * - If the transaction is unable to complete or an error is thrown from within the provided function, then the provided function will throw an error.
       *   - If the transaction is manually aborted within the provided function it will not throw.
       * - If the driver needs to attempt to retry the operations, the provided function may be called multiple times.
       *
       * Checkout a descriptive example here:
       * @see https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions
       *
       * If a command inside withTransaction fails:
       * - It may cause the transaction on the server to be aborted.
       * - This situation is normally handled transparently by the driver.
       * - However, if the application catches such an error and does not rethrow it, the driver will not be able to determine whether the transaction was aborted or not.
       * - The driver will then retry the transaction indefinitely.
       *
       * To avoid this situation, the application must not silently handle errors within the provided function.
       * If the application needs to handle errors within, it must await all operations such that if an operation is rejected it becomes the rejection of the callback function passed into withTransaction.
       *
       * @param fn - callback to run within a transaction
       * @param options - optional settings for the transaction
       * @returns A raw command response or undefined
       */
      async withTransaction(fn, options2) {
        const MAX_TIMEOUT = 12e4;
        const timeoutMS = options2?.timeoutMS ?? this.timeoutMS ?? null;
        this.timeoutContext = timeoutMS != null ? timeout_1.TimeoutContext.create({
          timeoutMS,
          serverSelectionTimeoutMS: this.clientOptions.serverSelectionTimeoutMS,
          socketTimeoutMS: this.clientOptions.socketTimeoutMS
        }) : null;
        const startTime = this.timeoutContext?.csotEnabled() ? this.timeoutContext.start : (0, utils_1.now)();
        let committed = false;
        let result;
        try {
          while (!committed) {
            this.startTransaction(options2);
            try {
              const promise = fn(this);
              if (!(0, utils_1.isPromiseLike)(promise)) {
                throw new error_1.MongoInvalidArgumentError("Function provided to `withTransaction` must return a Promise");
              }
              result = await promise;
              if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
                return result;
              }
            } catch (fnError) {
              if (!(fnError instanceof error_1.MongoError) || fnError instanceof error_1.MongoInvalidArgumentError) {
                await this.abortTransaction();
                throw fnError;
              }
              if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_IN_PROGRESS) {
                await this.abortTransaction();
              }
              if (fnError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && (this.timeoutContext != null || (0, utils_1.now)() - startTime < MAX_TIMEOUT)) {
                continue;
              }
              throw fnError;
            }
            while (!committed) {
              try {
                await this.commitTransaction();
                committed = true;
              } catch (commitError) {
                if (!isMaxTimeMSExpiredError(commitError) && commitError.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult) && (this.timeoutContext != null || (0, utils_1.now)() - startTime < MAX_TIMEOUT)) {
                  continue;
                }
                if (commitError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && (this.timeoutContext != null || (0, utils_1.now)() - startTime < MAX_TIMEOUT)) {
                  break;
                }
                throw commitError;
              }
            }
          }
          return result;
        } finally {
          this.timeoutContext = null;
        }
      }
    };
    exports2.ClientSession = ClientSession;
    (0, resource_management_1.configureResourceManagement)(ClientSession.prototype);
    var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = /* @__PURE__ */ new Set([
      "CannotSatisfyWriteConcern",
      "UnknownReplWriteConcern",
      "UnsatisfiableWriteConcern"
    ]);
    function shouldUnpinAfterCommitError(commitError) {
      if (commitError instanceof error_1.MongoError) {
        if ((0, error_1.isRetryableWriteError)(commitError) || commitError instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(commitError)) {
          if (isUnknownTransactionCommitResult(commitError)) {
            return true;
          }
        } else if (commitError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
          return true;
        }
      }
      return false;
    }
    function shouldAddUnknownTransactionCommitResultLabel(commitError) {
      let ok2 = (0, error_1.isRetryableWriteError)(commitError);
      ok2 ||= commitError instanceof error_1.MongoWriteConcernError;
      ok2 ||= isMaxTimeMSExpiredError(commitError);
      ok2 &&= isUnknownTransactionCommitResult(commitError);
      return ok2;
    }
    function isUnknownTransactionCommitResult(err) {
      const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);
      return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;
    }
    function maybeClearPinnedConnection(session, options2) {
      const conn = session.pinnedConnection;
      const error2 = options2?.error;
      if (session.inTransaction() && error2 && error2 instanceof error_1.MongoError && error2.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        return;
      }
      const topology = session.client.topology;
      if (conn && topology != null) {
        const servers = Array.from(topology.s.servers.values());
        const loadBalancer = servers[0];
        if (options2?.error == null || options2?.force) {
          loadBalancer.pool.checkIn(conn);
          session.pinnedConnection = void 0;
          conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
          if (options2?.forceClear) {
            loadBalancer.pool.clear({ serviceId: conn.serviceId });
          }
        }
      }
    }
    function isMaxTimeMSExpiredError(err) {
      if (err == null || !(err instanceof error_1.MongoServerError)) {
        return false;
      }
      return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
    }
    var ServerSession = class {
      /** @internal */
      constructor(cloned) {
        if (cloned != null) {
          const idBytes = Buffer.allocUnsafe(16);
          idBytes.set(cloned.id.id.buffer);
          this.id = { id: new bson_1.Binary(idBytes, cloned.id.id.sub_type) };
          this.lastUse = cloned.lastUse;
          this.txnNumber = cloned.txnNumber;
          this.isDirty = cloned.isDirty;
          return;
        }
        this.id = { id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID) };
        this.lastUse = (0, utils_1.now)();
        this.txnNumber = 0;
        this.isDirty = false;
      }
      /**
       * Determines if the server session has timed out.
       *
       * @param sessionTimeoutMinutes - The server's "logicalSessionTimeoutMinutes"
       */
      hasTimedOut(sessionTimeoutMinutes) {
        const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 864e5 % 36e5 / 6e4);
        return idleTimeMinutes > sessionTimeoutMinutes - 1;
      }
    };
    exports2.ServerSession = ServerSession;
    var ServerSessionPool = class {
      constructor(client) {
        if (client == null) {
          throw new error_1.MongoRuntimeError("ServerSessionPool requires a MongoClient");
        }
        this.client = client;
        this.sessions = new utils_1.List();
      }
      /**
       * Acquire a Server Session from the pool.
       * Iterates through each session in the pool, removing any stale sessions
       * along the way. The first non-stale session found is removed from the
       * pool and returned. If no non-stale session is found, a new ServerSession is created.
       */
      acquire() {
        const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;
        let session = null;
        while (this.sessions.length > 0) {
          const potentialSession = this.sessions.shift();
          if (potentialSession != null && (!!this.client.topology?.loadBalanced || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {
            session = potentialSession;
            break;
          }
        }
        if (session == null) {
          session = new ServerSession();
        }
        return session;
      }
      /**
       * Release a session to the session pool
       * Adds the session back to the session pool if the session has not timed out yet.
       * This method also removes any stale sessions from the pool.
       *
       * @param session - The session to release to the pool
       */
      release(session) {
        const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;
        if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {
          this.sessions.unshift(session);
        }
        if (!sessionTimeoutMinutes) {
          return;
        }
        this.sessions.prune((session2) => session2.hasTimedOut(sessionTimeoutMinutes));
        if (!session.hasTimedOut(sessionTimeoutMinutes)) {
          if (session.isDirty) {
            return;
          }
          this.sessions.unshift(session);
        }
      }
    };
    exports2.ServerSessionPool = ServerSessionPool;
    function applySession(session, command, options2) {
      if (session.hasEnded) {
        return new error_1.MongoExpiredSessionError();
      }
      const serverSession = session.serverSession;
      if (serverSession == null) {
        return new error_1.MongoRuntimeError("Unable to acquire server session");
      }
      if (options2.writeConcern?.w === 0) {
        if (session && session.explicit) {
          return new error_1.MongoAPIError("Cannot have explicit session with unacknowledged writes");
        }
        return;
      }
      serverSession.lastUse = (0, utils_1.now)();
      command.lsid = serverSession.id;
      const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);
      const isRetryableWrite = !!options2.willRetryWrite;
      if (isRetryableWrite || inTxnOrTxnCommand) {
        serverSession.txnNumber += session.txnNumberIncrement;
        session.txnNumberIncrement = 0;
        command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);
      }
      if (!inTxnOrTxnCommand) {
        if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {
          session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);
        }
        if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command)) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        } else if (session.snapshotEnabled) {
          command.readConcern = command.readConcern || { level: read_concern_1.ReadConcernLevel.snapshot };
          if (session.snapshotTime != null) {
            Object.assign(command.readConcern, { atClusterTime: session.snapshotTime });
          }
        }
        return;
      }
      command.autocommit = false;
      if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);
        command.startTransaction = true;
        const readConcern = session.transaction.options.readConcern || session?.clientOptions?.readConcern;
        if (readConcern) {
          command.readConcern = readConcern;
        }
        if (session.supports.causalConsistency && session.operationTime) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
      }
      return;
    }
    function updateSessionFromResponse(session, document2) {
      if (document2.$clusterTime) {
        (0, common_1._advanceClusterTime)(session, document2.$clusterTime);
      }
      if (document2.operationTime && session && session.supports.causalConsistency) {
        session.advanceOperationTime(document2.operationTime);
      }
      if (document2.recoveryToken && session && session.inTransaction()) {
        session.transaction._recoveryToken = document2.recoveryToken;
      }
      if (session?.snapshotEnabled && session.snapshotTime == null) {
        const atClusterTime = document2.atClusterTime;
        if (atClusterTime) {
          session.snapshotTime = atClusterTime;
        }
      }
    }
  }
});

// node_modules/mongodb/lib/cmap/command_monitoring_events.js
var require_command_monitoring_events = __commonJS({
  "node_modules/mongodb/lib/cmap/command_monitoring_events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SENSITIVE_COMMANDS = exports2.CommandFailedEvent = exports2.CommandSucceededEvent = exports2.CommandStartedEvent = void 0;
    var constants_1 = require_constants4();
    var utils_1 = require_utils5();
    var commands_1 = require_commands();
    var CommandStartedEvent = class {
      /**
       * Create a started event
       *
       * @internal
       * @param pool - the pool that originated the command
       * @param command - the command
       */
      constructor(connection, command, serverConnectionId) {
        this.name = constants_1.COMMAND_STARTED;
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const { address, connectionId, serviceId } = extractConnectionDetails(connection);
        if (exports2.SENSITIVE_COMMANDS.has(commandName)) {
          this.commandObj = {};
          this.commandObj[commandName] = true;
        }
        this.address = address;
        this.connectionId = connectionId;
        this.serviceId = serviceId;
        this.requestId = command.requestId;
        this.databaseName = command.databaseName;
        this.commandName = commandName;
        this.command = maybeRedact(commandName, cmd, cmd);
        this.serverConnectionId = serverConnectionId;
      }
      /* @internal */
      get hasServiceId() {
        return !!this.serviceId;
      }
    };
    exports2.CommandStartedEvent = CommandStartedEvent;
    var CommandSucceededEvent = class {
      /**
       * Create a succeeded event
       *
       * @internal
       * @param pool - the pool that originated the command
       * @param command - the command
       * @param reply - the reply for this command from the server
       * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration
       */
      constructor(connection, command, reply, started, serverConnectionId) {
        this.name = constants_1.COMMAND_SUCCEEDED;
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const { address, connectionId, serviceId } = extractConnectionDetails(connection);
        this.address = address;
        this.connectionId = connectionId;
        this.serviceId = serviceId;
        this.requestId = command.requestId;
        this.commandName = commandName;
        this.duration = (0, utils_1.calculateDurationInMs)(started);
        this.reply = maybeRedact(commandName, cmd, extractReply(reply));
        this.serverConnectionId = serverConnectionId;
      }
      /* @internal */
      get hasServiceId() {
        return !!this.serviceId;
      }
    };
    exports2.CommandSucceededEvent = CommandSucceededEvent;
    var CommandFailedEvent = class {
      /**
       * Create a failure event
       *
       * @internal
       * @param pool - the pool that originated the command
       * @param command - the command
       * @param error - the generated error or a server error response
       * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration
       */
      constructor(connection, command, error2, started, serverConnectionId) {
        this.name = constants_1.COMMAND_FAILED;
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const { address, connectionId, serviceId } = extractConnectionDetails(connection);
        this.address = address;
        this.connectionId = connectionId;
        this.serviceId = serviceId;
        this.requestId = command.requestId;
        this.commandName = commandName;
        this.duration = (0, utils_1.calculateDurationInMs)(started);
        this.failure = maybeRedact(commandName, cmd, error2);
        this.serverConnectionId = serverConnectionId;
      }
      /* @internal */
      get hasServiceId() {
        return !!this.serviceId;
      }
    };
    exports2.CommandFailedEvent = CommandFailedEvent;
    exports2.SENSITIVE_COMMANDS = /* @__PURE__ */ new Set([
      "authenticate",
      "saslStart",
      "saslContinue",
      "getnonce",
      "createUser",
      "updateUser",
      "copydbgetnonce",
      "copydbsaslstart",
      "copydb"
    ]);
    var HELLO_COMMANDS = /* @__PURE__ */ new Set(["hello", constants_1.LEGACY_HELLO_COMMAND, constants_1.LEGACY_HELLO_COMMAND_CAMEL_CASE]);
    var extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];
    var collectionName = (command) => command.ns.split(".")[1];
    var maybeRedact = (commandName, commandDoc, result) => exports2.SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate ? {} : result;
    var LEGACY_FIND_QUERY_MAP = {
      $query: "filter",
      $orderby: "sort",
      $hint: "hint",
      $comment: "comment",
      $maxScan: "maxScan",
      $max: "max",
      $min: "min",
      $returnKey: "returnKey",
      $showDiskLoc: "showRecordId",
      $maxTimeMS: "maxTimeMS",
      $snapshot: "snapshot"
    };
    var LEGACY_FIND_OPTIONS_MAP = {
      numberToSkip: "skip",
      numberToReturn: "batchSize",
      returnFieldSelector: "projection"
    };
    function extractCommand(command) {
      if (command instanceof commands_1.OpMsgRequest) {
        const cmd = { ...command.command };
        if (cmd.ops instanceof commands_1.DocumentSequence) {
          cmd.ops = cmd.ops.documents;
        }
        if (cmd.nsInfo instanceof commands_1.DocumentSequence) {
          cmd.nsInfo = cmd.nsInfo.documents;
        }
        return cmd;
      }
      if (command.query?.$query) {
        let result;
        if (command.ns === "admin.$cmd") {
          result = Object.assign({}, command.query.$query);
        } else {
          result = { find: collectionName(command) };
          Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
            if (command.query[key] != null) {
              result[LEGACY_FIND_QUERY_MAP[key]] = { ...command.query[key] };
            }
          });
        }
        Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
          const legacyKey = key;
          if (command[legacyKey] != null) {
            result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = command[legacyKey];
          }
        });
        return result;
      }
      let clonedQuery = {};
      const clonedCommand = { ...command };
      if (command.query) {
        clonedQuery = { ...command.query };
        clonedCommand.query = clonedQuery;
      }
      return command.query ? clonedQuery : clonedCommand;
    }
    function extractReply(reply) {
      if (!reply) {
        return reply;
      }
      return reply.result ? reply.result : reply;
    }
    function extractConnectionDetails(connection) {
      let connectionId;
      if ("id" in connection) {
        connectionId = connection.id;
      }
      return {
        address: connection.address,
        serviceId: connection.serviceId,
        connectionId
      };
    }
  }
});

// node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS({
  "node_modules/mongodb/lib/cmap/stream_description.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamDescription = void 0;
    var bson_1 = require_bson2();
    var common_1 = require_common2();
    var server_description_1 = require_server_description();
    var RESPONSE_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "logicalSessionTimeoutMinutes"
    ];
    var StreamDescription = class {
      constructor(address, options2) {
        this.hello = null;
        this.address = address;
        this.type = common_1.ServerType.Unknown;
        this.minWireVersion = void 0;
        this.maxWireVersion = void 0;
        this.maxBsonObjectSize = 16777216;
        this.maxMessageSizeBytes = 48e6;
        this.maxWriteBatchSize = 1e5;
        this.logicalSessionTimeoutMinutes = options2?.logicalSessionTimeoutMinutes;
        this.loadBalanced = !!options2?.loadBalanced;
        this.compressors = options2 && options2.compressors && Array.isArray(options2.compressors) ? options2.compressors : [];
        this.serverConnectionId = null;
      }
      receiveResponse(response) {
        if (response == null) {
          return;
        }
        this.hello = response;
        this.type = (0, server_description_1.parseServerType)(response);
        if ("connectionId" in response) {
          this.serverConnectionId = this.parseServerConnectionID(response.connectionId);
        } else {
          this.serverConnectionId = null;
        }
        for (const field of RESPONSE_FIELDS) {
          if (response[field] != null) {
            this[field] = response[field];
          }
          if ("__nodejs_mock_server__" in response) {
            this.__nodejs_mock_server__ = response["__nodejs_mock_server__"];
          }
        }
        if (response.compression) {
          this.compressor = this.compressors.filter((c) => response.compression?.includes(c))[0];
        }
      }
      /* @internal */
      parseServerConnectionID(serverConnectionId) {
        return bson_1.Long.isLong(serverConnectionId) ? serverConnectionId.toBigInt() : (
          // @ts-expect-error: Doubles are coercible to number
          BigInt(serverConnectionId)
        );
      }
    };
    exports2.StreamDescription = StreamDescription;
  }
});

// node_modules/mongodb/lib/cmap/wire_protocol/on_data.js
var require_on_data = __commonJS({
  "node_modules/mongodb/lib/cmap/wire_protocol/on_data.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.onData = onData;
    var utils_1 = require_utils5();
    function onData(emitter, { timeoutContext, signal }) {
      signal?.throwIfAborted();
      const unconsumedEvents = new utils_1.List();
      const unconsumedPromises = new utils_1.List();
      let error2 = null;
      let finished = false;
      const iterator = {
        next() {
          const value = unconsumedEvents.shift();
          if (value != null) {
            return Promise.resolve({ value, done: false });
          }
          if (error2 != null) {
            const p = Promise.reject(error2);
            error2 = null;
            return p;
          }
          if (finished)
            return closeHandler();
          const { promise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
          unconsumedPromises.push({ resolve, reject });
          return promise;
        },
        return() {
          return closeHandler();
        },
        throw(err) {
          errorHandler(err);
          return Promise.resolve({ value: void 0, done: true });
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
      emitter.on("data", eventHandler);
      emitter.on("error", errorHandler);
      const abortListener = (0, utils_1.addAbortListener)(signal, function() {
        errorHandler(this.reason);
      });
      const timeoutForSocketRead = timeoutContext?.timeoutForSocketRead;
      timeoutForSocketRead?.throwIfExpired();
      timeoutForSocketRead?.then(void 0, errorHandler);
      return iterator;
      function eventHandler(value) {
        const promise = unconsumedPromises.shift();
        if (promise != null)
          promise.resolve({ value, done: false });
        else
          unconsumedEvents.push(value);
      }
      function errorHandler(err) {
        const promise = unconsumedPromises.shift();
        if (promise != null)
          promise.reject(err);
        else
          error2 = err;
        void closeHandler();
      }
      function closeHandler() {
        emitter.off("data", eventHandler);
        emitter.off("error", errorHandler);
        abortListener?.[utils_1.kDispose]();
        finished = true;
        timeoutForSocketRead?.clear();
        const doneResult = { value: void 0, done: finished };
        for (const promise of unconsumedPromises) {
          promise.resolve(doneResult);
        }
        return Promise.resolve(doneResult);
      }
    }
  }
});

// node_modules/mongodb/lib/cmap/connection.js
var require_connection = __commonJS({
  "node_modules/mongodb/lib/cmap/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CryptoConnection = exports2.SizedMessageTransform = exports2.Connection = void 0;
    exports2.hasSessionSupport = hasSessionSupport;
    var stream_1 = require("stream");
    var timers_1 = require("timers");
    var bson_1 = require_bson2();
    var constants_1 = require_constants4();
    var error_1 = require_error();
    var mongo_logger_1 = require_mongo_logger();
    var mongo_types_1 = require_mongo_types();
    var read_preference_1 = require_read_preference();
    var common_1 = require_common2();
    var sessions_1 = require_sessions();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils5();
    var command_monitoring_events_1 = require_command_monitoring_events();
    var commands_1 = require_commands();
    var stream_description_1 = require_stream_description();
    var compression_1 = require_compression();
    var on_data_1 = require_on_data();
    var responses_1 = require_responses();
    var shared_1 = require_shared();
    function hasSessionSupport(conn) {
      const description = conn.description;
      return description.logicalSessionTimeoutMinutes != null;
    }
    function streamIdentifier(stream, options2) {
      if (options2.proxyHost) {
        return options2.hostAddress.toString();
      }
      const { remoteAddress, remotePort } = stream;
      if (typeof remoteAddress === "string" && typeof remotePort === "number") {
        return utils_1.HostAddress.fromHostPort(remoteAddress, remotePort).toString();
      }
      return (0, utils_1.uuidV4)().toString("hex");
    }
    var Connection = class _Connection extends mongo_types_1.TypedEventEmitter {
      constructor(stream, options2) {
        super();
        this.lastHelloMS = -1;
        this.helloOk = false;
        this.delayedTimeoutId = null;
        this.closed = false;
        this.clusterTime = null;
        this.error = null;
        this.dataEvents = null;
        this.on("error", utils_1.noop);
        this.socket = stream;
        this.id = options2.id;
        this.address = streamIdentifier(stream, options2);
        this.socketTimeoutMS = options2.socketTimeoutMS ?? 0;
        this.monitorCommands = options2.monitorCommands;
        this.serverApi = options2.serverApi;
        this.mongoLogger = options2.mongoLogger;
        this.established = false;
        this.description = new stream_description_1.StreamDescription(this.address, options2);
        this.generation = options2.generation;
        this.lastUseTime = (0, utils_1.now)();
        this.messageStream = this.socket.on("error", this.onSocketError.bind(this)).pipe(new SizedMessageTransform({ connection: this })).on("error", this.onTransformError.bind(this));
        this.socket.on("close", this.onClose.bind(this));
        this.socket.on("timeout", this.onTimeout.bind(this));
        this.messageStream.pause();
      }
      get hello() {
        return this.description.hello;
      }
      // the `connect` method stores the result of the handshake hello on the connection
      set hello(response) {
        this.description.receiveResponse(response);
        Object.freeze(this.description);
      }
      get serviceId() {
        return this.hello?.serviceId;
      }
      get loadBalanced() {
        return this.description.loadBalanced;
      }
      get idleTime() {
        return (0, utils_1.calculateDurationInMs)(this.lastUseTime);
      }
      get hasSessionSupport() {
        return this.description.logicalSessionTimeoutMinutes != null;
      }
      get supportsOpMsg() {
        return this.description != null && (0, utils_1.maxWireVersion)(this) >= 6 && !this.description.__nodejs_mock_server__;
      }
      get shouldEmitAndLogCommand() {
        return (this.monitorCommands || this.established && !this.authContext?.reauthenticating && this.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.COMMAND, mongo_logger_1.SeverityLevel.DEBUG)) ?? false;
      }
      markAvailable() {
        this.lastUseTime = (0, utils_1.now)();
      }
      onSocketError(cause) {
        this.onError(new error_1.MongoNetworkError(cause.message, { cause }));
      }
      onTransformError(error2) {
        this.onError(error2);
      }
      onError(error2) {
        this.cleanup(error2);
      }
      onClose() {
        const message = `connection ${this.id} to ${this.address} closed`;
        this.cleanup(new error_1.MongoNetworkError(message));
      }
      onTimeout() {
        this.delayedTimeoutId = (0, timers_1.setTimeout)(() => {
          const message = `connection ${this.id} to ${this.address} timed out`;
          const beforeHandshake = this.hello == null;
          this.cleanup(new error_1.MongoNetworkTimeoutError(message, { beforeHandshake }));
        }, 1).unref();
      }
      destroy() {
        if (this.closed) {
          return;
        }
        this.removeAllListeners(_Connection.PINNED);
        this.removeAllListeners(_Connection.UNPINNED);
        const message = `connection ${this.id} to ${this.address} closed`;
        this.cleanup(new error_1.MongoNetworkError(message));
      }
      /**
       * A method that cleans up the connection.  When `force` is true, this method
       * forcibly destroys the socket.
       *
       * If an error is provided, any in-flight operations will be closed with the error.
       *
       * This method does nothing if the connection is already closed.
       */
      cleanup(error2) {
        if (this.closed) {
          return;
        }
        this.socket.destroy();
        this.error = error2;
        this.dataEvents?.throw(error2).then(void 0, utils_1.squashError);
        this.closed = true;
        this.emit(_Connection.CLOSE);
      }
      prepareCommand(db, command, options2) {
        let cmd = { ...command };
        const readPreference = (0, shared_1.getReadPreference)(options2);
        const session = options2?.session;
        let clusterTime = this.clusterTime;
        if (this.serverApi) {
          const { version, strict, deprecationErrors } = this.serverApi;
          cmd.apiVersion = version;
          if (strict != null)
            cmd.apiStrict = strict;
          if (deprecationErrors != null)
            cmd.apiDeprecationErrors = deprecationErrors;
        }
        if (this.hasSessionSupport && session) {
          if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {
            clusterTime = session.clusterTime;
          }
          const sessionError = (0, sessions_1.applySession)(session, cmd, options2);
          if (sessionError)
            throw sessionError;
        } else if (session?.explicit) {
          throw new error_1.MongoCompatibilityError("Current topology does not support sessions");
        }
        if (clusterTime) {
          cmd.$clusterTime = clusterTime;
        }
        if (this.description.type !== common_1.ServerType.Standalone) {
          if (!(0, shared_1.isSharded)(this) && !this.description.loadBalanced && this.supportsOpMsg && options2.directConnection === true && readPreference?.mode === "primary") {
            cmd.$readPreference = read_preference_1.ReadPreference.primaryPreferred.toJSON();
          } else if ((0, shared_1.isSharded)(this) && !this.supportsOpMsg && readPreference?.mode !== "primary") {
            cmd = {
              $query: cmd,
              $readPreference: readPreference.toJSON()
            };
          } else if (readPreference?.mode !== "primary") {
            cmd.$readPreference = readPreference.toJSON();
          }
        }
        const commandOptions = {
          numberToSkip: 0,
          numberToReturn: -1,
          checkKeys: false,
          // This value is not overridable
          secondaryOk: readPreference.secondaryOk(),
          ...options2
        };
        options2.timeoutContext?.addMaxTimeMSToCommand(cmd, options2);
        const message = this.supportsOpMsg ? new commands_1.OpMsgRequest(db, cmd, commandOptions) : new commands_1.OpQueryRequest(db, cmd, commandOptions);
        return message;
      }
      async *sendWire(message, options2, responseType) {
        this.throwIfAborted();
        const timeout = options2.socketTimeoutMS ?? options2?.timeoutContext?.getSocketTimeoutMS() ?? this.socketTimeoutMS;
        this.socket.setTimeout(timeout);
        try {
          await this.writeCommand(message, {
            agreedCompressor: this.description.compressor ?? "none",
            zlibCompressionLevel: this.description.zlibCompressionLevel,
            timeoutContext: options2.timeoutContext,
            signal: options2.signal
          });
          if (options2.noResponse || message.moreToCome) {
            yield responses_1.MongoDBResponse.empty;
            return;
          }
          this.throwIfAborted();
          if (options2.timeoutContext?.csotEnabled() && options2.timeoutContext.minRoundTripTime != null && options2.timeoutContext.remainingTimeMS < options2.timeoutContext.minRoundTripTime) {
            throw new error_1.MongoOperationTimeoutError("Server roundtrip time is greater than the time remaining");
          }
          for await (const response of this.readMany(options2)) {
            this.socket.setTimeout(0);
            const bson = response.parse();
            const document2 = (responseType ?? responses_1.MongoDBResponse).make(bson);
            yield document2;
            this.throwIfAborted();
            this.socket.setTimeout(timeout);
          }
        } finally {
          this.socket.setTimeout(0);
        }
      }
      async *sendCommand(ns, command, options2, responseType) {
        options2?.signal?.throwIfAborted();
        const message = this.prepareCommand(ns.db, command, options2);
        let started = 0;
        if (this.shouldEmitAndLogCommand) {
          started = (0, utils_1.now)();
          this.emitAndLogCommand(this.monitorCommands, _Connection.COMMAND_STARTED, message.databaseName, this.established, new command_monitoring_events_1.CommandStartedEvent(this, message, this.description.serverConnectionId));
        }
        const bsonOptions = options2.documentsReturnedIn == null || !options2.raw ? options2 : {
          ...options2,
          raw: false,
          fieldsAsRaw: { [options2.documentsReturnedIn]: true }
        };
        let document2 = void 0;
        let object = void 0;
        try {
          this.throwIfAborted();
          for await (document2 of this.sendWire(message, options2, responseType)) {
            object = void 0;
            if (options2.session != null) {
              (0, sessions_1.updateSessionFromResponse)(options2.session, document2);
            }
            if (document2.$clusterTime) {
              this.clusterTime = document2.$clusterTime;
              this.emit(_Connection.CLUSTER_TIME_RECEIVED, document2.$clusterTime);
            }
            if (document2.ok === 0) {
              if (options2.timeoutContext?.csotEnabled() && document2.isMaxTimeExpiredError) {
                throw new error_1.MongoOperationTimeoutError("Server reported a timeout error", {
                  cause: new error_1.MongoServerError(object ??= document2.toObject(bsonOptions))
                });
              }
              throw new error_1.MongoServerError(object ??= document2.toObject(bsonOptions));
            }
            if (this.shouldEmitAndLogCommand) {
              this.emitAndLogCommand(this.monitorCommands, _Connection.COMMAND_SUCCEEDED, message.databaseName, this.established, new command_monitoring_events_1.CommandSucceededEvent(this, message, options2.noResponse ? void 0 : message.moreToCome ? { ok: 1 } : object ??= document2.toObject(bsonOptions), started, this.description.serverConnectionId));
            }
            if (responseType == null) {
              yield object ??= document2.toObject(bsonOptions);
            } else {
              yield document2;
            }
            this.throwIfAborted();
          }
        } catch (error2) {
          if (this.shouldEmitAndLogCommand) {
            this.emitAndLogCommand(this.monitorCommands, _Connection.COMMAND_FAILED, message.databaseName, this.established, new command_monitoring_events_1.CommandFailedEvent(this, message, error2, started, this.description.serverConnectionId));
          }
          throw error2;
        }
      }
      async command(ns, command, options2 = {}, responseType) {
        this.throwIfAborted();
        options2.signal?.throwIfAborted();
        for await (const document2 of this.sendCommand(ns, command, options2, responseType)) {
          if (options2.timeoutContext?.csotEnabled()) {
            if (responses_1.MongoDBResponse.is(document2)) {
              if (document2.isMaxTimeExpiredError) {
                throw new error_1.MongoOperationTimeoutError("Server reported a timeout error", {
                  cause: new error_1.MongoServerError(document2.toObject())
                });
              }
            } else {
              if (Array.isArray(document2?.writeErrors) && document2.writeErrors.some((error2) => error2?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired) || document2?.writeConcernError?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired) {
                throw new error_1.MongoOperationTimeoutError("Server reported a timeout error", {
                  cause: new error_1.MongoServerError(document2)
                });
              }
            }
          }
          return document2;
        }
        throw new error_1.MongoUnexpectedServerResponseError("Unable to get response from server");
      }
      exhaustCommand(ns, command, options2, replyListener) {
        const exhaustLoop = async () => {
          this.throwIfAborted();
          for await (const reply of this.sendCommand(ns, command, options2)) {
            replyListener(void 0, reply);
            this.throwIfAborted();
          }
          throw new error_1.MongoUnexpectedServerResponseError("Server ended moreToCome unexpectedly");
        };
        exhaustLoop().then(void 0, replyListener);
      }
      throwIfAborted() {
        if (this.error)
          throw this.error;
      }
      /**
       * @internal
       *
       * Writes an OP_MSG or OP_QUERY request to the socket, optionally compressing the command. This method
       * waits until the socket's buffer has emptied (the Nodejs socket `drain` event has fired).
       */
      async writeCommand(command, options2) {
        const finalCommand = options2.agreedCompressor === "none" || !commands_1.OpCompressedRequest.canCompress(command) ? command : new commands_1.OpCompressedRequest(command, {
          agreedCompressor: options2.agreedCompressor ?? "none",
          zlibCompressionLevel: options2.zlibCompressionLevel ?? 0
        });
        const buffer = Buffer.concat(await finalCommand.toBin());
        if (options2.timeoutContext?.csotEnabled()) {
          if (options2.timeoutContext.minRoundTripTime != null && options2.timeoutContext.remainingTimeMS < options2.timeoutContext.minRoundTripTime) {
            throw new error_1.MongoOperationTimeoutError("Server roundtrip time is greater than the time remaining");
          }
        }
        if (this.socket.write(buffer))
          return;
        const drainEvent = (0, utils_1.once)(this.socket, "drain", options2);
        const timeout = options2?.timeoutContext?.timeoutForSocketWrite;
        const drained = timeout ? Promise.race([drainEvent, timeout]) : drainEvent;
        try {
          return await drained;
        } catch (writeError) {
          if (timeout_1.TimeoutError.is(writeError)) {
            const timeoutError = new error_1.MongoOperationTimeoutError("Timed out at socket write");
            this.onError(timeoutError);
            throw timeoutError;
          } else if (writeError === options2.signal?.reason) {
            this.onError(writeError);
          }
          throw writeError;
        } finally {
          timeout?.clear();
        }
      }
      /**
       * @internal
       *
       * Returns an async generator that yields full wire protocol messages from the underlying socket.  This function
       * yields messages until `moreToCome` is false or not present in a response, or the caller cancels the request
       * by calling `return` on the generator.
       *
       * Note that `for-await` loops call `return` automatically when the loop is exited.
       */
      async *readMany(options2) {
        try {
          this.dataEvents = (0, on_data_1.onData)(this.messageStream, options2);
          this.messageStream.resume();
          for await (const message of this.dataEvents) {
            const response = await (0, compression_1.decompressResponse)(message);
            yield response;
            if (!response.moreToCome) {
              return;
            }
          }
        } catch (readError) {
          if (timeout_1.TimeoutError.is(readError)) {
            const timeoutError = new error_1.MongoOperationTimeoutError(`Timed out during socket read (${readError.duration}ms)`);
            this.dataEvents = null;
            this.onError(timeoutError);
            throw timeoutError;
          } else if (readError === options2.signal?.reason) {
            this.onError(readError);
          }
          throw readError;
        } finally {
          this.dataEvents = null;
          this.messageStream.pause();
        }
      }
    };
    exports2.Connection = Connection;
    Connection.COMMAND_STARTED = constants_1.COMMAND_STARTED;
    Connection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;
    Connection.COMMAND_FAILED = constants_1.COMMAND_FAILED;
    Connection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;
    Connection.CLOSE = constants_1.CLOSE;
    Connection.PINNED = constants_1.PINNED;
    Connection.UNPINNED = constants_1.UNPINNED;
    var SizedMessageTransform = class extends stream_1.Transform {
      constructor({ connection }) {
        super({ writableObjectMode: false, readableObjectMode: true });
        this.bufferPool = new utils_1.BufferPool();
        this.connection = connection;
      }
      _transform(chunk, encoding, callback) {
        if (this.connection.delayedTimeoutId != null) {
          (0, timers_1.clearTimeout)(this.connection.delayedTimeoutId);
          this.connection.delayedTimeoutId = null;
        }
        this.bufferPool.append(chunk);
        while (this.bufferPool.length) {
          const sizeOfMessage = this.bufferPool.getInt32();
          if (sizeOfMessage == null) {
            break;
          }
          if (sizeOfMessage < 0) {
            return callback(new error_1.MongoParseError(`Message size cannot be negative: ${sizeOfMessage}`));
          }
          if (sizeOfMessage > this.bufferPool.length) {
            break;
          }
          const message = this.bufferPool.read(sizeOfMessage);
          if (!this.push(message)) {
            return callback(new error_1.MongoRuntimeError(`SizedMessageTransform does not support backpressure`));
          }
        }
        callback();
      }
    };
    exports2.SizedMessageTransform = SizedMessageTransform;
    var CryptoConnection = class extends Connection {
      constructor(stream, options2) {
        super(stream, options2);
        this.autoEncrypter = options2.autoEncrypter;
      }
      async command(ns, cmd, options2, responseType) {
        const { autoEncrypter } = this;
        if (!autoEncrypter) {
          throw new error_1.MongoMissingDependencyError("No AutoEncrypter available for encryption", {
            dependencyName: "n/a"
          });
        }
        const serverWireVersion = (0, utils_1.maxWireVersion)(this);
        if (serverWireVersion === 0) {
          return await super.command(ns, cmd, options2, responseType);
        }
        if (serverWireVersion < 8) {
          throw new error_1.MongoCompatibilityError("Auto-encryption requires a minimum MongoDB version of 4.2");
        }
        const sort = cmd.find || cmd.findAndModify ? cmd.sort : null;
        const indexKeys = cmd.createIndexes ? cmd.indexes.map((index) => index.key) : null;
        const encrypted = await autoEncrypter.encrypt(ns.toString(), cmd, options2);
        if (sort != null && (cmd.find || cmd.findAndModify)) {
          encrypted.sort = sort;
        }
        if (indexKeys != null && cmd.createIndexes) {
          for (const [offset, index] of indexKeys.entries()) {
            encrypted.indexes[offset].key = index;
          }
        }
        const encryptedResponse = await super.command(
          ns,
          encrypted,
          options2,
          // Eventually we want to require `responseType` which means we would satisfy `T` as the return type.
          // In the meantime, we want encryptedResponse to always be _at least_ a MongoDBResponse if not a more specific subclass
          // So that we can ensure we have access to the on-demand APIs for decorate response
          responseType ?? responses_1.MongoDBResponse
        );
        const result = await autoEncrypter.decrypt(encryptedResponse.toBytes(), options2);
        const decryptedResponse = responseType?.make(result) ?? (0, bson_1.deserialize)(result, options2);
        if (autoEncrypter[constants_1.kDecorateResult]) {
          if (responseType == null) {
            (0, utils_1.decorateDecryptionResult)(decryptedResponse, encryptedResponse.toObject(), true);
          } else if (decryptedResponse instanceof responses_1.CursorResponse) {
            decryptedResponse.encryptedResponse = encryptedResponse;
          }
        }
        return decryptedResponse;
      }
    };
    exports2.CryptoConnection = CryptoConnection;
  }
});

// node_modules/mongodb/lib/cmap/connect.js
var require_connect = __commonJS({
  "node_modules/mongodb/lib/cmap/connect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LEGAL_TCP_SOCKET_OPTIONS = exports2.LEGAL_TLS_SOCKET_OPTIONS = void 0;
    exports2.connect = connect;
    exports2.makeConnection = makeConnection;
    exports2.performInitialHandshake = performInitialHandshake;
    exports2.prepareHandshakeDocument = prepareHandshakeDocument;
    exports2.makeSocket = makeSocket;
    var net = require("net");
    var tls = require("tls");
    var constants_1 = require_constants4();
    var deps_1 = require_deps();
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var auth_provider_1 = require_auth_provider();
    var providers_1 = require_providers();
    var connection_1 = require_connection();
    var constants_2 = require_constants3();
    async function connect(options2) {
      let connection = null;
      try {
        const socket = await makeSocket(options2);
        connection = makeConnection(options2, socket);
        await performInitialHandshake(connection, options2);
        return connection;
      } catch (error2) {
        connection?.destroy();
        throw error2;
      }
    }
    function makeConnection(options2, socket) {
      let ConnectionType = options2.connectionType ?? connection_1.Connection;
      if (options2.autoEncrypter) {
        ConnectionType = connection_1.CryptoConnection;
      }
      return new ConnectionType(socket, options2);
    }
    function checkSupportedServer(hello, options2) {
      const maxWireVersion = Number(hello.maxWireVersion);
      const minWireVersion = Number(hello.minWireVersion);
      const serverVersionHighEnough = !Number.isNaN(maxWireVersion) && maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;
      const serverVersionLowEnough = !Number.isNaN(minWireVersion) && minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;
      if (serverVersionHighEnough) {
        if (serverVersionLowEnough) {
          return null;
        }
        const message2 = `Server at ${options2.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;
        return new error_1.MongoCompatibilityError(message2);
      }
      const message = `Server at ${options2.hostAddress} reports maximum wire version ${JSON.stringify(hello.maxWireVersion) ?? 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;
      return new error_1.MongoCompatibilityError(message);
    }
    async function performInitialHandshake(conn, options2) {
      const credentials = options2.credentials;
      if (credentials) {
        if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !options2.authProviders.getOrCreateProvider(credentials.mechanism, credentials.mechanismProperties)) {
          throw new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`);
        }
      }
      const authContext = new auth_provider_1.AuthContext(conn, credentials, options2);
      conn.authContext = authContext;
      const handshakeDoc = await prepareHandshakeDocument(authContext);
      const handshakeOptions = { ...options2, raw: false };
      if (typeof options2.connectTimeoutMS === "number") {
        handshakeOptions.socketTimeoutMS = options2.connectTimeoutMS;
      }
      const start = (/* @__PURE__ */ new Date()).getTime();
      const response = await executeHandshake(handshakeDoc, handshakeOptions);
      if (!("isWritablePrimary" in response)) {
        response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];
      }
      if (response.helloOk) {
        conn.helloOk = true;
      }
      const supportedServerErr = checkSupportedServer(response, options2);
      if (supportedServerErr) {
        throw supportedServerErr;
      }
      if (options2.loadBalanced) {
        if (!response.serviceId) {
          throw new error_1.MongoCompatibilityError("Driver attempted to initialize in load balancing mode, but the server does not support this mode.");
        }
      }
      conn.hello = response;
      conn.lastHelloMS = (/* @__PURE__ */ new Date()).getTime() - start;
      if (!response.arbiterOnly && credentials) {
        authContext.response = response;
        const resolvedCredentials = credentials.resolveAuthMechanism(response);
        const provider = options2.authProviders.getOrCreateProvider(resolvedCredentials.mechanism, resolvedCredentials.mechanismProperties);
        if (!provider) {
          throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`);
        }
        try {
          await provider.auth(authContext);
        } catch (error2) {
          if (error2 instanceof error_1.MongoError) {
            error2.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);
            if ((0, error_1.needsRetryableWriteLabel)(error2, response.maxWireVersion, conn.description.type)) {
              error2.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
            }
          }
          throw error2;
        }
      }
      conn.established = true;
      async function executeHandshake(handshakeDoc2, handshakeOptions2) {
        try {
          const handshakeResponse = await conn.command((0, utils_1.ns)("admin.$cmd"), handshakeDoc2, handshakeOptions2);
          return handshakeResponse;
        } catch (error2) {
          if (error2 instanceof error_1.MongoError) {
            error2.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);
          }
          throw error2;
        }
      }
    }
    async function prepareHandshakeDocument(authContext) {
      const options2 = authContext.options;
      const compressors = options2.compressors ? options2.compressors : [];
      const { serverApi } = authContext.connection;
      const clientMetadata = await options2.extendedMetadata;
      const handshakeDoc = {
        [serverApi?.version || options2.loadBalanced === true ? "hello" : constants_1.LEGACY_HELLO_COMMAND]: 1,
        helloOk: true,
        client: clientMetadata,
        compression: compressors
      };
      if (options2.loadBalanced === true) {
        handshakeDoc.loadBalanced = true;
      }
      const credentials = authContext.credentials;
      if (credentials) {
        if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {
          handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;
          const provider2 = authContext.options.authProviders.getOrCreateProvider(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, credentials.mechanismProperties);
          if (!provider2) {
            throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`);
          }
          return await provider2.prepare(handshakeDoc, authContext);
        }
        const provider = authContext.options.authProviders.getOrCreateProvider(credentials.mechanism, credentials.mechanismProperties);
        if (!provider) {
          throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`);
        }
        return await provider.prepare(handshakeDoc, authContext);
      }
      return handshakeDoc;
    }
    exports2.LEGAL_TLS_SOCKET_OPTIONS = [
      "allowPartialTrustChain",
      "ALPNProtocols",
      "ca",
      "cert",
      "checkServerIdentity",
      "ciphers",
      "crl",
      "ecdhCurve",
      "key",
      "minDHSize",
      "passphrase",
      "pfx",
      "rejectUnauthorized",
      "secureContext",
      "secureProtocol",
      "servername",
      "session"
    ];
    exports2.LEGAL_TCP_SOCKET_OPTIONS = [
      "autoSelectFamily",
      "autoSelectFamilyAttemptTimeout",
      "keepAliveInitialDelay",
      "family",
      "hints",
      "localAddress",
      "localPort",
      "lookup"
    ];
    function parseConnectOptions(options2) {
      const hostAddress = options2.hostAddress;
      if (!hostAddress)
        throw new error_1.MongoInvalidArgumentError('Option "hostAddress" is required');
      const result = {};
      for (const name of exports2.LEGAL_TCP_SOCKET_OPTIONS) {
        if (options2[name] != null) {
          result[name] = options2[name];
        }
      }
      result.keepAliveInitialDelay ??= 12e4;
      result.keepAlive = true;
      result.noDelay = options2.noDelay ?? true;
      if (typeof hostAddress.socketPath === "string") {
        result.path = hostAddress.socketPath;
        return result;
      } else if (typeof hostAddress.host === "string") {
        result.host = hostAddress.host;
        result.port = hostAddress.port;
        return result;
      } else {
        throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);
      }
    }
    function parseSslOptions(options2) {
      const result = parseConnectOptions(options2);
      for (const name of exports2.LEGAL_TLS_SOCKET_OPTIONS) {
        if (options2[name] != null) {
          result[name] = options2[name];
        }
      }
      if (options2.existingSocket) {
        result.socket = options2.existingSocket;
      }
      if (result.servername == null && result.host && !net.isIP(result.host)) {
        result.servername = result.host;
      }
      return result;
    }
    async function makeSocket(options2) {
      const useTLS = options2.tls ?? false;
      const connectTimeoutMS = options2.connectTimeoutMS ?? 3e4;
      const existingSocket = options2.existingSocket;
      let socket;
      if (options2.proxyHost != null) {
        return await makeSocks5Connection({
          ...options2,
          connectTimeoutMS
          // Should always be present for Socks5
        });
      }
      if (useTLS) {
        const tlsSocket = tls.connect(parseSslOptions(options2));
        if (typeof tlsSocket.disableRenegotiation === "function") {
          tlsSocket.disableRenegotiation();
        }
        socket = tlsSocket;
      } else if (existingSocket) {
        socket = existingSocket;
      } else {
        socket = net.createConnection(parseConnectOptions(options2));
      }
      socket.setTimeout(connectTimeoutMS);
      let cancellationHandler = null;
      const { promise: connectedSocket, resolve, reject } = (0, utils_1.promiseWithResolvers)();
      if (existingSocket) {
        resolve(socket);
      } else {
        const start = performance.now();
        const connectEvent = useTLS ? "secureConnect" : "connect";
        socket.once(connectEvent, () => resolve(socket)).once("error", (cause) => reject(new error_1.MongoNetworkError(error_1.MongoError.buildErrorMessage(cause), { cause }))).once("timeout", () => {
          reject(new error_1.MongoNetworkTimeoutError(`Socket '${connectEvent}' timed out after ${performance.now() - start | 0}ms (connectTimeoutMS: ${connectTimeoutMS})`));
        }).once("close", () => reject(new error_1.MongoNetworkError(`Socket closed after ${performance.now() - start | 0} during connection establishment`)));
        if (options2.cancellationToken != null) {
          cancellationHandler = () => reject(new error_1.MongoNetworkError(`Socket connection establishment was cancelled after ${performance.now() - start | 0}`));
          options2.cancellationToken.once("cancel", cancellationHandler);
        }
      }
      try {
        socket = await connectedSocket;
        return socket;
      } catch (error2) {
        socket.destroy();
        throw error2;
      } finally {
        socket.setTimeout(0);
        if (cancellationHandler != null) {
          options2.cancellationToken?.removeListener("cancel", cancellationHandler);
        }
      }
    }
    var socks = null;
    function loadSocks() {
      if (socks == null) {
        const socksImport = (0, deps_1.getSocks)();
        if ("kModuleError" in socksImport) {
          throw socksImport.kModuleError;
        }
        socks = socksImport;
      }
      return socks;
    }
    async function makeSocks5Connection(options2) {
      const hostAddress = utils_1.HostAddress.fromHostPort(
        options2.proxyHost ?? "",
        // proxyHost is guaranteed to set here
        options2.proxyPort ?? 1080
      );
      const rawSocket = await makeSocket({
        ...options2,
        hostAddress,
        tls: false,
        proxyHost: void 0
      });
      const destination = parseConnectOptions(options2);
      if (typeof destination.host !== "string" || typeof destination.port !== "number") {
        throw new error_1.MongoInvalidArgumentError("Can only make Socks5 connections to TCP hosts");
      }
      socks ??= loadSocks();
      let existingSocket;
      try {
        const connection = await socks.SocksClient.createConnection({
          existing_socket: rawSocket,
          timeout: options2.connectTimeoutMS,
          command: "connect",
          destination: {
            host: destination.host,
            port: destination.port
          },
          proxy: {
            // host and port are ignored because we pass existing_socket
            host: "iLoveJavaScript",
            port: 0,
            type: 5,
            userId: options2.proxyUsername || void 0,
            password: options2.proxyPassword || void 0
          }
        });
        existingSocket = connection.socket;
      } catch (cause) {
        throw new error_1.MongoNetworkError(error_1.MongoError.buildErrorMessage(cause), { cause });
      }
      return await makeSocket({ ...options2, existingSocket, proxyHost: void 0 });
    }
  }
});

// node_modules/mongodb/lib/sdam/events.js
var require_events = __commonJS({
  "node_modules/mongodb/lib/sdam/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerHeartbeatFailedEvent = exports2.ServerHeartbeatSucceededEvent = exports2.ServerHeartbeatStartedEvent = exports2.TopologyClosedEvent = exports2.TopologyOpeningEvent = exports2.TopologyDescriptionChangedEvent = exports2.ServerClosedEvent = exports2.ServerOpeningEvent = exports2.ServerDescriptionChangedEvent = void 0;
    var constants_1 = require_constants4();
    var ServerDescriptionChangedEvent = class {
      /** @internal */
      constructor(topologyId, address, previousDescription, newDescription) {
        this.name = constants_1.SERVER_DESCRIPTION_CHANGED;
        this.topologyId = topologyId;
        this.address = address;
        this.previousDescription = previousDescription;
        this.newDescription = newDescription;
      }
    };
    exports2.ServerDescriptionChangedEvent = ServerDescriptionChangedEvent;
    var ServerOpeningEvent = class {
      /** @internal */
      constructor(topologyId, address) {
        this.name = constants_1.SERVER_OPENING;
        this.topologyId = topologyId;
        this.address = address;
      }
    };
    exports2.ServerOpeningEvent = ServerOpeningEvent;
    var ServerClosedEvent = class {
      /** @internal */
      constructor(topologyId, address) {
        this.name = constants_1.SERVER_CLOSED;
        this.topologyId = topologyId;
        this.address = address;
      }
    };
    exports2.ServerClosedEvent = ServerClosedEvent;
    var TopologyDescriptionChangedEvent = class {
      /** @internal */
      constructor(topologyId, previousDescription, newDescription) {
        this.name = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
        this.topologyId = topologyId;
        this.previousDescription = previousDescription;
        this.newDescription = newDescription;
      }
    };
    exports2.TopologyDescriptionChangedEvent = TopologyDescriptionChangedEvent;
    var TopologyOpeningEvent = class {
      /** @internal */
      constructor(topologyId) {
        this.name = constants_1.TOPOLOGY_OPENING;
        this.topologyId = topologyId;
      }
    };
    exports2.TopologyOpeningEvent = TopologyOpeningEvent;
    var TopologyClosedEvent = class {
      /** @internal */
      constructor(topologyId) {
        this.name = constants_1.TOPOLOGY_CLOSED;
        this.topologyId = topologyId;
      }
    };
    exports2.TopologyClosedEvent = TopologyClosedEvent;
    var ServerHeartbeatStartedEvent = class {
      /** @internal */
      constructor(connectionId, awaited) {
        this.name = constants_1.SERVER_HEARTBEAT_STARTED;
        this.connectionId = connectionId;
        this.awaited = awaited;
      }
    };
    exports2.ServerHeartbeatStartedEvent = ServerHeartbeatStartedEvent;
    var ServerHeartbeatSucceededEvent = class {
      /** @internal */
      constructor(connectionId, duration, reply, awaited) {
        this.name = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
        this.connectionId = connectionId;
        this.duration = duration;
        this.reply = reply ?? {};
        this.awaited = awaited;
      }
    };
    exports2.ServerHeartbeatSucceededEvent = ServerHeartbeatSucceededEvent;
    var ServerHeartbeatFailedEvent = class {
      /** @internal */
      constructor(connectionId, duration, failure, awaited) {
        this.name = constants_1.SERVER_HEARTBEAT_FAILED;
        this.connectionId = connectionId;
        this.duration = duration;
        this.failure = failure;
        this.awaited = awaited;
      }
    };
    exports2.ServerHeartbeatFailedEvent = ServerHeartbeatFailedEvent;
  }
});

// node_modules/mongodb/lib/cmap/connection_pool_events.js
var require_connection_pool_events = __commonJS({
  "node_modules/mongodb/lib/cmap/connection_pool_events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionPoolClearedEvent = exports2.ConnectionCheckedInEvent = exports2.ConnectionCheckedOutEvent = exports2.ConnectionCheckOutFailedEvent = exports2.ConnectionCheckOutStartedEvent = exports2.ConnectionClosedEvent = exports2.ConnectionReadyEvent = exports2.ConnectionCreatedEvent = exports2.ConnectionPoolClosedEvent = exports2.ConnectionPoolReadyEvent = exports2.ConnectionPoolCreatedEvent = exports2.ConnectionPoolMonitoringEvent = void 0;
    var constants_1 = require_constants4();
    var utils_1 = require_utils5();
    var ConnectionPoolMonitoringEvent = class {
      /** @internal */
      constructor(pool) {
        this.time = /* @__PURE__ */ new Date();
        this.address = pool.address;
      }
    };
    exports2.ConnectionPoolMonitoringEvent = ConnectionPoolMonitoringEvent;
    var ConnectionPoolCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool) {
        super(pool);
        this.name = constants_1.CONNECTION_POOL_CREATED;
        const { maxConnecting, maxPoolSize, minPoolSize, maxIdleTimeMS, waitQueueTimeoutMS } = pool.options;
        this.options = { maxConnecting, maxPoolSize, minPoolSize, maxIdleTimeMS, waitQueueTimeoutMS };
      }
    };
    exports2.ConnectionPoolCreatedEvent = ConnectionPoolCreatedEvent;
    var ConnectionPoolReadyEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool) {
        super(pool);
        this.name = constants_1.CONNECTION_POOL_READY;
      }
    };
    exports2.ConnectionPoolReadyEvent = ConnectionPoolReadyEvent;
    var ConnectionPoolClosedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool) {
        super(pool);
        this.name = constants_1.CONNECTION_POOL_CLOSED;
      }
    };
    exports2.ConnectionPoolClosedEvent = ConnectionPoolClosedEvent;
    var ConnectionCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection) {
        super(pool);
        this.name = constants_1.CONNECTION_CREATED;
        this.connectionId = connection.id;
      }
    };
    exports2.ConnectionCreatedEvent = ConnectionCreatedEvent;
    var ConnectionReadyEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection, connectionCreatedEventTime) {
        super(pool);
        this.name = constants_1.CONNECTION_READY;
        this.durationMS = (0, utils_1.now)() - connectionCreatedEventTime;
        this.connectionId = connection.id;
      }
    };
    exports2.ConnectionReadyEvent = ConnectionReadyEvent;
    var ConnectionClosedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection, reason, error2) {
        super(pool);
        this.name = constants_1.CONNECTION_CLOSED;
        this.connectionId = connection.id;
        this.reason = reason;
        this.serviceId = connection.serviceId;
        this.error = error2 ?? null;
      }
    };
    exports2.ConnectionClosedEvent = ConnectionClosedEvent;
    var ConnectionCheckOutStartedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool) {
        super(pool);
        this.name = constants_1.CONNECTION_CHECK_OUT_STARTED;
      }
    };
    exports2.ConnectionCheckOutStartedEvent = ConnectionCheckOutStartedEvent;
    var ConnectionCheckOutFailedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, reason, checkoutTime, error2) {
        super(pool);
        this.name = constants_1.CONNECTION_CHECK_OUT_FAILED;
        this.durationMS = (0, utils_1.now)() - checkoutTime;
        this.reason = reason;
        this.error = error2;
      }
    };
    exports2.ConnectionCheckOutFailedEvent = ConnectionCheckOutFailedEvent;
    var ConnectionCheckedOutEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection, checkoutTime) {
        super(pool);
        this.name = constants_1.CONNECTION_CHECKED_OUT;
        this.durationMS = (0, utils_1.now)() - checkoutTime;
        this.connectionId = connection.id;
      }
    };
    exports2.ConnectionCheckedOutEvent = ConnectionCheckedOutEvent;
    var ConnectionCheckedInEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection) {
        super(pool);
        this.name = constants_1.CONNECTION_CHECKED_IN;
        this.connectionId = connection.id;
      }
    };
    exports2.ConnectionCheckedInEvent = ConnectionCheckedInEvent;
    var ConnectionPoolClearedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, options2 = {}) {
        super(pool);
        this.name = constants_1.CONNECTION_POOL_CLEARED;
        this.serviceId = options2.serviceId;
        this.interruptInUseConnections = options2.interruptInUseConnections;
      }
    };
    exports2.ConnectionPoolClearedEvent = ConnectionPoolClearedEvent;
  }
});

// node_modules/mongodb/lib/cmap/errors.js
var require_errors4 = __commonJS({
  "node_modules/mongodb/lib/cmap/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WaitQueueTimeoutError = exports2.PoolClearedOnNetworkError = exports2.PoolClearedError = exports2.PoolClosedError = void 0;
    var error_1 = require_error();
    var PoolClosedError = class extends error_1.MongoDriverError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(pool) {
        super("Attempted to check out a connection from closed connection pool");
        this.address = pool.address;
      }
      get name() {
        return "MongoPoolClosedError";
      }
    };
    exports2.PoolClosedError = PoolClosedError;
    var PoolClearedError = class extends error_1.MongoNetworkError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(pool, message) {
        const errorMessage = message ? message : `Connection pool for ${pool.address} was cleared because another operation failed with: "${pool.serverError?.message}"`;
        super(errorMessage, pool.serverError ? { cause: pool.serverError } : void 0);
        this.address = pool.address;
        this.addErrorLabel(error_1.MongoErrorLabel.PoolRequstedRetry);
      }
      get name() {
        return "MongoPoolClearedError";
      }
    };
    exports2.PoolClearedError = PoolClearedError;
    var PoolClearedOnNetworkError = class extends PoolClearedError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(pool) {
        super(pool, `Connection to ${pool.address} interrupted due to server monitor timeout`);
      }
      get name() {
        return "PoolClearedOnNetworkError";
      }
    };
    exports2.PoolClearedOnNetworkError = PoolClearedOnNetworkError;
    var WaitQueueTimeoutError = class extends error_1.MongoDriverError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, address) {
        super(message);
        this.address = address;
      }
      get name() {
        return "MongoWaitQueueTimeoutError";
      }
    };
    exports2.WaitQueueTimeoutError = WaitQueueTimeoutError;
  }
});

// node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS({
  "node_modules/mongodb/lib/cmap/connection_pool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionPool = exports2.PoolState = void 0;
    var timers_1 = require("timers");
    var constants_1 = require_constants4();
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils5();
    var connect_1 = require_connect();
    var connection_1 = require_connection();
    var connection_pool_events_1 = require_connection_pool_events();
    var errors_1 = require_errors4();
    var metrics_1 = require_metrics();
    exports2.PoolState = Object.freeze({
      paused: "paused",
      ready: "ready",
      closed: "closed"
    });
    var ConnectionPool = class _ConnectionPool extends mongo_types_1.TypedEventEmitter {
      constructor(server, options2) {
        super();
        this.on("error", utils_1.noop);
        this.options = Object.freeze({
          connectionType: connection_1.Connection,
          ...options2,
          maxPoolSize: options2.maxPoolSize ?? 100,
          minPoolSize: options2.minPoolSize ?? 0,
          maxConnecting: options2.maxConnecting ?? 2,
          maxIdleTimeMS: options2.maxIdleTimeMS ?? 0,
          waitQueueTimeoutMS: options2.waitQueueTimeoutMS ?? 0,
          minPoolSizeCheckFrequencyMS: options2.minPoolSizeCheckFrequencyMS ?? 100,
          autoEncrypter: options2.autoEncrypter
        });
        if (this.options.minPoolSize > this.options.maxPoolSize) {
          throw new error_1.MongoInvalidArgumentError("Connection pool minimum size must not be greater than maximum pool size");
        }
        this.poolState = exports2.PoolState.paused;
        this.server = server;
        this.connections = new utils_1.List();
        this.pending = 0;
        this.checkedOut = /* @__PURE__ */ new Set();
        this.minPoolSizeTimer = void 0;
        this.generation = 0;
        this.serviceGenerations = /* @__PURE__ */ new Map();
        this.connectionCounter = (0, utils_1.makeCounter)(1);
        this.cancellationToken = new mongo_types_1.CancellationToken();
        this.cancellationToken.setMaxListeners(Infinity);
        this.waitQueue = new utils_1.List();
        this.metrics = new metrics_1.ConnectionPoolMetrics();
        this.processingWaitQueue = false;
        this.mongoLogger = this.server.topology.client?.mongoLogger;
        this.component = "connection";
        process.nextTick(() => {
          this.emitAndLog(_ConnectionPool.CONNECTION_POOL_CREATED, new connection_pool_events_1.ConnectionPoolCreatedEvent(this));
        });
      }
      /** The address of the endpoint the pool is connected to */
      get address() {
        return this.options.hostAddress.toString();
      }
      /**
       * Check if the pool has been closed
       *
       * TODO(NODE-3263): We can remove this property once shell no longer needs it
       */
      get closed() {
        return this.poolState === exports2.PoolState.closed;
      }
      /** An integer expressing how many total connections (available + pending + in use) the pool currently has */
      get totalConnectionCount() {
        return this.availableConnectionCount + this.pendingConnectionCount + this.currentCheckedOutCount;
      }
      /** An integer expressing how many connections are currently available in the pool. */
      get availableConnectionCount() {
        return this.connections.length;
      }
      get pendingConnectionCount() {
        return this.pending;
      }
      get currentCheckedOutCount() {
        return this.checkedOut.size;
      }
      get waitQueueSize() {
        return this.waitQueue.length;
      }
      get loadBalanced() {
        return this.options.loadBalanced;
      }
      get serverError() {
        return this.server.description.error;
      }
      /**
       * This is exposed ONLY for use in mongosh, to enable
       * killing all connections if a user quits the shell with
       * operations in progress.
       *
       * This property may be removed as a part of NODE-3263.
       */
      get checkedOutConnections() {
        return this.checkedOut;
      }
      /**
       * Get the metrics information for the pool when a wait queue timeout occurs.
       */
      waitQueueErrorMetrics() {
        return this.metrics.info(this.options.maxPoolSize);
      }
      /**
       * Set the pool state to "ready"
       */
      ready() {
        if (this.poolState !== exports2.PoolState.paused) {
          return;
        }
        this.poolState = exports2.PoolState.ready;
        this.emitAndLog(_ConnectionPool.CONNECTION_POOL_READY, new connection_pool_events_1.ConnectionPoolReadyEvent(this));
        (0, timers_1.clearTimeout)(this.minPoolSizeTimer);
        this.ensureMinPoolSize();
      }
      /**
       * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it
       * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or
       * explicitly destroyed by the new owner.
       */
      async checkOut(options2) {
        const checkoutTime = (0, utils_1.now)();
        this.emitAndLog(_ConnectionPool.CONNECTION_CHECK_OUT_STARTED, new connection_pool_events_1.ConnectionCheckOutStartedEvent(this));
        const { promise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
        const timeout = options2.timeoutContext.connectionCheckoutTimeout;
        const waitQueueMember = {
          resolve,
          reject,
          cancelled: false,
          checkoutTime
        };
        const abortListener = (0, utils_1.addAbortListener)(options2.signal, function() {
          waitQueueMember.cancelled = true;
          reject(this.reason);
        });
        this.waitQueue.push(waitQueueMember);
        process.nextTick(() => this.processWaitQueue());
        try {
          timeout?.throwIfExpired();
          return await (timeout ? Promise.race([promise, timeout]) : promise);
        } catch (error2) {
          if (timeout_1.TimeoutError.is(error2)) {
            timeout?.clear();
            waitQueueMember.cancelled = true;
            this.emitAndLog(_ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, "timeout", waitQueueMember.checkoutTime));
            const timeoutError = new errors_1.WaitQueueTimeoutError(this.loadBalanced ? this.waitQueueErrorMetrics() : "Timed out while checking out a connection from connection pool", this.address);
            if (options2.timeoutContext.csotEnabled()) {
              throw new error_1.MongoOperationTimeoutError("Timed out during connection checkout", {
                cause: timeoutError
              });
            }
            throw timeoutError;
          }
          throw error2;
        } finally {
          abortListener?.[utils_1.kDispose]();
          timeout?.clear();
        }
      }
      /**
       * Check a connection into the pool.
       *
       * @param connection - The connection to check in
       */
      checkIn(connection) {
        if (!this.checkedOut.has(connection)) {
          return;
        }
        const poolClosed = this.closed;
        const stale = this.connectionIsStale(connection);
        const willDestroy = !!(poolClosed || stale || connection.closed);
        if (!willDestroy) {
          connection.markAvailable();
          this.connections.unshift(connection);
        }
        this.checkedOut.delete(connection);
        this.emitAndLog(_ConnectionPool.CONNECTION_CHECKED_IN, new connection_pool_events_1.ConnectionCheckedInEvent(this, connection));
        if (willDestroy) {
          const reason = connection.closed ? "error" : poolClosed ? "poolClosed" : "stale";
          this.destroyConnection(connection, reason);
        }
        process.nextTick(() => this.processWaitQueue());
      }
      /**
       * Clear the pool
       *
       * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a
       * previous generation will eventually be pruned during subsequent checkouts.
       */
      clear(options2 = {}) {
        if (this.closed) {
          return;
        }
        if (this.loadBalanced) {
          const { serviceId } = options2;
          if (!serviceId) {
            throw new error_1.MongoRuntimeError("ConnectionPool.clear() called in load balanced mode with no serviceId.");
          }
          const sid = serviceId.toHexString();
          const generation = this.serviceGenerations.get(sid);
          if (generation == null) {
            throw new error_1.MongoRuntimeError("Service generations are required in load balancer mode.");
          } else {
            this.serviceGenerations.set(sid, generation + 1);
          }
          this.emitAndLog(_ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, { serviceId }));
          return;
        }
        const interruptInUseConnections = options2.interruptInUseConnections ?? false;
        const oldGeneration = this.generation;
        this.generation += 1;
        const alreadyPaused = this.poolState === exports2.PoolState.paused;
        this.poolState = exports2.PoolState.paused;
        this.clearMinPoolSizeTimer();
        if (!alreadyPaused) {
          this.emitAndLog(_ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, {
            interruptInUseConnections
          }));
        }
        if (interruptInUseConnections) {
          process.nextTick(() => this.interruptInUseConnections(oldGeneration));
        }
        this.processWaitQueue();
      }
      /**
       * Closes all stale in-use connections in the pool with a resumable PoolClearedOnNetworkError.
       *
       * Only connections where `connection.generation <= minGeneration` are killed.
       */
      interruptInUseConnections(minGeneration) {
        for (const connection of this.checkedOut) {
          if (connection.generation <= minGeneration) {
            connection.onError(new errors_1.PoolClearedOnNetworkError(this));
          }
        }
      }
      /** For MongoClient.close() procedures */
      closeCheckedOutConnections() {
        for (const conn of this.checkedOut) {
          conn.onError(new error_1.MongoClientClosedError());
        }
      }
      /** Close the pool */
      close() {
        if (this.closed) {
          return;
        }
        this.cancellationToken.emit("cancel");
        if (typeof this.connectionCounter.return === "function") {
          this.connectionCounter.return(void 0);
        }
        this.poolState = exports2.PoolState.closed;
        this.clearMinPoolSizeTimer();
        this.processWaitQueue();
        for (const conn of this.connections) {
          this.emitAndLog(_ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, conn, "poolClosed"));
          conn.destroy();
        }
        this.connections.clear();
        this.emitAndLog(_ConnectionPool.CONNECTION_POOL_CLOSED, new connection_pool_events_1.ConnectionPoolClosedEvent(this));
      }
      /**
       * @internal
       * Reauthenticate a connection
       */
      async reauthenticate(connection) {
        const authContext = connection.authContext;
        if (!authContext) {
          throw new error_1.MongoRuntimeError("No auth context found on connection.");
        }
        const credentials = authContext.credentials;
        if (!credentials) {
          throw new error_1.MongoMissingCredentialsError("Connection is missing credentials when asked to reauthenticate");
        }
        const resolvedCredentials = credentials.resolveAuthMechanism(connection.hello);
        const provider = this.server.topology.client.s.authProviders.getOrCreateProvider(resolvedCredentials.mechanism, resolvedCredentials.mechanismProperties);
        if (!provider) {
          throw new error_1.MongoMissingCredentialsError(`Reauthenticate failed due to no auth provider for ${credentials.mechanism}`);
        }
        await provider.reauth(authContext);
        return;
      }
      /** Clear the min pool size timer */
      clearMinPoolSizeTimer() {
        const minPoolSizeTimer = this.minPoolSizeTimer;
        if (minPoolSizeTimer) {
          (0, timers_1.clearTimeout)(minPoolSizeTimer);
        }
      }
      destroyConnection(connection, reason) {
        this.emitAndLog(_ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, connection, reason));
        connection.destroy();
      }
      connectionIsStale(connection) {
        const serviceId = connection.serviceId;
        if (this.loadBalanced && serviceId) {
          const sid = serviceId.toHexString();
          const generation = this.serviceGenerations.get(sid);
          return connection.generation !== generation;
        }
        return connection.generation !== this.generation;
      }
      connectionIsIdle(connection) {
        return !!(this.options.maxIdleTimeMS && connection.idleTime > this.options.maxIdleTimeMS);
      }
      /**
       * Destroys a connection if the connection is perished.
       *
       * @returns `true` if the connection was destroyed, `false` otherwise.
       */
      destroyConnectionIfPerished(connection) {
        const isStale = this.connectionIsStale(connection);
        const isIdle = this.connectionIsIdle(connection);
        if (!isStale && !isIdle && !connection.closed) {
          return false;
        }
        const reason = connection.closed ? "error" : isStale ? "stale" : "idle";
        this.destroyConnection(connection, reason);
        return true;
      }
      createConnection(callback) {
        const connectOptions = {
          ...this.options,
          id: this.connectionCounter.next().value,
          generation: this.generation,
          cancellationToken: this.cancellationToken,
          mongoLogger: this.mongoLogger,
          authProviders: this.server.topology.client.s.authProviders
        };
        this.pending++;
        const connectionCreatedTime = (0, utils_1.now)();
        this.emitAndLog(_ConnectionPool.CONNECTION_CREATED, new connection_pool_events_1.ConnectionCreatedEvent(this, { id: connectOptions.id }));
        (0, connect_1.connect)(connectOptions).then((connection) => {
          if (this.poolState !== exports2.PoolState.ready) {
            this.pending--;
            connection.destroy();
            callback(this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this));
            return;
          }
          for (const event of [...constants_1.APM_EVENTS, connection_1.Connection.CLUSTER_TIME_RECEIVED]) {
            connection.on(event, (e) => this.emit(event, e));
          }
          if (this.loadBalanced) {
            connection.on(connection_1.Connection.PINNED, (pinType) => this.metrics.markPinned(pinType));
            connection.on(connection_1.Connection.UNPINNED, (pinType) => this.metrics.markUnpinned(pinType));
            const serviceId = connection.serviceId;
            if (serviceId) {
              let generation;
              const sid = serviceId.toHexString();
              if (generation = this.serviceGenerations.get(sid)) {
                connection.generation = generation;
              } else {
                this.serviceGenerations.set(sid, 0);
                connection.generation = 0;
              }
            }
          }
          connection.markAvailable();
          this.emitAndLog(_ConnectionPool.CONNECTION_READY, new connection_pool_events_1.ConnectionReadyEvent(this, connection, connectionCreatedTime));
          this.pending--;
          callback(void 0, connection);
        }, (error2) => {
          this.pending--;
          this.server.handleError(error2);
          this.emitAndLog(_ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(
            this,
            { id: connectOptions.id, serviceId: void 0 },
            "error",
            // TODO(NODE-5192): Remove this cast
            error2
          ));
          if (error2 instanceof error_1.MongoNetworkError || error2 instanceof error_1.MongoServerError) {
            error2.connectionGeneration = connectOptions.generation;
          }
          callback(error2 ?? new error_1.MongoRuntimeError("Connection creation failed without error"));
        });
      }
      ensureMinPoolSize() {
        const minPoolSize = this.options.minPoolSize;
        if (this.poolState !== exports2.PoolState.ready || minPoolSize === 0) {
          return;
        }
        this.connections.prune((connection) => this.destroyConnectionIfPerished(connection));
        if (this.totalConnectionCount < minPoolSize && this.pendingConnectionCount < this.options.maxConnecting) {
          this.createConnection((err, connection) => {
            if (!err && connection) {
              this.connections.push(connection);
              process.nextTick(() => this.processWaitQueue());
            }
            if (this.poolState === exports2.PoolState.ready) {
              (0, timers_1.clearTimeout)(this.minPoolSizeTimer);
              this.minPoolSizeTimer = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
            }
          });
        } else {
          (0, timers_1.clearTimeout)(this.minPoolSizeTimer);
          this.minPoolSizeTimer = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
        }
      }
      processWaitQueue() {
        if (this.processingWaitQueue) {
          return;
        }
        this.processingWaitQueue = true;
        while (this.waitQueueSize) {
          const waitQueueMember = this.waitQueue.first();
          if (!waitQueueMember) {
            this.waitQueue.shift();
            continue;
          }
          if (waitQueueMember.cancelled) {
            this.waitQueue.shift();
            continue;
          }
          if (this.poolState !== exports2.PoolState.ready) {
            const reason = this.closed ? "poolClosed" : "connectionError";
            const error2 = this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this);
            this.emitAndLog(_ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, reason, waitQueueMember.checkoutTime, error2));
            this.waitQueue.shift();
            waitQueueMember.reject(error2);
            continue;
          }
          if (!this.availableConnectionCount) {
            break;
          }
          const connection = this.connections.shift();
          if (!connection) {
            break;
          }
          if (!this.destroyConnectionIfPerished(connection)) {
            this.checkedOut.add(connection);
            this.emitAndLog(_ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection, waitQueueMember.checkoutTime));
            this.waitQueue.shift();
            waitQueueMember.resolve(connection);
          }
        }
        const { maxPoolSize, maxConnecting } = this.options;
        while (this.waitQueueSize > 0 && this.pendingConnectionCount < maxConnecting && (maxPoolSize === 0 || this.totalConnectionCount < maxPoolSize)) {
          const waitQueueMember = this.waitQueue.shift();
          if (!waitQueueMember || waitQueueMember.cancelled) {
            continue;
          }
          this.createConnection((err, connection) => {
            if (waitQueueMember.cancelled) {
              if (!err && connection) {
                this.connections.push(connection);
              }
            } else {
              if (err) {
                this.emitAndLog(
                  _ConnectionPool.CONNECTION_CHECK_OUT_FAILED,
                  // TODO(NODE-5192): Remove this cast
                  new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, "connectionError", waitQueueMember.checkoutTime, err)
                );
                waitQueueMember.reject(err);
              } else if (connection) {
                this.checkedOut.add(connection);
                this.emitAndLog(_ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection, waitQueueMember.checkoutTime));
                waitQueueMember.resolve(connection);
              }
            }
            process.nextTick(() => this.processWaitQueue());
          });
        }
        this.processingWaitQueue = false;
      }
    };
    exports2.ConnectionPool = ConnectionPool;
    ConnectionPool.CONNECTION_POOL_CREATED = constants_1.CONNECTION_POOL_CREATED;
    ConnectionPool.CONNECTION_POOL_CLOSED = constants_1.CONNECTION_POOL_CLOSED;
    ConnectionPool.CONNECTION_POOL_CLEARED = constants_1.CONNECTION_POOL_CLEARED;
    ConnectionPool.CONNECTION_POOL_READY = constants_1.CONNECTION_POOL_READY;
    ConnectionPool.CONNECTION_CREATED = constants_1.CONNECTION_CREATED;
    ConnectionPool.CONNECTION_READY = constants_1.CONNECTION_READY;
    ConnectionPool.CONNECTION_CLOSED = constants_1.CONNECTION_CLOSED;
    ConnectionPool.CONNECTION_CHECK_OUT_STARTED = constants_1.CONNECTION_CHECK_OUT_STARTED;
    ConnectionPool.CONNECTION_CHECK_OUT_FAILED = constants_1.CONNECTION_CHECK_OUT_FAILED;
    ConnectionPool.CONNECTION_CHECKED_OUT = constants_1.CONNECTION_CHECKED_OUT;
    ConnectionPool.CONNECTION_CHECKED_IN = constants_1.CONNECTION_CHECKED_IN;
  }
});

// node_modules/mongodb/lib/sdam/server.js
var require_server = __commonJS({
  "node_modules/mongodb/lib/sdam/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Server = void 0;
    var connection_1 = require_connection();
    var connection_pool_1 = require_connection_pool();
    var errors_1 = require_errors4();
    var constants_1 = require_constants4();
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var transactions_1 = require_transactions();
    var utils_1 = require_utils5();
    var write_concern_1 = require_write_concern();
    var common_1 = require_common2();
    var monitor_1 = require_monitor();
    var server_description_1 = require_server_description();
    var stateTransition = (0, utils_1.makeStateMachine)({
      [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
      [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
      [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
      [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
    });
    var Server = class _Server extends mongo_types_1.TypedEventEmitter {
      /**
       * Create a server
       */
      constructor(topology, description, options2) {
        super();
        this.on("error", utils_1.noop);
        this.serverApi = options2.serverApi;
        const poolOptions = { hostAddress: description.hostAddress, ...options2 };
        this.topology = topology;
        this.pool = new connection_pool_1.ConnectionPool(this, poolOptions);
        this.s = {
          description,
          options: options2,
          state: common_1.STATE_CLOSED,
          operationCount: 0
        };
        for (const event of [...constants_1.CMAP_EVENTS, ...constants_1.APM_EVENTS]) {
          this.pool.on(event, (e) => this.emit(event, e));
        }
        this.pool.on(connection_1.Connection.CLUSTER_TIME_RECEIVED, (clusterTime) => {
          this.clusterTime = clusterTime;
        });
        if (this.loadBalanced) {
          this.monitor = null;
          return;
        }
        this.monitor = new monitor_1.Monitor(this, this.s.options);
        for (const event of constants_1.HEARTBEAT_EVENTS) {
          this.monitor.on(event, (e) => this.emit(event, e));
        }
        this.monitor.on("resetServer", (error2) => markServerUnknown(this, error2));
        this.monitor.on(_Server.SERVER_HEARTBEAT_SUCCEEDED, (event) => {
          this.emit(_Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(this.description.hostAddress, event.reply, {
            roundTripTime: this.monitor?.roundTripTime,
            minRoundTripTime: this.monitor?.minRoundTripTime
          }));
          if (this.s.state === common_1.STATE_CONNECTING) {
            stateTransition(this, common_1.STATE_CONNECTED);
            this.emit(_Server.CONNECT, this);
          }
        });
      }
      get clusterTime() {
        return this.topology.clusterTime;
      }
      set clusterTime(clusterTime) {
        this.topology.clusterTime = clusterTime;
      }
      get description() {
        return this.s.description;
      }
      get name() {
        return this.s.description.address;
      }
      get autoEncrypter() {
        if (this.s.options && this.s.options.autoEncrypter) {
          return this.s.options.autoEncrypter;
        }
        return;
      }
      get loadBalanced() {
        return this.topology.description.type === common_1.TopologyType.LoadBalanced;
      }
      /**
       * Initiate server connect
       */
      connect() {
        if (this.s.state !== common_1.STATE_CLOSED) {
          return;
        }
        stateTransition(this, common_1.STATE_CONNECTING);
        if (!this.loadBalanced) {
          this.monitor?.connect();
        } else {
          stateTransition(this, common_1.STATE_CONNECTED);
          this.emit(_Server.CONNECT, this);
        }
      }
      closeCheckedOutConnections() {
        return this.pool.closeCheckedOutConnections();
      }
      /** Destroy the server connection */
      close() {
        if (this.s.state === common_1.STATE_CLOSED) {
          return;
        }
        stateTransition(this, common_1.STATE_CLOSING);
        if (!this.loadBalanced) {
          this.monitor?.close();
        }
        this.pool.close();
        stateTransition(this, common_1.STATE_CLOSED);
        this.emit("closed");
      }
      /**
       * Immediately schedule monitoring of this server. If there already an attempt being made
       * this will be a no-op.
       */
      requestCheck() {
        if (!this.loadBalanced) {
          this.monitor?.requestCheck();
        }
      }
      async command(ns, cmd, { ...options2 }, responseType) {
        if (ns.db == null || typeof ns === "string") {
          throw new error_1.MongoInvalidArgumentError("Namespace must not be a string");
        }
        if (this.s.state === common_1.STATE_CLOSING || this.s.state === common_1.STATE_CLOSED) {
          throw new error_1.MongoServerClosedError();
        }
        options2.directConnection = this.topology.s.options.directConnection;
        if (options2.omitReadPreference) {
          delete options2.readPreference;
        }
        if (this.description.iscryptd) {
          options2.omitMaxTimeMS = true;
        }
        const session = options2.session;
        let conn = session?.pinnedConnection;
        this.incrementOperationCount();
        if (conn == null) {
          try {
            conn = await this.pool.checkOut(options2);
            if (this.loadBalanced && isPinnableCommand(cmd, session)) {
              session?.pin(conn);
            }
          } catch (checkoutError) {
            this.decrementOperationCount();
            if (!(checkoutError instanceof errors_1.PoolClearedError))
              this.handleError(checkoutError);
            throw checkoutError;
          }
        }
        let reauthPromise = null;
        try {
          try {
            const res = await conn.command(ns, cmd, options2, responseType);
            (0, write_concern_1.throwIfWriteConcernError)(res);
            return res;
          } catch (commandError) {
            throw this.decorateCommandError(conn, cmd, options2, commandError);
          }
        } catch (operationError) {
          if (operationError instanceof error_1.MongoError && operationError.code === error_1.MONGODB_ERROR_CODES.Reauthenticate) {
            reauthPromise = this.pool.reauthenticate(conn);
            reauthPromise.then(void 0, (error2) => {
              reauthPromise = null;
              (0, utils_1.squashError)(error2);
            });
            await (0, utils_1.abortable)(reauthPromise, options2);
            reauthPromise = null;
            try {
              const res = await conn.command(ns, cmd, options2, responseType);
              (0, write_concern_1.throwIfWriteConcernError)(res);
              return res;
            } catch (commandError) {
              throw this.decorateCommandError(conn, cmd, options2, commandError);
            }
          } else {
            throw operationError;
          }
        } finally {
          this.decrementOperationCount();
          if (session?.pinnedConnection !== conn) {
            if (reauthPromise != null) {
              const checkBackIn = () => {
                this.pool.checkIn(conn);
              };
              void reauthPromise.then(checkBackIn, checkBackIn);
            } else {
              this.pool.checkIn(conn);
            }
          }
        }
      }
      /**
       * Handle SDAM error
       * @internal
       */
      handleError(error2, connection) {
        if (!(error2 instanceof error_1.MongoError)) {
          return;
        }
        const isStaleError = error2.connectionGeneration && error2.connectionGeneration < this.pool.generation;
        if (isStaleError) {
          return;
        }
        const isNetworkNonTimeoutError = error2 instanceof error_1.MongoNetworkError && !(error2 instanceof error_1.MongoNetworkTimeoutError);
        const isNetworkTimeoutBeforeHandshakeError = error2 instanceof error_1.MongoNetworkError && error2.beforeHandshake;
        const isAuthHandshakeError = error2.hasErrorLabel(error_1.MongoErrorLabel.HandshakeError);
        if (isNetworkNonTimeoutError || isNetworkTimeoutBeforeHandshakeError || isAuthHandshakeError) {
          if (!this.loadBalanced) {
            error2.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
            markServerUnknown(this, error2);
          } else if (connection) {
            this.pool.clear({ serviceId: connection.serviceId });
          }
        } else {
          if ((0, error_1.isSDAMUnrecoverableError)(error2)) {
            if (shouldHandleStateChangeError(this, error2)) {
              const shouldClearPool = (0, utils_1.maxWireVersion)(this) <= 7 || (0, error_1.isNodeShuttingDownError)(error2);
              if (this.loadBalanced && connection && shouldClearPool) {
                this.pool.clear({ serviceId: connection.serviceId });
              }
              if (!this.loadBalanced) {
                if (shouldClearPool) {
                  error2.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
                }
                markServerUnknown(this, error2);
                process.nextTick(() => this.requestCheck());
              }
            }
          }
        }
      }
      /**
       * Ensure that error is properly decorated and internal state is updated before throwing
       * @internal
       */
      decorateCommandError(connection, cmd, options2, error2) {
        if (typeof error2 !== "object" || error2 == null || !("name" in error2)) {
          throw new error_1.MongoRuntimeError("An unexpected error type: " + typeof error2);
        }
        if (error2.name === "AbortError" && "cause" in error2 && error2.cause instanceof error_1.MongoError) {
          error2 = error2.cause;
        }
        if (!(error2 instanceof error_1.MongoError)) {
          return error2;
        }
        if (connectionIsStale(this.pool, connection)) {
          return error2;
        }
        const session = options2?.session;
        if (error2 instanceof error_1.MongoNetworkError) {
          if (session && !session.hasEnded && session.serverSession) {
            session.serverSession.isDirty = true;
          }
          if (inActiveTransaction(session, cmd) && !error2.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
            error2.addErrorLabel(error_1.MongoErrorLabel.TransientTransactionError);
          }
          if ((isRetryableWritesEnabled(this.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, utils_1.supportsRetryableWrites)(this) && !inActiveTransaction(session, cmd)) {
            error2.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
          }
        } else {
          if ((isRetryableWritesEnabled(this.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, error_1.needsRetryableWriteLabel)(error2, (0, utils_1.maxWireVersion)(this), this.description.type) && !inActiveTransaction(session, cmd)) {
            error2.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
          }
        }
        if (session && session.isPinned && error2.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
          session.unpin({ force: true });
        }
        this.handleError(error2, connection);
        return error2;
      }
      /**
       * Decrement the operation count, returning the new count.
       */
      decrementOperationCount() {
        return this.s.operationCount -= 1;
      }
      /**
       * Increment the operation count, returning the new count.
       */
      incrementOperationCount() {
        return this.s.operationCount += 1;
      }
    };
    exports2.Server = Server;
    Server.SERVER_HEARTBEAT_STARTED = constants_1.SERVER_HEARTBEAT_STARTED;
    Server.SERVER_HEARTBEAT_SUCCEEDED = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
    Server.SERVER_HEARTBEAT_FAILED = constants_1.SERVER_HEARTBEAT_FAILED;
    Server.CONNECT = constants_1.CONNECT;
    Server.DESCRIPTION_RECEIVED = constants_1.DESCRIPTION_RECEIVED;
    Server.CLOSED = constants_1.CLOSED;
    Server.ENDED = constants_1.ENDED;
    function markServerUnknown(server, error2) {
      if (server.loadBalanced) {
        return;
      }
      if (error2 instanceof error_1.MongoNetworkError && !(error2 instanceof error_1.MongoNetworkTimeoutError)) {
        server.monitor?.reset();
      }
      server.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(server.description.hostAddress, void 0, { error: error2 }));
    }
    function isPinnableCommand(cmd, session) {
      if (session) {
        return session.inTransaction() || session.transaction.isCommitted && "commitTransaction" in cmd || "aggregate" in cmd || "find" in cmd || "getMore" in cmd || "listCollections" in cmd || "listIndexes" in cmd || "bulkWrite" in cmd;
      }
      return false;
    }
    function connectionIsStale(pool, connection) {
      if (connection.serviceId) {
        return connection.generation !== pool.serviceGenerations.get(connection.serviceId.toHexString());
      }
      return connection.generation !== pool.generation;
    }
    function shouldHandleStateChangeError(server, err) {
      const etv = err.topologyVersion;
      const stv = server.description.topologyVersion;
      return (0, server_description_1.compareTopologyVersion)(stv, etv) < 0;
    }
    function inActiveTransaction(session, cmd) {
      return session && session.inTransaction() && !(0, transactions_1.isTransactionCommand)(cmd);
    }
    function isRetryableWritesEnabled(topology) {
      return topology.s.options.retryWrites !== false;
    }
  }
});

// node_modules/mongodb/lib/sdam/monitor.js
var require_monitor = __commonJS({
  "node_modules/mongodb/lib/sdam/monitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RTTSampler = exports2.MonitorInterval = exports2.RTTPinger = exports2.Monitor = exports2.ServerMonitoringMode = void 0;
    var timers_1 = require("timers");
    var bson_1 = require_bson2();
    var connect_1 = require_connect();
    var client_metadata_1 = require_client_metadata();
    var constants_1 = require_constants4();
    var error_1 = require_error();
    var mongo_logger_1 = require_mongo_logger();
    var mongo_types_1 = require_mongo_types();
    var utils_1 = require_utils5();
    var common_1 = require_common2();
    var events_1 = require_events();
    var server_1 = require_server();
    var STATE_IDLE = "idle";
    var STATE_MONITORING = "monitoring";
    var stateTransition = (0, utils_1.makeStateMachine)({
      [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],
      [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],
      [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],
      [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]
    });
    var INVALID_REQUEST_CHECK_STATES = /* @__PURE__ */ new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);
    function isInCloseState(monitor) {
      return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;
    }
    exports2.ServerMonitoringMode = Object.freeze({
      auto: "auto",
      poll: "poll",
      stream: "stream"
    });
    var Monitor = class extends mongo_types_1.TypedEventEmitter {
      constructor(server, options2) {
        super();
        this.component = mongo_logger_1.MongoLoggableComponent.TOPOLOGY;
        this.on("error", utils_1.noop);
        this.server = server;
        this.connection = null;
        this.cancellationToken = new mongo_types_1.CancellationToken();
        this.cancellationToken.setMaxListeners(Infinity);
        this.monitorId = void 0;
        this.s = {
          state: common_1.STATE_CLOSED
        };
        this.address = server.description.address;
        this.options = Object.freeze({
          connectTimeoutMS: options2.connectTimeoutMS ?? 1e4,
          heartbeatFrequencyMS: options2.heartbeatFrequencyMS ?? 1e4,
          minHeartbeatFrequencyMS: options2.minHeartbeatFrequencyMS ?? 500,
          serverMonitoringMode: options2.serverMonitoringMode
        });
        this.isRunningInFaasEnv = (0, client_metadata_1.getFAASEnv)() != null;
        this.mongoLogger = this.server.topology.client?.mongoLogger;
        this.rttSampler = new RTTSampler(10);
        const cancellationToken = this.cancellationToken;
        const connectOptions = {
          id: "<monitor>",
          generation: server.pool.generation,
          cancellationToken,
          hostAddress: server.description.hostAddress,
          ...options2,
          // force BSON serialization options
          raw: false,
          useBigInt64: false,
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: true
        };
        delete connectOptions.credentials;
        if (connectOptions.autoEncrypter) {
          delete connectOptions.autoEncrypter;
        }
        this.connectOptions = Object.freeze(connectOptions);
      }
      connect() {
        if (this.s.state !== common_1.STATE_CLOSED) {
          return;
        }
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this.monitorId = new MonitorInterval(monitorServer(this), {
          heartbeatFrequencyMS,
          minHeartbeatFrequencyMS,
          immediate: true
        });
      }
      requestCheck() {
        if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
          return;
        }
        this.monitorId?.wake();
      }
      reset() {
        const topologyVersion = this.server.description.topologyVersion;
        if (isInCloseState(this) || topologyVersion == null) {
          return;
        }
        stateTransition(this, common_1.STATE_CLOSING);
        resetMonitorState(this);
        stateTransition(this, STATE_IDLE);
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this.monitorId = new MonitorInterval(monitorServer(this), {
          heartbeatFrequencyMS,
          minHeartbeatFrequencyMS
        });
      }
      close() {
        if (isInCloseState(this)) {
          return;
        }
        stateTransition(this, common_1.STATE_CLOSING);
        resetMonitorState(this);
        this.emit("close");
        stateTransition(this, common_1.STATE_CLOSED);
      }
      get roundTripTime() {
        return this.rttSampler.average();
      }
      get minRoundTripTime() {
        return this.rttSampler.min();
      }
      get latestRtt() {
        return this.rttSampler.last;
      }
      addRttSample(rtt) {
        this.rttSampler.addSample(rtt);
      }
      clearRttSamples() {
        this.rttSampler.clear();
      }
    };
    exports2.Monitor = Monitor;
    function resetMonitorState(monitor) {
      monitor.monitorId?.stop();
      monitor.monitorId = void 0;
      monitor.rttPinger?.close();
      monitor.rttPinger = void 0;
      monitor.cancellationToken.emit("cancel");
      monitor.connection?.destroy();
      monitor.connection = null;
      monitor.clearRttSamples();
    }
    function useStreamingProtocol(monitor, topologyVersion) {
      if (topologyVersion == null)
        return false;
      const serverMonitoringMode = monitor.options.serverMonitoringMode;
      if (serverMonitoringMode === exports2.ServerMonitoringMode.poll)
        return false;
      if (serverMonitoringMode === exports2.ServerMonitoringMode.stream)
        return true;
      if (monitor.isRunningInFaasEnv)
        return false;
      return true;
    }
    function checkServer(monitor, callback) {
      let start;
      let awaited;
      const topologyVersion = monitor.server.description.topologyVersion;
      const isAwaitable = useStreamingProtocol(monitor, topologyVersion);
      monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor.server.topology.s.id, void 0, new events_1.ServerHeartbeatStartedEvent(monitor.address, isAwaitable));
      function onHeartbeatFailed(err) {
        monitor.connection?.destroy();
        monitor.connection = null;
        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_FAILED, monitor.server.topology.s.id, void 0, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err, awaited));
        const error2 = !(err instanceof error_1.MongoError) ? new error_1.MongoError(error_1.MongoError.buildErrorMessage(err), { cause: err }) : err;
        error2.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
        if (error2 instanceof error_1.MongoNetworkTimeoutError) {
          error2.addErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
        }
        monitor.emit("resetServer", error2);
        callback(err);
      }
      function onHeartbeatSucceeded(hello) {
        if (!("isWritablePrimary" in hello)) {
          hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];
        }
        const duration = isAwaitable && monitor.rttPinger ? monitor.rttPinger.latestRtt ?? (0, utils_1.calculateDurationInMs)(start) : (0, utils_1.calculateDurationInMs)(start);
        monitor.addRttSample(duration);
        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor.server.topology.s.id, hello.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello, isAwaitable));
        if (isAwaitable) {
          monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor.server.topology.s.id, void 0, new events_1.ServerHeartbeatStartedEvent(monitor.address, true));
          start = (0, utils_1.now)();
        } else {
          monitor.rttPinger?.close();
          monitor.rttPinger = void 0;
          callback(void 0, hello);
        }
      }
      const { connection } = monitor;
      if (connection && !connection.closed) {
        const { serverApi, helloOk } = connection;
        const connectTimeoutMS = monitor.options.connectTimeoutMS;
        const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
        const cmd = {
          [serverApi?.version || helloOk ? "hello" : constants_1.LEGACY_HELLO_COMMAND]: 1,
          ...isAwaitable && topologyVersion ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) } : {}
        };
        const options2 = isAwaitable ? {
          socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,
          exhaustAllowed: true
        } : { socketTimeoutMS: connectTimeoutMS };
        if (isAwaitable && monitor.rttPinger == null) {
          monitor.rttPinger = new RTTPinger(monitor);
        }
        start = (0, utils_1.now)();
        if (isAwaitable) {
          awaited = true;
          return connection.exhaustCommand((0, utils_1.ns)("admin.$cmd"), cmd, options2, (error2, hello) => {
            if (error2)
              return onHeartbeatFailed(error2);
            return onHeartbeatSucceeded(hello);
          });
        }
        awaited = false;
        connection.command((0, utils_1.ns)("admin.$cmd"), cmd, options2).then(onHeartbeatSucceeded, onHeartbeatFailed);
        return;
      }
      (async () => {
        const socket = await (0, connect_1.makeSocket)(monitor.connectOptions);
        const connection2 = (0, connect_1.makeConnection)(monitor.connectOptions, socket);
        start = (0, utils_1.now)();
        try {
          await (0, connect_1.performInitialHandshake)(connection2, monitor.connectOptions);
          return connection2;
        } catch (error2) {
          connection2.destroy();
          throw error2;
        }
      })().then((connection2) => {
        if (isInCloseState(monitor)) {
          connection2.destroy();
          return;
        }
        const duration = (0, utils_1.calculateDurationInMs)(start);
        monitor.addRttSample(duration);
        monitor.connection = connection2;
        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor.server.topology.s.id, connection2.hello?.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, connection2.hello, useStreamingProtocol(monitor, connection2.hello?.topologyVersion)));
        callback(void 0, connection2.hello);
      }, (error2) => {
        monitor.connection = null;
        awaited = false;
        onHeartbeatFailed(error2);
      });
    }
    function monitorServer(monitor) {
      return (callback) => {
        if (monitor.s.state === STATE_MONITORING) {
          process.nextTick(callback);
          return;
        }
        stateTransition(monitor, STATE_MONITORING);
        function done() {
          if (!isInCloseState(monitor)) {
            stateTransition(monitor, STATE_IDLE);
          }
          callback();
        }
        checkServer(monitor, (err, hello) => {
          if (err) {
            if (monitor.server.description.type === common_1.ServerType.Unknown) {
              return done();
            }
          }
          if (useStreamingProtocol(monitor, hello?.topologyVersion)) {
            (0, timers_1.setTimeout)(() => {
              if (!isInCloseState(monitor)) {
                monitor.monitorId?.wake();
              }
            }, 0);
          }
          done();
        });
      };
    }
    function makeTopologyVersion(tv) {
      return {
        processId: tv.processId,
        // tests mock counter as just number, but in a real situation counter should always be a Long
        // TODO(NODE-2674): Preserve int64 sent from MongoDB
        counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)
      };
    }
    var RTTPinger = class {
      constructor(monitor) {
        this.connection = void 0;
        this.cancellationToken = monitor.cancellationToken;
        this.closed = false;
        this.monitor = monitor;
        this.latestRtt = monitor.latestRtt ?? void 0;
        const heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;
        this.monitorId = (0, timers_1.setTimeout)(() => this.measureRoundTripTime(), heartbeatFrequencyMS);
      }
      get roundTripTime() {
        return this.monitor.roundTripTime;
      }
      get minRoundTripTime() {
        return this.monitor.minRoundTripTime;
      }
      close() {
        this.closed = true;
        (0, timers_1.clearTimeout)(this.monitorId);
        this.connection?.destroy();
        this.connection = void 0;
      }
      measureAndReschedule(start, conn) {
        if (this.closed) {
          conn?.destroy();
          return;
        }
        if (this.connection == null) {
          this.connection = conn;
        }
        this.latestRtt = (0, utils_1.calculateDurationInMs)(start);
        this.monitorId = (0, timers_1.setTimeout)(() => this.measureRoundTripTime(), this.monitor.options.heartbeatFrequencyMS);
      }
      measureRoundTripTime() {
        const start = (0, utils_1.now)();
        if (this.closed) {
          return;
        }
        const connection = this.connection;
        if (connection == null) {
          (0, connect_1.connect)(this.monitor.connectOptions).then((connection2) => {
            this.measureAndReschedule(start, connection2);
          }, () => {
            this.connection = void 0;
          });
          return;
        }
        const commandName = connection.serverApi?.version || connection.helloOk ? "hello" : constants_1.LEGACY_HELLO_COMMAND;
        connection.command((0, utils_1.ns)("admin.$cmd"), { [commandName]: 1 }, void 0).then(() => this.measureAndReschedule(start), () => {
          this.connection?.destroy();
          this.connection = void 0;
          return;
        });
      }
    };
    exports2.RTTPinger = RTTPinger;
    var MonitorInterval = class {
      constructor(fn, options2 = {}) {
        this.isExpeditedCallToFnScheduled = false;
        this.stopped = false;
        this.isExecutionInProgress = false;
        this.hasExecutedOnce = false;
        this._executeAndReschedule = () => {
          if (this.stopped)
            return;
          if (this.timerId) {
            (0, timers_1.clearTimeout)(this.timerId);
          }
          this.isExpeditedCallToFnScheduled = false;
          this.isExecutionInProgress = true;
          this.fn(() => {
            this.lastExecutionEnded = (0, utils_1.now)();
            this.isExecutionInProgress = false;
            this._reschedule(this.heartbeatFrequencyMS);
          });
        };
        this.fn = fn;
        this.lastExecutionEnded = -Infinity;
        this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS ?? 1e3;
        this.minHeartbeatFrequencyMS = options2.minHeartbeatFrequencyMS ?? 500;
        if (options2.immediate) {
          this._executeAndReschedule();
        } else {
          this._reschedule(void 0);
        }
      }
      wake() {
        const currentTime = (0, utils_1.now)();
        const timeSinceLastCall = currentTime - this.lastExecutionEnded;
        if (timeSinceLastCall < 0) {
          return this._executeAndReschedule();
        }
        if (this.isExecutionInProgress) {
          return;
        }
        if (this.isExpeditedCallToFnScheduled) {
          return;
        }
        if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {
          this.isExpeditedCallToFnScheduled = true;
          this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);
          return;
        }
        this._executeAndReschedule();
      }
      stop() {
        this.stopped = true;
        if (this.timerId) {
          (0, timers_1.clearTimeout)(this.timerId);
          this.timerId = void 0;
        }
        this.lastExecutionEnded = -Infinity;
        this.isExpeditedCallToFnScheduled = false;
      }
      toString() {
        return JSON.stringify(this);
      }
      toJSON() {
        const currentTime = (0, utils_1.now)();
        const timeSinceLastCall = currentTime - this.lastExecutionEnded;
        return {
          timerId: this.timerId != null ? "set" : "cleared",
          lastCallTime: this.lastExecutionEnded,
          isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,
          stopped: this.stopped,
          heartbeatFrequencyMS: this.heartbeatFrequencyMS,
          minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,
          currentTime,
          timeSinceLastCall
        };
      }
      _reschedule(ms) {
        if (this.stopped)
          return;
        if (this.timerId) {
          (0, timers_1.clearTimeout)(this.timerId);
        }
        this.timerId = (0, timers_1.setTimeout)(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);
      }
    };
    exports2.MonitorInterval = MonitorInterval;
    var RTTSampler = class {
      constructor(windowSize = 10) {
        this.rttSamples = new Float64Array(windowSize);
        this.length = 0;
        this.writeIndex = 0;
      }
      /**
       * Adds an rtt sample to the end of the circular buffer
       * When `windowSize` samples have been collected, `addSample` overwrites the least recently added
       * sample
       */
      addSample(sample) {
        this.rttSamples[this.writeIndex++] = sample;
        if (this.length < this.rttSamples.length) {
          this.length++;
        }
        this.writeIndex %= this.rttSamples.length;
      }
      /**
       * When \< 2 samples have been collected, returns 0
       * Otherwise computes the minimum value samples contained in the buffer
       */
      min() {
        if (this.length < 2)
          return 0;
        let min = this.rttSamples[0];
        for (let i = 1; i < this.length; i++) {
          if (this.rttSamples[i] < min)
            min = this.rttSamples[i];
        }
        return min;
      }
      /**
       * Returns mean of samples contained in the buffer
       */
      average() {
        if (this.length === 0)
          return 0;
        let sum = 0;
        for (let i = 0; i < this.length; i++) {
          sum += this.rttSamples[i];
        }
        return sum / this.length;
      }
      /**
       * Returns most recently inserted element in the buffer
       * Returns null if the buffer is empty
       * */
      get last() {
        if (this.length === 0)
          return null;
        return this.rttSamples[this.writeIndex === 0 ? this.length - 1 : this.writeIndex - 1];
      }
      /**
       * Clear the buffer
       * NOTE: this does not overwrite the data held in the internal array, just the pointers into
       * this array
       */
      clear() {
        this.length = 0;
        this.writeIndex = 0;
      }
    };
    exports2.RTTSampler = RTTSampler;
  }
});

// node_modules/mongodb/lib/connection_string.js
var require_connection_string = __commonJS({
  "node_modules/mongodb/lib/connection_string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_OPTIONS = exports2.OPTIONS = void 0;
    exports2.resolveSRVRecord = resolveSRVRecord;
    exports2.parseOptions = parseOptions;
    var dns = require("dns");
    var mongodb_connection_string_url_1 = require_lib5();
    var url_1 = require("url");
    var mongo_credentials_1 = require_mongo_credentials();
    var providers_1 = require_providers();
    var client_metadata_1 = require_client_metadata();
    var compression_1 = require_compression();
    var encrypter_1 = require_encrypter();
    var error_1 = require_error();
    var mongo_client_1 = require_mongo_client();
    var mongo_logger_1 = require_mongo_logger();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var monitor_1 = require_monitor();
    var utils_1 = require_utils5();
    var write_concern_1 = require_write_concern();
    var VALID_TXT_RECORDS = ["authSource", "replicaSet", "loadBalanced"];
    var LB_SINGLE_HOST_ERROR = "loadBalanced option only supported with a single host in the URI";
    var LB_REPLICA_SET_ERROR = "loadBalanced option not supported with a replicaSet option";
    var LB_DIRECT_CONNECTION_ERROR = "loadBalanced option not supported when directConnection is provided";
    function retryDNSTimeoutFor(api) {
      return async function dnsReqRetryTimeout(lookupAddress) {
        try {
          return await dns.promises[api](lookupAddress);
        } catch (firstDNSError) {
          if (firstDNSError.code === dns.TIMEOUT) {
            return await dns.promises[api](lookupAddress);
          } else {
            throw firstDNSError;
          }
        }
      };
    }
    var resolveSrv = retryDNSTimeoutFor("resolveSrv");
    var resolveTxt = retryDNSTimeoutFor("resolveTxt");
    async function resolveSRVRecord(options2) {
      if (typeof options2.srvHost !== "string") {
        throw new error_1.MongoAPIError('Option "srvHost" must not be empty');
      }
      const lookupAddress = options2.srvHost;
      const txtResolutionPromise = resolveTxt(lookupAddress);
      txtResolutionPromise.then(void 0, utils_1.squashError);
      const hostname = `_${options2.srvServiceName}._tcp.${lookupAddress}`;
      const addresses = await resolveSrv(hostname);
      if (addresses.length === 0) {
        throw new error_1.MongoAPIError("No addresses found at host");
      }
      for (const { name } of addresses) {
        (0, utils_1.checkParentDomainMatch)(name, lookupAddress);
      }
      const hostAddresses = addresses.map((r) => utils_1.HostAddress.fromString(`${r.name}:${r.port ?? 27017}`));
      validateLoadBalancedOptions(hostAddresses, options2, true);
      let record;
      try {
        record = await txtResolutionPromise;
      } catch (error2) {
        if (error2.code !== "ENODATA" && error2.code !== "ENOTFOUND") {
          throw error2;
        }
        return hostAddresses;
      }
      if (record.length > 1) {
        throw new error_1.MongoParseError("Multiple text records not allowed");
      }
      const txtRecordOptions = new url_1.URLSearchParams(record[0].join(""));
      const txtRecordOptionKeys = [...txtRecordOptions.keys()];
      if (txtRecordOptionKeys.some((key) => !VALID_TXT_RECORDS.includes(key))) {
        throw new error_1.MongoParseError(`Text record may only set any of: ${VALID_TXT_RECORDS.join(", ")}`);
      }
      if (VALID_TXT_RECORDS.some((option) => txtRecordOptions.get(option) === "")) {
        throw new error_1.MongoParseError("Cannot have empty URI params in DNS TXT Record");
      }
      const source = txtRecordOptions.get("authSource") ?? void 0;
      const replicaSet = txtRecordOptions.get("replicaSet") ?? void 0;
      const loadBalanced = txtRecordOptions.get("loadBalanced") ?? void 0;
      if (!options2.userSpecifiedAuthSource && source && options2.credentials && !providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(options2.credentials.mechanism)) {
        options2.credentials = mongo_credentials_1.MongoCredentials.merge(options2.credentials, { source });
      }
      if (!options2.userSpecifiedReplicaSet && replicaSet) {
        options2.replicaSet = replicaSet;
      }
      if (loadBalanced === "true") {
        options2.loadBalanced = true;
      }
      if (options2.replicaSet && options2.srvMaxHosts > 0) {
        throw new error_1.MongoParseError("Cannot combine replicaSet option with srvMaxHosts");
      }
      validateLoadBalancedOptions(hostAddresses, options2, true);
      return hostAddresses;
    }
    function checkTLSOptions(allOptions) {
      if (!allOptions)
        return;
      const check = (a, b) => {
        if (allOptions.has(a) && allOptions.has(b)) {
          throw new error_1.MongoAPIError(`The '${a}' option cannot be used with the '${b}' option`);
        }
      };
      check("tlsInsecure", "tlsAllowInvalidCertificates");
      check("tlsInsecure", "tlsAllowInvalidHostnames");
      check("tlsInsecure", "tlsDisableCertificateRevocationCheck");
      check("tlsInsecure", "tlsDisableOCSPEndpointCheck");
      check("tlsAllowInvalidCertificates", "tlsDisableCertificateRevocationCheck");
      check("tlsAllowInvalidCertificates", "tlsDisableOCSPEndpointCheck");
      check("tlsDisableCertificateRevocationCheck", "tlsDisableOCSPEndpointCheck");
    }
    function getBoolean(name, value) {
      if (typeof value === "boolean")
        return value;
      switch (value) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          throw new error_1.MongoParseError(`${name} must be either "true" or "false"`);
      }
    }
    function getIntFromOptions(name, value) {
      const parsedInt = (0, utils_1.parseInteger)(value);
      if (parsedInt != null) {
        return parsedInt;
      }
      throw new error_1.MongoParseError(`Expected ${name} to be stringified int value, got: ${value}`);
    }
    function getUIntFromOptions(name, value) {
      const parsedValue = getIntFromOptions(name, value);
      if (parsedValue < 0) {
        throw new error_1.MongoParseError(`${name} can only be a positive int value, got: ${value}`);
      }
      return parsedValue;
    }
    function* entriesFromString(value) {
      if (value === "") {
        return;
      }
      const keyValuePairs = value.split(",");
      for (const keyValue of keyValuePairs) {
        const [key, value2] = keyValue.split(/:(.*)/);
        if (value2 == null) {
          throw new error_1.MongoParseError("Cannot have undefined values in key value pairs");
        }
        yield [key, value2];
      }
    }
    var CaseInsensitiveMap = class extends Map {
      constructor(entries = []) {
        super(entries.map(([k, v]) => [k.toLowerCase(), v]));
      }
      has(k) {
        return super.has(k.toLowerCase());
      }
      get(k) {
        return super.get(k.toLowerCase());
      }
      set(k, v) {
        return super.set(k.toLowerCase(), v);
      }
      delete(k) {
        return super.delete(k.toLowerCase());
      }
    };
    function parseOptions(uri, mongoClient = void 0, options2 = {}) {
      if (mongoClient != null && !(mongoClient instanceof mongo_client_1.MongoClient)) {
        options2 = mongoClient;
        mongoClient = void 0;
      }
      if (options2.useBigInt64 && typeof options2.promoteLongs === "boolean" && !options2.promoteLongs) {
        throw new error_1.MongoAPIError("Must request either bigint or Long for int64 deserialization");
      }
      if (options2.useBigInt64 && typeof options2.promoteValues === "boolean" && !options2.promoteValues) {
        throw new error_1.MongoAPIError("Must request either bigint or Long for int64 deserialization");
      }
      const url = new mongodb_connection_string_url_1.default(uri);
      const { hosts, isSRV } = url;
      const mongoOptions = /* @__PURE__ */ Object.create(null);
      mongoOptions.hosts = isSRV ? [] : hosts.map(utils_1.HostAddress.fromString);
      const urlOptions = new CaseInsensitiveMap();
      if (url.pathname !== "/" && url.pathname !== "") {
        const dbName = decodeURIComponent(url.pathname[0] === "/" ? url.pathname.slice(1) : url.pathname);
        if (dbName) {
          urlOptions.set("dbName", [dbName]);
        }
      }
      if (url.username !== "") {
        const auth = {
          username: decodeURIComponent(url.username)
        };
        if (typeof url.password === "string") {
          auth.password = decodeURIComponent(url.password);
        }
        urlOptions.set("auth", [auth]);
      }
      for (const key of url.searchParams.keys()) {
        const values = url.searchParams.getAll(key);
        const isReadPreferenceTags = /readPreferenceTags/i.test(key);
        if (!isReadPreferenceTags && values.length > 1) {
          throw new error_1.MongoInvalidArgumentError(`URI option "${key}" cannot appear more than once in the connection string`);
        }
        if (!isReadPreferenceTags && values.includes("")) {
          throw new error_1.MongoAPIError(`URI option "${key}" cannot be specified with no value`);
        }
        if (!urlOptions.has(key)) {
          urlOptions.set(key, values);
        }
      }
      const objectOptions = new CaseInsensitiveMap(Object.entries(options2).filter(([, v]) => v != null));
      if (urlOptions.has("serverApi")) {
        throw new error_1.MongoParseError("URI cannot contain `serverApi`, it can only be passed to the client");
      }
      const uriMechanismProperties = urlOptions.get("authMechanismProperties");
      if (uriMechanismProperties) {
        for (const property of uriMechanismProperties) {
          if (/(^|,)ALLOWED_HOSTS:/.test(property)) {
            throw new error_1.MongoParseError("Auth mechanism property ALLOWED_HOSTS is not allowed in the connection string.");
          }
        }
      }
      if (objectOptions.has("loadBalanced")) {
        throw new error_1.MongoParseError("loadBalanced is only a valid option in the URI");
      }
      const allProvidedOptions = new CaseInsensitiveMap();
      const allProvidedKeys = /* @__PURE__ */ new Set([...urlOptions.keys(), ...objectOptions.keys()]);
      for (const key of allProvidedKeys) {
        const values = [];
        const objectOptionValue = objectOptions.get(key);
        if (objectOptionValue != null) {
          values.push(objectOptionValue);
        }
        const urlValues = urlOptions.get(key) ?? [];
        values.push(...urlValues);
        allProvidedOptions.set(key, values);
      }
      if (allProvidedOptions.has("tls") || allProvidedOptions.has("ssl")) {
        const tlsAndSslOpts = (allProvidedOptions.get("tls") || []).concat(allProvidedOptions.get("ssl") || []).map(getBoolean.bind(null, "tls/ssl"));
        if (new Set(tlsAndSslOpts).size !== 1) {
          throw new error_1.MongoParseError("All values of tls/ssl must be the same.");
        }
      }
      checkTLSOptions(allProvidedOptions);
      const unsupportedOptions = (0, utils_1.setDifference)(allProvidedKeys, Array.from(Object.keys(exports2.OPTIONS)).map((s) => s.toLowerCase()));
      if (unsupportedOptions.size !== 0) {
        const optionWord = unsupportedOptions.size > 1 ? "options" : "option";
        const isOrAre = unsupportedOptions.size > 1 ? "are" : "is";
        throw new error_1.MongoParseError(`${optionWord} ${Array.from(unsupportedOptions).join(", ")} ${isOrAre} not supported`);
      }
      for (const [key, descriptor] of Object.entries(exports2.OPTIONS)) {
        const values = allProvidedOptions.get(key);
        if (!values || values.length === 0) {
          if (exports2.DEFAULT_OPTIONS.has(key)) {
            setOption(mongoOptions, key, descriptor, [exports2.DEFAULT_OPTIONS.get(key)]);
          }
        } else {
          const { deprecated } = descriptor;
          if (deprecated) {
            const deprecatedMsg = typeof deprecated === "string" ? `: ${deprecated}` : "";
            (0, utils_1.emitWarning)(`${key} is a deprecated option${deprecatedMsg}`);
          }
          setOption(mongoOptions, key, descriptor, values);
        }
      }
      if (mongoOptions.credentials) {
        const isGssapi = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI;
        const isX509 = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_X509;
        const isAws = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_AWS;
        const isOidc = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_OIDC;
        if ((isGssapi || isX509) && allProvidedOptions.has("authSource") && mongoOptions.credentials.source !== "$external") {
          throw new error_1.MongoParseError(`authMechanism ${mongoOptions.credentials.mechanism} requires an authSource of '$external'`);
        }
        if (!(isGssapi || isX509 || isAws || isOidc) && mongoOptions.dbName && !allProvidedOptions.has("authSource")) {
          mongoOptions.credentials = mongo_credentials_1.MongoCredentials.merge(mongoOptions.credentials, {
            source: mongoOptions.dbName
          });
        }
        if (isAws && mongoOptions.credentials.username && !mongoOptions.credentials.password) {
          throw new error_1.MongoMissingCredentialsError(`When using ${mongoOptions.credentials.mechanism} password must be set when a username is specified`);
        }
        mongoOptions.credentials.validate();
        if (mongoOptions.credentials.password === "" && mongoOptions.credentials.username === "" && mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && Object.keys(mongoOptions.credentials.mechanismProperties).length === 0) {
          delete mongoOptions.credentials;
        }
      }
      if (!mongoOptions.dbName) {
        mongoOptions.dbName = "test";
      }
      validateLoadBalancedOptions(hosts, mongoOptions, isSRV);
      if (mongoClient && mongoOptions.autoEncryption) {
        encrypter_1.Encrypter.checkForMongoCrypt();
        mongoOptions.encrypter = new encrypter_1.Encrypter(mongoClient, uri, options2);
        mongoOptions.autoEncrypter = mongoOptions.encrypter.autoEncrypter;
      }
      mongoOptions.userSpecifiedAuthSource = objectOptions.has("authSource") || urlOptions.has("authSource");
      mongoOptions.userSpecifiedReplicaSet = objectOptions.has("replicaSet") || urlOptions.has("replicaSet");
      if (isSRV) {
        mongoOptions.srvHost = hosts[0];
        if (mongoOptions.directConnection) {
          throw new error_1.MongoAPIError("SRV URI does not support directConnection");
        }
        if (mongoOptions.srvMaxHosts > 0 && typeof mongoOptions.replicaSet === "string") {
          throw new error_1.MongoParseError("Cannot use srvMaxHosts option with replicaSet");
        }
        const noUserSpecifiedTLS = !objectOptions.has("tls") && !urlOptions.has("tls");
        const noUserSpecifiedSSL = !objectOptions.has("ssl") && !urlOptions.has("ssl");
        if (noUserSpecifiedTLS && noUserSpecifiedSSL) {
          mongoOptions.tls = true;
        }
      } else {
        const userSpecifiedSrvOptions = urlOptions.has("srvMaxHosts") || objectOptions.has("srvMaxHosts") || urlOptions.has("srvServiceName") || objectOptions.has("srvServiceName");
        if (userSpecifiedSrvOptions) {
          throw new error_1.MongoParseError("Cannot use srvMaxHosts or srvServiceName with a non-srv connection string");
        }
      }
      if (mongoOptions.directConnection && mongoOptions.hosts.length !== 1) {
        throw new error_1.MongoParseError("directConnection option requires exactly one host");
      }
      if (!mongoOptions.proxyHost && (mongoOptions.proxyPort || mongoOptions.proxyUsername || mongoOptions.proxyPassword)) {
        throw new error_1.MongoParseError("Must specify proxyHost if other proxy options are passed");
      }
      if (mongoOptions.proxyUsername && !mongoOptions.proxyPassword || !mongoOptions.proxyUsername && mongoOptions.proxyPassword) {
        throw new error_1.MongoParseError("Can only specify both of proxy username/password or neither");
      }
      const proxyOptions = ["proxyHost", "proxyPort", "proxyUsername", "proxyPassword"].map((key) => urlOptions.get(key) ?? []);
      if (proxyOptions.some((options3) => options3.length > 1)) {
        throw new error_1.MongoParseError("Proxy options cannot be specified multiple times in the connection string");
      }
      mongoOptions.mongoLoggerOptions = mongo_logger_1.MongoLogger.resolveOptions({
        MONGODB_LOG_COMMAND: process.env.MONGODB_LOG_COMMAND,
        MONGODB_LOG_TOPOLOGY: process.env.MONGODB_LOG_TOPOLOGY,
        MONGODB_LOG_SERVER_SELECTION: process.env.MONGODB_LOG_SERVER_SELECTION,
        MONGODB_LOG_CONNECTION: process.env.MONGODB_LOG_CONNECTION,
        MONGODB_LOG_CLIENT: process.env.MONGODB_LOG_CLIENT,
        MONGODB_LOG_ALL: process.env.MONGODB_LOG_ALL,
        MONGODB_LOG_MAX_DOCUMENT_LENGTH: process.env.MONGODB_LOG_MAX_DOCUMENT_LENGTH,
        MONGODB_LOG_PATH: process.env.MONGODB_LOG_PATH
      }, {
        mongodbLogPath: mongoOptions.mongodbLogPath,
        mongodbLogComponentSeverities: mongoOptions.mongodbLogComponentSeverities,
        mongodbLogMaxDocumentLength: mongoOptions.mongodbLogMaxDocumentLength
      });
      mongoOptions.metadata = (0, client_metadata_1.makeClientMetadata)(mongoOptions);
      mongoOptions.extendedMetadata = (0, client_metadata_1.addContainerMetadata)(mongoOptions.metadata).then(void 0, utils_1.squashError);
      return mongoOptions;
    }
    function validateLoadBalancedOptions(hosts, mongoOptions, isSrv) {
      if (mongoOptions.loadBalanced) {
        if (hosts.length > 1) {
          throw new error_1.MongoParseError(LB_SINGLE_HOST_ERROR);
        }
        if (mongoOptions.replicaSet) {
          throw new error_1.MongoParseError(LB_REPLICA_SET_ERROR);
        }
        if (mongoOptions.directConnection) {
          throw new error_1.MongoParseError(LB_DIRECT_CONNECTION_ERROR);
        }
        if (isSrv && mongoOptions.srvMaxHosts > 0) {
          throw new error_1.MongoParseError("Cannot limit srv hosts with loadBalanced enabled");
        }
      }
      return;
    }
    function setOption(mongoOptions, key, descriptor, values) {
      const { target, type, transform } = descriptor;
      const name = target ?? key;
      switch (type) {
        case "boolean":
          mongoOptions[name] = getBoolean(name, values[0]);
          break;
        case "int":
          mongoOptions[name] = getIntFromOptions(name, values[0]);
          break;
        case "uint":
          mongoOptions[name] = getUIntFromOptions(name, values[0]);
          break;
        case "string":
          if (values[0] == null) {
            break;
          }
          mongoOptions[name] = String(values[0]);
          break;
        case "record":
          if (!(0, utils_1.isRecord)(values[0])) {
            throw new error_1.MongoParseError(`${name} must be an object`);
          }
          mongoOptions[name] = values[0];
          break;
        case "any":
          mongoOptions[name] = values[0];
          break;
        default: {
          if (!transform) {
            throw new error_1.MongoParseError("Descriptors missing a type must define a transform");
          }
          const transformValue = transform({ name, options: mongoOptions, values });
          mongoOptions[name] = transformValue;
          break;
        }
      }
    }
    exports2.OPTIONS = {
      appName: {
        type: "string"
      },
      auth: {
        target: "credentials",
        transform({ name, options: options2, values: [value] }) {
          if (!(0, utils_1.isRecord)(value, ["username", "password"])) {
            throw new error_1.MongoParseError(`${name} must be an object with 'username' and 'password' properties`);
          }
          return mongo_credentials_1.MongoCredentials.merge(options2.credentials, {
            username: value.username,
            password: value.password
          });
        }
      },
      authMechanism: {
        target: "credentials",
        transform({ options: options2, values: [value] }) {
          const mechanisms = Object.values(providers_1.AuthMechanism);
          const [mechanism] = mechanisms.filter((m) => m.match(RegExp(String.raw`\b${value}\b`, "i")));
          if (!mechanism) {
            throw new error_1.MongoParseError(`authMechanism one of ${mechanisms}, got ${value}`);
          }
          let source = options2.credentials?.source;
          if (mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(mechanism)) {
            source = "$external";
          }
          let password = options2.credentials?.password;
          if (mechanism === providers_1.AuthMechanism.MONGODB_X509 && password === "") {
            password = void 0;
          }
          return mongo_credentials_1.MongoCredentials.merge(options2.credentials, {
            mechanism,
            source,
            password
          });
        }
      },
      // Note that if the authMechanismProperties contain a TOKEN_RESOURCE that has a
      // comma in it, it MUST be supplied as a MongoClient option instead of in the
      // connection string.
      authMechanismProperties: {
        target: "credentials",
        transform({ options: options2, values }) {
          let mechanismProperties = /* @__PURE__ */ Object.create(null);
          for (const optionValue of values) {
            if (typeof optionValue === "string") {
              for (const [key, value] of entriesFromString(optionValue)) {
                try {
                  mechanismProperties[key] = getBoolean(key, value);
                } catch {
                  mechanismProperties[key] = value;
                }
              }
            } else {
              if (!(0, utils_1.isRecord)(optionValue)) {
                throw new error_1.MongoParseError("AuthMechanismProperties must be an object");
              }
              mechanismProperties = { ...optionValue };
            }
          }
          return mongo_credentials_1.MongoCredentials.merge(options2.credentials, {
            mechanismProperties
          });
        }
      },
      authSource: {
        target: "credentials",
        transform({ options: options2, values: [value] }) {
          const source = String(value);
          return mongo_credentials_1.MongoCredentials.merge(options2.credentials, { source });
        }
      },
      autoEncryption: {
        type: "record"
      },
      autoSelectFamily: {
        type: "boolean",
        default: true
      },
      autoSelectFamilyAttemptTimeout: {
        type: "uint"
      },
      bsonRegExp: {
        type: "boolean"
      },
      serverApi: {
        target: "serverApi",
        transform({ values: [version] }) {
          const serverApiToValidate = typeof version === "string" ? { version } : version;
          const versionToValidate = serverApiToValidate && serverApiToValidate.version;
          if (!versionToValidate) {
            throw new error_1.MongoParseError(`Invalid \`serverApi\` property; must specify a version from the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
          }
          if (!Object.values(mongo_client_1.ServerApiVersion).some((v) => v === versionToValidate)) {
            throw new error_1.MongoParseError(`Invalid server API version=${versionToValidate}; must be in the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
          }
          return serverApiToValidate;
        }
      },
      checkKeys: {
        type: "boolean"
      },
      compressors: {
        default: "none",
        target: "compressors",
        transform({ values }) {
          const compressionList = /* @__PURE__ */ new Set();
          for (const compVal of values) {
            const compValArray = typeof compVal === "string" ? compVal.split(",") : compVal;
            if (!Array.isArray(compValArray)) {
              throw new error_1.MongoInvalidArgumentError("compressors must be an array or a comma-delimited list of strings");
            }
            for (const c of compValArray) {
              if (Object.keys(compression_1.Compressor).includes(String(c))) {
                compressionList.add(String(c));
              } else {
                throw new error_1.MongoInvalidArgumentError(`${c} is not a valid compression mechanism. Must be one of: ${Object.keys(compression_1.Compressor)}.`);
              }
            }
          }
          return [...compressionList];
        }
      },
      connectTimeoutMS: {
        default: 3e4,
        type: "uint"
      },
      dbName: {
        type: "string"
      },
      directConnection: {
        default: false,
        type: "boolean"
      },
      driverInfo: {
        default: {},
        type: "record"
      },
      enableUtf8Validation: { type: "boolean", default: true },
      family: {
        transform({ name, values: [value] }) {
          const transformValue = getIntFromOptions(name, value);
          if (transformValue === 4 || transformValue === 6) {
            return transformValue;
          }
          throw new error_1.MongoParseError(`Option 'family' must be 4 or 6 got ${transformValue}.`);
        }
      },
      fieldsAsRaw: {
        type: "record"
      },
      forceServerObjectId: {
        default: false,
        type: "boolean"
      },
      fsync: {
        deprecated: "Please use journal instead",
        target: "writeConcern",
        transform({ name, options: options2, values: [value] }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options2.writeConcern,
              fsync: getBoolean(name, value)
            }
          });
          if (!wc)
            throw new error_1.MongoParseError(`Unable to make a writeConcern from fsync=${value}`);
          return wc;
        }
      },
      heartbeatFrequencyMS: {
        default: 1e4,
        type: "uint"
      },
      ignoreUndefined: {
        type: "boolean"
      },
      j: {
        deprecated: "Please use journal instead",
        target: "writeConcern",
        transform({ name, options: options2, values: [value] }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options2.writeConcern,
              journal: getBoolean(name, value)
            }
          });
          if (!wc)
            throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value}`);
          return wc;
        }
      },
      journal: {
        target: "writeConcern",
        transform({ name, options: options2, values: [value] }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options2.writeConcern,
              journal: getBoolean(name, value)
            }
          });
          if (!wc)
            throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value}`);
          return wc;
        }
      },
      loadBalanced: {
        default: false,
        type: "boolean"
      },
      localThresholdMS: {
        default: 15,
        type: "uint"
      },
      maxConnecting: {
        default: 2,
        transform({ name, values: [value] }) {
          const maxConnecting = getUIntFromOptions(name, value);
          if (maxConnecting === 0) {
            throw new error_1.MongoInvalidArgumentError("maxConnecting must be > 0 if specified");
          }
          return maxConnecting;
        }
      },
      maxIdleTimeMS: {
        default: 0,
        type: "uint"
      },
      maxPoolSize: {
        default: 100,
        type: "uint"
      },
      maxStalenessSeconds: {
        target: "readPreference",
        transform({ name, options: options2, values: [value] }) {
          const maxStalenessSeconds = getUIntFromOptions(name, value);
          if (options2.readPreference) {
            return read_preference_1.ReadPreference.fromOptions({
              readPreference: { ...options2.readPreference, maxStalenessSeconds }
            });
          } else {
            return new read_preference_1.ReadPreference("secondary", void 0, { maxStalenessSeconds });
          }
        }
      },
      minInternalBufferSize: {
        type: "uint"
      },
      minPoolSize: {
        default: 0,
        type: "uint"
      },
      minHeartbeatFrequencyMS: {
        default: 500,
        type: "uint"
      },
      monitorCommands: {
        default: false,
        type: "boolean"
      },
      name: {
        target: "driverInfo",
        transform({ values: [value], options: options2 }) {
          return { ...options2.driverInfo, name: String(value) };
        }
      },
      noDelay: {
        default: true,
        type: "boolean"
      },
      pkFactory: {
        default: utils_1.DEFAULT_PK_FACTORY,
        transform({ values: [value] }) {
          if ((0, utils_1.isRecord)(value, ["createPk"]) && typeof value.createPk === "function") {
            return value;
          }
          throw new error_1.MongoParseError(`Option pkFactory must be an object with a createPk function, got ${value}`);
        }
      },
      promoteBuffers: {
        type: "boolean"
      },
      promoteLongs: {
        type: "boolean"
      },
      promoteValues: {
        type: "boolean"
      },
      useBigInt64: {
        type: "boolean"
      },
      proxyHost: {
        type: "string"
      },
      proxyPassword: {
        type: "string"
      },
      proxyPort: {
        type: "uint"
      },
      proxyUsername: {
        type: "string"
      },
      raw: {
        default: false,
        type: "boolean"
      },
      readConcern: {
        transform({ values: [value], options: options2 }) {
          if (value instanceof read_concern_1.ReadConcern || (0, utils_1.isRecord)(value, ["level"])) {
            return read_concern_1.ReadConcern.fromOptions({ ...options2.readConcern, ...value });
          }
          throw new error_1.MongoParseError(`ReadConcern must be an object, got ${JSON.stringify(value)}`);
        }
      },
      readConcernLevel: {
        target: "readConcern",
        transform({ values: [level], options: options2 }) {
          return read_concern_1.ReadConcern.fromOptions({
            ...options2.readConcern,
            level
          });
        }
      },
      readPreference: {
        default: read_preference_1.ReadPreference.primary,
        transform({ values: [value], options: options2 }) {
          if (value instanceof read_preference_1.ReadPreference) {
            return read_preference_1.ReadPreference.fromOptions({
              readPreference: { ...options2.readPreference, ...value },
              ...value
            });
          }
          if ((0, utils_1.isRecord)(value, ["mode"])) {
            const rp = read_preference_1.ReadPreference.fromOptions({
              readPreference: { ...options2.readPreference, ...value },
              ...value
            });
            if (rp)
              return rp;
            else
              throw new error_1.MongoParseError(`Cannot make read preference from ${JSON.stringify(value)}`);
          }
          if (typeof value === "string") {
            const rpOpts = {
              hedge: options2.readPreference?.hedge,
              maxStalenessSeconds: options2.readPreference?.maxStalenessSeconds
            };
            return new read_preference_1.ReadPreference(value, options2.readPreference?.tags, rpOpts);
          }
          throw new error_1.MongoParseError(`Unknown ReadPreference value: ${value}`);
        }
      },
      readPreferenceTags: {
        target: "readPreference",
        transform({ values, options: options2 }) {
          const tags = Array.isArray(values[0]) ? values[0] : values;
          const readPreferenceTags = [];
          for (const tag of tags) {
            const readPreferenceTag = /* @__PURE__ */ Object.create(null);
            if (typeof tag === "string") {
              for (const [k, v] of entriesFromString(tag)) {
                readPreferenceTag[k] = v;
              }
            }
            if ((0, utils_1.isRecord)(tag)) {
              for (const [k, v] of Object.entries(tag)) {
                readPreferenceTag[k] = v;
              }
            }
            readPreferenceTags.push(readPreferenceTag);
          }
          return read_preference_1.ReadPreference.fromOptions({
            readPreference: options2.readPreference,
            readPreferenceTags
          });
        }
      },
      replicaSet: {
        type: "string"
      },
      retryReads: {
        default: true,
        type: "boolean"
      },
      retryWrites: {
        default: true,
        type: "boolean"
      },
      serializeFunctions: {
        type: "boolean"
      },
      serverMonitoringMode: {
        default: "auto",
        transform({ values: [value] }) {
          if (!Object.values(monitor_1.ServerMonitoringMode).includes(value)) {
            throw new error_1.MongoParseError("serverMonitoringMode must be one of `auto`, `poll`, or `stream`");
          }
          return value;
        }
      },
      serverSelectionTimeoutMS: {
        default: 3e4,
        type: "uint"
      },
      servername: {
        type: "string"
      },
      socketTimeoutMS: {
        // TODO(NODE-6491): deprecated: 'Please use timeoutMS instead',
        default: 0,
        type: "uint"
      },
      srvMaxHosts: {
        type: "uint",
        default: 0
      },
      srvServiceName: {
        type: "string",
        default: "mongodb"
      },
      ssl: {
        target: "tls",
        type: "boolean"
      },
      timeoutMS: {
        type: "uint"
      },
      tls: {
        type: "boolean"
      },
      tlsAllowInvalidCertificates: {
        target: "rejectUnauthorized",
        transform({ name, values: [value] }) {
          return !getBoolean(name, value);
        }
      },
      tlsAllowInvalidHostnames: {
        target: "checkServerIdentity",
        transform({ name, values: [value] }) {
          return getBoolean(name, value) ? () => void 0 : void 0;
        }
      },
      tlsCAFile: {
        type: "string"
      },
      tlsCRLFile: {
        type: "string"
      },
      tlsCertificateKeyFile: {
        type: "string"
      },
      tlsCertificateKeyFilePassword: {
        target: "passphrase",
        type: "any"
      },
      tlsInsecure: {
        transform({ name, options: options2, values: [value] }) {
          const tlsInsecure = getBoolean(name, value);
          if (tlsInsecure) {
            options2.checkServerIdentity = () => void 0;
            options2.rejectUnauthorized = false;
          } else {
            options2.checkServerIdentity = options2.tlsAllowInvalidHostnames ? () => void 0 : void 0;
            options2.rejectUnauthorized = options2.tlsAllowInvalidCertificates ? false : true;
          }
          return tlsInsecure;
        }
      },
      w: {
        target: "writeConcern",
        transform({ values: [value], options: options2 }) {
          return write_concern_1.WriteConcern.fromOptions({ writeConcern: { ...options2.writeConcern, w: value } });
        }
      },
      waitQueueTimeoutMS: {
        // TODO(NODE-6491): deprecated: 'Please use timeoutMS instead',
        default: 0,
        type: "uint"
      },
      writeConcern: {
        target: "writeConcern",
        transform({ values: [value], options: options2 }) {
          if ((0, utils_1.isRecord)(value) || value instanceof write_concern_1.WriteConcern) {
            return write_concern_1.WriteConcern.fromOptions({
              writeConcern: {
                ...options2.writeConcern,
                ...value
              }
            });
          } else if (value === "majority" || typeof value === "number") {
            return write_concern_1.WriteConcern.fromOptions({
              writeConcern: {
                ...options2.writeConcern,
                w: value
              }
            });
          }
          throw new error_1.MongoParseError(`Invalid WriteConcern cannot parse: ${JSON.stringify(value)}`);
        }
      },
      wtimeout: {
        deprecated: "Please use wtimeoutMS instead",
        target: "writeConcern",
        transform({ values: [value], options: options2 }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options2.writeConcern,
              wtimeout: getUIntFromOptions("wtimeout", value)
            }
          });
          if (wc)
            return wc;
          throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
        }
      },
      wtimeoutMS: {
        target: "writeConcern",
        transform({ values: [value], options: options2 }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options2.writeConcern,
              wtimeoutMS: getUIntFromOptions("wtimeoutMS", value)
            }
          });
          if (wc)
            return wc;
          throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
        }
      },
      zlibCompressionLevel: {
        default: 0,
        type: "int"
      },
      mongodbLogPath: {
        transform({ values: [value] }) {
          if (!(typeof value === "string" && ["stderr", "stdout"].includes(value) || value && typeof value === "object" && "write" in value && typeof value.write === "function")) {
            throw new error_1.MongoAPIError(`Option 'mongodbLogPath' must be of type 'stderr' | 'stdout' | MongoDBLogWritable`);
          }
          return value;
        }
      },
      mongodbLogComponentSeverities: {
        transform({ values: [value] }) {
          if (typeof value !== "object" || !value) {
            throw new error_1.MongoAPIError(`Option 'mongodbLogComponentSeverities' must be a non-null object`);
          }
          for (const [k, v] of Object.entries(value)) {
            if (typeof v !== "string" || typeof k !== "string") {
              throw new error_1.MongoAPIError(`User input for option 'mongodbLogComponentSeverities' object cannot include a non-string key or value`);
            }
            if (!Object.values(mongo_logger_1.MongoLoggableComponent).some((val) => val === k) && k !== "default") {
              throw new error_1.MongoAPIError(`User input for option 'mongodbLogComponentSeverities' contains invalid key: ${k}`);
            }
            if (!Object.values(mongo_logger_1.SeverityLevel).some((val) => val === v)) {
              throw new error_1.MongoAPIError(`Option 'mongodbLogComponentSeverities' does not support ${v} as a value for ${k}`);
            }
          }
          return value;
        }
      },
      mongodbLogMaxDocumentLength: { type: "uint" },
      // Custom types for modifying core behavior
      connectionType: { type: "any" },
      srvPoller: { type: "any" },
      // Accepted Node.js Options
      allowPartialTrustChain: { type: "any" },
      minDHSize: { type: "any" },
      pskCallback: { type: "any" },
      secureContext: { type: "any" },
      enableTrace: { type: "any" },
      requestCert: { type: "any" },
      rejectUnauthorized: { type: "any" },
      checkServerIdentity: { type: "any" },
      keepAliveInitialDelay: { type: "any" },
      ALPNProtocols: { type: "any" },
      SNICallback: { type: "any" },
      session: { type: "any" },
      requestOCSP: { type: "any" },
      localAddress: { type: "any" },
      localPort: { type: "any" },
      hints: { type: "any" },
      lookup: { type: "any" },
      ca: { type: "any" },
      cert: { type: "any" },
      ciphers: { type: "any" },
      crl: { type: "any" },
      ecdhCurve: { type: "any" },
      key: { type: "any" },
      passphrase: { type: "any" },
      pfx: { type: "any" },
      secureProtocol: { type: "any" },
      index: { type: "any" },
      // Legacy options from v3 era
      useNewUrlParser: {
        type: "boolean",
        deprecated: "useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version"
      },
      useUnifiedTopology: {
        type: "boolean",
        deprecated: "useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version"
      },
      __skipPingOnConnect: { type: "boolean" }
    };
    exports2.DEFAULT_OPTIONS = new CaseInsensitiveMap(Object.entries(exports2.OPTIONS).filter(([, descriptor]) => descriptor.default != null).map(([k, d]) => [k, d.default]));
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_aws.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoDBAWS = void 0;
    var BSON = require_bson2();
    var deps_1 = require_deps();
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var auth_provider_1 = require_auth_provider();
    var aws_temporary_credentials_1 = require_aws_temporary_credentials();
    var mongo_credentials_1 = require_mongo_credentials();
    var providers_1 = require_providers();
    var ASCII_N = 110;
    var bsonOptions = {
      useBigInt64: false,
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: false,
      bsonRegExp: false
    };
    var MongoDBAWS = class extends auth_provider_1.AuthProvider {
      constructor(credentialProvider) {
        super();
        this.credentialProvider = credentialProvider;
        this.credentialFetcher = aws_temporary_credentials_1.AWSTemporaryCredentialProvider.isAWSSDKInstalled ? new aws_temporary_credentials_1.AWSSDKCredentialProvider(credentialProvider) : new aws_temporary_credentials_1.LegacyAWSTemporaryCredentialProvider();
      }
      async auth(authContext) {
        const { connection } = authContext;
        if (!authContext.credentials) {
          throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
        }
        if ("kModuleError" in deps_1.aws4) {
          throw deps_1.aws4["kModuleError"];
        }
        const { sign } = deps_1.aws4;
        if ((0, utils_1.maxWireVersion)(connection) < 9) {
          throw new error_1.MongoCompatibilityError("MONGODB-AWS authentication requires MongoDB version 4.4 or later");
        }
        if (!authContext.credentials.username) {
          authContext.credentials = await makeTempCredentials(authContext.credentials, this.credentialFetcher);
        }
        const { credentials } = authContext;
        const accessKeyId = credentials.username;
        const secretAccessKey = credentials.password;
        const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;
        const awsCredentials = accessKeyId && secretAccessKey && sessionToken ? { accessKeyId, secretAccessKey, sessionToken } : accessKeyId && secretAccessKey ? { accessKeyId, secretAccessKey } : void 0;
        const db = credentials.source;
        const nonce = await (0, utils_1.randomBytes)(32);
        const saslStart = {
          saslStart: 1,
          mechanism: "MONGODB-AWS",
          payload: BSON.serialize({ r: nonce, p: ASCII_N }, bsonOptions)
        };
        const saslStartResponse = await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStart, void 0);
        const serverResponse = BSON.deserialize(saslStartResponse.payload.buffer, bsonOptions);
        const host = serverResponse.h;
        const serverNonce = serverResponse.s.buffer;
        if (serverNonce.length !== 64) {
          throw new error_1.MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`);
        }
        if (!utils_1.ByteUtils.equals(serverNonce.subarray(0, nonce.byteLength), nonce)) {
          throw new error_1.MongoRuntimeError("Server nonce does not begin with client nonce");
        }
        if (host.length < 1 || host.length > 255 || host.indexOf("..") !== -1) {
          throw new error_1.MongoRuntimeError(`Server returned an invalid host: "${host}"`);
        }
        const body = "Action=GetCallerIdentity&Version=2011-06-15";
        const options2 = sign({
          method: "POST",
          host,
          region: deriveRegion(serverResponse.h),
          service: "sts",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            "Content-Length": body.length,
            "X-MongoDB-Server-Nonce": utils_1.ByteUtils.toBase64(serverNonce),
            "X-MongoDB-GS2-CB-Flag": "n"
          },
          path: "/",
          body
        }, awsCredentials);
        const payload = {
          a: options2.headers.Authorization,
          d: options2.headers["X-Amz-Date"]
        };
        if (sessionToken) {
          payload.t = sessionToken;
        }
        const saslContinue = {
          saslContinue: 1,
          conversationId: saslStartResponse.conversationId,
          payload: BSON.serialize(payload, bsonOptions)
        };
        await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinue, void 0);
      }
    };
    exports2.MongoDBAWS = MongoDBAWS;
    async function makeTempCredentials(credentials, awsCredentialFetcher) {
      function makeMongoCredentialsFromAWSTemp(creds) {
        if (!creds.AccessKeyId || !creds.SecretAccessKey) {
          throw new error_1.MongoMissingCredentialsError("Could not obtain temporary MONGODB-AWS credentials");
        }
        return new mongo_credentials_1.MongoCredentials({
          username: creds.AccessKeyId,
          password: creds.SecretAccessKey,
          source: credentials.source,
          mechanism: providers_1.AuthMechanism.MONGODB_AWS,
          mechanismProperties: {
            AWS_SESSION_TOKEN: creds.Token
          }
        });
      }
      const temporaryCredentials = await awsCredentialFetcher.getCredentials();
      return makeMongoCredentialsFromAWSTemp(temporaryCredentials);
    }
    function deriveRegion(host) {
      const parts = host.split(".");
      if (parts.length === 1 || parts[1] === "amazonaws") {
        return "us-east-1";
      }
      return parts[1];
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/command_builders.js
var require_command_builders = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/command_builders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.finishCommandDocument = finishCommandDocument;
    exports2.startCommandDocument = startCommandDocument;
    var bson_1 = require_bson2();
    var providers_1 = require_providers();
    function finishCommandDocument(token, conversationId) {
      if (conversationId != null) {
        return {
          saslContinue: 1,
          conversationId,
          payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))
        };
      }
      return {
        saslStart: 1,
        mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
        payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))
      };
    }
    function startCommandDocument(credentials) {
      const payload = {};
      if (credentials.username) {
        payload.n = credentials.username;
      }
      return {
        saslStart: 1,
        autoAuthorize: 1,
        mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
        payload: new bson_1.Binary(bson_1.BSON.serialize(payload))
      };
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/callback_workflow.js
var require_callback_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/callback_workflow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallbackWorkflow = exports2.AUTOMATED_TIMEOUT_MS = exports2.HUMAN_TIMEOUT_MS = void 0;
    var promises_1 = require("timers/promises");
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var command_builders_1 = require_command_builders();
    exports2.HUMAN_TIMEOUT_MS = 3e5;
    exports2.AUTOMATED_TIMEOUT_MS = 6e4;
    var RESULT_PROPERTIES = ["accessToken", "expiresInSeconds", "refreshToken"];
    var CALLBACK_RESULT_ERROR = "User provided OIDC callbacks must return a valid object with an accessToken.";
    var THROTTLE_MS = 100;
    var CallbackWorkflow = class {
      /**
       * Instantiate the callback workflow.
       */
      constructor(cache, callback) {
        this.cache = cache;
        this.callback = this.withLock(callback);
        this.lastExecutionTime = Date.now() - THROTTLE_MS;
      }
      /**
       * Get the document to add for speculative authentication. This also needs
       * to add a db field from the credentials source.
       */
      async speculativeAuth(connection, credentials) {
        if (this.cache.hasAccessToken) {
          const accessToken = this.cache.getAccessToken();
          connection.accessToken = accessToken;
          const document2 = (0, command_builders_1.finishCommandDocument)(accessToken);
          document2.db = credentials.source;
          return { speculativeAuthenticate: document2 };
        }
        return {};
      }
      /**
       * Reauthenticate the callback workflow. For this we invalidated the access token
       * in the cache and run the authentication steps again. No initial handshake needs
       * to be sent.
       */
      async reauthenticate(connection, credentials) {
        if (this.cache.hasAccessToken) {
          if (connection.accessToken === this.cache.getAccessToken()) {
            this.cache.removeAccessToken();
            delete connection.accessToken;
          } else {
            connection.accessToken = this.cache.getAccessToken();
          }
        }
        await this.execute(connection, credentials);
      }
      /**
       * Starts the callback authentication process. If there is a speculative
       * authentication document from the initial handshake, then we will use that
       * value to get the issuer, otherwise we will send the saslStart command.
       */
      async startAuthentication(connection, credentials, response) {
        let result;
        if (response?.speculativeAuthenticate) {
          result = response.speculativeAuthenticate;
        } else {
          result = await connection.command((0, utils_1.ns)(credentials.source), (0, command_builders_1.startCommandDocument)(credentials), void 0);
        }
        return result;
      }
      /**
       * Finishes the callback authentication process.
       */
      async finishAuthentication(connection, credentials, token, conversationId) {
        await connection.command((0, utils_1.ns)(credentials.source), (0, command_builders_1.finishCommandDocument)(token, conversationId), void 0);
      }
      /**
       * Executes the callback and validates the output.
       */
      async executeAndValidateCallback(params) {
        const result = await this.callback(params);
        if (isCallbackResultInvalid(result)) {
          throw new error_1.MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);
        }
        return result;
      }
      /**
       * Ensure the callback is only executed one at a time and throttles the calls
       * to every 100ms.
       */
      withLock(callback) {
        let lock = Promise.resolve();
        return async (params) => {
          await lock;
          lock = lock.catch(() => null).then(async () => {
            const difference = Date.now() - this.lastExecutionTime;
            if (difference <= THROTTLE_MS) {
              await (0, promises_1.setTimeout)(THROTTLE_MS - difference, { signal: params.timeoutContext });
            }
            this.lastExecutionTime = Date.now();
            return await callback(params);
          });
          return await lock;
        };
      }
    };
    exports2.CallbackWorkflow = CallbackWorkflow;
    function isCallbackResultInvalid(tokenResult) {
      if (tokenResult == null || typeof tokenResult !== "object")
        return true;
      if (!("accessToken" in tokenResult))
        return true;
      return !Object.getOwnPropertyNames(tokenResult).every((prop) => RESULT_PROPERTIES.includes(prop));
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/automated_callback_workflow.js
var require_automated_callback_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/automated_callback_workflow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AutomatedCallbackWorkflow = void 0;
    var error_1 = require_error();
    var timeout_1 = require_timeout();
    var mongodb_oidc_1 = require_mongodb_oidc();
    var callback_workflow_1 = require_callback_workflow();
    var AutomatedCallbackWorkflow = class extends callback_workflow_1.CallbackWorkflow {
      /**
       * Instantiate the human callback workflow.
       */
      constructor(cache, callback) {
        super(cache, callback);
      }
      /**
       * Execute the OIDC callback workflow.
       */
      async execute(connection, credentials) {
        if (this.cache.hasAccessToken) {
          const token = this.cache.getAccessToken();
          if (!connection.accessToken) {
            connection.accessToken = token;
          }
          try {
            return await this.finishAuthentication(connection, credentials, token);
          } catch (error2) {
            if (error2 instanceof error_1.MongoError && error2.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
              this.cache.removeAccessToken();
              return await this.execute(connection, credentials);
            } else {
              throw error2;
            }
          }
        }
        const response = await this.fetchAccessToken(credentials);
        this.cache.put(response);
        connection.accessToken = response.accessToken;
        await this.finishAuthentication(connection, credentials, response.accessToken);
      }
      /**
       * Fetches the access token using the callback.
       */
      async fetchAccessToken(credentials) {
        const controller = new AbortController();
        const params = {
          timeoutContext: controller.signal,
          version: mongodb_oidc_1.OIDC_VERSION
        };
        if (credentials.username) {
          params.username = credentials.username;
        }
        if (credentials.mechanismProperties.TOKEN_RESOURCE) {
          params.tokenAudience = credentials.mechanismProperties.TOKEN_RESOURCE;
        }
        const timeout = timeout_1.Timeout.expires(callback_workflow_1.AUTOMATED_TIMEOUT_MS);
        try {
          return await Promise.race([this.executeAndValidateCallback(params), timeout]);
        } catch (error2) {
          if (timeout_1.TimeoutError.is(error2)) {
            controller.abort();
            throw new error_1.MongoOIDCError(`OIDC callback timed out after ${callback_workflow_1.AUTOMATED_TIMEOUT_MS}ms.`);
          }
          throw error2;
        } finally {
          timeout.clear();
        }
      }
    };
    exports2.AutomatedCallbackWorkflow = AutomatedCallbackWorkflow;
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/azure_machine_workflow.js
var require_azure_machine_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/azure_machine_workflow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callback = void 0;
    var azure_1 = require_azure();
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var AZURE_HEADERS = Object.freeze({ Metadata: "true", Accept: "application/json" });
    var ENDPOINT_RESULT_ERROR = "Azure endpoint did not return a value with only access_token and expires_in properties";
    var TOKEN_RESOURCE_MISSING_ERROR = "TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is azure.";
    var callback = async (params) => {
      const tokenAudience = params.tokenAudience;
      const username = params.username;
      if (!tokenAudience) {
        throw new error_1.MongoAzureError(TOKEN_RESOURCE_MISSING_ERROR);
      }
      const response = await getAzureTokenData(tokenAudience, username);
      if (!isEndpointResultValid(response)) {
        throw new error_1.MongoAzureError(ENDPOINT_RESULT_ERROR);
      }
      return response;
    };
    exports2.callback = callback;
    async function getAzureTokenData(tokenAudience, username) {
      const url = new URL(azure_1.AZURE_BASE_URL);
      (0, azure_1.addAzureParams)(url, tokenAudience, username);
      const response = await (0, utils_1.get)(url, {
        headers: AZURE_HEADERS
      });
      if (response.status !== 200) {
        throw new error_1.MongoAzureError(`Status code ${response.status} returned from the Azure endpoint. Response body: ${response.body}`);
      }
      const result = JSON.parse(response.body);
      return {
        accessToken: result.access_token,
        expiresInSeconds: Number(result.expires_in)
      };
    }
    function isEndpointResultValid(token) {
      if (token == null || typeof token !== "object")
        return false;
      return "accessToken" in token && typeof token.accessToken === "string" && "expiresInSeconds" in token && typeof token.expiresInSeconds === "number";
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/gcp_machine_workflow.js
var require_gcp_machine_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/gcp_machine_workflow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callback = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var GCP_BASE_URL = "http://metadata/computeMetadata/v1/instance/service-accounts/default/identity";
    var GCP_HEADERS = Object.freeze({ "Metadata-Flavor": "Google" });
    var TOKEN_RESOURCE_MISSING_ERROR = "TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is gcp.";
    var callback = async (params) => {
      const tokenAudience = params.tokenAudience;
      if (!tokenAudience) {
        throw new error_1.MongoGCPError(TOKEN_RESOURCE_MISSING_ERROR);
      }
      return await getGcpTokenData(tokenAudience);
    };
    exports2.callback = callback;
    async function getGcpTokenData(tokenAudience) {
      const url = new URL(GCP_BASE_URL);
      url.searchParams.append("audience", tokenAudience);
      const response = await (0, utils_1.get)(url, {
        headers: GCP_HEADERS
      });
      if (response.status !== 200) {
        throw new error_1.MongoGCPError(`Status code ${response.status} returned from the GCP endpoint. Response body: ${response.body}`);
      }
      return { accessToken: response.body };
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/k8s_machine_workflow.js
var require_k8s_machine_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/k8s_machine_workflow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callback = void 0;
    var promises_1 = require("fs/promises");
    var FALLBACK_FILENAME = "/var/run/secrets/kubernetes.io/serviceaccount/token";
    var AZURE_FILENAME = "AZURE_FEDERATED_TOKEN_FILE";
    var AWS_FILENAME = "AWS_WEB_IDENTITY_TOKEN_FILE";
    var callback = async () => {
      let filename;
      if (process.env[AZURE_FILENAME]) {
        filename = process.env[AZURE_FILENAME];
      } else if (process.env[AWS_FILENAME]) {
        filename = process.env[AWS_FILENAME];
      } else {
        filename = FALLBACK_FILENAME;
      }
      const token = await (0, promises_1.readFile)(filename, "utf8");
      return { accessToken: token };
    };
    exports2.callback = callback;
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/token_cache.js
var require_token_cache = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/token_cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenCache = void 0;
    var error_1 = require_error();
    var MongoOIDCError = class extends error_1.MongoDriverError {
    };
    var TokenCache = class {
      get hasAccessToken() {
        return !!this.accessToken;
      }
      get hasRefreshToken() {
        return !!this.refreshToken;
      }
      get hasIdpInfo() {
        return !!this.idpInfo;
      }
      getAccessToken() {
        if (!this.accessToken) {
          throw new MongoOIDCError("Attempted to get an access token when none exists.");
        }
        return this.accessToken;
      }
      getRefreshToken() {
        if (!this.refreshToken) {
          throw new MongoOIDCError("Attempted to get a refresh token when none exists.");
        }
        return this.refreshToken;
      }
      getIdpInfo() {
        if (!this.idpInfo) {
          throw new MongoOIDCError("Attempted to get IDP information when none exists.");
        }
        return this.idpInfo;
      }
      put(response, idpInfo) {
        this.accessToken = response.accessToken;
        this.refreshToken = response.refreshToken;
        this.expiresInSeconds = response.expiresInSeconds;
        if (idpInfo) {
          this.idpInfo = idpInfo;
        }
      }
      removeAccessToken() {
        this.accessToken = void 0;
      }
      removeRefreshToken() {
        this.refreshToken = void 0;
      }
    };
    exports2.TokenCache = TokenCache;
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/token_machine_workflow.js
var require_token_machine_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/token_machine_workflow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callback = void 0;
    var fs = require("fs");
    var error_1 = require_error();
    var TOKEN_MISSING_ERROR = "OIDC_TOKEN_FILE must be set in the environment.";
    var callback = async () => {
      const tokenFile = process.env.OIDC_TOKEN_FILE;
      if (!tokenFile) {
        throw new error_1.MongoAWSError(TOKEN_MISSING_ERROR);
      }
      const token = await fs.promises.readFile(tokenFile, "utf8");
      return { accessToken: token };
    };
    exports2.callback = callback;
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc.js
var require_mongodb_oidc = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoDBOIDC = exports2.OIDC_WORKFLOWS = exports2.OIDC_VERSION = void 0;
    var error_1 = require_error();
    var auth_provider_1 = require_auth_provider();
    var automated_callback_workflow_1 = require_automated_callback_workflow();
    var azure_machine_workflow_1 = require_azure_machine_workflow();
    var gcp_machine_workflow_1 = require_gcp_machine_workflow();
    var k8s_machine_workflow_1 = require_k8s_machine_workflow();
    var token_cache_1 = require_token_cache();
    var token_machine_workflow_1 = require_token_machine_workflow();
    var MISSING_CREDENTIALS_ERROR = "AuthContext must provide credentials.";
    exports2.OIDC_VERSION = 1;
    exports2.OIDC_WORKFLOWS = /* @__PURE__ */ new Map();
    exports2.OIDC_WORKFLOWS.set("test", () => new automated_callback_workflow_1.AutomatedCallbackWorkflow(new token_cache_1.TokenCache(), token_machine_workflow_1.callback));
    exports2.OIDC_WORKFLOWS.set("azure", () => new automated_callback_workflow_1.AutomatedCallbackWorkflow(new token_cache_1.TokenCache(), azure_machine_workflow_1.callback));
    exports2.OIDC_WORKFLOWS.set("gcp", () => new automated_callback_workflow_1.AutomatedCallbackWorkflow(new token_cache_1.TokenCache(), gcp_machine_workflow_1.callback));
    exports2.OIDC_WORKFLOWS.set("k8s", () => new automated_callback_workflow_1.AutomatedCallbackWorkflow(new token_cache_1.TokenCache(), k8s_machine_workflow_1.callback));
    var MongoDBOIDC = class extends auth_provider_1.AuthProvider {
      /**
       * Instantiate the auth provider.
       */
      constructor(workflow) {
        super();
        if (!workflow) {
          throw new error_1.MongoInvalidArgumentError("No workflow provided to the OIDC auth provider.");
        }
        this.workflow = workflow;
      }
      /**
       * Authenticate using OIDC
       */
      async auth(authContext) {
        const { connection, reauthenticating, response } = authContext;
        if (response?.speculativeAuthenticate?.done && !reauthenticating) {
          return;
        }
        const credentials = getCredentials(authContext);
        if (reauthenticating) {
          await this.workflow.reauthenticate(connection, credentials);
        } else {
          await this.workflow.execute(connection, credentials, response);
        }
      }
      /**
       * Add the speculative auth for the initial handshake.
       */
      async prepare(handshakeDoc, authContext) {
        const { connection } = authContext;
        const credentials = getCredentials(authContext);
        const result = await this.workflow.speculativeAuth(connection, credentials);
        return { ...handshakeDoc, ...result };
      }
    };
    exports2.MongoDBOIDC = MongoDBOIDC;
    function getCredentials(authContext) {
      const { credentials } = authContext;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError(MISSING_CREDENTIALS_ERROR);
      }
      return credentials;
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/human_callback_workflow.js
var require_human_callback_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/human_callback_workflow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HumanCallbackWorkflow = void 0;
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var timeout_1 = require_timeout();
    var mongodb_oidc_1 = require_mongodb_oidc();
    var callback_workflow_1 = require_callback_workflow();
    var HumanCallbackWorkflow = class extends callback_workflow_1.CallbackWorkflow {
      /**
       * Instantiate the human callback workflow.
       */
      constructor(cache, callback) {
        super(cache, callback);
      }
      /**
       * Execute the OIDC human callback workflow.
       */
      async execute(connection, credentials) {
        if (this.cache.hasAccessToken) {
          const token = this.cache.getAccessToken();
          connection.accessToken = token;
          try {
            return await this.finishAuthentication(connection, credentials, token);
          } catch (error2) {
            if (error2 instanceof error_1.MongoError && error2.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
              this.cache.removeAccessToken();
              delete connection.accessToken;
              return await this.execute(connection, credentials);
            } else {
              throw error2;
            }
          }
        }
        if (this.cache.hasRefreshToken) {
          const refreshToken = this.cache.getRefreshToken();
          const result = await this.fetchAccessToken(this.cache.getIdpInfo(), credentials, refreshToken);
          this.cache.put(result);
          connection.accessToken = result.accessToken;
          try {
            return await this.finishAuthentication(connection, credentials, result.accessToken);
          } catch (error2) {
            if (error2 instanceof error_1.MongoError && error2.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
              this.cache.removeRefreshToken();
              delete connection.accessToken;
              return await this.execute(connection, credentials);
            } else {
              throw error2;
            }
          }
        }
        const startResponse = await this.startAuthentication(connection, credentials);
        const conversationId = startResponse.conversationId;
        const idpInfo = bson_1.BSON.deserialize(startResponse.payload.buffer);
        const callbackResponse = await this.fetchAccessToken(idpInfo, credentials);
        this.cache.put(callbackResponse, idpInfo);
        connection.accessToken = callbackResponse.accessToken;
        return await this.finishAuthentication(connection, credentials, callbackResponse.accessToken, conversationId);
      }
      /**
       * Fetches an access token using the callback.
       */
      async fetchAccessToken(idpInfo, credentials, refreshToken) {
        const controller = new AbortController();
        const params = {
          timeoutContext: controller.signal,
          version: mongodb_oidc_1.OIDC_VERSION,
          idpInfo
        };
        if (credentials.username) {
          params.username = credentials.username;
        }
        if (refreshToken) {
          params.refreshToken = refreshToken;
        }
        const timeout = timeout_1.Timeout.expires(callback_workflow_1.HUMAN_TIMEOUT_MS);
        try {
          return await Promise.race([this.executeAndValidateCallback(params), timeout]);
        } catch (error2) {
          if (timeout_1.TimeoutError.is(error2)) {
            controller.abort();
            throw new error_1.MongoOIDCError(`OIDC callback timed out after ${callback_workflow_1.HUMAN_TIMEOUT_MS}ms.`);
          }
          throw error2;
        } finally {
          timeout.clear();
        }
      }
    };
    exports2.HumanCallbackWorkflow = HumanCallbackWorkflow;
  }
});

// node_modules/mongodb/lib/cmap/auth/plain.js
var require_plain = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/plain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Plain = void 0;
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var auth_provider_1 = require_auth_provider();
    var Plain = class extends auth_provider_1.AuthProvider {
      async auth(authContext) {
        const { connection, credentials } = authContext;
        if (!credentials) {
          throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
        }
        const { username, password } = credentials;
        const payload = new bson_1.Binary(Buffer.from(`\0${username}\0${password}`));
        const command = {
          saslStart: 1,
          mechanism: "PLAIN",
          payload,
          autoAuthorize: 1
        };
        await connection.command((0, utils_1.ns)("$external.$cmd"), command, void 0);
      }
    };
    exports2.Plain = Plain;
  }
});

// node_modules/@mongodb-js/saslprep/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@mongodb-js/saslprep/dist/index.js"(exports2, module2) {
    "use strict";
    var getCodePoint = (character) => character.codePointAt(0);
    var first = (x) => x[0];
    var last = (x) => x[x.length - 1];
    function toCodePoints(input) {
      const codepoints = [];
      const size = input.length;
      for (let i = 0; i < size; i += 1) {
        const before = input.charCodeAt(i);
        if (before >= 55296 && before <= 56319 && size > i + 1) {
          const next = input.charCodeAt(i + 1);
          if (next >= 56320 && next <= 57343) {
            codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
            i += 1;
            continue;
          }
        }
        codepoints.push(before);
      }
      return codepoints;
    }
    function saslprep({ unassigned_code_points, commonly_mapped_to_nothing, non_ASCII_space_characters, prohibited_characters, bidirectional_r_al, bidirectional_l }, input, opts = {}) {
      const mapping2space = non_ASCII_space_characters;
      const mapping2nothing = commonly_mapped_to_nothing;
      if (typeof input !== "string") {
        throw new TypeError("Expected string.");
      }
      if (input.length === 0) {
        return "";
      }
      const mapped_input = toCodePoints(input).map((character) => mapping2space.get(character) ? 32 : character).filter((character) => !mapping2nothing.get(character));
      const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
      const normalized_map = toCodePoints(normalized_input);
      const hasProhibited = normalized_map.some((character) => prohibited_characters.get(character));
      if (hasProhibited) {
        throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3");
      }
      if (opts.allowUnassigned !== true) {
        const hasUnassigned = normalized_map.some((character) => unassigned_code_points.get(character));
        if (hasUnassigned) {
          throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5");
        }
      }
      const hasBidiRAL = normalized_map.some((character) => bidirectional_r_al.get(character));
      const hasBidiL = normalized_map.some((character) => bidirectional_l.get(character));
      if (hasBidiRAL && hasBidiL) {
        throw new Error("String must not contain RandALCat and LCat at the same time, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      const isFirstBidiRAL = bidirectional_r_al.get(getCodePoint(first(normalized_input)));
      const isLastBidiRAL = bidirectional_r_al.get(getCodePoint(last(normalized_input)));
      if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
        throw new Error("Bidirectional RandALCat character must be the first and the last character of the string, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      return normalized_input;
    }
    saslprep.saslprep = saslprep;
    saslprep.default = saslprep;
    module2.exports = saslprep;
  }
});

// node_modules/memory-pager/index.js
var require_memory_pager = __commonJS({
  "node_modules/memory-pager/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Pager;
    function Pager(pageSize, opts) {
      if (!(this instanceof Pager)) return new Pager(pageSize, opts);
      this.length = 0;
      this.updates = [];
      this.path = new Uint16Array(4);
      this.pages = new Array(32768);
      this.maxPages = this.pages.length;
      this.level = 0;
      this.pageSize = pageSize || 1024;
      this.deduplicate = opts ? opts.deduplicate : null;
      this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
    }
    Pager.prototype.updated = function(page) {
      while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
        page.deduplicate++;
        if (page.deduplicate === this.deduplicate.length) {
          page.deduplicate = 0;
          if (page.buffer.equals && page.buffer.equals(this.deduplicate)) page.buffer = this.deduplicate;
          break;
        }
      }
      if (page.updated || !this.updates) return;
      page.updated = true;
      this.updates.push(page);
    };
    Pager.prototype.lastUpdate = function() {
      if (!this.updates || !this.updates.length) return null;
      var page = this.updates.pop();
      page.updated = false;
      return page;
    };
    Pager.prototype._array = function(i, noAllocate) {
      if (i >= this.maxPages) {
        if (noAllocate) return;
        grow(this, i);
      }
      factor(i, this.path);
      var arr = this.pages;
      for (var j = this.level; j > 0; j--) {
        var p = this.path[j];
        var next = arr[p];
        if (!next) {
          if (noAllocate) return;
          next = arr[p] = new Array(32768);
        }
        arr = next;
      }
      return arr;
    };
    Pager.prototype.get = function(i, noAllocate) {
      var arr = this._array(i, noAllocate);
      var first = this.path[0];
      var page = arr && arr[first];
      if (!page && !noAllocate) {
        page = arr[first] = new Page(i, alloc(this.pageSize));
        if (i >= this.length) this.length = i + 1;
      }
      if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
        page.buffer = copy(page.buffer);
        page.deduplicate = 0;
      }
      return page;
    };
    Pager.prototype.set = function(i, buf) {
      var arr = this._array(i, false);
      var first = this.path[0];
      if (i >= this.length) this.length = i + 1;
      if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
        arr[first] = void 0;
        return;
      }
      if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
        buf = this.deduplicate;
      }
      var page = arr[first];
      var b = truncate(buf, this.pageSize);
      if (page) page.buffer = b;
      else arr[first] = new Page(i, b);
    };
    Pager.prototype.toBuffer = function() {
      var list = new Array(this.length);
      var empty = alloc(this.pageSize);
      var ptr = 0;
      while (ptr < list.length) {
        var arr = this._array(ptr, true);
        for (var i = 0; i < 32768 && ptr < list.length; i++) {
          list[ptr++] = arr && arr[i] ? arr[i].buffer : empty;
        }
      }
      return Buffer.concat(list);
    };
    function grow(pager, index) {
      while (pager.maxPages < index) {
        var old = pager.pages;
        pager.pages = new Array(32768);
        pager.pages[0] = old;
        pager.level++;
        pager.maxPages *= 32768;
      }
    }
    function truncate(buf, len) {
      if (buf.length === len) return buf;
      if (buf.length > len) return buf.slice(0, len);
      var cpy = alloc(len);
      buf.copy(cpy);
      return cpy;
    }
    function alloc(size) {
      if (Buffer.alloc) return Buffer.alloc(size);
      var buf = new Buffer(size);
      buf.fill(0);
      return buf;
    }
    function copy(buf) {
      var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
      buf.copy(cpy);
      return cpy;
    }
    function Page(i, buf) {
      this.offset = i * buf.length;
      this.buffer = buf;
      this.updated = false;
      this.deduplicate = 0;
    }
    function factor(n, out) {
      n = (n - (out[0] = n & 32767)) / 32768;
      n = (n - (out[1] = n & 32767)) / 32768;
      out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
    }
  }
});

// node_modules/sparse-bitfield/index.js
var require_sparse_bitfield = __commonJS({
  "node_modules/sparse-bitfield/index.js"(exports2, module2) {
    "use strict";
    var pager = require_memory_pager();
    module2.exports = Bitfield;
    function Bitfield(opts) {
      if (!(this instanceof Bitfield)) return new Bitfield(opts);
      if (!opts) opts = {};
      if (Buffer.isBuffer(opts)) opts = { buffer: opts };
      this.pageOffset = opts.pageOffset || 0;
      this.pageSize = opts.pageSize || 1024;
      this.pages = opts.pages || pager(this.pageSize);
      this.byteLength = this.pages.length * this.pageSize;
      this.length = 8 * this.byteLength;
      if (!powerOfTwo(this.pageSize)) throw new Error("The page size should be a power of two");
      this._trackUpdates = !!opts.trackUpdates;
      this._pageMask = this.pageSize - 1;
      if (opts.buffer) {
        for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
          this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
        }
        this.byteLength = opts.buffer.length;
        this.length = 8 * this.byteLength;
      }
    }
    Bitfield.prototype.get = function(i) {
      var o = i & 7;
      var j = (i - o) / 8;
      return !!(this.getByte(j) & 128 >> o);
    };
    Bitfield.prototype.getByte = function(i) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, true);
      return page ? page.buffer[o + this.pageOffset] : 0;
    };
    Bitfield.prototype.set = function(i, v) {
      var o = i & 7;
      var j = (i - o) / 8;
      var b = this.getByte(j);
      return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
    };
    Bitfield.prototype.toBuffer = function() {
      var all = alloc(this.pages.length * this.pageSize);
      for (var i = 0; i < this.pages.length; i++) {
        var next = this.pages.get(i, true);
        var allOffset = i * this.pageSize;
        if (next) next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
      }
      return all;
    };
    Bitfield.prototype.setByte = function(i, b) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, false);
      o += this.pageOffset;
      if (page.buffer[o] === b) return false;
      page.buffer[o] = b;
      if (i >= this.byteLength) {
        this.byteLength = i + 1;
        this.length = this.byteLength * 8;
      }
      if (this._trackUpdates) this.pages.updated(page);
      return true;
    };
    function alloc(n) {
      if (Buffer.alloc) return Buffer.alloc(n);
      var b = new Buffer(n);
      b.fill(0);
      return b;
    }
    function powerOfTwo(x) {
      return !(x & x - 1);
    }
  }
});

// node_modules/@mongodb-js/saslprep/dist/memory-code-points.js
var require_memory_code_points = __commonJS({
  "node_modules/@mongodb-js/saslprep/dist/memory-code-points.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMemoryCodePoints = createMemoryCodePoints;
    var sparse_bitfield_1 = __importDefault2(require_sparse_bitfield());
    function createMemoryCodePoints(data) {
      let offset = 0;
      function read() {
        const size = data.readUInt32BE(offset);
        offset += 4;
        const codepoints = data.slice(offset, offset + size);
        offset += size;
        return (0, sparse_bitfield_1.default)({ buffer: codepoints });
      }
      const unassigned_code_points = read();
      const commonly_mapped_to_nothing = read();
      const non_ASCII_space_characters = read();
      const prohibited_characters = read();
      const bidirectional_r_al = read();
      const bidirectional_l = read();
      return {
        unassigned_code_points,
        commonly_mapped_to_nothing,
        non_ASCII_space_characters,
        prohibited_characters,
        bidirectional_r_al,
        bidirectional_l
      };
    }
  }
});

// node_modules/@mongodb-js/saslprep/dist/code-points-data.js
var require_code_points_data = __commonJS({
  "node_modules/@mongodb-js/saslprep/dist/code-points-data.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var zlib_1 = require("zlib");
    exports2.default = (0, zlib_1.gunzipSync)(Buffer.from("H4sIAAAAAAACA+3dTYgcaRkA4LemO9Mhxm0FITnE9Cwr4jHgwgZ22B6YywqCJ0HQg5CL4sGTuOjCtGSF4CkHEW856MlTQHD3EJnWkU0Owh5VxE3LHlYQdNxd2U6mU59UV/d09fw4M2EySSXPAzNdP1/9fX/99bzVNZEN4jisRDulVFnQmLxm1aXF9Id/2/xMxNJ4XZlg576yuYlGt9gupV6xoFf8jhu9YvulVrFlp5XSx+lfvYhORGPXvqIRWSxERKtIm8bKFd10WNfKDS5Fo9jJWrq2+M2IlW+8uHgl/+BsROfPF4v5L7148Ur68Sha6dqZpYiVVy8tvLCWXo80Sf/lS89dGX2wHGvpzoXVn75/YWH5wmqe8uika82ViJXTy83Ve2k5Urozm38wm4/ls6t5uT6yfsTSJ7J3T0VKt8c5ExEXI8aFkH729c3eT+7EC6ca8cVULZUiYacX0R5PNWNxlh9L1y90q5kyzrpyy+9WcvOV6URntqw7La9sNVstXyczWVaWYbaaTYqzOHpr7pyiNT3/YzKuT63Z/FqKZlFTiuXtFM2vVOtIq7jiyKJbWZaOWD0euz0yoV2Z7kY0xq2x0YhfzVpmM5px9nTEH7JZ0ot5u39p0ma75Z472/s/H+2yr2inYyuq7fMvJivH2rM72N/Z3lyL31F2b1ya1P0zn816k2KP6JU9UzseucdQH5YqVeH/lFajSN2udg+TLJ9rksNxlvV2lki19rXKI43TPLejFu4ov7k3nMbhyhfY3Xb37f8BAGCf0eMTOH5szf154KmnNgKcnLb+Fzi2AfXktbN7fJelwTAiO/W5uQ2KINXRYu+znqo/WTAdLadURHmy3qciazd3bra4T3w16/f7t7Ms9U5gfJu10955sx1r3vmhBAAAAAAAgId20J1iZbDowNvIjuH427Gr5l/eiC+8OplZON8sVjx/qr9y+Pj+YRItT+NqAM+kkZs3AAAAAID6yfx1FwCAI97/dCh1/ub6SA0AAAAAAAAAgNoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hutp5SiQpYAAAAAAAAAQO2MIpZiT804flnAE2fhwjOeAZXr76kOAAAAAAAA8FjNf4N/l0NE3U/vuVQskLpSd4/Yh2xu9xTu0tFeeNYsLI2f/VMdNxTzj6Je9E/+6pp6Nn3awW3A54goe4Bss6v+PGsjQGMAAAAAAOBp5XEgwH6e7J7rwEQHRb/XvAMAAAAAAAA8yzoDeQDwVGjIAgAAAAAAAACoPfF/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqL/GSkSkClkCAAAAAAAAALXTSAAAAAAAAABA3Y1kAQAAAAAAAADUX8RSXZ9dsHC9+M8Fg2Ex/em1lAZpEBGttcrVjZqLEa+k0XpKw9mG4zWx4ukPUMhkAQAAAAAAABzBqbSe3//rXOS9HxGdo4TqR2XkutCdBu+LaPZw/lBbO7cbHnh2C7N7AIo4evEznllqLqWUp/LnYOtpM2bnOH66wI1+9GO4sOuISwv/TOlumu56FDv3NZhc4mR9v7zYIrafr40j/Cccvj9Xns3t3mu99E7qxUv3bqS0/ouNH/08++RGemfQ+nsx/5uNXsQPGulynPvv3ZTW37zd+1ovrqaYpP/122X6Xpx779Z3zr/3YOPKW1lkaRDf31pPaf3j/msRsVGkL+d/f+/m4sJsPm1cfSsr16e8m9Ldj/KsnyIuR3nXw83Is3EhxLd/2V773ks3m/cj/THKUummdP9qKhIOImuOU0Xjwb3y+oqt735rpTetVbF9n8R4x9crRfO77TKqVOZpDclv5bfK18lMnk+q0K18UpxF/RrGXE0Zxtqx3tWSj+vxbL4XaasfKb0dRbtLW73JsfPGg177H+OmGKlfvS1msllt7JEJm9XOJqXR+Fkfo1H66uy5H1v3Xx5+uJmGLw9jro2u7Loj4PnuR6+f+e3d261+eazNhzrL7X83MohoHpS4PddV8ki1it61//pw1g7z6p1U/26Nm2llST57B5rUvuG0XqSU/rPd7jYrqWcbd+beJQ77BgPMDwn37/8BAGCf0eMTOH4cPlufv9VGgJOzqf8Fjm1APXkd7B7f5dF57GPMaWy/MTvjvNvtXj6h8W2+GXvnzXaseeeHEgAAAAAAAB7aQXeKlcGiadBoEOeLb2dtpGOL2MyOtf391a3P/zD96c3JzIP3t4oV797vrh8+vn+YRL5bBuj/AQAAAABqJvfHXQAAHkX82zfXAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACeAgkAAAAAAAAAqLuRLAAAAAAAAACA2hv9D1iu/VAYaAYA", "base64"));
  }
});

// node_modules/@mongodb-js/saslprep/dist/node.js
var require_node3 = __commonJS({
  "node_modules/@mongodb-js/saslprep/dist/node.js"(exports2, module2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var index_1 = __importDefault2(require_dist4());
    var memory_code_points_1 = require_memory_code_points();
    var code_points_data_1 = __importDefault2(require_code_points_data());
    var codePoints = (0, memory_code_points_1.createMemoryCodePoints)(code_points_data_1.default);
    function saslprep(input, opts) {
      return (0, index_1.default)(codePoints, input, opts);
    }
    saslprep.saslprep = saslprep;
    saslprep.default = saslprep;
    module2.exports = saslprep;
  }
});

// node_modules/mongodb/lib/cmap/auth/scram.js
var require_scram = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/scram.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ScramSHA256 = exports2.ScramSHA1 = void 0;
    var saslprep_1 = require_node3();
    var crypto = require("crypto");
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var auth_provider_1 = require_auth_provider();
    var providers_1 = require_providers();
    var ScramSHA = class extends auth_provider_1.AuthProvider {
      constructor(cryptoMethod) {
        super();
        this.cryptoMethod = cryptoMethod || "sha1";
      }
      async prepare(handshakeDoc, authContext) {
        const cryptoMethod = this.cryptoMethod;
        const credentials = authContext.credentials;
        if (!credentials) {
          throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
        }
        const nonce = await (0, utils_1.randomBytes)(24);
        authContext.nonce = nonce;
        const request2 = {
          ...handshakeDoc,
          speculativeAuthenticate: {
            ...makeFirstMessage(cryptoMethod, credentials, nonce),
            db: credentials.source
          }
        };
        return request2;
      }
      async auth(authContext) {
        const { reauthenticating, response } = authContext;
        if (response?.speculativeAuthenticate && !reauthenticating) {
          return await continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext);
        }
        return await executeScram(this.cryptoMethod, authContext);
      }
    };
    function cleanUsername(username) {
      return username.replace("=", "=3D").replace(",", "=2C");
    }
    function clientFirstMessageBare(username, nonce) {
      return Buffer.concat([
        Buffer.from("n=", "utf8"),
        Buffer.from(username, "utf8"),
        Buffer.from(",r=", "utf8"),
        Buffer.from(nonce.toString("base64"), "utf8")
      ]);
    }
    function makeFirstMessage(cryptoMethod, credentials, nonce) {
      const username = cleanUsername(credentials.username);
      const mechanism = cryptoMethod === "sha1" ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;
      return {
        saslStart: 1,
        mechanism,
        payload: new bson_1.Binary(Buffer.concat([Buffer.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])),
        autoAuthorize: 1,
        options: { skipEmptyExchange: true }
      };
    }
    async function executeScram(cryptoMethod, authContext) {
      const { connection, credentials } = authContext;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      if (!authContext.nonce) {
        throw new error_1.MongoInvalidArgumentError("AuthContext must contain a valid nonce property");
      }
      const nonce = authContext.nonce;
      const db = credentials.source;
      const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
      const response = await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStartCmd, void 0);
      await continueScramConversation(cryptoMethod, response, authContext);
    }
    async function continueScramConversation(cryptoMethod, response, authContext) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      if (!authContext.nonce) {
        throw new error_1.MongoInvalidArgumentError("Unable to continue SCRAM without valid nonce");
      }
      const nonce = authContext.nonce;
      const db = credentials.source;
      const username = cleanUsername(credentials.username);
      const password = credentials.password;
      const processedPassword = cryptoMethod === "sha256" ? (0, saslprep_1.saslprep)(password) : passwordDigest(username, password);
      const payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;
      const dict = parsePayload(payload);
      const iterations = parseInt(dict.i, 10);
      if (iterations && iterations < 4096) {
        throw new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`);
      }
      const salt = dict.s;
      const rnonce = dict.r;
      if (rnonce.startsWith("nonce")) {
        throw new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`);
      }
      const withoutProof = `c=biws,r=${rnonce}`;
      const saltedPassword = HI(processedPassword, Buffer.from(salt, "base64"), iterations, cryptoMethod);
      const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
      const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
      const storedKey = H(cryptoMethod, clientKey);
      const authMessage = [
        clientFirstMessageBare(username, nonce),
        payload.toString("utf8"),
        withoutProof
      ].join(",");
      const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
      const clientProof = `p=${xor(clientKey, clientSignature)}`;
      const clientFinal = [withoutProof, clientProof].join(",");
      const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
      const saslContinueCmd = {
        saslContinue: 1,
        conversationId: response.conversationId,
        payload: new bson_1.Binary(Buffer.from(clientFinal))
      };
      const r = await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinueCmd, void 0);
      const parsedResponse = parsePayload(r.payload);
      if (!compareDigest(Buffer.from(parsedResponse.v, "base64"), serverSignature)) {
        throw new error_1.MongoRuntimeError("Server returned an invalid signature");
      }
      if (r.done !== false) {
        return;
      }
      const retrySaslContinueCmd = {
        saslContinue: 1,
        conversationId: r.conversationId,
        payload: Buffer.alloc(0)
      };
      await connection.command((0, utils_1.ns)(`${db}.$cmd`), retrySaslContinueCmd, void 0);
    }
    function parsePayload(payload) {
      const payloadStr = payload.toString("utf8");
      const dict = {};
      const parts = payloadStr.split(",");
      for (let i = 0; i < parts.length; i++) {
        const valueParts = (parts[i].match(/^([^=]*)=(.*)$/) ?? []).slice(1);
        dict[valueParts[0]] = valueParts[1];
      }
      return dict;
    }
    function passwordDigest(username, password) {
      if (typeof username !== "string") {
        throw new error_1.MongoInvalidArgumentError("Username must be a string");
      }
      if (typeof password !== "string") {
        throw new error_1.MongoInvalidArgumentError("Password must be a string");
      }
      if (password.length === 0) {
        throw new error_1.MongoInvalidArgumentError("Password cannot be empty");
      }
      let md5;
      try {
        md5 = crypto.createHash("md5");
      } catch (err) {
        if (crypto.getFips()) {
          throw new Error("Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode");
        }
        throw err;
      }
      md5.update(`${username}:mongo:${password}`, "utf8");
      return md5.digest("hex");
    }
    function xor(a, b) {
      if (!Buffer.isBuffer(a)) {
        a = Buffer.from(a);
      }
      if (!Buffer.isBuffer(b)) {
        b = Buffer.from(b);
      }
      const length = Math.max(a.length, b.length);
      const res = [];
      for (let i = 0; i < length; i += 1) {
        res.push(a[i] ^ b[i]);
      }
      return Buffer.from(res).toString("base64");
    }
    function H(method, text) {
      return crypto.createHash(method).update(text).digest();
    }
    function HMAC(method, key, text) {
      return crypto.createHmac(method, key).update(text).digest();
    }
    var _hiCache = {};
    var _hiCacheCount = 0;
    function _hiCachePurge() {
      _hiCache = {};
      _hiCacheCount = 0;
    }
    var hiLengthMap = {
      sha256: 32,
      sha1: 20
    };
    function HI(data, salt, iterations, cryptoMethod) {
      const key = [data, salt.toString("base64"), iterations].join("_");
      if (_hiCache[key] != null) {
        return _hiCache[key];
      }
      const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
      if (_hiCacheCount >= 200) {
        _hiCachePurge();
      }
      _hiCache[key] = saltedData;
      _hiCacheCount += 1;
      return saltedData;
    }
    function compareDigest(lhs, rhs) {
      if (lhs.length !== rhs.length) {
        return false;
      }
      if (typeof crypto.timingSafeEqual === "function") {
        return crypto.timingSafeEqual(lhs, rhs);
      }
      let result = 0;
      for (let i = 0; i < lhs.length; i++) {
        result |= lhs[i] ^ rhs[i];
      }
      return result === 0;
    }
    var ScramSHA1 = class extends ScramSHA {
      constructor() {
        super("sha1");
      }
    };
    exports2.ScramSHA1 = ScramSHA1;
    var ScramSHA256 = class extends ScramSHA {
      constructor() {
        super("sha256");
      }
    };
    exports2.ScramSHA256 = ScramSHA256;
  }
});

// node_modules/mongodb/lib/cmap/auth/x509.js
var require_x509 = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/x509.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.X509 = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils5();
    var auth_provider_1 = require_auth_provider();
    var X509 = class extends auth_provider_1.AuthProvider {
      async prepare(handshakeDoc, authContext) {
        const { credentials } = authContext;
        if (!credentials) {
          throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
        }
        return { ...handshakeDoc, speculativeAuthenticate: x509AuthenticateCommand(credentials) };
      }
      async auth(authContext) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        if (!credentials) {
          throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
        }
        const response = authContext.response;
        if (response?.speculativeAuthenticate) {
          return;
        }
        await connection.command((0, utils_1.ns)("$external.$cmd"), x509AuthenticateCommand(credentials), void 0);
      }
    };
    exports2.X509 = X509;
    function x509AuthenticateCommand(credentials) {
      const command = { authenticate: 1, mechanism: "MONGODB-X509" };
      if (credentials.username) {
        command.user = credentials.username;
      }
      return command;
    }
  }
});

// node_modules/mongodb/lib/mongo_client_auth_providers.js
var require_mongo_client_auth_providers = __commonJS({
  "node_modules/mongodb/lib/mongo_client_auth_providers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoClientAuthProviders = void 0;
    var gssapi_1 = require_gssapi();
    var mongodb_aws_1 = require_mongodb_aws();
    var mongodb_oidc_1 = require_mongodb_oidc();
    var automated_callback_workflow_1 = require_automated_callback_workflow();
    var human_callback_workflow_1 = require_human_callback_workflow();
    var token_cache_1 = require_token_cache();
    var plain_1 = require_plain();
    var providers_1 = require_providers();
    var scram_1 = require_scram();
    var x509_1 = require_x509();
    var error_1 = require_error();
    var AUTH_PROVIDERS = /* @__PURE__ */ new Map([
      [
        providers_1.AuthMechanism.MONGODB_AWS,
        ({ AWS_CREDENTIAL_PROVIDER }) => new mongodb_aws_1.MongoDBAWS(AWS_CREDENTIAL_PROVIDER)
      ],
      [
        providers_1.AuthMechanism.MONGODB_CR,
        () => {
          throw new error_1.MongoInvalidArgumentError("MONGODB-CR is no longer a supported auth mechanism in MongoDB 4.0+");
        }
      ],
      [providers_1.AuthMechanism.MONGODB_GSSAPI, () => new gssapi_1.GSSAPI()],
      [providers_1.AuthMechanism.MONGODB_OIDC, (properties) => new mongodb_oidc_1.MongoDBOIDC(getWorkflow(properties))],
      [providers_1.AuthMechanism.MONGODB_PLAIN, () => new plain_1.Plain()],
      [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, () => new scram_1.ScramSHA1()],
      [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, () => new scram_1.ScramSHA256()],
      [providers_1.AuthMechanism.MONGODB_X509, () => new x509_1.X509()]
    ]);
    var MongoClientAuthProviders = class {
      constructor() {
        this.existingProviders = /* @__PURE__ */ new Map();
      }
      /**
       * Get or create an authentication provider based on the provided mechanism.
       * We don't want to create all providers at once, as some providers may not be used.
       * @param name - The name of the provider to get or create.
       * @param credentials - The credentials.
       * @returns The provider.
       * @throws MongoInvalidArgumentError if the mechanism is not supported.
       * @internal
       */
      getOrCreateProvider(name, authMechanismProperties) {
        const authProvider = this.existingProviders.get(name);
        if (authProvider) {
          return authProvider;
        }
        const providerFunction = AUTH_PROVIDERS.get(name);
        if (!providerFunction) {
          throw new error_1.MongoInvalidArgumentError(`authMechanism ${name} not supported`);
        }
        const provider = providerFunction(authMechanismProperties);
        this.existingProviders.set(name, provider);
        return provider;
      }
    };
    exports2.MongoClientAuthProviders = MongoClientAuthProviders;
    function getWorkflow(authMechanismProperties) {
      if (authMechanismProperties.OIDC_HUMAN_CALLBACK) {
        return new human_callback_workflow_1.HumanCallbackWorkflow(new token_cache_1.TokenCache(), authMechanismProperties.OIDC_HUMAN_CALLBACK);
      } else if (authMechanismProperties.OIDC_CALLBACK) {
        return new automated_callback_workflow_1.AutomatedCallbackWorkflow(new token_cache_1.TokenCache(), authMechanismProperties.OIDC_CALLBACK);
      } else {
        const environment = authMechanismProperties.ENVIRONMENT;
        const workflow = mongodb_oidc_1.OIDC_WORKFLOWS.get(environment)?.();
        if (!workflow) {
          throw new error_1.MongoInvalidArgumentError(`Could not load workflow for environment ${authMechanismProperties.ENVIRONMENT}`);
        }
        return workflow;
      }
    }
  }
});

// node_modules/mongodb/lib/beta.js
var require_beta = __commonJS({
  "node_modules/mongodb/lib/beta.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar2(require_lib6(), exports2);
    function __exportStar2(mod) {
      for (const key of Object.keys(mod)) {
        Object.defineProperty(exports2, key, {
          enumerable: true,
          get: function() {
            return mod[key];
          }
        });
      }
    }
  }
});

// node_modules/mongodb/lib/operations/client_bulk_write/client_bulk_write.js
var require_client_bulk_write = __commonJS({
  "node_modules/mongodb/lib/operations/client_bulk_write/client_bulk_write.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientBulkWriteOperation = void 0;
    var beta_1 = require_beta();
    var responses_1 = require_responses();
    var utils_1 = require_utils5();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var ClientBulkWriteOperation = class extends command_1.CommandOperation {
      get commandName() {
        return "bulkWrite";
      }
      constructor(commandBuilder, options2) {
        super(void 0, options2);
        this.commandBuilder = commandBuilder;
        this.options = options2;
        this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
      }
      resetBatch() {
        return this.commandBuilder.resetBatch();
      }
      get canRetryWrite() {
        return this.commandBuilder.isBatchRetryable;
      }
      /**
       * Execute the command. Superclass will handle write concern, etc.
       * @param server - The server.
       * @param session - The session.
       * @returns The response.
       */
      async execute(server, session, timeoutContext) {
        let command;
        if (server.description.type === beta_1.ServerType.LoadBalancer) {
          if (session) {
            let connection;
            if (!session.pinnedConnection) {
              connection = await server.pool.checkOut({ timeoutContext });
              session.pin(connection);
            } else {
              connection = session.pinnedConnection;
            }
            command = this.commandBuilder.buildBatch(connection.hello?.maxMessageSizeBytes, connection.hello?.maxWriteBatchSize, connection.hello?.maxBsonObjectSize);
          } else {
            throw new beta_1.MongoClientBulkWriteExecutionError("Session provided to the client bulk write operation must be present.");
          }
        } else {
          if (!server.description.maxWriteBatchSize || !server.description.maxMessageSizeBytes || !server.description.maxBsonObjectSize) {
            throw new beta_1.MongoClientBulkWriteExecutionError("In order to execute a client bulk write, both maxWriteBatchSize, maxMessageSizeBytes and maxBsonObjectSize must be provided by the servers hello response.");
          }
          command = this.commandBuilder.buildBatch(server.description.maxMessageSizeBytes, server.description.maxWriteBatchSize, server.description.maxBsonObjectSize);
        }
        if (!this.canRetryWrite) {
          this.options.willRetryWrite = false;
        }
        return await super.executeCommand(server, session, command, timeoutContext, responses_1.ClientBulkWriteCursorResponse);
      }
    };
    exports2.ClientBulkWriteOperation = ClientBulkWriteOperation;
    (0, operation_1.defineAspects)(ClientBulkWriteOperation, [
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.SKIP_COLLATION,
      operation_1.Aspect.CURSOR_CREATING,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.COMMAND_BATCHING
    ]);
  }
});

// node_modules/mongodb/lib/cursor/client_bulk_write_cursor.js
var require_client_bulk_write_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/client_bulk_write_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientBulkWriteCursor = void 0;
    var client_bulk_write_1 = require_client_bulk_write();
    var execute_operation_1 = require_execute_operation();
    var utils_1 = require_utils5();
    var abstract_cursor_1 = require_abstract_cursor();
    var ClientBulkWriteCursor = class _ClientBulkWriteCursor extends abstract_cursor_1.AbstractCursor {
      /** @internal */
      constructor(client, commandBuilder, options2 = {}) {
        super(client, new utils_1.MongoDBNamespace("admin", "$cmd"), options2);
        this.commandBuilder = commandBuilder;
        this.clientBulkWriteOptions = options2;
      }
      /**
       * We need a way to get the top level cursor response fields for
       * generating the bulk write result, so we expose this here.
       */
      get response() {
        if (this.cursorResponse)
          return this.cursorResponse;
        return null;
      }
      get operations() {
        return this.commandBuilder.lastOperations;
      }
      clone() {
        const clonedOptions = (0, utils_1.mergeOptions)({}, this.clientBulkWriteOptions);
        delete clonedOptions.session;
        return new _ClientBulkWriteCursor(this.client, this.commandBuilder, {
          ...clonedOptions
        });
      }
      /** @internal */
      async _initialize(session) {
        const clientBulkWriteOperation = new client_bulk_write_1.ClientBulkWriteOperation(this.commandBuilder, {
          ...this.clientBulkWriteOptions,
          ...this.cursorOptions,
          session
        });
        const response = await (0, execute_operation_1.executeOperation)(this.client, clientBulkWriteOperation, this.timeoutContext);
        this.cursorResponse = response;
        return { server: clientBulkWriteOperation.server, session, response };
      }
    };
    exports2.ClientBulkWriteCursor = ClientBulkWriteCursor;
  }
});

// node_modules/mongodb/lib/operations/client_bulk_write/command_builder.js
var require_command_builder = __commonJS({
  "node_modules/mongodb/lib/operations/client_bulk_write/command_builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildReplaceOneOperation = exports2.buildUpdateManyOperation = exports2.buildUpdateOneOperation = exports2.buildDeleteManyOperation = exports2.buildDeleteOneOperation = exports2.buildInsertOneOperation = exports2.ClientBulkWriteCommandBuilder = void 0;
    exports2.buildOperation = buildOperation;
    var bson_1 = require_bson2();
    var commands_1 = require_commands();
    var error_1 = require_error();
    var sort_1 = require_sort2();
    var utils_1 = require_utils5();
    var MESSAGE_OVERHEAD_BYTES = 1e3;
    var ClientBulkWriteCommandBuilder = class {
      /**
       * Create the command builder.
       * @param models - The client write models.
       */
      constructor(models, options2, pkFactory) {
        this.models = models;
        this.options = options2;
        this.pkFactory = pkFactory ?? utils_1.DEFAULT_PK_FACTORY;
        this.currentModelIndex = 0;
        this.previousModelIndex = 0;
        this.lastOperations = [];
        this.isBatchRetryable = true;
      }
      /**
       * Gets the errorsOnly value for the command, which is the inverse of the
       * user provided verboseResults option. Defaults to true.
       */
      get errorsOnly() {
        if ("verboseResults" in this.options) {
          return !this.options.verboseResults;
        }
        return true;
      }
      /**
       * Determines if there is another batch to process.
       * @returns True if not all batches have been built.
       */
      hasNextBatch() {
        return this.currentModelIndex < this.models.length;
      }
      /**
       * When we need to retry a command we need to set the current
       * model index back to its previous value.
       */
      resetBatch() {
        this.currentModelIndex = this.previousModelIndex;
        return true;
      }
      /**
       * Build a single batch of a client bulk write command.
       * @param maxMessageSizeBytes - The max message size in bytes.
       * @param maxWriteBatchSize - The max write batch size.
       * @returns The client bulk write command.
       */
      buildBatch(maxMessageSizeBytes, maxWriteBatchSize, maxBsonObjectSize) {
        this.isBatchRetryable = true;
        let commandLength = 0;
        let currentNamespaceIndex = 0;
        const command = this.baseCommand();
        const namespaces = /* @__PURE__ */ new Map();
        this.previousModelIndex = this.currentModelIndex;
        while (this.currentModelIndex < this.models.length) {
          const model = this.models[this.currentModelIndex];
          const ns = model.namespace;
          const nsIndex = namespaces.get(ns);
          if (model.name === "deleteMany" || model.name === "updateMany") {
            this.isBatchRetryable = false;
          }
          if (nsIndex != null) {
            const operation = buildOperation(model, nsIndex, this.pkFactory, this.options);
            let operationBuffer;
            try {
              operationBuffer = bson_1.BSON.serialize(operation);
            } catch (cause) {
              throw new error_1.MongoInvalidArgumentError(`Could not serialize operation to BSON`, { cause });
            }
            validateBufferSize("ops", operationBuffer, maxBsonObjectSize);
            if (commandLength + operationBuffer.length < maxMessageSizeBytes && command.ops.documents.length < maxWriteBatchSize) {
              commandLength = MESSAGE_OVERHEAD_BYTES + command.ops.push(operation, operationBuffer);
              this.currentModelIndex++;
            } else {
              break;
            }
          } else {
            namespaces.set(ns, currentNamespaceIndex);
            const nsInfo = { ns };
            const operation = buildOperation(model, currentNamespaceIndex, this.pkFactory, this.options);
            let nsInfoBuffer;
            let operationBuffer;
            try {
              nsInfoBuffer = bson_1.BSON.serialize(nsInfo);
              operationBuffer = bson_1.BSON.serialize(operation);
            } catch (cause) {
              throw new error_1.MongoInvalidArgumentError(`Could not serialize ns info to BSON`, { cause });
            }
            validateBufferSize("nsInfo", nsInfoBuffer, maxBsonObjectSize);
            validateBufferSize("ops", operationBuffer, maxBsonObjectSize);
            if (commandLength + nsInfoBuffer.length + operationBuffer.length < maxMessageSizeBytes && command.ops.documents.length < maxWriteBatchSize) {
              commandLength = MESSAGE_OVERHEAD_BYTES + command.nsInfo.push(nsInfo, nsInfoBuffer) + command.ops.push(operation, operationBuffer);
              currentNamespaceIndex++;
              this.currentModelIndex++;
            } else {
              break;
            }
          }
        }
        this.lastOperations = command.ops.documents;
        return command;
      }
      baseCommand() {
        const command = {
          bulkWrite: 1,
          errorsOnly: this.errorsOnly,
          ordered: this.options.ordered ?? true,
          ops: new commands_1.DocumentSequence("ops"),
          nsInfo: new commands_1.DocumentSequence("nsInfo")
        };
        if (this.options.bypassDocumentValidation != null) {
          command.bypassDocumentValidation = this.options.bypassDocumentValidation;
        }
        if (this.options.let) {
          command.let = this.options.let;
        }
        if (this.options.comment !== void 0) {
          command.comment = this.options.comment;
        }
        return command;
      }
    };
    exports2.ClientBulkWriteCommandBuilder = ClientBulkWriteCommandBuilder;
    function validateBufferSize(name, buffer, maxBsonObjectSize) {
      if (buffer.length > maxBsonObjectSize) {
        throw new error_1.MongoInvalidArgumentError(`Client bulk write operation ${name} of length ${buffer.length} exceeds the max bson object size of ${maxBsonObjectSize}`);
      }
    }
    var buildInsertOneOperation = (model, index, pkFactory) => {
      const document2 = {
        insert: index,
        document: model.document
      };
      document2.document._id = model.document._id ?? pkFactory.createPk();
      return document2;
    };
    exports2.buildInsertOneOperation = buildInsertOneOperation;
    var buildDeleteOneOperation = (model, index) => {
      return createDeleteOperation(model, index, false);
    };
    exports2.buildDeleteOneOperation = buildDeleteOneOperation;
    var buildDeleteManyOperation = (model, index) => {
      return createDeleteOperation(model, index, true);
    };
    exports2.buildDeleteManyOperation = buildDeleteManyOperation;
    function createDeleteOperation(model, index, multi) {
      const document2 = {
        delete: index,
        multi,
        filter: model.filter
      };
      if (model.hint) {
        document2.hint = model.hint;
      }
      if (model.collation) {
        document2.collation = model.collation;
      }
      return document2;
    }
    var buildUpdateOneOperation = (model, index, options2) => {
      return createUpdateOperation(model, index, false, options2);
    };
    exports2.buildUpdateOneOperation = buildUpdateOneOperation;
    var buildUpdateManyOperation = (model, index, options2) => {
      return createUpdateOperation(model, index, true, options2);
    };
    exports2.buildUpdateManyOperation = buildUpdateManyOperation;
    function validateUpdate(update, options2) {
      if (!(0, utils_1.hasAtomicOperators)(update, options2)) {
        throw new error_1.MongoAPIError("Client bulk write update models must only contain atomic modifiers (start with $) and must not be empty.");
      }
    }
    function createUpdateOperation(model, index, multi, options2) {
      validateUpdate(model.update, options2);
      const document2 = {
        update: index,
        multi,
        filter: model.filter,
        updateMods: model.update
      };
      if (model.hint) {
        document2.hint = model.hint;
      }
      if (model.upsert) {
        document2.upsert = model.upsert;
      }
      if (model.arrayFilters) {
        document2.arrayFilters = model.arrayFilters;
      }
      if (model.collation) {
        document2.collation = model.collation;
      }
      if (!multi && "sort" in model && model.sort != null) {
        document2.sort = (0, sort_1.formatSort)(model.sort);
      }
      return document2;
    }
    var buildReplaceOneOperation = (model, index) => {
      if ((0, utils_1.hasAtomicOperators)(model.replacement)) {
        throw new error_1.MongoAPIError("Client bulk write replace models must not contain atomic modifiers (start with $) and must not be empty.");
      }
      const document2 = {
        update: index,
        multi: false,
        filter: model.filter,
        updateMods: model.replacement
      };
      if (model.hint) {
        document2.hint = model.hint;
      }
      if (model.upsert) {
        document2.upsert = model.upsert;
      }
      if (model.collation) {
        document2.collation = model.collation;
      }
      if (model.sort != null) {
        document2.sort = (0, sort_1.formatSort)(model.sort);
      }
      return document2;
    };
    exports2.buildReplaceOneOperation = buildReplaceOneOperation;
    function buildOperation(model, index, pkFactory, options2) {
      switch (model.name) {
        case "insertOne":
          return (0, exports2.buildInsertOneOperation)(model, index, pkFactory);
        case "deleteOne":
          return (0, exports2.buildDeleteOneOperation)(model, index);
        case "deleteMany":
          return (0, exports2.buildDeleteManyOperation)(model, index);
        case "updateOne":
          return (0, exports2.buildUpdateOneOperation)(model, index, options2);
        case "updateMany":
          return (0, exports2.buildUpdateManyOperation)(model, index, options2);
        case "replaceOne":
          return (0, exports2.buildReplaceOneOperation)(model, index);
      }
    }
  }
});

// node_modules/mongodb/lib/operations/client_bulk_write/results_merger.js
var require_results_merger = __commonJS({
  "node_modules/mongodb/lib/operations/client_bulk_write/results_merger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientBulkWriteResultsMerger = void 0;
    var __1 = require_lib6();
    var error_1 = require_error();
    var UNACKNOWLEDGED = {
      acknowledged: false,
      insertedCount: 0,
      upsertedCount: 0,
      matchedCount: 0,
      modifiedCount: 0,
      deletedCount: 0,
      insertResults: void 0,
      updateResults: void 0,
      deleteResults: void 0
    };
    var ClientBulkWriteResultsMerger = class {
      /**
       * @returns The standard unacknowledged bulk write result.
       */
      static unacknowledged() {
        return UNACKNOWLEDGED;
      }
      /**
       * Instantiate the merger.
       * @param options - The options.
       */
      constructor(options2) {
        this.options = options2;
        this.currentBatchOffset = 0;
        this.writeConcernErrors = [];
        this.writeErrors = /* @__PURE__ */ new Map();
        this.result = {
          acknowledged: true,
          insertedCount: 0,
          upsertedCount: 0,
          matchedCount: 0,
          modifiedCount: 0,
          deletedCount: 0,
          insertResults: void 0,
          updateResults: void 0,
          deleteResults: void 0
        };
        if (options2.verboseResults) {
          this.result.insertResults = /* @__PURE__ */ new Map();
          this.result.updateResults = /* @__PURE__ */ new Map();
          this.result.deleteResults = /* @__PURE__ */ new Map();
        }
      }
      /**
       * Get the bulk write result object.
       */
      get bulkWriteResult() {
        return {
          acknowledged: this.result.acknowledged,
          insertedCount: this.result.insertedCount,
          upsertedCount: this.result.upsertedCount,
          matchedCount: this.result.matchedCount,
          modifiedCount: this.result.modifiedCount,
          deletedCount: this.result.deletedCount,
          insertResults: this.result.insertResults,
          updateResults: this.result.updateResults,
          deleteResults: this.result.deleteResults
        };
      }
      /**
       * Merge the results in the cursor to the existing result.
       * @param currentBatchOffset - The offset index to the original models.
       * @param response - The cursor response.
       * @param documents - The documents in the cursor.
       * @returns The current result.
       */
      async merge(cursor) {
        let writeConcernErrorResult;
        try {
          for await (const document2 of cursor) {
            if (document2.ok === 1) {
              if (this.options.verboseResults) {
                this.processDocument(cursor, document2);
              }
            } else {
              if (this.options.ordered) {
                const error2 = new error_1.MongoClientBulkWriteError({
                  message: "Mongo client ordered bulk write encountered a write error."
                });
                error2.writeErrors.set(document2.idx + this.currentBatchOffset, {
                  code: document2.code,
                  message: document2.errmsg
                });
                error2.partialResult = this.result;
                throw error2;
              } else {
                this.writeErrors.set(document2.idx + this.currentBatchOffset, {
                  code: document2.code,
                  message: document2.errmsg
                });
              }
            }
          }
        } catch (error2) {
          if (error2 instanceof __1.MongoWriteConcernError) {
            const result = error2.result;
            writeConcernErrorResult = {
              insertedCount: result.nInserted,
              upsertedCount: result.nUpserted,
              matchedCount: result.nMatched,
              modifiedCount: result.nModified,
              deletedCount: result.nDeleted,
              writeConcernError: result.writeConcernError
            };
            if (this.options.verboseResults && result.cursor.firstBatch) {
              for (const document2 of result.cursor.firstBatch) {
                if (document2.ok === 1) {
                  this.processDocument(cursor, document2);
                }
              }
            }
          } else {
            throw error2;
          }
        } finally {
          if (cursor.response) {
            const response = cursor.response;
            this.incrementCounts(response);
          }
          this.currentBatchOffset += cursor.operations.length;
        }
        if (writeConcernErrorResult) {
          const writeConcernError = writeConcernErrorResult.writeConcernError;
          this.incrementCounts(writeConcernErrorResult);
          this.writeConcernErrors.push({
            code: writeConcernError.code,
            message: writeConcernError.errmsg
          });
        }
        return this.result;
      }
      /**
       * Process an individual document in the results.
       * @param cursor - The cursor.
       * @param document - The document to process.
       */
      processDocument(cursor, document2) {
        const operation = cursor.operations[document2.idx];
        if ("insert" in operation) {
          this.result.insertResults?.set(document2.idx + this.currentBatchOffset, {
            insertedId: operation.document._id
          });
        }
        if ("update" in operation) {
          const result = {
            matchedCount: document2.n,
            modifiedCount: document2.nModified ?? 0,
            // Check if the bulk did actually upsert.
            didUpsert: document2.upserted != null
          };
          if (document2.upserted) {
            result.upsertedId = document2.upserted._id;
          }
          this.result.updateResults?.set(document2.idx + this.currentBatchOffset, result);
        }
        if ("delete" in operation) {
          this.result.deleteResults?.set(document2.idx + this.currentBatchOffset, {
            deletedCount: document2.n
          });
        }
      }
      /**
       * Increment the result counts.
       * @param document - The document with the results.
       */
      incrementCounts(document2) {
        this.result.insertedCount += document2.insertedCount;
        this.result.upsertedCount += document2.upsertedCount;
        this.result.matchedCount += document2.matchedCount;
        this.result.modifiedCount += document2.modifiedCount;
        this.result.deletedCount += document2.deletedCount;
      }
    };
    exports2.ClientBulkWriteResultsMerger = ClientBulkWriteResultsMerger;
  }
});

// node_modules/mongodb/lib/operations/client_bulk_write/executor.js
var require_executor = __commonJS({
  "node_modules/mongodb/lib/operations/client_bulk_write/executor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientBulkWriteExecutor = void 0;
    var abstract_cursor_1 = require_abstract_cursor();
    var client_bulk_write_cursor_1 = require_client_bulk_write_cursor();
    var error_1 = require_error();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils5();
    var write_concern_1 = require_write_concern();
    var execute_operation_1 = require_execute_operation();
    var client_bulk_write_1 = require_client_bulk_write();
    var command_builder_1 = require_command_builder();
    var results_merger_1 = require_results_merger();
    var ClientBulkWriteExecutor = class {
      /**
       * Instantiate the executor.
       * @param client - The mongo client.
       * @param operations - The user supplied bulk write models.
       * @param options - The bulk write options.
       */
      constructor(client, operations, options2) {
        if (operations.length === 0) {
          throw new error_1.MongoClientBulkWriteExecutionError("No client bulk write models were provided.");
        }
        this.client = client;
        this.operations = operations;
        this.options = {
          ordered: true,
          bypassDocumentValidation: false,
          verboseResults: false,
          ...options2
        };
        if (!this.options.writeConcern) {
          this.options.writeConcern = write_concern_1.WriteConcern.fromOptions(this.client.s.options);
        }
        if (this.options.writeConcern?.w === 0) {
          if (this.options.verboseResults) {
            throw new error_1.MongoInvalidArgumentError("Cannot request unacknowledged write concern and verbose results");
          }
          if (this.options.ordered) {
            throw new error_1.MongoInvalidArgumentError("Cannot request unacknowledged write concern and ordered writes");
          }
        }
      }
      /**
       * Execute the client bulk write. Will split commands into batches and exhaust the cursors
       * for each, then merge the results into one.
       * @returns The result.
       */
      async execute() {
        const pkFactory = this.client.s.options.pkFactory;
        const commandBuilder = new command_builder_1.ClientBulkWriteCommandBuilder(this.operations, this.options, pkFactory);
        const resolvedOptions = (0, utils_1.resolveTimeoutOptions)(this.client, this.options);
        const context = timeout_1.TimeoutContext.create(resolvedOptions);
        if (this.options.writeConcern?.w === 0) {
          while (commandBuilder.hasNextBatch()) {
            const operation = new client_bulk_write_1.ClientBulkWriteOperation(commandBuilder, this.options);
            await (0, execute_operation_1.executeOperation)(this.client, operation, context);
          }
          return results_merger_1.ClientBulkWriteResultsMerger.unacknowledged();
        } else {
          const resultsMerger = new results_merger_1.ClientBulkWriteResultsMerger(this.options);
          while (commandBuilder.hasNextBatch()) {
            const cursorContext = new abstract_cursor_1.CursorTimeoutContext(context, Symbol());
            const options2 = {
              ...this.options,
              timeoutContext: cursorContext,
              ...resolvedOptions.timeoutMS != null && { timeoutMode: abstract_cursor_1.CursorTimeoutMode.LIFETIME }
            };
            const cursor = new client_bulk_write_cursor_1.ClientBulkWriteCursor(this.client, commandBuilder, options2);
            try {
              await resultsMerger.merge(cursor);
            } catch (error2) {
              if (error2 instanceof error_1.MongoServerError && !(error2 instanceof error_1.MongoClientBulkWriteError)) {
                const bulkWriteError = new error_1.MongoClientBulkWriteError({
                  message: "Mongo client bulk write encountered an error during execution"
                });
                bulkWriteError.cause = error2;
                bulkWriteError.partialResult = resultsMerger.bulkWriteResult;
                throw bulkWriteError;
              } else {
                throw error2;
              }
            }
          }
          if (resultsMerger.writeConcernErrors.length > 0 || resultsMerger.writeErrors.size > 0) {
            const error2 = new error_1.MongoClientBulkWriteError({
              message: "Mongo client bulk write encountered errors during execution."
            });
            error2.writeConcernErrors = resultsMerger.writeConcernErrors;
            error2.writeErrors = resultsMerger.writeErrors;
            error2.partialResult = resultsMerger.bulkWriteResult;
            throw error2;
          }
          return resultsMerger.bulkWriteResult;
        }
      }
    };
    exports2.ClientBulkWriteExecutor = ClientBulkWriteExecutor;
  }
});

// node_modules/mongodb/lib/sdam/server_selection_events.js
var require_server_selection_events = __commonJS({
  "node_modules/mongodb/lib/sdam/server_selection_events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WaitingForSuitableServerEvent = exports2.ServerSelectionSucceededEvent = exports2.ServerSelectionFailedEvent = exports2.ServerSelectionStartedEvent = exports2.ServerSelectionEvent = void 0;
    var utils_1 = require_utils5();
    var constants_1 = require_constants4();
    var ServerSelectionEvent = class {
      /** @internal */
      constructor(selector, topologyDescription, operation) {
        this.selector = selector;
        this.operation = operation;
        this.topologyDescription = topologyDescription;
      }
    };
    exports2.ServerSelectionEvent = ServerSelectionEvent;
    var ServerSelectionStartedEvent = class extends ServerSelectionEvent {
      /** @internal */
      constructor(selector, topologyDescription, operation) {
        super(selector, topologyDescription, operation);
        this.name = constants_1.SERVER_SELECTION_STARTED;
        this.message = "Server selection started";
      }
    };
    exports2.ServerSelectionStartedEvent = ServerSelectionStartedEvent;
    var ServerSelectionFailedEvent = class extends ServerSelectionEvent {
      /** @internal */
      constructor(selector, topologyDescription, error2, operation) {
        super(selector, topologyDescription, operation);
        this.name = constants_1.SERVER_SELECTION_FAILED;
        this.message = "Server selection failed";
        this.failure = error2;
      }
    };
    exports2.ServerSelectionFailedEvent = ServerSelectionFailedEvent;
    var ServerSelectionSucceededEvent = class extends ServerSelectionEvent {
      /** @internal */
      constructor(selector, topologyDescription, address, operation) {
        super(selector, topologyDescription, operation);
        this.name = constants_1.SERVER_SELECTION_SUCCEEDED;
        this.message = "Server selection succeeded";
        const { host, port } = utils_1.HostAddress.fromString(address).toHostPort();
        this.serverHost = host;
        this.serverPort = port;
      }
    };
    exports2.ServerSelectionSucceededEvent = ServerSelectionSucceededEvent;
    var WaitingForSuitableServerEvent = class extends ServerSelectionEvent {
      /** @internal */
      constructor(selector, topologyDescription, remainingTimeMS, operation) {
        super(selector, topologyDescription, operation);
        this.name = constants_1.WAITING_FOR_SUITABLE_SERVER;
        this.message = "Waiting for suitable server to become available";
        this.remainingTimeMS = remainingTimeMS;
      }
    };
    exports2.WaitingForSuitableServerEvent = WaitingForSuitableServerEvent;
  }
});

// node_modules/mongodb/lib/sdam/srv_polling.js
var require_srv_polling = __commonJS({
  "node_modules/mongodb/lib/sdam/srv_polling.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SrvPoller = exports2.SrvPollingEvent = void 0;
    var dns = require("dns");
    var timers_1 = require("timers");
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var utils_1 = require_utils5();
    var SrvPollingEvent = class {
      constructor(srvRecords) {
        this.srvRecords = srvRecords;
      }
      hostnames() {
        return new Set(this.srvRecords.map((r) => utils_1.HostAddress.fromSrvRecord(r).toString()));
      }
    };
    exports2.SrvPollingEvent = SrvPollingEvent;
    var SrvPoller = class _SrvPoller extends mongo_types_1.TypedEventEmitter {
      constructor(options2) {
        super();
        this.on("error", utils_1.noop);
        if (!options2 || !options2.srvHost) {
          throw new error_1.MongoRuntimeError("Options for SrvPoller must exist and include srvHost");
        }
        this.srvHost = options2.srvHost;
        this.srvMaxHosts = options2.srvMaxHosts ?? 0;
        this.srvServiceName = options2.srvServiceName ?? "mongodb";
        this.rescanSrvIntervalMS = 6e4;
        this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS ?? 1e4;
        this.haMode = false;
        this.generation = 0;
        this._timeout = void 0;
      }
      get srvAddress() {
        return `_${this.srvServiceName}._tcp.${this.srvHost}`;
      }
      get intervalMS() {
        return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
      }
      start() {
        if (!this._timeout) {
          this.schedule();
        }
      }
      stop() {
        if (this._timeout) {
          (0, timers_1.clearTimeout)(this._timeout);
          this.generation += 1;
          this._timeout = void 0;
        }
      }
      // TODO(NODE-4994): implement new logging logic for SrvPoller failures
      schedule() {
        if (this._timeout) {
          (0, timers_1.clearTimeout)(this._timeout);
        }
        this._timeout = (0, timers_1.setTimeout)(() => {
          this._poll().then(void 0, utils_1.squashError);
        }, this.intervalMS);
      }
      success(srvRecords) {
        this.haMode = false;
        this.schedule();
        this.emit(_SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));
      }
      failure() {
        this.haMode = true;
        this.schedule();
      }
      async _poll() {
        const generation = this.generation;
        let srvRecords;
        try {
          srvRecords = await dns.promises.resolveSrv(this.srvAddress);
        } catch {
          this.failure();
          return;
        }
        if (generation !== this.generation) {
          return;
        }
        const finalAddresses = [];
        for (const record of srvRecords) {
          try {
            (0, utils_1.checkParentDomainMatch)(record.name, this.srvHost);
            finalAddresses.push(record);
          } catch (error2) {
            (0, utils_1.squashError)(error2);
          }
        }
        if (!finalAddresses.length) {
          this.failure();
          return;
        }
        this.success(finalAddresses);
      }
    };
    exports2.SrvPoller = SrvPoller;
    SrvPoller.SRV_RECORD_DISCOVERY = "srvRecordDiscovery";
  }
});

// node_modules/mongodb/lib/sdam/topology.js
var require_topology = __commonJS({
  "node_modules/mongodb/lib/sdam/topology.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerCapabilities = exports2.Topology = void 0;
    var connection_string_1 = require_connection_string();
    var constants_1 = require_constants4();
    var error_1 = require_error();
    var mongo_logger_1 = require_mongo_logger();
    var mongo_types_1 = require_mongo_types();
    var read_preference_1 = require_read_preference();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils5();
    var common_1 = require_common2();
    var events_1 = require_events();
    var server_1 = require_server();
    var server_description_1 = require_server_description();
    var server_selection_1 = require_server_selection();
    var server_selection_events_1 = require_server_selection_events();
    var srv_polling_1 = require_srv_polling();
    var topology_description_1 = require_topology_description();
    var globalTopologyCounter = 0;
    var stateTransition = (0, utils_1.makeStateMachine)({
      [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
      [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
      [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
      [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
    });
    var Topology = class _Topology extends mongo_types_1.TypedEventEmitter {
      /**
       * @param seedlist - a list of HostAddress instances to connect to
       */
      constructor(client, seeds, options2) {
        super();
        this.on("error", utils_1.noop);
        this.client = client;
        options2 = options2 ?? {
          hosts: [utils_1.HostAddress.fromString("localhost:27017")],
          ...Object.fromEntries(connection_string_1.DEFAULT_OPTIONS.entries())
        };
        if (typeof seeds === "string") {
          seeds = [utils_1.HostAddress.fromString(seeds)];
        } else if (!Array.isArray(seeds)) {
          seeds = [seeds];
        }
        const seedlist = [];
        for (const seed of seeds) {
          if (typeof seed === "string") {
            seedlist.push(utils_1.HostAddress.fromString(seed));
          } else if (seed instanceof utils_1.HostAddress) {
            seedlist.push(seed);
          } else {
            throw new error_1.MongoRuntimeError(`Topology cannot be constructed from ${JSON.stringify(seed)}`);
          }
        }
        const topologyType = topologyTypeFromOptions(options2);
        const topologyId = globalTopologyCounter++;
        const selectedHosts = options2.srvMaxHosts == null || options2.srvMaxHosts === 0 || options2.srvMaxHosts >= seedlist.length ? seedlist : (0, utils_1.shuffle)(seedlist, options2.srvMaxHosts);
        const serverDescriptions = /* @__PURE__ */ new Map();
        for (const hostAddress of selectedHosts) {
          serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));
        }
        this.waitQueue = new utils_1.List();
        this.s = {
          // the id of this topology
          id: topologyId,
          // passed in options
          options: options2,
          // initial seedlist of servers to connect to
          seedlist,
          // initial state
          state: common_1.STATE_CLOSED,
          // the topology description
          description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options2.replicaSet, void 0, void 0, void 0, options2),
          serverSelectionTimeoutMS: options2.serverSelectionTimeoutMS,
          heartbeatFrequencyMS: options2.heartbeatFrequencyMS,
          minHeartbeatFrequencyMS: options2.minHeartbeatFrequencyMS,
          // a map of server instances to normalized addresses
          servers: /* @__PURE__ */ new Map(),
          credentials: options2?.credentials,
          clusterTime: void 0,
          detectShardedTopology: (ev) => this.detectShardedTopology(ev),
          detectSrvRecords: (ev) => this.detectSrvRecords(ev)
        };
        this.mongoLogger = client.mongoLogger;
        this.component = "topology";
        if (options2.srvHost && !options2.loadBalanced) {
          this.s.srvPoller = options2.srvPoller ?? new srv_polling_1.SrvPoller({
            heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
            srvHost: options2.srvHost,
            srvMaxHosts: options2.srvMaxHosts,
            srvServiceName: options2.srvServiceName
          });
          this.on(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
        }
        this.connectionLock = void 0;
      }
      detectShardedTopology(event) {
        const previousType = event.previousDescription.type;
        const newType = event.newDescription.type;
        const transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;
        const srvListeners = this.s.srvPoller?.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);
        const listeningToSrvPolling = !!srvListeners?.includes(this.s.detectSrvRecords);
        if (transitionToSharded && !listeningToSrvPolling) {
          this.s.srvPoller?.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
          this.s.srvPoller?.start();
        }
      }
      detectSrvRecords(ev) {
        const previousTopologyDescription = this.s.description;
        this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);
        if (this.s.description === previousTopologyDescription) {
          return;
        }
        updateServers(this);
        this.emitAndLog(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
      }
      /**
       * @returns A `TopologyDescription` for this topology
       */
      get description() {
        return this.s.description;
      }
      get loadBalanced() {
        return this.s.options.loadBalanced;
      }
      get serverApi() {
        return this.s.options.serverApi;
      }
      get capabilities() {
        return new ServerCapabilities(this.lastHello());
      }
      /** Initiate server connect */
      async connect(options2) {
        this.connectionLock ??= this._connect(options2);
        try {
          await this.connectionLock;
          return this;
        } finally {
          this.connectionLock = void 0;
        }
      }
      async _connect(options2) {
        options2 = options2 ?? {};
        if (this.s.state === common_1.STATE_CONNECTED) {
          return this;
        }
        stateTransition(this, common_1.STATE_CONNECTING);
        this.emitAndLog(_Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id));
        this.emitAndLog(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(
          this.s.id,
          new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown),
          // initial is always Unknown
          this.s.description
        ));
        const serverDescriptions = Array.from(this.s.description.servers.values());
        this.s.servers = new Map(serverDescriptions.map((serverDescription) => [
          serverDescription.address,
          createAndConnectServer(this, serverDescription)
        ]));
        if (this.s.options.loadBalanced) {
          for (const description of serverDescriptions) {
            const newDescription = new server_description_1.ServerDescription(description.hostAddress, void 0, {
              loadBalanced: this.s.options.loadBalanced
            });
            this.serverUpdateHandler(newDescription);
          }
        }
        const serverSelectionTimeoutMS = this.client.s.options.serverSelectionTimeoutMS;
        const readPreference = options2.readPreference ?? read_preference_1.ReadPreference.primary;
        const timeoutContext = timeout_1.TimeoutContext.create({
          // TODO(NODE-6448): auto-connect ignores timeoutMS; potential future feature
          timeoutMS: void 0,
          serverSelectionTimeoutMS,
          waitQueueTimeoutMS: this.client.s.options.waitQueueTimeoutMS
        });
        const selectServerOptions = {
          operationName: "ping",
          ...options2,
          timeoutContext
        };
        try {
          const server = await this.selectServer((0, server_selection_1.readPreferenceServerSelector)(readPreference), selectServerOptions);
          const skipPingOnConnect = this.s.options.__skipPingOnConnect === true;
          if (!skipPingOnConnect && this.s.credentials) {
            await server.command((0, utils_1.ns)("admin.$cmd"), { ping: 1 }, { timeoutContext });
            stateTransition(this, common_1.STATE_CONNECTED);
            this.emit(_Topology.OPEN, this);
            this.emit(_Topology.CONNECT, this);
            return this;
          }
          stateTransition(this, common_1.STATE_CONNECTED);
          this.emit(_Topology.OPEN, this);
          this.emit(_Topology.CONNECT, this);
          return this;
        } catch (error2) {
          this.close();
          throw error2;
        }
      }
      closeCheckedOutConnections() {
        for (const server of this.s.servers.values()) {
          return server.closeCheckedOutConnections();
        }
      }
      /** Close this topology */
      close() {
        if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {
          return;
        }
        for (const server of this.s.servers.values()) {
          closeServer(server, this);
        }
        this.s.servers.clear();
        stateTransition(this, common_1.STATE_CLOSING);
        drainWaitQueue(this.waitQueue, new error_1.MongoTopologyClosedError());
        if (this.s.srvPoller) {
          this.s.srvPoller.stop();
          this.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
        }
        this.removeListener(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
        stateTransition(this, common_1.STATE_CLOSED);
        this.emitAndLog(_Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(this.s.id));
      }
      /**
       * Selects a server according to the selection predicate provided
       *
       * @param selector - An optional selector to select servers by, defaults to a random selection within a latency window
       * @param options - Optional settings related to server selection
       * @param callback - The callback used to indicate success or failure
       * @returns An instance of a `Server` meeting the criteria of the predicate provided
       */
      async selectServer(selector, options2) {
        let serverSelector;
        if (typeof selector !== "function") {
          if (typeof selector === "string") {
            serverSelector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.fromString(selector));
          } else {
            let readPreference;
            if (selector instanceof read_preference_1.ReadPreference) {
              readPreference = selector;
            } else {
              read_preference_1.ReadPreference.translate(options2);
              readPreference = options2.readPreference || read_preference_1.ReadPreference.primary;
            }
            serverSelector = (0, server_selection_1.readPreferenceServerSelector)(readPreference);
          }
        } else {
          serverSelector = selector;
        }
        options2 = { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS, ...options2 };
        if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
          this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionStartedEvent(selector, this.description, options2.operationName));
        }
        let timeout;
        if (options2.timeoutContext)
          timeout = options2.timeoutContext.serverSelectionTimeout;
        else {
          timeout = timeout_1.Timeout.expires(options2.serverSelectionTimeoutMS ?? 0);
        }
        const isSharded = this.description.type === common_1.TopologyType.Sharded;
        const session = options2.session;
        const transaction = session && session.transaction;
        if (isSharded && transaction && transaction.server) {
          if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
            this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionSucceededEvent(selector, this.description, transaction.server.pool.address, options2.operationName));
          }
          if (options2.timeoutContext?.clearServerSelectionTimeout)
            timeout?.clear();
          return transaction.server;
        }
        const { promise: serverPromise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
        const waitQueueMember = {
          serverSelector,
          topologyDescription: this.description,
          mongoLogger: this.client.mongoLogger,
          transaction,
          resolve,
          reject,
          cancelled: false,
          startTime: (0, utils_1.now)(),
          operationName: options2.operationName,
          waitingLogged: false,
          previousServer: options2.previousServer
        };
        const abortListener = (0, utils_1.addAbortListener)(options2.signal, function() {
          waitQueueMember.cancelled = true;
          reject(this.reason);
        });
        this.waitQueue.push(waitQueueMember);
        processWaitQueue(this);
        try {
          timeout?.throwIfExpired();
          const server = await (timeout ? Promise.race([serverPromise, timeout]) : serverPromise);
          if (options2.timeoutContext?.csotEnabled() && server.description.minRoundTripTime !== 0) {
            options2.timeoutContext.minRoundTripTime = server.description.minRoundTripTime;
          }
          return server;
        } catch (error2) {
          if (timeout_1.TimeoutError.is(error2)) {
            waitQueueMember.cancelled = true;
            const timeoutError = new error_1.MongoServerSelectionError(`Server selection timed out after ${timeout?.duration} ms`, this.description);
            if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
              this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(selector, this.description, timeoutError, options2.operationName));
            }
            if (options2.timeoutContext?.csotEnabled()) {
              throw new error_1.MongoOperationTimeoutError("Timed out during server selection", {
                cause: timeoutError
              });
            }
            throw timeoutError;
          }
          throw error2;
        } finally {
          abortListener?.[utils_1.kDispose]();
          if (options2.timeoutContext?.clearServerSelectionTimeout)
            timeout?.clear();
        }
      }
      /**
       * Update the internal TopologyDescription with a ServerDescription
       *
       * @param serverDescription - The server to update in the internal list of server descriptions
       */
      serverUpdateHandler(serverDescription) {
        if (!this.s.description.hasServer(serverDescription.address)) {
          return;
        }
        if (isStaleServerDescription(this.s.description, serverDescription)) {
          return;
        }
        const previousTopologyDescription = this.s.description;
        const previousServerDescription = this.s.description.servers.get(serverDescription.address);
        if (!previousServerDescription) {
          return;
        }
        const clusterTime = serverDescription.$clusterTime;
        if (clusterTime) {
          (0, common_1._advanceClusterTime)(this, clusterTime);
        }
        const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
        this.s.description = this.s.description.update(serverDescription);
        if (this.s.description.compatibilityError) {
          this.emit(_Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));
          return;
        }
        if (!equalDescriptions) {
          const newDescription = this.s.description.servers.get(serverDescription.address);
          if (newDescription) {
            this.emit(_Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));
          }
        }
        updateServers(this, serverDescription);
        if (this.waitQueue.length > 0) {
          processWaitQueue(this);
        }
        if (!equalDescriptions) {
          this.emitAndLog(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
        }
      }
      auth(credentials, callback) {
        if (typeof credentials === "function")
          callback = credentials, credentials = void 0;
        if (typeof callback === "function")
          callback(void 0, true);
      }
      get clientMetadata() {
        return this.s.options.metadata;
      }
      isConnected() {
        return this.s.state === common_1.STATE_CONNECTED;
      }
      isDestroyed() {
        return this.s.state === common_1.STATE_CLOSED;
      }
      // NOTE: There are many places in code where we explicitly check the last hello
      //       to do feature support detection. This should be done any other way, but for
      //       now we will just return the first hello seen, which should suffice.
      lastHello() {
        const serverDescriptions = Array.from(this.description.servers.values());
        if (serverDescriptions.length === 0)
          return {};
        const sd = serverDescriptions.filter((sd2) => sd2.type !== common_1.ServerType.Unknown)[0];
        const result = sd || { maxWireVersion: this.description.commonWireVersion };
        return result;
      }
      get commonWireVersion() {
        return this.description.commonWireVersion;
      }
      get logicalSessionTimeoutMinutes() {
        return this.description.logicalSessionTimeoutMinutes;
      }
      get clusterTime() {
        return this.s.clusterTime;
      }
      set clusterTime(clusterTime) {
        this.s.clusterTime = clusterTime;
      }
    };
    exports2.Topology = Topology;
    Topology.SERVER_OPENING = constants_1.SERVER_OPENING;
    Topology.SERVER_CLOSED = constants_1.SERVER_CLOSED;
    Topology.SERVER_DESCRIPTION_CHANGED = constants_1.SERVER_DESCRIPTION_CHANGED;
    Topology.TOPOLOGY_OPENING = constants_1.TOPOLOGY_OPENING;
    Topology.TOPOLOGY_CLOSED = constants_1.TOPOLOGY_CLOSED;
    Topology.TOPOLOGY_DESCRIPTION_CHANGED = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
    Topology.ERROR = constants_1.ERROR;
    Topology.OPEN = constants_1.OPEN;
    Topology.CONNECT = constants_1.CONNECT;
    Topology.CLOSE = constants_1.CLOSE;
    Topology.TIMEOUT = constants_1.TIMEOUT;
    function closeServer(server, topology) {
      for (const event of constants_1.LOCAL_SERVER_EVENTS) {
        server.removeAllListeners(event);
      }
      server.close();
      topology.emitAndLog(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server.description.address));
      for (const event of constants_1.SERVER_RELAY_EVENTS) {
        server.removeAllListeners(event);
      }
    }
    function topologyTypeFromOptions(options2) {
      if (options2?.directConnection) {
        return common_1.TopologyType.Single;
      }
      if (options2?.replicaSet) {
        return common_1.TopologyType.ReplicaSetNoPrimary;
      }
      if (options2?.loadBalanced) {
        return common_1.TopologyType.LoadBalanced;
      }
      return common_1.TopologyType.Unknown;
    }
    function createAndConnectServer(topology, serverDescription) {
      topology.emitAndLog(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));
      const server = new server_1.Server(topology, serverDescription, topology.s.options);
      for (const event of constants_1.SERVER_RELAY_EVENTS) {
        server.on(event, (e) => topology.emit(event, e));
      }
      server.on(server_1.Server.DESCRIPTION_RECEIVED, (description) => topology.serverUpdateHandler(description));
      server.connect();
      return server;
    }
    function updateServers(topology, incomingServerDescription) {
      if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
        const server = topology.s.servers.get(incomingServerDescription.address);
        if (server) {
          server.s.description = incomingServerDescription;
          if (incomingServerDescription.error instanceof error_1.MongoError && incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.ResetPool)) {
            const interruptInUseConnections = incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
            server.pool.clear({ interruptInUseConnections });
          } else if (incomingServerDescription.error == null) {
            const newTopologyType = topology.s.description.type;
            const shouldMarkPoolReady = incomingServerDescription.isDataBearing || incomingServerDescription.type !== common_1.ServerType.Unknown && newTopologyType === common_1.TopologyType.Single;
            if (shouldMarkPoolReady) {
              server.pool.ready();
            }
          }
        }
      }
      for (const serverDescription of topology.description.servers.values()) {
        if (!topology.s.servers.has(serverDescription.address)) {
          const server = createAndConnectServer(topology, serverDescription);
          topology.s.servers.set(serverDescription.address, server);
        }
      }
      for (const entry of topology.s.servers) {
        const serverAddress = entry[0];
        if (topology.description.hasServer(serverAddress)) {
          continue;
        }
        if (!topology.s.servers.has(serverAddress)) {
          continue;
        }
        const server = topology.s.servers.get(serverAddress);
        topology.s.servers.delete(serverAddress);
        if (server) {
          closeServer(server, topology);
        }
      }
    }
    function drainWaitQueue(queue, drainError) {
      while (queue.length) {
        const waitQueueMember = queue.shift();
        if (!waitQueueMember) {
          continue;
        }
        if (!waitQueueMember.cancelled) {
          if (waitQueueMember.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
            waitQueueMember.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, waitQueueMember.topologyDescription, drainError, waitQueueMember.operationName));
          }
          waitQueueMember.reject(drainError);
        }
      }
    }
    function processWaitQueue(topology) {
      if (topology.s.state === common_1.STATE_CLOSED) {
        drainWaitQueue(topology.waitQueue, new error_1.MongoTopologyClosedError());
        return;
      }
      const isSharded = topology.description.type === common_1.TopologyType.Sharded;
      const serverDescriptions = Array.from(topology.description.servers.values());
      const membersToProcess = topology.waitQueue.length;
      for (let i = 0; i < membersToProcess; ++i) {
        const waitQueueMember = topology.waitQueue.shift();
        if (!waitQueueMember) {
          continue;
        }
        if (waitQueueMember.cancelled) {
          continue;
        }
        let selectedDescriptions;
        try {
          const serverSelector = waitQueueMember.serverSelector;
          const previousServer = waitQueueMember.previousServer;
          selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions, previousServer ? [previousServer] : []) : serverDescriptions;
        } catch (selectorError) {
          if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
            topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, topology.description, selectorError, waitQueueMember.operationName));
          }
          waitQueueMember.reject(selectorError);
          continue;
        }
        let selectedServer;
        if (selectedDescriptions.length === 0) {
          if (!waitQueueMember.waitingLogged) {
            if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.INFORMATIONAL)) {
              topology.client.mongoLogger?.info(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.WaitingForSuitableServerEvent(waitQueueMember.serverSelector, topology.description, topology.s.serverSelectionTimeoutMS !== 0 ? topology.s.serverSelectionTimeoutMS - ((0, utils_1.now)() - waitQueueMember.startTime) : -1, waitQueueMember.operationName));
            }
            waitQueueMember.waitingLogged = true;
          }
          topology.waitQueue.push(waitQueueMember);
          continue;
        } else if (selectedDescriptions.length === 1) {
          selectedServer = topology.s.servers.get(selectedDescriptions[0].address);
        } else {
          const descriptions = (0, utils_1.shuffle)(selectedDescriptions, 2);
          const server1 = topology.s.servers.get(descriptions[0].address);
          const server2 = topology.s.servers.get(descriptions[1].address);
          selectedServer = server1 && server2 && server1.s.operationCount < server2.s.operationCount ? server1 : server2;
        }
        if (!selectedServer) {
          const serverSelectionError = new error_1.MongoServerSelectionError("server selection returned a server description but the server was not found in the topology", topology.description);
          if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
            topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, topology.description, serverSelectionError, waitQueueMember.operationName));
          }
          waitQueueMember.reject(serverSelectionError);
          return;
        }
        const transaction = waitQueueMember.transaction;
        if (isSharded && transaction && transaction.isActive && selectedServer) {
          transaction.pinServer(selectedServer);
        }
        if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
          topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionSucceededEvent(waitQueueMember.serverSelector, waitQueueMember.topologyDescription, selectedServer.pool.address, waitQueueMember.operationName));
        }
        waitQueueMember.resolve(selectedServer);
      }
      if (topology.waitQueue.length > 0) {
        for (const [, server] of topology.s.servers) {
          process.nextTick(function scheduleServerCheck() {
            return server.requestCheck();
          });
        }
      }
    }
    function isStaleServerDescription(topologyDescription, incomingServerDescription) {
      const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
      const currentTopologyVersion = currentServerDescription?.topologyVersion;
      return (0, server_description_1.compareTopologyVersion)(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
    }
    var ServerCapabilities = class {
      constructor(hello) {
        this.minWireVersion = hello.minWireVersion || 0;
        this.maxWireVersion = hello.maxWireVersion || 0;
      }
      get hasAggregationCursor() {
        return this.maxWireVersion >= 1;
      }
      get hasWriteCommands() {
        return this.maxWireVersion >= 2;
      }
      get hasTextSearch() {
        return this.minWireVersion >= 0;
      }
      get hasAuthCommands() {
        return this.maxWireVersion >= 1;
      }
      get hasListCollectionsCommand() {
        return this.maxWireVersion >= 3;
      }
      get hasListIndexesCommand() {
        return this.maxWireVersion >= 3;
      }
      get supportsSnapshotReads() {
        return this.maxWireVersion >= 13;
      }
      get commandsTakeWriteConcern() {
        return this.maxWireVersion >= 5;
      }
      get commandsTakeCollation() {
        return this.maxWireVersion >= 5;
      }
    };
    exports2.ServerCapabilities = ServerCapabilities;
  }
});

// node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS({
  "node_modules/mongodb/lib/mongo_client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoClient = exports2.ServerApiVersion = void 0;
    var fs_1 = require("fs");
    var bson_1 = require_bson2();
    var change_stream_1 = require_change_stream();
    var mongo_credentials_1 = require_mongo_credentials();
    var providers_1 = require_providers();
    var connection_string_1 = require_connection_string();
    var constants_1 = require_constants4();
    var db_1 = require_db2();
    var error_1 = require_error();
    var mongo_client_auth_providers_1 = require_mongo_client_auth_providers();
    var mongo_logger_1 = require_mongo_logger();
    var mongo_types_1 = require_mongo_types();
    var executor_1 = require_executor();
    var execute_operation_1 = require_execute_operation();
    var run_command_1 = require_run_command();
    var read_preference_1 = require_read_preference();
    var resource_management_1 = require_resource_management();
    var server_selection_1 = require_server_selection();
    var topology_1 = require_topology();
    var sessions_1 = require_sessions();
    var utils_1 = require_utils5();
    exports2.ServerApiVersion = Object.freeze({
      v1: "1"
    });
    var MongoClient = class extends mongo_types_1.TypedEventEmitter {
      constructor(url, options2) {
        super();
        this.on("error", utils_1.noop);
        this.options = (0, connection_string_1.parseOptions)(url, this, options2);
        const shouldSetLogger = Object.values(this.options.mongoLoggerOptions.componentSeverities).some((value) => value !== mongo_logger_1.SeverityLevel.OFF);
        this.mongoLogger = shouldSetLogger ? new mongo_logger_1.MongoLogger(this.options.mongoLoggerOptions) : void 0;
        const client = this;
        this.s = {
          url,
          bsonOptions: (0, bson_1.resolveBSONOptions)(this.options),
          namespace: (0, utils_1.ns)("admin"),
          hasBeenClosed: false,
          sessionPool: new sessions_1.ServerSessionPool(this),
          activeSessions: /* @__PURE__ */ new Set(),
          activeCursors: /* @__PURE__ */ new Set(),
          authProviders: new mongo_client_auth_providers_1.MongoClientAuthProviders(),
          get options() {
            return client.options;
          },
          get readConcern() {
            return client.options.readConcern;
          },
          get writeConcern() {
            return client.options.writeConcern;
          },
          get readPreference() {
            return client.options.readPreference;
          },
          get isMongoClient() {
            return true;
          }
        };
        this.checkForNonGenuineHosts();
      }
      /** @internal */
      async asyncDispose() {
        await this.close();
      }
      /** @internal */
      checkForNonGenuineHosts() {
        const documentDBHostnames = this.options.hosts.filter((hostAddress) => (0, utils_1.isHostMatch)(utils_1.DOCUMENT_DB_CHECK, hostAddress.host));
        const srvHostIsDocumentDB = (0, utils_1.isHostMatch)(utils_1.DOCUMENT_DB_CHECK, this.options.srvHost);
        const cosmosDBHostnames = this.options.hosts.filter((hostAddress) => (0, utils_1.isHostMatch)(utils_1.COSMOS_DB_CHECK, hostAddress.host));
        const srvHostIsCosmosDB = (0, utils_1.isHostMatch)(utils_1.COSMOS_DB_CHECK, this.options.srvHost);
        if (documentDBHostnames.length !== 0 || srvHostIsDocumentDB) {
          this.mongoLogger?.info("client", utils_1.DOCUMENT_DB_MSG);
        } else if (cosmosDBHostnames.length !== 0 || srvHostIsCosmosDB) {
          this.mongoLogger?.info("client", utils_1.COSMOS_DB_MSG);
        }
      }
      get serverApi() {
        return this.options.serverApi && Object.freeze({ ...this.options.serverApi });
      }
      /**
       * Intended for APM use only
       * @internal
       */
      get monitorCommands() {
        return this.options.monitorCommands;
      }
      set monitorCommands(value) {
        this.options.monitorCommands = value;
      }
      /** @internal */
      get autoEncrypter() {
        return this.options.autoEncrypter;
      }
      get readConcern() {
        return this.s.readConcern;
      }
      get writeConcern() {
        return this.s.writeConcern;
      }
      get readPreference() {
        return this.s.readPreference;
      }
      get bsonOptions() {
        return this.s.bsonOptions;
      }
      get timeoutMS() {
        return this.s.options.timeoutMS;
      }
      /**
       * Executes a client bulk write operation, available on server 8.0+.
       * @param models - The client bulk write models.
       * @param options - The client bulk write options.
       * @returns A ClientBulkWriteResult for acknowledged writes and ok: 1 for unacknowledged writes.
       */
      async bulkWrite(models, options2) {
        if (this.autoEncrypter) {
          throw new error_1.MongoInvalidArgumentError("MongoClient bulkWrite does not currently support automatic encryption.");
        }
        return await new executor_1.ClientBulkWriteExecutor(this, models, (0, utils_1.resolveOptions)(this, options2)).execute();
      }
      /**
       * Connect to MongoDB using a url
       *
       * @remarks
       * Calling `connect` is optional since the first operation you perform will call `connect` if it's needed.
       * `timeoutMS` will bound the time any operation can take before throwing a timeout error.
       * However, when the operation being run is automatically connecting your `MongoClient` the `timeoutMS` will not apply to the time taken to connect the MongoClient.
       * This means the time to setup the `MongoClient` does not count against `timeoutMS`.
       * If you are using `timeoutMS` we recommend connecting your client explicitly in advance of any operation to avoid this inconsistent execution time.
       *
       * @remarks
       * The driver will look up corresponding SRV and TXT records if the connection string starts with `mongodb+srv://`.
       * If those look ups throw a DNS Timeout error, the driver will retry the look up once.
       *
       * @see docs.mongodb.org/manual/reference/connection-string/
       */
      async connect() {
        if (this.connectionLock) {
          return await this.connectionLock;
        }
        try {
          this.connectionLock = this._connect();
          await this.connectionLock;
        } finally {
          this.connectionLock = void 0;
        }
        return this;
      }
      /**
       * Create a topology to open the connection, must be locked to avoid topology leaks in concurrency scenario.
       * Locking is enforced by the connect method.
       *
       * @internal
       */
      async _connect() {
        if (this.topology && this.topology.isConnected()) {
          return this;
        }
        const options2 = this.options;
        if (options2.tls) {
          if (typeof options2.tlsCAFile === "string") {
            options2.ca ??= await fs_1.promises.readFile(options2.tlsCAFile);
          }
          if (typeof options2.tlsCRLFile === "string") {
            options2.crl ??= await fs_1.promises.readFile(options2.tlsCRLFile);
          }
          if (typeof options2.tlsCertificateKeyFile === "string") {
            if (!options2.key || !options2.cert) {
              const contents = await fs_1.promises.readFile(options2.tlsCertificateKeyFile);
              options2.key ??= contents;
              options2.cert ??= contents;
            }
          }
        }
        if (typeof options2.srvHost === "string") {
          const hosts = await (0, connection_string_1.resolveSRVRecord)(options2);
          for (const [index, host] of hosts.entries()) {
            options2.hosts[index] = host;
          }
        }
        if (options2.credentials?.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
          const allowedHosts = options2.credentials?.mechanismProperties?.ALLOWED_HOSTS || mongo_credentials_1.DEFAULT_ALLOWED_HOSTS;
          const isServiceAuth = !!options2.credentials?.mechanismProperties?.ENVIRONMENT;
          if (!isServiceAuth) {
            for (const host of options2.hosts) {
              if (!(0, utils_1.hostMatchesWildcards)(host.toHostPort().host, allowedHosts)) {
                throw new error_1.MongoInvalidArgumentError(`Host '${host}' is not valid for OIDC authentication with ALLOWED_HOSTS of '${allowedHosts.join(",")}'`);
              }
            }
          }
        }
        this.topology = new topology_1.Topology(this, options2.hosts, options2);
        this.topology.once(topology_1.Topology.OPEN, () => this.emit("open", this));
        for (const event of constants_1.MONGO_CLIENT_EVENTS) {
          this.topology.on(event, (...args) => this.emit(event, ...args));
        }
        const topologyConnect = async () => {
          try {
            await this.topology?.connect(options2);
          } catch (error2) {
            this.topology?.close();
            throw error2;
          }
        };
        if (this.autoEncrypter) {
          await this.autoEncrypter?.init();
          await topologyConnect();
          await options2.encrypter.connectInternalClient();
        } else {
          await topologyConnect();
        }
        return this;
      }
      /**
       * Cleans up resources managed by the MongoClient.
       *
       * The close method clears and closes all resources whose lifetimes are managed by the MongoClient.
       * Please refer to the `MongoClient` class documentation for a high level overview of the client's key features and responsibilities.
       *
       * **However,** the close method does not handle the cleanup of resources explicitly created by the user.
       * Any user-created driver resource with its own `close()` method should be explicitly closed by the user before calling MongoClient.close().
       * This method is written as a "best effort" attempt to leave behind the least amount of resources server-side when possible.
       *
       * The following list defines ideal preconditions and consequent pitfalls if they are not met.
       * The MongoClient, ClientSession, Cursors and ChangeStreams all support [explicit resource management](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html).
       * By using explicit resource management to manage the lifetime of driver resources instead of manually managing their lifetimes, the pitfalls outlined below can be avoided.
       *
       * The close method performs the following in the order listed:
       * - Client-side:
       *   - **Close in-use connections**: Any connections that are currently waiting on a response from the server will be closed.
       *     This is performed _first_ to avoid reaching the next step (server-side clean up) and having no available connections to check out.
       *     - _Ideal_: All operations have been awaited or cancelled, and the outcomes, regardless of success or failure, have been processed before closing the client servicing the operation.
       *     - _Pitfall_: When `client.close()` is called and all connections are in use, after closing them, the client must create new connections for cleanup operations, which comes at the cost of new TLS/TCP handshakes and authentication steps.
       * - Server-side:
       *   - **Close active cursors**: All cursors that haven't been completed will have a `killCursor` operation sent to the server they were initialized on, freeing the server-side resource.
       *     - _Ideal_: Cursors are explicitly closed or completed before `client.close()` is called.
       *     - _Pitfall_: `killCursors` may have to build a new connection if the in-use closure ended all pooled connections.
       *   - **End active sessions**: In-use sessions created with `client.startSession()` or `client.withSession()` or implicitly by the driver will have their `.endSession()` method called.
       *     Contrary to the name of the method, `endSession()` returns the session to the client's pool of sessions rather than end them on the server.
       *     - _Ideal_: Transaction outcomes are awaited and their corresponding explicit sessions are ended before `client.close()` is called.
       *     - _Pitfall_: **This step aborts in-progress transactions**. It is advisable to observe the outcome of a transaction before closing your client.
       *   - **End all pooled sessions**: The `endSessions` command with all session IDs the client has pooled is sent to the server to inform the cluster it can clean them up.
       *     - _Ideal_: No user intervention is expected.
       *     - _Pitfall_: None.
       *
       * The remaining shutdown is of the MongoClient resources that are intended to be entirely internal but is documented here as their existence relates to the JS event loop.
       *
       * - Client-side (again):
       *   - **Stop all server monitoring**: Connections kept live for detecting cluster changes and roundtrip time measurements are shutdown.
       *   - **Close all pooled connections**: Each server node in the cluster has a corresponding connection pool and all connections in the pool are closed. Any operations waiting to check out a connection will have an error thrown instead of a connection returned.
       *   - **Clear out server selection queue**: Any operations that are in the process of waiting for a server to be selected will have an error thrown instead of a server returned.
       *   - **Close encryption-related resources**: An internal MongoClient created for communicating with `mongocryptd` or other encryption purposes is closed. (Using this same method of course!)
       *
       * After the close method completes there should be no MongoClient related resources [ref-ed in Node.js' event loop](https://docs.libuv.org/en/v1.x/handle.html#reference-counting).
       * This should allow Node.js to exit gracefully if MongoClient resources were the only active handles in the event loop.
       *
       * @param _force - currently an unused flag that has no effect. Defaults to `false`.
       */
      async close(_force = false) {
        if (this.closeLock) {
          return await this.closeLock;
        }
        try {
          this.closeLock = this._close();
          await this.closeLock;
        } finally {
          this.closeLock = void 0;
        }
      }
      /* @internal */
      async _close() {
        Object.defineProperty(this.s, "hasBeenClosed", {
          value: true,
          enumerable: true,
          configurable: false,
          writable: false
        });
        this.topology?.closeCheckedOutConnections();
        const activeCursorCloses = Array.from(this.s.activeCursors, (cursor) => cursor.close());
        this.s.activeCursors.clear();
        await Promise.all(activeCursorCloses);
        const activeSessionEnds = Array.from(this.s.activeSessions, (session) => session.endSession());
        this.s.activeSessions.clear();
        await Promise.all(activeSessionEnds);
        if (this.topology == null) {
          return;
        }
        const selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);
        const topologyDescription = this.topology.description;
        const serverDescriptions = Array.from(topologyDescription.servers.values());
        const servers = selector(topologyDescription, serverDescriptions);
        if (servers.length !== 0) {
          const endSessions = Array.from(this.s.sessionPool.sessions, ({ id }) => id);
          if (endSessions.length !== 0) {
            try {
              await (0, execute_operation_1.executeOperation)(this, new run_command_1.RunAdminCommandOperation({ endSessions }, { readPreference: read_preference_1.ReadPreference.primaryPreferred, noResponse: true }));
            } catch (error2) {
              (0, utils_1.squashError)(error2);
            }
          }
        }
        const topology = this.topology;
        this.topology = void 0;
        topology.close();
        const { encrypter } = this.options;
        if (encrypter) {
          await encrypter.close(this);
        }
      }
      /**
       * Create a new Db instance sharing the current socket connections.
       *
       * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.
       * @param options - Optional settings for Db construction
       */
      db(dbName, options2) {
        options2 = options2 ?? {};
        if (!dbName) {
          dbName = this.s.options.dbName;
        }
        const finalOptions = Object.assign({}, this.options, options2);
        const db = new db_1.Db(this, dbName, finalOptions);
        return db;
      }
      /**
       * Connect to MongoDB using a url
       *
       * @remarks
       * Calling `connect` is optional since the first operation you perform will call `connect` if it's needed.
       * `timeoutMS` will bound the time any operation can take before throwing a timeout error.
       * However, when the operation being run is automatically connecting your `MongoClient` the `timeoutMS` will not apply to the time taken to connect the MongoClient.
       * This means the time to setup the `MongoClient` does not count against `timeoutMS`.
       * If you are using `timeoutMS` we recommend connecting your client explicitly in advance of any operation to avoid this inconsistent execution time.
       *
       * @remarks
       * The programmatically provided options take precedence over the URI options.
       *
       * @remarks
       * The driver will look up corresponding SRV and TXT records if the connection string starts with `mongodb+srv://`.
       * If those look ups throw a DNS Timeout error, the driver will retry the look up once.
       *
       * @see https://www.mongodb.com/docs/manual/reference/connection-string/
       */
      static async connect(url, options2) {
        const client = new this(url, options2);
        return await client.connect();
      }
      /**
       * Creates a new ClientSession. When using the returned session in an operation
       * a corresponding ServerSession will be created.
       *
       * @remarks
       * A ClientSession instance may only be passed to operations being performed on the same
       * MongoClient it was started from.
       */
      startSession(options2) {
        const session = new sessions_1.ClientSession(this, this.s.sessionPool, { explicit: true, ...options2 }, this.options);
        this.s.activeSessions.add(session);
        session.once("ended", () => {
          this.s.activeSessions.delete(session);
        });
        return session;
      }
      async withSession(optionsOrExecutor, executor) {
        const options2 = {
          // Always define an owner
          owner: Symbol(),
          // If it's an object inherit the options
          ...typeof optionsOrExecutor === "object" ? optionsOrExecutor : {}
        };
        const withSessionCallback = typeof optionsOrExecutor === "function" ? optionsOrExecutor : executor;
        if (withSessionCallback == null) {
          throw new error_1.MongoInvalidArgumentError("Missing required callback parameter");
        }
        const session = this.startSession(options2);
        try {
          return await withSessionCallback(session);
        } finally {
          try {
            await session.endSession();
          } catch (error2) {
            (0, utils_1.squashError)(error2);
          }
        }
      }
      /**
       * Create a new Change Stream, watching for new changes (insertions, updates,
       * replacements, deletions, and invalidations) in this cluster. Will ignore all
       * changes to system collections, as well as the local, admin, and config databases.
       *
       * @remarks
       * watch() accepts two generic arguments for distinct use cases:
       * - The first is to provide the schema that may be defined for all the data within the current cluster
       * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
       *
       * @remarks
       * When `timeoutMS` is configured for a change stream, it will have different behaviour depending
       * on whether the change stream is in iterator mode or emitter mode. In both cases, a change
       * stream will time out if it does not receive a change event within `timeoutMS` of the last change
       * event.
       *
       * Note that if a change stream is consistently timing out when watching a collection, database or
       * client that is being changed, then this may be due to the server timing out before it can finish
       * processing the existing oplog. To address this, restart the change stream with a higher
       * `timeoutMS`.
       *
       * If the change stream times out the initial aggregate operation to establish the change stream on
       * the server, then the client will close the change stream. If the getMore calls to the server
       * time out, then the change stream will be left open, but will throw a MongoOperationTimeoutError
       * when in iterator mode and emit an error event that returns a MongoOperationTimeoutError in
       * emitter mode.
       *
       * To determine whether or not the change stream is still open following a timeout, check the
       * {@link ChangeStream.closed} getter.
       *
       * @example
       * In iterator mode, if a next() call throws a timeout error, it will attempt to resume the change stream.
       * The next call can just be retried after this succeeds.
       * ```ts
       * const changeStream = collection.watch([], { timeoutMS: 100 });
       * try {
       *     await changeStream.next();
       * } catch (e) {
       *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {
       *       await changeStream.next();
       *     }
       *     throw e;
       * }
       * ```
       *
       * @example
       * In emitter mode, if the change stream goes `timeoutMS` without emitting a change event, it will
       * emit an error event that returns a MongoOperationTimeoutError, but will not close the change
       * stream unless the resume attempt fails. There is no need to re-establish change listeners as
       * this will automatically continue emitting change events once the resume attempt completes.
       *
       * ```ts
       * const changeStream = collection.watch([], { timeoutMS: 100 });
       * changeStream.on('change', console.log);
       * changeStream.on('error', e => {
       *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {
       *         // do nothing
       *     } else {
       *         changeStream.close();
       *     }
       * });
       * ```
       * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
       * @param options - Optional settings for the command
       * @typeParam TSchema - Type of the data being detected by the change stream
       * @typeParam TChange - Type of the whole change stream document emitted
       */
      watch(pipeline = [], options2 = {}) {
        if (!Array.isArray(pipeline)) {
          options2 = pipeline;
          pipeline = [];
        }
        return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options2));
      }
    };
    exports2.MongoClient = MongoClient;
    (0, resource_management_1.configureResourceManagement)(MongoClient.prototype);
  }
});

// node_modules/mongodb/lib/resource_management.js
var require_resource_management = __commonJS({
  "node_modules/mongodb/lib/resource_management.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.configureResourceManagement = configureResourceManagement;
    exports2.configureExplicitResourceManagement = configureExplicitResourceManagement;
    function configureResourceManagement(target) {
      Symbol.asyncDispose && Object.defineProperty(target, Symbol.asyncDispose, {
        value: async function asyncDispose() {
          await this.asyncDispose();
        },
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    function configureExplicitResourceManagement() {
      const { MongoClient } = require_mongo_client();
      const { ClientSession } = require_sessions();
      const { AbstractCursor } = require_abstract_cursor();
      const { ChangeStream } = require_change_stream();
      configureResourceManagement(MongoClient.prototype);
      configureResourceManagement(ClientSession.prototype);
      configureResourceManagement(AbstractCursor.prototype);
      configureResourceManagement(ChangeStream.prototype);
    }
  }
});

// node_modules/mongodb/lib/cursor/abstract_cursor.js
var require_abstract_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/abstract_cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CursorTimeoutContext = exports2.AbstractCursor = exports2.CursorTimeoutMode = exports2.CURSOR_FLAGS = void 0;
    var stream_1 = require("stream");
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var execute_operation_1 = require_execute_operation();
    var get_more_1 = require_get_more();
    var kill_cursors_1 = require_kill_cursors();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var resource_management_1 = require_resource_management();
    var sessions_1 = require_sessions();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils5();
    exports2.CURSOR_FLAGS = [
      "tailable",
      "oplogReplay",
      "noCursorTimeout",
      "awaitData",
      "exhaust",
      "partial"
    ];
    function removeActiveCursor() {
      this.client.s.activeCursors.delete(this);
    }
    exports2.CursorTimeoutMode = Object.freeze({
      ITERATION: "iteration",
      LIFETIME: "cursorLifetime"
    });
    var AbstractCursor = class extends mongo_types_1.TypedEventEmitter {
      /** @internal */
      constructor(client, namespace, options2 = {}) {
        super();
        this.documents = null;
        this.hasEmittedClose = false;
        this.on("error", utils_1.noop);
        if (!client.s.isMongoClient) {
          throw new error_1.MongoRuntimeError("Cursor must be constructed with MongoClient");
        }
        this.cursorClient = client;
        this.cursorNamespace = namespace;
        this.cursorId = null;
        this.initialized = false;
        this.isClosed = false;
        this.isKilled = false;
        this.cursorOptions = {
          readPreference: options2.readPreference && options2.readPreference instanceof read_preference_1.ReadPreference ? options2.readPreference : read_preference_1.ReadPreference.primary,
          ...(0, bson_1.pluckBSONSerializeOptions)(options2),
          timeoutMS: options2?.timeoutContext?.csotEnabled() ? options2.timeoutContext.timeoutMS : options2.timeoutMS,
          tailable: options2.tailable,
          awaitData: options2.awaitData
        };
        if (this.cursorOptions.timeoutMS != null) {
          if (options2.timeoutMode == null) {
            if (options2.tailable) {
              if (options2.awaitData) {
                if (options2.maxAwaitTimeMS != null && options2.maxAwaitTimeMS >= this.cursorOptions.timeoutMS)
                  throw new error_1.MongoInvalidArgumentError("Cannot specify maxAwaitTimeMS >= timeoutMS for a tailable awaitData cursor");
              }
              this.cursorOptions.timeoutMode = exports2.CursorTimeoutMode.ITERATION;
            } else {
              this.cursorOptions.timeoutMode = exports2.CursorTimeoutMode.LIFETIME;
            }
          } else {
            if (options2.tailable && options2.timeoutMode === exports2.CursorTimeoutMode.LIFETIME) {
              throw new error_1.MongoInvalidArgumentError("Cannot set tailable cursor's timeoutMode to LIFETIME");
            }
            this.cursorOptions.timeoutMode = options2.timeoutMode;
          }
        } else {
          if (options2.timeoutMode != null)
            throw new error_1.MongoInvalidArgumentError("Cannot set timeoutMode without setting timeoutMS");
        }
        this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null && (this.cursorOptions.timeoutMode === exports2.CursorTimeoutMode.ITERATION && !this.cursorOptions.tailable || this.cursorOptions.tailable && !this.cursorOptions.awaitData);
        const readConcern = read_concern_1.ReadConcern.fromOptions(options2);
        if (readConcern) {
          this.cursorOptions.readConcern = readConcern;
        }
        if (typeof options2.batchSize === "number") {
          this.cursorOptions.batchSize = options2.batchSize;
        }
        if (options2.comment !== void 0) {
          this.cursorOptions.comment = options2.comment;
        }
        if (typeof options2.maxTimeMS === "number") {
          this.cursorOptions.maxTimeMS = options2.maxTimeMS;
        }
        if (typeof options2.maxAwaitTimeMS === "number") {
          this.cursorOptions.maxAwaitTimeMS = options2.maxAwaitTimeMS;
        }
        if (options2.session instanceof sessions_1.ClientSession) {
          this.cursorSession = options2.session;
        } else {
          this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });
        }
        this.deserializationOptions = {
          ...this.cursorOptions,
          validation: {
            utf8: options2?.enableUtf8Validation === false ? false : true
          }
        };
        this.timeoutContext = options2.timeoutContext;
        this.signal = options2.signal;
        this.abortListener = (0, utils_1.addAbortListener)(this.signal, () => void this.close().then(void 0, utils_1.squashError));
        this.trackCursor();
      }
      /**
       * The cursor has no id until it receives a response from the initial cursor creating command.
       *
       * It is non-zero for as long as the database has an open cursor.
       *
       * The initiating command may receive a zero id if the entire result is in the `firstBatch`.
       */
      get id() {
        return this.cursorId ?? void 0;
      }
      /** @internal */
      get isDead() {
        return (this.cursorId?.isZero() ?? false) || this.isClosed || this.isKilled;
      }
      /** @internal */
      get client() {
        return this.cursorClient;
      }
      /** @internal */
      get server() {
        return this.selectedServer;
      }
      get namespace() {
        return this.cursorNamespace;
      }
      get readPreference() {
        return this.cursorOptions.readPreference;
      }
      get readConcern() {
        return this.cursorOptions.readConcern;
      }
      /** @internal */
      get session() {
        return this.cursorSession;
      }
      set session(clientSession) {
        this.cursorSession = clientSession;
      }
      /**
       * The cursor is closed and all remaining locally buffered documents have been iterated.
       */
      get closed() {
        return this.isClosed && (this.documents?.length ?? 0) === 0;
      }
      /**
       * A `killCursors` command was attempted on this cursor.
       * This is performed if the cursor id is non zero.
       */
      get killed() {
        return this.isKilled;
      }
      get loadBalanced() {
        return !!this.cursorClient.topology?.loadBalanced;
      }
      /** @internal */
      async asyncDispose() {
        await this.close();
      }
      /** Adds cursor to client's tracking so it will be closed by MongoClient.close() */
      trackCursor() {
        this.cursorClient.s.activeCursors.add(this);
        if (!this.listeners("close").includes(removeActiveCursor)) {
          this.once("close", removeActiveCursor);
        }
      }
      /** Returns current buffered documents length */
      bufferedCount() {
        return this.documents?.length ?? 0;
      }
      /** Returns current buffered documents */
      readBufferedDocuments(number) {
        const bufferedDocs = [];
        const documentsToRead = Math.min(number ?? this.documents?.length ?? 0, this.documents?.length ?? 0);
        for (let count = 0; count < documentsToRead; count++) {
          const document2 = this.documents?.shift(this.deserializationOptions);
          if (document2 != null) {
            bufferedDocs.push(document2);
          }
        }
        return bufferedDocs;
      }
      async *[Symbol.asyncIterator]() {
        this.signal?.throwIfAborted();
        if (this.closed) {
          return;
        }
        try {
          while (true) {
            if (this.isKilled) {
              return;
            }
            if (this.closed) {
              return;
            }
            if (this.cursorId != null && this.isDead && (this.documents?.length ?? 0) === 0) {
              return;
            }
            const document2 = await this.next();
            if (document2 === null) {
              return;
            }
            yield document2;
            this.signal?.throwIfAborted();
          }
        } finally {
          if (!this.isClosed) {
            try {
              await this.close();
            } catch (error2) {
              (0, utils_1.squashError)(error2);
            }
          }
        }
      }
      stream(options2) {
        const readable = new ReadableCursorStream(this);
        const abortListener = (0, utils_1.addAbortListener)(this.signal, function() {
          readable.destroy(this.reason);
        });
        readable.once("end", () => {
          abortListener?.[utils_1.kDispose]();
        });
        if (options2?.transform) {
          const transform = options2.transform;
          const transformedStream = readable.pipe(new stream_1.Transform({
            objectMode: true,
            highWaterMark: 1,
            transform(chunk, _, callback) {
              try {
                const transformed = transform(chunk);
                callback(void 0, transformed);
              } catch (err) {
                callback(err);
              }
            }
          }));
          readable.on("error", (err) => transformedStream.emit("error", err));
          return transformedStream;
        }
        return readable;
      }
      async hasNext() {
        this.signal?.throwIfAborted();
        if (this.cursorId === bson_1.Long.ZERO) {
          return false;
        }
        if (this.cursorOptions.timeoutMode === exports2.CursorTimeoutMode.ITERATION && this.cursorId != null) {
          this.timeoutContext?.refresh();
        }
        try {
          do {
            if ((this.documents?.length ?? 0) !== 0) {
              return true;
            }
            await this.fetchBatch();
          } while (!this.isDead || (this.documents?.length ?? 0) !== 0);
        } finally {
          if (this.cursorOptions.timeoutMode === exports2.CursorTimeoutMode.ITERATION) {
            this.timeoutContext?.clear();
          }
        }
        return false;
      }
      /** Get the next available document from the cursor, returns null if no more documents are available. */
      async next() {
        this.signal?.throwIfAborted();
        if (this.cursorId === bson_1.Long.ZERO) {
          throw new error_1.MongoCursorExhaustedError();
        }
        if (this.cursorOptions.timeoutMode === exports2.CursorTimeoutMode.ITERATION && this.cursorId != null) {
          this.timeoutContext?.refresh();
        }
        try {
          do {
            const doc = this.documents?.shift(this.deserializationOptions);
            if (doc != null) {
              if (this.transform != null)
                return await this.transformDocument(doc);
              return doc;
            }
            await this.fetchBatch();
          } while (!this.isDead || (this.documents?.length ?? 0) !== 0);
        } finally {
          if (this.cursorOptions.timeoutMode === exports2.CursorTimeoutMode.ITERATION) {
            this.timeoutContext?.clear();
          }
        }
        return null;
      }
      /**
       * Try to get the next available document from the cursor or `null` if an empty batch is returned
       */
      async tryNext() {
        this.signal?.throwIfAborted();
        if (this.cursorId === bson_1.Long.ZERO) {
          throw new error_1.MongoCursorExhaustedError();
        }
        if (this.cursorOptions.timeoutMode === exports2.CursorTimeoutMode.ITERATION && this.cursorId != null) {
          this.timeoutContext?.refresh();
        }
        try {
          let doc = this.documents?.shift(this.deserializationOptions);
          if (doc != null) {
            if (this.transform != null)
              return await this.transformDocument(doc);
            return doc;
          }
          await this.fetchBatch();
          doc = this.documents?.shift(this.deserializationOptions);
          if (doc != null) {
            if (this.transform != null)
              return await this.transformDocument(doc);
            return doc;
          }
        } finally {
          if (this.cursorOptions.timeoutMode === exports2.CursorTimeoutMode.ITERATION) {
            this.timeoutContext?.clear();
          }
        }
        return null;
      }
      /**
       * Iterates over all the documents for this cursor using the iterator, callback pattern.
       *
       * If the iterator returns `false`, iteration will stop.
       *
       * @param iterator - The iteration callback.
       * @deprecated - Will be removed in a future release. Use for await...of instead.
       */
      async forEach(iterator) {
        this.signal?.throwIfAborted();
        if (typeof iterator !== "function") {
          throw new error_1.MongoInvalidArgumentError('Argument "iterator" must be a function');
        }
        for await (const document2 of this) {
          const result = iterator(document2);
          if (result === false) {
            break;
          }
        }
      }
      /**
       * Frees any client-side resources used by the cursor.
       */
      async close(options2) {
        await this.cleanup(options2?.timeoutMS);
      }
      /**
       * Returns an array of documents. The caller is responsible for making sure that there
       * is enough memory to store the results. Note that the array only contains partial
       * results when this cursor had been previously accessed. In that case,
       * cursor.rewind() can be used to reset the cursor.
       */
      async toArray() {
        this.signal?.throwIfAborted();
        const array = [];
        for await (const document2 of this) {
          array.push(document2);
          const docs = this.readBufferedDocuments();
          if (this.transform != null) {
            for (const doc of docs) {
              array.push(await this.transformDocument(doc));
            }
          } else {
            array.push(...docs);
          }
        }
        return array;
      }
      /**
       * Add a cursor flag to the cursor
       *
       * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.
       * @param value - The flag boolean value.
       */
      addCursorFlag(flag, value) {
        this.throwIfInitialized();
        if (!exports2.CURSOR_FLAGS.includes(flag)) {
          throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports2.CURSOR_FLAGS}`);
        }
        if (typeof value !== "boolean") {
          throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);
        }
        this.cursorOptions[flag] = value;
        return this;
      }
      /**
       * Map all documents using the provided function
       * If there is a transform set on the cursor, that will be called first and the result passed to
       * this function's transform.
       *
       * @remarks
       *
       * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping
       * function that maps values to `null` will result in the cursor closing itself before it has finished iterating
       * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:
       *
       * ```typescript
       * const cursor = collection.find({});
       * cursor.map(() => null);
       *
       * const documents = await cursor.toArray();
       * // documents is always [], regardless of how many documents are in the collection.
       * ```
       *
       * Other falsey values are allowed:
       *
       * ```typescript
       * const cursor = collection.find({});
       * cursor.map(() => '');
       *
       * const documents = await cursor.toArray();
       * // documents is now an array of empty strings
       * ```
       *
       * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
       * it **does not** return a new instance of a cursor. This means when calling map,
       * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
       * Take note of the following example:
       *
       * @example
       * ```typescript
       * const cursor: FindCursor<Document> = coll.find();
       * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);
       * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]
       * ```
       * @param transform - The mapping transformation method.
       */
      map(transform) {
        this.throwIfInitialized();
        const oldTransform = this.transform;
        if (oldTransform) {
          this.transform = (doc) => {
            return transform(oldTransform(doc));
          };
        } else {
          this.transform = transform;
        }
        return this;
      }
      /**
       * Set the ReadPreference for the cursor.
       *
       * @param readPreference - The new read preference for the cursor.
       */
      withReadPreference(readPreference) {
        this.throwIfInitialized();
        if (readPreference instanceof read_preference_1.ReadPreference) {
          this.cursorOptions.readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this.cursorOptions.readPreference = read_preference_1.ReadPreference.fromString(readPreference);
        } else {
          throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);
        }
        return this;
      }
      /**
       * Set the ReadPreference for the cursor.
       *
       * @param readPreference - The new read preference for the cursor.
       */
      withReadConcern(readConcern) {
        this.throwIfInitialized();
        const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({ readConcern });
        if (resolvedReadConcern) {
          this.cursorOptions.readConcern = resolvedReadConcern;
        }
        return this;
      }
      /**
       * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
       *
       * @param value - Number of milliseconds to wait before aborting the query.
       */
      maxTimeMS(value) {
        this.throwIfInitialized();
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError("Argument for maxTimeMS must be a number");
        }
        this.cursorOptions.maxTimeMS = value;
        return this;
      }
      /**
       * Set the batch size for the cursor.
       *
       * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.
       */
      batchSize(value) {
        this.throwIfInitialized();
        if (this.cursorOptions.tailable) {
          throw new error_1.MongoTailableCursorError("Tailable cursor does not support batchSize");
        }
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError('Operation "batchSize" requires an integer');
        }
        this.cursorOptions.batchSize = value;
        return this;
      }
      /**
       * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will
       * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even
       * if the resultant data has already been retrieved by this cursor.
       */
      rewind() {
        if (this.timeoutContext && this.timeoutContext.owner !== this) {
          throw new error_1.MongoAPIError(`Cannot rewind cursor that does not own its timeout context.`);
        }
        if (!this.initialized) {
          return;
        }
        this.cursorId = null;
        this.documents?.clear();
        this.timeoutContext?.clear();
        this.timeoutContext = void 0;
        this.isClosed = false;
        this.isKilled = false;
        this.initialized = false;
        this.hasEmittedClose = false;
        this.trackCursor();
        if (this.cursorSession.explicit === false) {
          if (!this.cursorSession.hasEnded) {
            this.cursorSession.endSession().then(void 0, utils_1.squashError);
          }
          this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });
        }
      }
      /** @internal */
      async getMore(batchSize) {
        if (this.cursorId == null) {
          throw new error_1.MongoRuntimeError("Unexpected null cursor id. A cursor creating command should have set this");
        }
        if (this.selectedServer == null) {
          throw new error_1.MongoRuntimeError("Unexpected null selectedServer. A cursor creating command should have set this");
        }
        const getMoreOptions = {
          ...this.cursorOptions,
          session: this.cursorSession,
          batchSize
        };
        const getMoreOperation = new get_more_1.GetMoreOperation(this.cursorNamespace, this.cursorId, this.selectedServer, getMoreOptions);
        return await (0, execute_operation_1.executeOperation)(this.cursorClient, getMoreOperation, this.timeoutContext);
      }
      /**
       * @internal
       *
       * This function is exposed for the unified test runner's createChangeStream
       * operation.  We cannot refactor to use the abstract _initialize method without
       * a significant refactor.
       */
      async cursorInit() {
        if (this.cursorOptions.timeoutMS != null) {
          this.timeoutContext ??= new CursorTimeoutContext(timeout_1.TimeoutContext.create({
            serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,
            timeoutMS: this.cursorOptions.timeoutMS
          }), this);
        }
        try {
          const state = await this._initialize(this.cursorSession);
          this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null;
          const response = state.response;
          this.selectedServer = state.server;
          this.cursorId = response.id;
          this.cursorNamespace = response.ns ?? this.namespace;
          this.documents = response;
          this.initialized = true;
        } catch (error2) {
          this.initialized = true;
          await this.cleanup(void 0, error2);
          throw error2;
        }
        if (this.isDead) {
          await this.cleanup();
        }
        return;
      }
      /** @internal Attempt to obtain more documents */
      async fetchBatch() {
        if (this.isClosed) {
          return;
        }
        if (this.isDead) {
          await this.cleanup();
          return;
        }
        if (this.cursorId == null) {
          await this.cursorInit();
          if ((this.documents?.length ?? 0) !== 0 || this.isDead)
            return;
        }
        const batchSize = this.cursorOptions.batchSize || 1e3;
        try {
          const response = await this.getMore(batchSize);
          this.cursorId = response.id;
          this.documents = response;
        } catch (error2) {
          try {
            await this.cleanup(void 0, error2);
          } catch (cleanupError) {
            (0, utils_1.squashError)(cleanupError);
          }
          throw error2;
        }
        if (this.isDead) {
          await this.cleanup();
        }
      }
      /** @internal */
      async cleanup(timeoutMS, error2) {
        this.abortListener?.[utils_1.kDispose]();
        this.isClosed = true;
        const timeoutContextForKillCursors = () => {
          if (timeoutMS != null) {
            this.timeoutContext?.clear();
            return new CursorTimeoutContext(timeout_1.TimeoutContext.create({
              serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,
              timeoutMS
            }), this);
          } else {
            return this.timeoutContext?.refreshed();
          }
        };
        try {
          if (!this.isKilled && this.cursorId && !this.cursorId.isZero() && this.cursorNamespace && this.selectedServer && !this.cursorSession.hasEnded) {
            this.isKilled = true;
            const cursorId = this.cursorId;
            this.cursorId = bson_1.Long.ZERO;
            await (0, execute_operation_1.executeOperation)(this.cursorClient, new kill_cursors_1.KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {
              session: this.cursorSession
            }), timeoutContextForKillCursors());
          }
        } catch (error3) {
          (0, utils_1.squashError)(error3);
        } finally {
          try {
            if (this.cursorSession?.owner === this) {
              await this.cursorSession.endSession({ error: error2 });
            }
            if (!this.cursorSession?.inTransaction()) {
              (0, sessions_1.maybeClearPinnedConnection)(this.cursorSession, { error: error2 });
            }
          } finally {
            this.emitClose();
          }
        }
      }
      /** @internal */
      emitClose() {
        try {
          if (!this.hasEmittedClose && ((this.documents?.length ?? 0) === 0 || this.isClosed)) {
            this.emit("close");
          }
        } finally {
          this.hasEmittedClose = true;
        }
      }
      /** @internal */
      async transformDocument(document2) {
        if (this.transform == null)
          return document2;
        try {
          const transformedDocument = this.transform(document2);
          if (transformedDocument === null) {
            const TRANSFORM_TO_NULL_ERROR = "Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.";
            throw new error_1.MongoAPIError(TRANSFORM_TO_NULL_ERROR);
          }
          return transformedDocument;
        } catch (transformError) {
          try {
            await this.close();
          } catch (closeError) {
            (0, utils_1.squashError)(closeError);
          }
          throw transformError;
        }
      }
      /** @internal */
      throwIfInitialized() {
        if (this.initialized)
          throw new error_1.MongoCursorInUseError();
      }
    };
    exports2.AbstractCursor = AbstractCursor;
    AbstractCursor.CLOSE = "close";
    var ReadableCursorStream = class extends stream_1.Readable {
      constructor(cursor) {
        super({
          objectMode: true,
          autoDestroy: false,
          highWaterMark: 1
        });
        this._readInProgress = false;
        this._cursor = cursor;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _read(size) {
        if (!this._readInProgress) {
          this._readInProgress = true;
          this._readNext();
        }
      }
      _destroy(error2, callback) {
        this._cursor.close().then(() => callback(error2), (closeError) => callback(closeError));
      }
      _readNext() {
        if (this._cursor.id === bson_1.Long.ZERO) {
          this.push(null);
          return;
        }
        this._cursor.next().then(
          // result from next()
          (result) => {
            if (result == null) {
              this.push(null);
            } else if (this.destroyed) {
              this._cursor.close().then(void 0, utils_1.squashError);
            } else {
              if (this.push(result)) {
                return this._readNext();
              }
              this._readInProgress = false;
            }
          },
          // error from next()
          (err) => {
            if (err.message.match(/server is closed/)) {
              this._cursor.close().then(void 0, utils_1.squashError);
              return this.push(null);
            }
            if (err.message.match(/operation was interrupted/)) {
              return this.push(null);
            }
            return this.destroy(err);
          }
        ).catch((error2) => {
          this._readInProgress = false;
          this.destroy(error2);
        });
      }
    };
    (0, resource_management_1.configureResourceManagement)(AbstractCursor.prototype);
    var CursorTimeoutContext = class _CursorTimeoutContext extends timeout_1.TimeoutContext {
      constructor(timeoutContext, owner) {
        super();
        this.timeoutContext = timeoutContext;
        this.owner = owner;
      }
      get serverSelectionTimeout() {
        return this.timeoutContext.serverSelectionTimeout;
      }
      get connectionCheckoutTimeout() {
        return this.timeoutContext.connectionCheckoutTimeout;
      }
      get clearServerSelectionTimeout() {
        return this.timeoutContext.clearServerSelectionTimeout;
      }
      get timeoutForSocketWrite() {
        return this.timeoutContext.timeoutForSocketWrite;
      }
      get timeoutForSocketRead() {
        return this.timeoutContext.timeoutForSocketRead;
      }
      csotEnabled() {
        return this.timeoutContext.csotEnabled();
      }
      refresh() {
        if (typeof this.owner !== "symbol")
          return this.timeoutContext.refresh();
      }
      clear() {
        if (typeof this.owner !== "symbol")
          return this.timeoutContext.clear();
      }
      get maxTimeMS() {
        return this.timeoutContext.maxTimeMS;
      }
      get timeoutMS() {
        return this.timeoutContext.csotEnabled() ? this.timeoutContext.timeoutMS : null;
      }
      refreshed() {
        return new _CursorTimeoutContext(this.timeoutContext.refreshed(), this.owner);
      }
      addMaxTimeMSToCommand(command, options2) {
        this.timeoutContext.addMaxTimeMSToCommand(command, options2);
      }
      getSocketTimeoutMS() {
        return this.timeoutContext.getSocketTimeoutMS();
      }
    };
    exports2.CursorTimeoutContext = CursorTimeoutContext;
  }
});

// node_modules/mongodb/lib/explain.js
var require_explain = __commonJS({
  "node_modules/mongodb/lib/explain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExplainableCursor = exports2.Explain = exports2.ExplainVerbosity = void 0;
    exports2.validateExplainTimeoutOptions = validateExplainTimeoutOptions;
    exports2.decorateWithExplain = decorateWithExplain;
    var abstract_cursor_1 = require_abstract_cursor();
    var error_1 = require_error();
    exports2.ExplainVerbosity = Object.freeze({
      queryPlanner: "queryPlanner",
      queryPlannerExtended: "queryPlannerExtended",
      executionStats: "executionStats",
      allPlansExecution: "allPlansExecution"
    });
    var Explain = class _Explain {
      constructor(verbosity, maxTimeMS) {
        if (typeof verbosity === "boolean") {
          this.verbosity = verbosity ? exports2.ExplainVerbosity.allPlansExecution : exports2.ExplainVerbosity.queryPlanner;
        } else {
          this.verbosity = verbosity;
        }
        this.maxTimeMS = maxTimeMS;
      }
      static fromOptions({ explain } = {}) {
        if (explain == null)
          return;
        if (typeof explain === "boolean" || typeof explain === "string") {
          return new _Explain(explain);
        }
        const { verbosity, maxTimeMS } = explain;
        return new _Explain(verbosity, maxTimeMS);
      }
    };
    exports2.Explain = Explain;
    function validateExplainTimeoutOptions(options2, explain) {
      const { maxTimeMS, timeoutMS } = options2;
      if (timeoutMS != null && (maxTimeMS != null || explain?.maxTimeMS != null)) {
        throw new error_1.MongoAPIError("Cannot use maxTimeMS with timeoutMS for explain commands.");
      }
    }
    function decorateWithExplain(command, explain) {
      const { verbosity, maxTimeMS } = explain;
      const baseCommand = { explain: command, verbosity };
      if (typeof maxTimeMS === "number") {
        baseCommand.maxTimeMS = maxTimeMS;
      }
      return baseCommand;
    }
    var ExplainableCursor = class extends abstract_cursor_1.AbstractCursor {
      resolveExplainTimeoutOptions(verbosity, options2) {
        let explain;
        let timeout;
        if (verbosity == null && options2 == null) {
          explain = void 0;
          timeout = void 0;
        } else if (verbosity != null && options2 == null) {
          explain = typeof verbosity !== "object" ? verbosity : "verbosity" in verbosity ? verbosity : void 0;
          timeout = typeof verbosity === "object" && "timeoutMS" in verbosity ? verbosity : void 0;
        } else {
          explain = verbosity;
          timeout = options2;
        }
        return { timeout, explain };
      }
    };
    exports2.ExplainableCursor = ExplainableCursor;
  }
});

// node_modules/mongodb/lib/operations/command.js
var require_command = __commonJS({
  "node_modules/mongodb/lib/operations/command.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommandOperation = void 0;
    var error_1 = require_error();
    var explain_1 = require_explain();
    var read_concern_1 = require_read_concern();
    var server_selection_1 = require_server_selection();
    var utils_1 = require_utils5();
    var write_concern_1 = require_write_concern();
    var operation_1 = require_operation();
    var CommandOperation = class extends operation_1.AbstractOperation {
      constructor(parent, options2) {
        super(options2);
        this.options = options2 ?? {};
        const dbNameOverride = options2?.dbName || options2?.authdb;
        if (dbNameOverride) {
          this.ns = new utils_1.MongoDBNamespace(dbNameOverride, "$cmd");
        } else {
          this.ns = parent ? parent.s.namespace.withCollection("$cmd") : new utils_1.MongoDBNamespace("admin", "$cmd");
        }
        this.readConcern = read_concern_1.ReadConcern.fromOptions(options2);
        this.writeConcern = write_concern_1.WriteConcern.fromOptions(options2);
        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
          this.explain = explain_1.Explain.fromOptions(options2);
          if (this.explain)
            (0, explain_1.validateExplainTimeoutOptions)(this.options, this.explain);
        } else if (options2?.explain != null) {
          throw new error_1.MongoInvalidArgumentError(`Option "explain" is not supported on this command`);
        }
      }
      get canRetryWrite() {
        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
          return this.explain == null;
        }
        return super.canRetryWrite;
      }
      async executeCommand(server, session, cmd, timeoutContext, responseType) {
        this.server = server;
        const options2 = {
          ...this.options,
          ...this.bsonOptions,
          timeoutContext,
          readPreference: this.readPreference,
          session
        };
        const serverWireVersion = (0, utils_1.maxWireVersion)(server);
        const inTransaction = this.session && this.session.inTransaction();
        if (this.readConcern && (0, utils_1.commandSupportsReadConcern)(cmd) && !inTransaction) {
          Object.assign(cmd, { readConcern: this.readConcern });
        }
        if (this.trySecondaryWrite && serverWireVersion < server_selection_1.MIN_SECONDARY_WRITE_WIRE_VERSION) {
          options2.omitReadPreference = true;
        }
        if (this.writeConcern && this.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !inTransaction) {
          write_concern_1.WriteConcern.apply(cmd, this.writeConcern);
        }
        if (options2.collation && typeof options2.collation === "object" && !this.hasAspect(operation_1.Aspect.SKIP_COLLATION)) {
          Object.assign(cmd, { collation: options2.collation });
        }
        if (typeof options2.maxTimeMS === "number") {
          cmd.maxTimeMS = options2.maxTimeMS;
        }
        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE) && this.explain) {
          cmd = (0, explain_1.decorateWithExplain)(cmd, this.explain);
        }
        return await server.command(this.ns, cmd, options2, responseType);
      }
    };
    exports2.CommandOperation = CommandOperation;
  }
});

// node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS({
  "node_modules/mongodb/lib/operations/list_databases.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ListDatabasesOperation = void 0;
    var utils_1 = require_utils5();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var ListDatabasesOperation = class extends command_1.CommandOperation {
      constructor(db, options2) {
        super(db, options2);
        this.options = options2 ?? {};
        this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
      }
      get commandName() {
        return "listDatabases";
      }
      async execute(server, session, timeoutContext) {
        const cmd = { listDatabases: 1 };
        if (typeof this.options.nameOnly === "boolean") {
          cmd.nameOnly = this.options.nameOnly;
        }
        if (this.options.filter) {
          cmd.filter = this.options.filter;
        }
        if (typeof this.options.authorizedDatabases === "boolean") {
          cmd.authorizedDatabases = this.options.authorizedDatabases;
        }
        if ((0, utils_1.maxWireVersion)(server) >= 9 && this.options.comment !== void 0) {
          cmd.comment = this.options.comment;
        }
        return await super.executeCommand(server, session, cmd, timeoutContext);
      }
    };
    exports2.ListDatabasesOperation = ListDatabasesOperation;
    (0, operation_1.defineAspects)(ListDatabasesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
  }
});

// node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS({
  "node_modules/mongodb/lib/operations/validate_collection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValidateCollectionOperation = void 0;
    var error_1 = require_error();
    var command_1 = require_command();
    var ValidateCollectionOperation = class extends command_1.CommandOperation {
      constructor(admin, collectionName, options2) {
        const command = { validate: collectionName };
        const keys = Object.keys(options2);
        for (let i = 0; i < keys.length; i++) {
          if (Object.prototype.hasOwnProperty.call(options2, keys[i]) && keys[i] !== "session") {
            command[keys[i]] = options2[keys[i]];
          }
        }
        super(admin.s.db, options2);
        this.options = options2;
        this.command = command;
        this.collectionName = collectionName;
      }
      get commandName() {
        return "validate";
      }
      async execute(server, session, timeoutContext) {
        const collectionName = this.collectionName;
        const doc = await super.executeCommand(server, session, this.command, timeoutContext);
        if (doc.result != null && typeof doc.result !== "string")
          throw new error_1.MongoUnexpectedServerResponseError("Error with validation data");
        if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
          throw new error_1.MongoUnexpectedServerResponseError(`Invalid collection ${collectionName}`);
        if (doc.valid != null && !doc.valid)
          throw new error_1.MongoUnexpectedServerResponseError(`Invalid collection ${collectionName}`);
        return doc;
      }
    };
    exports2.ValidateCollectionOperation = ValidateCollectionOperation;
  }
});

// node_modules/mongodb/lib/admin.js
var require_admin = __commonJS({
  "node_modules/mongodb/lib/admin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Admin = void 0;
    var bson_1 = require_bson2();
    var execute_operation_1 = require_execute_operation();
    var list_databases_1 = require_list_databases();
    var remove_user_1 = require_remove_user();
    var run_command_1 = require_run_command();
    var validate_collection_1 = require_validate_collection();
    var Admin = class {
      /**
       * Create a new Admin instance
       * @internal
       */
      constructor(db) {
        this.s = { db };
      }
      /**
       * Execute a command
       *
       * The driver will ensure the following fields are attached to the command sent to the server:
       * - `lsid` - sourced from an implicit session or options.session
       * - `$readPreference` - defaults to primary or can be configured by options.readPreference
       * - `$db` - sourced from the name of this database
       *
       * If the client has a serverApi setting:
       * - `apiVersion`
       * - `apiStrict`
       * - `apiDeprecationErrors`
       *
       * When in a transaction:
       * - `readConcern` - sourced from readConcern set on the TransactionOptions
       * - `writeConcern` - sourced from writeConcern set on the TransactionOptions
       *
       * Attaching any of the above fields to the command will have no effect as the driver will overwrite the value.
       *
       * @param command - The command to execute
       * @param options - Optional settings for the command
       */
      async command(command, options2) {
        return await (0, execute_operation_1.executeOperation)(this.s.db.client, new run_command_1.RunAdminCommandOperation(command, {
          ...(0, bson_1.resolveBSONOptions)(options2),
          session: options2?.session,
          readPreference: options2?.readPreference,
          timeoutMS: options2?.timeoutMS ?? this.s.db.timeoutMS
        }));
      }
      /**
       * Retrieve the server build information
       *
       * @param options - Optional settings for the command
       */
      async buildInfo(options2) {
        return await this.command({ buildinfo: 1 }, options2);
      }
      /**
       * Retrieve the server build information
       *
       * @param options - Optional settings for the command
       */
      async serverInfo(options2) {
        return await this.command({ buildinfo: 1 }, options2);
      }
      /**
       * Retrieve this db's server status.
       *
       * @param options - Optional settings for the command
       */
      async serverStatus(options2) {
        return await this.command({ serverStatus: 1 }, options2);
      }
      /**
       * Ping the MongoDB server and retrieve results
       *
       * @param options - Optional settings for the command
       */
      async ping(options2) {
        return await this.command({ ping: 1 }, options2);
      }
      /**
       * Remove a user from a database
       *
       * @param username - The username to remove
       * @param options - Optional settings for the command
       */
      async removeUser(username, options2) {
        return await (0, execute_operation_1.executeOperation)(this.s.db.client, new remove_user_1.RemoveUserOperation(this.s.db, username, { dbName: "admin", ...options2 }));
      }
      /**
       * Validate an existing collection
       *
       * @param collectionName - The name of the collection to validate.
       * @param options - Optional settings for the command
       */
      async validateCollection(collectionName, options2 = {}) {
        return await (0, execute_operation_1.executeOperation)(this.s.db.client, new validate_collection_1.ValidateCollectionOperation(this, collectionName, options2));
      }
      /**
       * List the available databases
       *
       * @param options - Optional settings for the command
       */
      async listDatabases(options2) {
        return await (0, execute_operation_1.executeOperation)(this.s.db.client, new list_databases_1.ListDatabasesOperation(this.s.db, { timeoutMS: this.s.db.timeoutMS, ...options2 }));
      }
      /**
       * Get ReplicaSet status
       *
       * @param options - Optional settings for the command
       */
      async replSetGetStatus(options2) {
        return await this.command({ replSetGetStatus: 1 }, options2);
      }
    };
    exports2.Admin = Admin;
  }
});

// node_modules/mongodb/lib/gridfs/download.js
var require_download = __commonJS({
  "node_modules/mongodb/lib/gridfs/download.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GridFSBucketReadStream = void 0;
    var stream_1 = require("stream");
    var abstract_cursor_1 = require_abstract_cursor();
    var error_1 = require_error();
    var timeout_1 = require_timeout();
    var GridFSBucketReadStream = class extends stream_1.Readable {
      /**
       * @param chunks - Handle for chunks collection
       * @param files - Handle for files collection
       * @param readPreference - The read preference to use
       * @param filter - The filter to use to find the file document
       * @internal
       */
      constructor(chunks, files, readPreference, filter, options2) {
        super({ emitClose: true });
        this.s = {
          bytesToTrim: 0,
          bytesToSkip: 0,
          bytesRead: 0,
          chunks,
          expected: 0,
          files,
          filter,
          init: false,
          expectedEnd: 0,
          options: {
            start: 0,
            end: 0,
            ...options2
          },
          readPreference,
          timeoutContext: options2?.timeoutMS != null ? new timeout_1.CSOTTimeoutContext({ timeoutMS: options2.timeoutMS, serverSelectionTimeoutMS: 0 }) : void 0
        };
      }
      /**
       * Reads from the cursor and pushes to the stream.
       * Private Impl, do not call directly
       * @internal
       */
      _read() {
        if (this.destroyed)
          return;
        waitForFile(this, () => doRead(this));
      }
      /**
       * Sets the 0-based offset in bytes to start streaming from. Throws
       * an error if this stream has entered flowing mode
       * (e.g. if you've already called `on('data')`)
       *
       * @param start - 0-based offset in bytes to start streaming from
       */
      start(start = 0) {
        throwIfInitialized(this);
        this.s.options.start = start;
        return this;
      }
      /**
       * Sets the 0-based offset in bytes to start streaming from. Throws
       * an error if this stream has entered flowing mode
       * (e.g. if you've already called `on('data')`)
       *
       * @param end - Offset in bytes to stop reading at
       */
      end(end = 0) {
        throwIfInitialized(this);
        this.s.options.end = end;
        return this;
      }
      /**
       * Marks this stream as aborted (will never push another `data` event)
       * and kills the underlying cursor. Will emit the 'end' event, and then
       * the 'close' event once the cursor is successfully killed.
       */
      async abort() {
        this.push(null);
        this.destroy();
        const remainingTimeMS = this.s.timeoutContext?.getRemainingTimeMSOrThrow();
        await this.s.cursor?.close({ timeoutMS: remainingTimeMS });
      }
    };
    exports2.GridFSBucketReadStream = GridFSBucketReadStream;
    GridFSBucketReadStream.FILE = "file";
    function throwIfInitialized(stream) {
      if (stream.s.init) {
        throw new error_1.MongoGridFSStreamError("Options cannot be changed after the stream is initialized");
      }
    }
    function doRead(stream) {
      if (stream.destroyed)
        return;
      if (!stream.s.cursor)
        return;
      if (!stream.s.file)
        return;
      const handleReadResult = (doc) => {
        if (stream.destroyed)
          return;
        if (!doc) {
          stream.push(null);
          stream.s.cursor?.close().then(void 0, (error2) => stream.destroy(error2));
          return;
        }
        if (!stream.s.file)
          return;
        const bytesRemaining = stream.s.file.length - stream.s.bytesRead;
        const expectedN = stream.s.expected++;
        const expectedLength = Math.min(stream.s.file.chunkSize, bytesRemaining);
        if (doc.n > expectedN) {
          return stream.destroy(new error_1.MongoGridFSChunkError(`ChunkIsMissing: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
        }
        if (doc.n < expectedN) {
          return stream.destroy(new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
        }
        let buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
        if (buf.byteLength !== expectedLength) {
          if (bytesRemaining <= 0) {
            return stream.destroy(new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected file length ${stream.s.file.length} bytes but already read ${stream.s.bytesRead} bytes`));
          }
          return stream.destroy(new error_1.MongoGridFSChunkError(`ChunkIsWrongSize: Got unexpected length: ${buf.byteLength}, expected: ${expectedLength}`));
        }
        stream.s.bytesRead += buf.byteLength;
        if (buf.byteLength === 0) {
          return stream.push(null);
        }
        let sliceStart = null;
        let sliceEnd = null;
        if (stream.s.bytesToSkip != null) {
          sliceStart = stream.s.bytesToSkip;
          stream.s.bytesToSkip = 0;
        }
        const atEndOfStream = expectedN === stream.s.expectedEnd - 1;
        const bytesLeftToRead = stream.s.options.end - stream.s.bytesToSkip;
        if (atEndOfStream && stream.s.bytesToTrim != null) {
          sliceEnd = stream.s.file.chunkSize - stream.s.bytesToTrim;
        } else if (stream.s.options.end && bytesLeftToRead < doc.data.byteLength) {
          sliceEnd = bytesLeftToRead;
        }
        if (sliceStart != null || sliceEnd != null) {
          buf = buf.slice(sliceStart || 0, sliceEnd || buf.byteLength);
        }
        stream.push(buf);
        return;
      };
      stream.s.cursor.next().then(handleReadResult, (error2) => {
        if (stream.destroyed)
          return;
        stream.destroy(error2);
      });
    }
    function init(stream) {
      const findOneOptions = {};
      if (stream.s.readPreference) {
        findOneOptions.readPreference = stream.s.readPreference;
      }
      if (stream.s.options && stream.s.options.sort) {
        findOneOptions.sort = stream.s.options.sort;
      }
      if (stream.s.options && stream.s.options.skip) {
        findOneOptions.skip = stream.s.options.skip;
      }
      const handleReadResult = (doc) => {
        if (stream.destroyed)
          return;
        if (!doc) {
          const identifier = stream.s.filter._id ? stream.s.filter._id.toString() : stream.s.filter.filename;
          const errmsg = `FileNotFound: file ${identifier} was not found`;
          const err = new error_1.MongoRuntimeError(errmsg);
          err.code = "ENOENT";
          return stream.destroy(err);
        }
        if (doc.length <= 0) {
          stream.push(null);
          return;
        }
        if (stream.destroyed) {
          stream.destroy();
          return;
        }
        try {
          stream.s.bytesToSkip = handleStartOption(stream, doc, stream.s.options);
        } catch (error2) {
          return stream.destroy(error2);
        }
        const filter = { files_id: doc._id };
        if (stream.s.options && stream.s.options.start != null) {
          const skip = Math.floor(stream.s.options.start / doc.chunkSize);
          if (skip > 0) {
            filter["n"] = { $gte: skip };
          }
        }
        let remainingTimeMS2;
        try {
          remainingTimeMS2 = stream.s.timeoutContext?.getRemainingTimeMSOrThrow(`Download timed out after ${stream.s.timeoutContext?.timeoutMS}ms`);
        } catch (error2) {
          return stream.destroy(error2);
        }
        stream.s.cursor = stream.s.chunks.find(filter, {
          timeoutMode: stream.s.options.timeoutMS != null ? abstract_cursor_1.CursorTimeoutMode.LIFETIME : void 0,
          timeoutMS: remainingTimeMS2
        }).sort({ n: 1 });
        if (stream.s.readPreference) {
          stream.s.cursor.withReadPreference(stream.s.readPreference);
        }
        stream.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
        stream.s.file = doc;
        try {
          stream.s.bytesToTrim = handleEndOption(stream, doc, stream.s.cursor, stream.s.options);
        } catch (error2) {
          return stream.destroy(error2);
        }
        stream.emit(GridFSBucketReadStream.FILE, doc);
        return;
      };
      let remainingTimeMS;
      try {
        remainingTimeMS = stream.s.timeoutContext?.getRemainingTimeMSOrThrow(`Download timed out after ${stream.s.timeoutContext?.timeoutMS}ms`);
      } catch (error2) {
        if (!stream.destroyed)
          stream.destroy(error2);
        return;
      }
      findOneOptions.timeoutMS = remainingTimeMS;
      stream.s.files.findOne(stream.s.filter, findOneOptions).then(handleReadResult, (error2) => {
        if (stream.destroyed)
          return;
        stream.destroy(error2);
      });
    }
    function waitForFile(stream, callback) {
      if (stream.s.file) {
        return callback();
      }
      if (!stream.s.init) {
        init(stream);
        stream.s.init = true;
      }
      stream.once("file", () => {
        callback();
      });
    }
    function handleStartOption(stream, doc, options2) {
      if (options2 && options2.start != null) {
        if (options2.start > doc.length) {
          throw new error_1.MongoInvalidArgumentError(`Stream start (${options2.start}) must not be more than the length of the file (${doc.length})`);
        }
        if (options2.start < 0) {
          throw new error_1.MongoInvalidArgumentError(`Stream start (${options2.start}) must not be negative`);
        }
        if (options2.end != null && options2.end < options2.start) {
          throw new error_1.MongoInvalidArgumentError(`Stream start (${options2.start}) must not be greater than stream end (${options2.end})`);
        }
        stream.s.bytesRead = Math.floor(options2.start / doc.chunkSize) * doc.chunkSize;
        stream.s.expected = Math.floor(options2.start / doc.chunkSize);
        return options2.start - stream.s.bytesRead;
      }
      throw new error_1.MongoInvalidArgumentError("Start option must be defined");
    }
    function handleEndOption(stream, doc, cursor, options2) {
      if (options2 && options2.end != null) {
        if (options2.end > doc.length) {
          throw new error_1.MongoInvalidArgumentError(`Stream end (${options2.end}) must not be more than the length of the file (${doc.length})`);
        }
        if (options2.start == null || options2.start < 0) {
          throw new error_1.MongoInvalidArgumentError(`Stream end (${options2.end}) must not be negative`);
        }
        const start = options2.start != null ? Math.floor(options2.start / doc.chunkSize) : 0;
        cursor.limit(Math.ceil(options2.end / doc.chunkSize) - start);
        stream.s.expectedEnd = Math.ceil(options2.end / doc.chunkSize);
        return Math.ceil(options2.end / doc.chunkSize) * doc.chunkSize - options2.end;
      }
      throw new error_1.MongoInvalidArgumentError("End option must be defined");
    }
  }
});

// node_modules/mongodb/lib/gridfs/upload.js
var require_upload = __commonJS({
  "node_modules/mongodb/lib/gridfs/upload.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GridFSBucketWriteStream = void 0;
    var stream_1 = require("stream");
    var bson_1 = require_bson2();
    var abstract_cursor_1 = require_abstract_cursor();
    var error_1 = require_error();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils5();
    var write_concern_1 = require_write_concern();
    var GridFSBucketWriteStream = class extends stream_1.Writable {
      /**
       * @param bucket - Handle for this stream's corresponding bucket
       * @param filename - The value of the 'filename' key in the files doc
       * @param options - Optional settings.
       * @internal
       */
      constructor(bucket, filename, options2) {
        super();
        this.gridFSFile = null;
        options2 = options2 ?? {};
        this.bucket = bucket;
        this.chunks = bucket.s._chunksCollection;
        this.filename = filename;
        this.files = bucket.s._filesCollection;
        this.options = options2;
        this.writeConcern = write_concern_1.WriteConcern.fromOptions(options2) || bucket.s.options.writeConcern;
        this.done = false;
        this.id = options2.id ? options2.id : new bson_1.ObjectId();
        this.chunkSizeBytes = options2.chunkSizeBytes || this.bucket.s.options.chunkSizeBytes;
        this.bufToStore = Buffer.alloc(this.chunkSizeBytes);
        this.length = 0;
        this.n = 0;
        this.pos = 0;
        this.state = {
          streamEnd: false,
          outstandingRequests: 0,
          errored: false,
          aborted: false
        };
        if (options2.timeoutMS != null)
          this.timeoutContext = new timeout_1.CSOTTimeoutContext({
            timeoutMS: options2.timeoutMS,
            serverSelectionTimeoutMS: (0, utils_1.resolveTimeoutOptions)(this.bucket.s.db.client, {}).serverSelectionTimeoutMS
          });
      }
      /**
       * @internal
       *
       * The stream is considered constructed when the indexes are done being created
       */
      _construct(callback) {
        if (!this.bucket.s.calledOpenUploadStream) {
          this.bucket.s.calledOpenUploadStream = true;
          checkIndexes(this).then(() => {
            this.bucket.s.checkedIndexes = true;
            this.bucket.emit("index");
            callback();
          }, (error2) => {
            if (error2 instanceof error_1.MongoOperationTimeoutError) {
              return handleError(this, error2, callback);
            }
            (0, utils_1.squashError)(error2);
            callback();
          });
        } else {
          return process.nextTick(callback);
        }
      }
      /**
       * @internal
       * Write a buffer to the stream.
       *
       * @param chunk - Buffer to write
       * @param encoding - Optional encoding for the buffer
       * @param callback - Function to call when the chunk was added to the buffer, or if the entire chunk was persisted to MongoDB if this chunk caused a flush.
       */
      _write(chunk, encoding, callback) {
        doWrite(this, chunk, encoding, callback);
      }
      /** @internal */
      _final(callback) {
        if (this.state.streamEnd) {
          return process.nextTick(callback);
        }
        this.state.streamEnd = true;
        writeRemnant(this, callback);
      }
      /**
       * Places this write stream into an aborted state (all future writes fail)
       * and deletes all chunks that have already been written.
       */
      async abort() {
        if (this.state.streamEnd) {
          throw new error_1.MongoAPIError("Cannot abort a stream that has already completed");
        }
        if (this.state.aborted) {
          throw new error_1.MongoAPIError("Cannot call abort() on a stream twice");
        }
        this.state.aborted = true;
        const remainingTimeMS = this.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${this.timeoutContext?.timeoutMS}ms`);
        await this.chunks.deleteMany({ files_id: this.id }, { timeoutMS: remainingTimeMS });
      }
    };
    exports2.GridFSBucketWriteStream = GridFSBucketWriteStream;
    function handleError(stream, error2, callback) {
      if (stream.state.errored) {
        process.nextTick(callback);
        return;
      }
      stream.state.errored = true;
      process.nextTick(callback, error2);
    }
    function createChunkDoc(filesId, n, data) {
      return {
        _id: new bson_1.ObjectId(),
        files_id: filesId,
        n,
        data
      };
    }
    async function checkChunksIndex(stream) {
      const index = { files_id: 1, n: 1 };
      let remainingTimeMS;
      remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
      let indexes;
      try {
        indexes = await stream.chunks.listIndexes({
          timeoutMode: remainingTimeMS != null ? abstract_cursor_1.CursorTimeoutMode.LIFETIME : void 0,
          timeoutMS: remainingTimeMS
        }).toArray();
      } catch (error2) {
        if (error2 instanceof error_1.MongoError && error2.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
          indexes = [];
        } else {
          throw error2;
        }
      }
      const hasChunksIndex = !!indexes.find((index2) => {
        const keys = Object.keys(index2.key);
        if (keys.length === 2 && index2.key.files_id === 1 && index2.key.n === 1) {
          return true;
        }
        return false;
      });
      if (!hasChunksIndex) {
        remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
        await stream.chunks.createIndex(index, {
          ...stream.writeConcern,
          background: true,
          unique: true,
          timeoutMS: remainingTimeMS
        });
      }
    }
    function checkDone(stream, callback) {
      if (stream.done) {
        return process.nextTick(callback);
      }
      if (stream.state.streamEnd && stream.state.outstandingRequests === 0 && !stream.state.errored) {
        stream.done = true;
        const gridFSFile = createFilesDoc(stream.id, stream.length, stream.chunkSizeBytes, stream.filename, stream.options.contentType, stream.options.aliases, stream.options.metadata);
        if (isAborted(stream, callback)) {
          return;
        }
        const remainingTimeMS = stream.timeoutContext?.remainingTimeMS;
        if (remainingTimeMS != null && remainingTimeMS <= 0) {
          return handleError(stream, new error_1.MongoOperationTimeoutError(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`), callback);
        }
        stream.files.insertOne(gridFSFile, { writeConcern: stream.writeConcern, timeoutMS: remainingTimeMS }).then(() => {
          stream.gridFSFile = gridFSFile;
          callback();
        }, (error2) => {
          return handleError(stream, error2, callback);
        });
        return;
      }
      process.nextTick(callback);
    }
    async function checkIndexes(stream) {
      let remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
      const doc = await stream.files.findOne({}, {
        projection: { _id: 1 },
        timeoutMS: remainingTimeMS
      });
      if (doc != null) {
        return;
      }
      const index = { filename: 1, uploadDate: 1 };
      let indexes;
      remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
      const listIndexesOptions = {
        timeoutMode: remainingTimeMS != null ? abstract_cursor_1.CursorTimeoutMode.LIFETIME : void 0,
        timeoutMS: remainingTimeMS
      };
      try {
        indexes = await stream.files.listIndexes(listIndexesOptions).toArray();
      } catch (error2) {
        if (error2 instanceof error_1.MongoError && error2.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
          indexes = [];
        } else {
          throw error2;
        }
      }
      const hasFileIndex = !!indexes.find((index2) => {
        const keys = Object.keys(index2.key);
        if (keys.length === 2 && index2.key.filename === 1 && index2.key.uploadDate === 1) {
          return true;
        }
        return false;
      });
      if (!hasFileIndex) {
        remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
        await stream.files.createIndex(index, { background: false, timeoutMS: remainingTimeMS });
      }
      await checkChunksIndex(stream);
    }
    function createFilesDoc(_id, length, chunkSize, filename, contentType, aliases, metadata) {
      const ret = {
        _id,
        length,
        chunkSize,
        uploadDate: /* @__PURE__ */ new Date(),
        filename
      };
      if (contentType) {
        ret.contentType = contentType;
      }
      if (aliases) {
        ret.aliases = aliases;
      }
      if (metadata) {
        ret.metadata = metadata;
      }
      return ret;
    }
    function doWrite(stream, chunk, encoding, callback) {
      if (isAborted(stream, callback)) {
        return;
      }
      const inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
      stream.length += inputBuf.length;
      if (stream.pos + inputBuf.length < stream.chunkSizeBytes) {
        inputBuf.copy(stream.bufToStore, stream.pos);
        stream.pos += inputBuf.length;
        process.nextTick(callback);
        return;
      }
      let inputBufRemaining = inputBuf.length;
      let spaceRemaining = stream.chunkSizeBytes - stream.pos;
      let numToCopy = Math.min(spaceRemaining, inputBuf.length);
      let outstandingRequests = 0;
      while (inputBufRemaining > 0) {
        const inputBufPos = inputBuf.length - inputBufRemaining;
        inputBuf.copy(stream.bufToStore, stream.pos, inputBufPos, inputBufPos + numToCopy);
        stream.pos += numToCopy;
        spaceRemaining -= numToCopy;
        let doc;
        if (spaceRemaining === 0) {
          doc = createChunkDoc(stream.id, stream.n, Buffer.from(stream.bufToStore));
          const remainingTimeMS = stream.timeoutContext?.remainingTimeMS;
          if (remainingTimeMS != null && remainingTimeMS <= 0) {
            return handleError(stream, new error_1.MongoOperationTimeoutError(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`), callback);
          }
          ++stream.state.outstandingRequests;
          ++outstandingRequests;
          if (isAborted(stream, callback)) {
            return;
          }
          stream.chunks.insertOne(doc, { writeConcern: stream.writeConcern, timeoutMS: remainingTimeMS }).then(() => {
            --stream.state.outstandingRequests;
            --outstandingRequests;
            if (!outstandingRequests) {
              checkDone(stream, callback);
            }
          }, (error2) => {
            return handleError(stream, error2, callback);
          });
          spaceRemaining = stream.chunkSizeBytes;
          stream.pos = 0;
          ++stream.n;
        }
        inputBufRemaining -= numToCopy;
        numToCopy = Math.min(spaceRemaining, inputBufRemaining);
      }
    }
    function writeRemnant(stream, callback) {
      if (stream.pos === 0) {
        return checkDone(stream, callback);
      }
      const remnant = Buffer.alloc(stream.pos);
      stream.bufToStore.copy(remnant, 0, 0, stream.pos);
      const doc = createChunkDoc(stream.id, stream.n, remnant);
      if (isAborted(stream, callback)) {
        return;
      }
      const remainingTimeMS = stream.timeoutContext?.remainingTimeMS;
      if (remainingTimeMS != null && remainingTimeMS <= 0) {
        return handleError(stream, new error_1.MongoOperationTimeoutError(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`), callback);
      }
      ++stream.state.outstandingRequests;
      stream.chunks.insertOne(doc, { writeConcern: stream.writeConcern, timeoutMS: remainingTimeMS }).then(() => {
        --stream.state.outstandingRequests;
        checkDone(stream, callback);
      }, (error2) => {
        return handleError(stream, error2, callback);
      });
    }
    function isAborted(stream, callback) {
      if (stream.state.aborted) {
        process.nextTick(callback, new error_1.MongoAPIError("Stream has been aborted"));
        return true;
      }
      return false;
    }
  }
});

// node_modules/mongodb/lib/gridfs/index.js
var require_gridfs = __commonJS({
  "node_modules/mongodb/lib/gridfs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GridFSBucket = void 0;
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils5();
    var write_concern_1 = require_write_concern();
    var download_1 = require_download();
    var upload_1 = require_upload();
    var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
      bucketName: "fs",
      chunkSizeBytes: 255 * 1024
    };
    var GridFSBucket = class extends mongo_types_1.TypedEventEmitter {
      constructor(db, options2) {
        super();
        this.on("error", utils_1.noop);
        this.setMaxListeners(0);
        const privateOptions = (0, utils_1.resolveOptions)(db, {
          ...DEFAULT_GRIDFS_BUCKET_OPTIONS,
          ...options2,
          writeConcern: write_concern_1.WriteConcern.fromOptions(options2)
        });
        this.s = {
          db,
          options: privateOptions,
          _chunksCollection: db.collection(privateOptions.bucketName + ".chunks"),
          _filesCollection: db.collection(privateOptions.bucketName + ".files"),
          checkedIndexes: false,
          calledOpenUploadStream: false
        };
      }
      /**
       * Returns a writable stream (GridFSBucketWriteStream) for writing
       * buffers to GridFS. The stream's 'id' property contains the resulting
       * file's id.
       *
       * @param filename - The value of the 'filename' key in the files doc
       * @param options - Optional settings.
       */
      openUploadStream(filename, options2) {
        return new upload_1.GridFSBucketWriteStream(this, filename, {
          timeoutMS: this.s.options.timeoutMS,
          ...options2
        });
      }
      /**
       * Returns a writable stream (GridFSBucketWriteStream) for writing
       * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting
       * file's id.
       */
      openUploadStreamWithId(id, filename, options2) {
        return new upload_1.GridFSBucketWriteStream(this, filename, {
          timeoutMS: this.s.options.timeoutMS,
          ...options2,
          id
        });
      }
      /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */
      openDownloadStream(id, options2) {
        return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { _id: id }, { timeoutMS: this.s.options.timeoutMS, ...options2 });
      }
      /**
       * Deletes a file with the given id
       *
       * @param id - The id of the file doc
       */
      async delete(id, options2) {
        const { timeoutMS } = (0, utils_1.resolveOptions)(this.s.db, options2);
        let timeoutContext = void 0;
        if (timeoutMS) {
          timeoutContext = new timeout_1.CSOTTimeoutContext({
            timeoutMS,
            serverSelectionTimeoutMS: this.s.db.client.s.options.serverSelectionTimeoutMS
          });
        }
        const { deletedCount } = await this.s._filesCollection.deleteOne({ _id: id }, { timeoutMS: timeoutContext?.remainingTimeMS });
        const remainingTimeMS = timeoutContext?.remainingTimeMS;
        if (remainingTimeMS != null && remainingTimeMS <= 0)
          throw new error_1.MongoOperationTimeoutError(`Timed out after ${timeoutMS}ms`);
        await this.s._chunksCollection.deleteMany({ files_id: id }, { timeoutMS: remainingTimeMS });
        if (deletedCount === 0) {
          throw new error_1.MongoRuntimeError(`File not found for id ${id}`);
        }
      }
      /** Convenience wrapper around find on the files collection */
      find(filter = {}, options2 = {}) {
        return this.s._filesCollection.find(filter, options2);
      }
      /**
       * Returns a readable stream (GridFSBucketReadStream) for streaming the
       * file with the given name from GridFS. If there are multiple files with
       * the same name, this will stream the most recent file with the given name
       * (as determined by the `uploadDate` field). You can set the `revision`
       * option to change this behavior.
       */
      openDownloadStreamByName(filename, options2) {
        let sort = { uploadDate: -1 };
        let skip = void 0;
        if (options2 && options2.revision != null) {
          if (options2.revision >= 0) {
            sort = { uploadDate: 1 };
            skip = options2.revision;
          } else {
            skip = -options2.revision - 1;
          }
        }
        return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { filename }, { timeoutMS: this.s.options.timeoutMS, ...options2, sort, skip });
      }
      /**
       * Renames the file with the given _id to the given string
       *
       * @param id - the id of the file to rename
       * @param filename - new name for the file
       */
      async rename(id, filename, options2) {
        const filter = { _id: id };
        const update = { $set: { filename } };
        const { matchedCount } = await this.s._filesCollection.updateOne(filter, update, options2);
        if (matchedCount === 0) {
          throw new error_1.MongoRuntimeError(`File with id ${id} not found`);
        }
      }
      /** Removes this bucket's files collection, followed by its chunks collection. */
      async drop(options2) {
        const { timeoutMS } = (0, utils_1.resolveOptions)(this.s.db, options2);
        let timeoutContext = void 0;
        if (timeoutMS) {
          timeoutContext = new timeout_1.CSOTTimeoutContext({
            timeoutMS,
            serverSelectionTimeoutMS: this.s.db.client.s.options.serverSelectionTimeoutMS
          });
        }
        if (timeoutContext) {
          await this.s._filesCollection.drop({ timeoutMS: timeoutContext.remainingTimeMS });
          const remainingTimeMS = timeoutContext.getRemainingTimeMSOrThrow(`Timed out after ${timeoutMS}ms`);
          await this.s._chunksCollection.drop({ timeoutMS: remainingTimeMS });
        } else {
          await this.s._filesCollection.drop();
          await this.s._chunksCollection.drop();
        }
      }
    };
    exports2.GridFSBucket = GridFSBucket;
    GridFSBucket.INDEX = "index";
  }
});

// node_modules/mongodb/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/mongodb/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoServerClosedError = exports2.MongoRuntimeError = exports2.MongoParseError = exports2.MongoOperationTimeoutError = exports2.MongoOIDCError = exports2.MongoNotConnectedError = exports2.MongoNetworkTimeoutError = exports2.MongoNetworkError = exports2.MongoMissingDependencyError = exports2.MongoMissingCredentialsError = exports2.MongoKerberosError = exports2.MongoInvalidArgumentError = exports2.MongoGridFSStreamError = exports2.MongoGridFSChunkError = exports2.MongoGCPError = exports2.MongoExpiredSessionError = exports2.MongoError = exports2.MongoDriverError = exports2.MongoDecompressionError = exports2.MongoCursorInUseError = exports2.MongoCursorExhaustedError = exports2.MongoCompatibilityError = exports2.MongoClientClosedError = exports2.MongoClientBulkWriteExecutionError = exports2.MongoClientBulkWriteError = exports2.MongoClientBulkWriteCursorError = exports2.MongoChangeStreamError = exports2.MongoBatchReExecutionError = exports2.MongoAzureError = exports2.MongoAWSError = exports2.MongoAPIError = exports2.ChangeStreamCursor = exports2.ClientEncryption = exports2.MongoBulkWriteError = exports2.UUID = exports2.Timestamp = exports2.ObjectId = exports2.MinKey = exports2.MaxKey = exports2.Long = exports2.Int32 = exports2.Double = exports2.Decimal128 = exports2.DBRef = exports2.Code = exports2.BSONType = exports2.BSONSymbol = exports2.BSONRegExp = exports2.Binary = exports2.BSON = void 0;
    exports2.CommandFailedEvent = exports2.WriteConcern = exports2.ReadPreference = exports2.ReadConcern = exports2.TopologyType = exports2.ServerType = exports2.ReadPreferenceMode = exports2.ReadConcernLevel = exports2.ProfilingLevel = exports2.ReturnDocument = exports2.SeverityLevel = exports2.MongoLoggableComponent = exports2.ServerApiVersion = exports2.ExplainVerbosity = exports2.MongoErrorLabel = exports2.CursorTimeoutMode = exports2.CURSOR_FLAGS = exports2.Compressor = exports2.AuthMechanism = exports2.GSSAPICanonicalizationValue = exports2.AutoEncryptionLoggerLevel = exports2.BatchType = exports2.UnorderedBulkOperation = exports2.OrderedBulkOperation = exports2.MongoClient = exports2.ListIndexesCursor = exports2.ListCollectionsCursor = exports2.GridFSBucketWriteStream = exports2.GridFSBucketReadStream = exports2.GridFSBucket = exports2.FindCursor = exports2.ExplainableCursor = exports2.Db = exports2.Collection = exports2.ClientSession = exports2.ChangeStream = exports2.CancellationToken = exports2.AggregationCursor = exports2.Admin = exports2.AbstractCursor = exports2.configureExplicitResourceManagement = exports2.MongoWriteConcernError = exports2.MongoUnexpectedServerResponseError = exports2.MongoTransactionError = exports2.MongoTopologyClosedError = exports2.MongoTailableCursorError = exports2.MongoSystemError = exports2.MongoStalePrimaryError = exports2.MongoServerSelectionError = exports2.MongoServerError = void 0;
    exports2.MongoClientAuthProviders = exports2.MongoCryptKMSRequestNetworkTimeoutError = exports2.MongoCryptInvalidArgumentError = exports2.MongoCryptError = exports2.MongoCryptCreateEncryptedCollectionError = exports2.MongoCryptCreateDataKeyError = exports2.MongoCryptAzureKMSRequestError = exports2.SrvPollingEvent = exports2.WaitingForSuitableServerEvent = exports2.ServerSelectionSucceededEvent = exports2.ServerSelectionStartedEvent = exports2.ServerSelectionFailedEvent = exports2.ServerSelectionEvent = exports2.TopologyOpeningEvent = exports2.TopologyDescriptionChangedEvent = exports2.TopologyClosedEvent = exports2.ServerOpeningEvent = exports2.ServerHeartbeatSucceededEvent = exports2.ServerHeartbeatStartedEvent = exports2.ServerHeartbeatFailedEvent = exports2.ServerDescriptionChangedEvent = exports2.ServerClosedEvent = exports2.ConnectionReadyEvent = exports2.ConnectionPoolReadyEvent = exports2.ConnectionPoolMonitoringEvent = exports2.ConnectionPoolCreatedEvent = exports2.ConnectionPoolClosedEvent = exports2.ConnectionPoolClearedEvent = exports2.ConnectionCreatedEvent = exports2.ConnectionClosedEvent = exports2.ConnectionCheckOutStartedEvent = exports2.ConnectionCheckOutFailedEvent = exports2.ConnectionCheckedOutEvent = exports2.ConnectionCheckedInEvent = exports2.CommandSucceededEvent = exports2.CommandStartedEvent = void 0;
    var admin_1 = require_admin();
    Object.defineProperty(exports2, "Admin", { enumerable: true, get: function() {
      return admin_1.Admin;
    } });
    var ordered_1 = require_ordered();
    Object.defineProperty(exports2, "OrderedBulkOperation", { enumerable: true, get: function() {
      return ordered_1.OrderedBulkOperation;
    } });
    var unordered_1 = require_unordered();
    Object.defineProperty(exports2, "UnorderedBulkOperation", { enumerable: true, get: function() {
      return unordered_1.UnorderedBulkOperation;
    } });
    var change_stream_1 = require_change_stream();
    Object.defineProperty(exports2, "ChangeStream", { enumerable: true, get: function() {
      return change_stream_1.ChangeStream;
    } });
    var collection_1 = require_collection();
    Object.defineProperty(exports2, "Collection", { enumerable: true, get: function() {
      return collection_1.Collection;
    } });
    var abstract_cursor_1 = require_abstract_cursor();
    Object.defineProperty(exports2, "AbstractCursor", { enumerable: true, get: function() {
      return abstract_cursor_1.AbstractCursor;
    } });
    var aggregation_cursor_1 = require_aggregation_cursor();
    Object.defineProperty(exports2, "AggregationCursor", { enumerable: true, get: function() {
      return aggregation_cursor_1.AggregationCursor;
    } });
    var find_cursor_1 = require_find_cursor();
    Object.defineProperty(exports2, "FindCursor", { enumerable: true, get: function() {
      return find_cursor_1.FindCursor;
    } });
    var list_collections_cursor_1 = require_list_collections_cursor();
    Object.defineProperty(exports2, "ListCollectionsCursor", { enumerable: true, get: function() {
      return list_collections_cursor_1.ListCollectionsCursor;
    } });
    var list_indexes_cursor_1 = require_list_indexes_cursor();
    Object.defineProperty(exports2, "ListIndexesCursor", { enumerable: true, get: function() {
      return list_indexes_cursor_1.ListIndexesCursor;
    } });
    var db_1 = require_db2();
    Object.defineProperty(exports2, "Db", { enumerable: true, get: function() {
      return db_1.Db;
    } });
    var explain_1 = require_explain();
    Object.defineProperty(exports2, "ExplainableCursor", { enumerable: true, get: function() {
      return explain_1.ExplainableCursor;
    } });
    var gridfs_1 = require_gridfs();
    Object.defineProperty(exports2, "GridFSBucket", { enumerable: true, get: function() {
      return gridfs_1.GridFSBucket;
    } });
    var download_1 = require_download();
    Object.defineProperty(exports2, "GridFSBucketReadStream", { enumerable: true, get: function() {
      return download_1.GridFSBucketReadStream;
    } });
    var upload_1 = require_upload();
    Object.defineProperty(exports2, "GridFSBucketWriteStream", { enumerable: true, get: function() {
      return upload_1.GridFSBucketWriteStream;
    } });
    var mongo_client_1 = require_mongo_client();
    Object.defineProperty(exports2, "MongoClient", { enumerable: true, get: function() {
      return mongo_client_1.MongoClient;
    } });
    var mongo_types_1 = require_mongo_types();
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return mongo_types_1.CancellationToken;
    } });
    var sessions_1 = require_sessions();
    Object.defineProperty(exports2, "ClientSession", { enumerable: true, get: function() {
      return sessions_1.ClientSession;
    } });
    var bson_1 = require_bson2();
    Object.defineProperty(exports2, "BSON", { enumerable: true, get: function() {
      return bson_1.BSON;
    } });
    var bson_2 = require_bson2();
    Object.defineProperty(exports2, "Binary", { enumerable: true, get: function() {
      return bson_2.Binary;
    } });
    Object.defineProperty(exports2, "BSONRegExp", { enumerable: true, get: function() {
      return bson_2.BSONRegExp;
    } });
    Object.defineProperty(exports2, "BSONSymbol", { enumerable: true, get: function() {
      return bson_2.BSONSymbol;
    } });
    Object.defineProperty(exports2, "BSONType", { enumerable: true, get: function() {
      return bson_2.BSONType;
    } });
    Object.defineProperty(exports2, "Code", { enumerable: true, get: function() {
      return bson_2.Code;
    } });
    Object.defineProperty(exports2, "DBRef", { enumerable: true, get: function() {
      return bson_2.DBRef;
    } });
    Object.defineProperty(exports2, "Decimal128", { enumerable: true, get: function() {
      return bson_2.Decimal128;
    } });
    Object.defineProperty(exports2, "Double", { enumerable: true, get: function() {
      return bson_2.Double;
    } });
    Object.defineProperty(exports2, "Int32", { enumerable: true, get: function() {
      return bson_2.Int32;
    } });
    Object.defineProperty(exports2, "Long", { enumerable: true, get: function() {
      return bson_2.Long;
    } });
    Object.defineProperty(exports2, "MaxKey", { enumerable: true, get: function() {
      return bson_2.MaxKey;
    } });
    Object.defineProperty(exports2, "MinKey", { enumerable: true, get: function() {
      return bson_2.MinKey;
    } });
    Object.defineProperty(exports2, "ObjectId", { enumerable: true, get: function() {
      return bson_2.ObjectId;
    } });
    Object.defineProperty(exports2, "Timestamp", { enumerable: true, get: function() {
      return bson_2.Timestamp;
    } });
    Object.defineProperty(exports2, "UUID", { enumerable: true, get: function() {
      return bson_2.UUID;
    } });
    var common_1 = require_common3();
    Object.defineProperty(exports2, "MongoBulkWriteError", { enumerable: true, get: function() {
      return common_1.MongoBulkWriteError;
    } });
    var client_encryption_1 = require_client_encryption();
    Object.defineProperty(exports2, "ClientEncryption", { enumerable: true, get: function() {
      return client_encryption_1.ClientEncryption;
    } });
    var change_stream_cursor_1 = require_change_stream_cursor();
    Object.defineProperty(exports2, "ChangeStreamCursor", { enumerable: true, get: function() {
      return change_stream_cursor_1.ChangeStreamCursor;
    } });
    var error_1 = require_error();
    Object.defineProperty(exports2, "MongoAPIError", { enumerable: true, get: function() {
      return error_1.MongoAPIError;
    } });
    Object.defineProperty(exports2, "MongoAWSError", { enumerable: true, get: function() {
      return error_1.MongoAWSError;
    } });
    Object.defineProperty(exports2, "MongoAzureError", { enumerable: true, get: function() {
      return error_1.MongoAzureError;
    } });
    Object.defineProperty(exports2, "MongoBatchReExecutionError", { enumerable: true, get: function() {
      return error_1.MongoBatchReExecutionError;
    } });
    Object.defineProperty(exports2, "MongoChangeStreamError", { enumerable: true, get: function() {
      return error_1.MongoChangeStreamError;
    } });
    Object.defineProperty(exports2, "MongoClientBulkWriteCursorError", { enumerable: true, get: function() {
      return error_1.MongoClientBulkWriteCursorError;
    } });
    Object.defineProperty(exports2, "MongoClientBulkWriteError", { enumerable: true, get: function() {
      return error_1.MongoClientBulkWriteError;
    } });
    Object.defineProperty(exports2, "MongoClientBulkWriteExecutionError", { enumerable: true, get: function() {
      return error_1.MongoClientBulkWriteExecutionError;
    } });
    Object.defineProperty(exports2, "MongoClientClosedError", { enumerable: true, get: function() {
      return error_1.MongoClientClosedError;
    } });
    Object.defineProperty(exports2, "MongoCompatibilityError", { enumerable: true, get: function() {
      return error_1.MongoCompatibilityError;
    } });
    Object.defineProperty(exports2, "MongoCursorExhaustedError", { enumerable: true, get: function() {
      return error_1.MongoCursorExhaustedError;
    } });
    Object.defineProperty(exports2, "MongoCursorInUseError", { enumerable: true, get: function() {
      return error_1.MongoCursorInUseError;
    } });
    Object.defineProperty(exports2, "MongoDecompressionError", { enumerable: true, get: function() {
      return error_1.MongoDecompressionError;
    } });
    Object.defineProperty(exports2, "MongoDriverError", { enumerable: true, get: function() {
      return error_1.MongoDriverError;
    } });
    Object.defineProperty(exports2, "MongoError", { enumerable: true, get: function() {
      return error_1.MongoError;
    } });
    Object.defineProperty(exports2, "MongoExpiredSessionError", { enumerable: true, get: function() {
      return error_1.MongoExpiredSessionError;
    } });
    Object.defineProperty(exports2, "MongoGCPError", { enumerable: true, get: function() {
      return error_1.MongoGCPError;
    } });
    Object.defineProperty(exports2, "MongoGridFSChunkError", { enumerable: true, get: function() {
      return error_1.MongoGridFSChunkError;
    } });
    Object.defineProperty(exports2, "MongoGridFSStreamError", { enumerable: true, get: function() {
      return error_1.MongoGridFSStreamError;
    } });
    Object.defineProperty(exports2, "MongoInvalidArgumentError", { enumerable: true, get: function() {
      return error_1.MongoInvalidArgumentError;
    } });
    Object.defineProperty(exports2, "MongoKerberosError", { enumerable: true, get: function() {
      return error_1.MongoKerberosError;
    } });
    Object.defineProperty(exports2, "MongoMissingCredentialsError", { enumerable: true, get: function() {
      return error_1.MongoMissingCredentialsError;
    } });
    Object.defineProperty(exports2, "MongoMissingDependencyError", { enumerable: true, get: function() {
      return error_1.MongoMissingDependencyError;
    } });
    Object.defineProperty(exports2, "MongoNetworkError", { enumerable: true, get: function() {
      return error_1.MongoNetworkError;
    } });
    Object.defineProperty(exports2, "MongoNetworkTimeoutError", { enumerable: true, get: function() {
      return error_1.MongoNetworkTimeoutError;
    } });
    Object.defineProperty(exports2, "MongoNotConnectedError", { enumerable: true, get: function() {
      return error_1.MongoNotConnectedError;
    } });
    Object.defineProperty(exports2, "MongoOIDCError", { enumerable: true, get: function() {
      return error_1.MongoOIDCError;
    } });
    Object.defineProperty(exports2, "MongoOperationTimeoutError", { enumerable: true, get: function() {
      return error_1.MongoOperationTimeoutError;
    } });
    Object.defineProperty(exports2, "MongoParseError", { enumerable: true, get: function() {
      return error_1.MongoParseError;
    } });
    Object.defineProperty(exports2, "MongoRuntimeError", { enumerable: true, get: function() {
      return error_1.MongoRuntimeError;
    } });
    Object.defineProperty(exports2, "MongoServerClosedError", { enumerable: true, get: function() {
      return error_1.MongoServerClosedError;
    } });
    Object.defineProperty(exports2, "MongoServerError", { enumerable: true, get: function() {
      return error_1.MongoServerError;
    } });
    Object.defineProperty(exports2, "MongoServerSelectionError", { enumerable: true, get: function() {
      return error_1.MongoServerSelectionError;
    } });
    Object.defineProperty(exports2, "MongoStalePrimaryError", { enumerable: true, get: function() {
      return error_1.MongoStalePrimaryError;
    } });
    Object.defineProperty(exports2, "MongoSystemError", { enumerable: true, get: function() {
      return error_1.MongoSystemError;
    } });
    Object.defineProperty(exports2, "MongoTailableCursorError", { enumerable: true, get: function() {
      return error_1.MongoTailableCursorError;
    } });
    Object.defineProperty(exports2, "MongoTopologyClosedError", { enumerable: true, get: function() {
      return error_1.MongoTopologyClosedError;
    } });
    Object.defineProperty(exports2, "MongoTransactionError", { enumerable: true, get: function() {
      return error_1.MongoTransactionError;
    } });
    Object.defineProperty(exports2, "MongoUnexpectedServerResponseError", { enumerable: true, get: function() {
      return error_1.MongoUnexpectedServerResponseError;
    } });
    Object.defineProperty(exports2, "MongoWriteConcernError", { enumerable: true, get: function() {
      return error_1.MongoWriteConcernError;
    } });
    var resource_management_1 = require_resource_management();
    Object.defineProperty(exports2, "configureExplicitResourceManagement", { enumerable: true, get: function() {
      return resource_management_1.configureExplicitResourceManagement;
    } });
    var common_2 = require_common3();
    Object.defineProperty(exports2, "BatchType", { enumerable: true, get: function() {
      return common_2.BatchType;
    } });
    var auto_encrypter_1 = require_auto_encrypter();
    Object.defineProperty(exports2, "AutoEncryptionLoggerLevel", { enumerable: true, get: function() {
      return auto_encrypter_1.AutoEncryptionLoggerLevel;
    } });
    var gssapi_1 = require_gssapi();
    Object.defineProperty(exports2, "GSSAPICanonicalizationValue", { enumerable: true, get: function() {
      return gssapi_1.GSSAPICanonicalizationValue;
    } });
    var providers_1 = require_providers();
    Object.defineProperty(exports2, "AuthMechanism", { enumerable: true, get: function() {
      return providers_1.AuthMechanism;
    } });
    var compression_1 = require_compression();
    Object.defineProperty(exports2, "Compressor", { enumerable: true, get: function() {
      return compression_1.Compressor;
    } });
    var abstract_cursor_2 = require_abstract_cursor();
    Object.defineProperty(exports2, "CURSOR_FLAGS", { enumerable: true, get: function() {
      return abstract_cursor_2.CURSOR_FLAGS;
    } });
    Object.defineProperty(exports2, "CursorTimeoutMode", { enumerable: true, get: function() {
      return abstract_cursor_2.CursorTimeoutMode;
    } });
    var error_2 = require_error();
    Object.defineProperty(exports2, "MongoErrorLabel", { enumerable: true, get: function() {
      return error_2.MongoErrorLabel;
    } });
    var explain_2 = require_explain();
    Object.defineProperty(exports2, "ExplainVerbosity", { enumerable: true, get: function() {
      return explain_2.ExplainVerbosity;
    } });
    var mongo_client_2 = require_mongo_client();
    Object.defineProperty(exports2, "ServerApiVersion", { enumerable: true, get: function() {
      return mongo_client_2.ServerApiVersion;
    } });
    var mongo_logger_1 = require_mongo_logger();
    Object.defineProperty(exports2, "MongoLoggableComponent", { enumerable: true, get: function() {
      return mongo_logger_1.MongoLoggableComponent;
    } });
    Object.defineProperty(exports2, "SeverityLevel", { enumerable: true, get: function() {
      return mongo_logger_1.SeverityLevel;
    } });
    var find_and_modify_1 = require_find_and_modify();
    Object.defineProperty(exports2, "ReturnDocument", { enumerable: true, get: function() {
      return find_and_modify_1.ReturnDocument;
    } });
    var set_profiling_level_1 = require_set_profiling_level();
    Object.defineProperty(exports2, "ProfilingLevel", { enumerable: true, get: function() {
      return set_profiling_level_1.ProfilingLevel;
    } });
    var read_concern_1 = require_read_concern();
    Object.defineProperty(exports2, "ReadConcernLevel", { enumerable: true, get: function() {
      return read_concern_1.ReadConcernLevel;
    } });
    var read_preference_1 = require_read_preference();
    Object.defineProperty(exports2, "ReadPreferenceMode", { enumerable: true, get: function() {
      return read_preference_1.ReadPreferenceMode;
    } });
    var common_3 = require_common2();
    Object.defineProperty(exports2, "ServerType", { enumerable: true, get: function() {
      return common_3.ServerType;
    } });
    Object.defineProperty(exports2, "TopologyType", { enumerable: true, get: function() {
      return common_3.TopologyType;
    } });
    var read_concern_2 = require_read_concern();
    Object.defineProperty(exports2, "ReadConcern", { enumerable: true, get: function() {
      return read_concern_2.ReadConcern;
    } });
    var read_preference_2 = require_read_preference();
    Object.defineProperty(exports2, "ReadPreference", { enumerable: true, get: function() {
      return read_preference_2.ReadPreference;
    } });
    var write_concern_1 = require_write_concern();
    Object.defineProperty(exports2, "WriteConcern", { enumerable: true, get: function() {
      return write_concern_1.WriteConcern;
    } });
    var command_monitoring_events_1 = require_command_monitoring_events();
    Object.defineProperty(exports2, "CommandFailedEvent", { enumerable: true, get: function() {
      return command_monitoring_events_1.CommandFailedEvent;
    } });
    Object.defineProperty(exports2, "CommandStartedEvent", { enumerable: true, get: function() {
      return command_monitoring_events_1.CommandStartedEvent;
    } });
    Object.defineProperty(exports2, "CommandSucceededEvent", { enumerable: true, get: function() {
      return command_monitoring_events_1.CommandSucceededEvent;
    } });
    var connection_pool_events_1 = require_connection_pool_events();
    Object.defineProperty(exports2, "ConnectionCheckedInEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCheckedInEvent;
    } });
    Object.defineProperty(exports2, "ConnectionCheckedOutEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCheckedOutEvent;
    } });
    Object.defineProperty(exports2, "ConnectionCheckOutFailedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCheckOutFailedEvent;
    } });
    Object.defineProperty(exports2, "ConnectionCheckOutStartedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCheckOutStartedEvent;
    } });
    Object.defineProperty(exports2, "ConnectionClosedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionClosedEvent;
    } });
    Object.defineProperty(exports2, "ConnectionCreatedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCreatedEvent;
    } });
    Object.defineProperty(exports2, "ConnectionPoolClearedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolClearedEvent;
    } });
    Object.defineProperty(exports2, "ConnectionPoolClosedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolClosedEvent;
    } });
    Object.defineProperty(exports2, "ConnectionPoolCreatedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolCreatedEvent;
    } });
    Object.defineProperty(exports2, "ConnectionPoolMonitoringEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolMonitoringEvent;
    } });
    Object.defineProperty(exports2, "ConnectionPoolReadyEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolReadyEvent;
    } });
    Object.defineProperty(exports2, "ConnectionReadyEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionReadyEvent;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "ServerClosedEvent", { enumerable: true, get: function() {
      return events_1.ServerClosedEvent;
    } });
    Object.defineProperty(exports2, "ServerDescriptionChangedEvent", { enumerable: true, get: function() {
      return events_1.ServerDescriptionChangedEvent;
    } });
    Object.defineProperty(exports2, "ServerHeartbeatFailedEvent", { enumerable: true, get: function() {
      return events_1.ServerHeartbeatFailedEvent;
    } });
    Object.defineProperty(exports2, "ServerHeartbeatStartedEvent", { enumerable: true, get: function() {
      return events_1.ServerHeartbeatStartedEvent;
    } });
    Object.defineProperty(exports2, "ServerHeartbeatSucceededEvent", { enumerable: true, get: function() {
      return events_1.ServerHeartbeatSucceededEvent;
    } });
    Object.defineProperty(exports2, "ServerOpeningEvent", { enumerable: true, get: function() {
      return events_1.ServerOpeningEvent;
    } });
    Object.defineProperty(exports2, "TopologyClosedEvent", { enumerable: true, get: function() {
      return events_1.TopologyClosedEvent;
    } });
    Object.defineProperty(exports2, "TopologyDescriptionChangedEvent", { enumerable: true, get: function() {
      return events_1.TopologyDescriptionChangedEvent;
    } });
    Object.defineProperty(exports2, "TopologyOpeningEvent", { enumerable: true, get: function() {
      return events_1.TopologyOpeningEvent;
    } });
    var server_selection_events_1 = require_server_selection_events();
    Object.defineProperty(exports2, "ServerSelectionEvent", { enumerable: true, get: function() {
      return server_selection_events_1.ServerSelectionEvent;
    } });
    Object.defineProperty(exports2, "ServerSelectionFailedEvent", { enumerable: true, get: function() {
      return server_selection_events_1.ServerSelectionFailedEvent;
    } });
    Object.defineProperty(exports2, "ServerSelectionStartedEvent", { enumerable: true, get: function() {
      return server_selection_events_1.ServerSelectionStartedEvent;
    } });
    Object.defineProperty(exports2, "ServerSelectionSucceededEvent", { enumerable: true, get: function() {
      return server_selection_events_1.ServerSelectionSucceededEvent;
    } });
    Object.defineProperty(exports2, "WaitingForSuitableServerEvent", { enumerable: true, get: function() {
      return server_selection_events_1.WaitingForSuitableServerEvent;
    } });
    var srv_polling_1 = require_srv_polling();
    Object.defineProperty(exports2, "SrvPollingEvent", { enumerable: true, get: function() {
      return srv_polling_1.SrvPollingEvent;
    } });
    var errors_1 = require_errors3();
    Object.defineProperty(exports2, "MongoCryptAzureKMSRequestError", { enumerable: true, get: function() {
      return errors_1.MongoCryptAzureKMSRequestError;
    } });
    Object.defineProperty(exports2, "MongoCryptCreateDataKeyError", { enumerable: true, get: function() {
      return errors_1.MongoCryptCreateDataKeyError;
    } });
    Object.defineProperty(exports2, "MongoCryptCreateEncryptedCollectionError", { enumerable: true, get: function() {
      return errors_1.MongoCryptCreateEncryptedCollectionError;
    } });
    Object.defineProperty(exports2, "MongoCryptError", { enumerable: true, get: function() {
      return errors_1.MongoCryptError;
    } });
    Object.defineProperty(exports2, "MongoCryptInvalidArgumentError", { enumerable: true, get: function() {
      return errors_1.MongoCryptInvalidArgumentError;
    } });
    Object.defineProperty(exports2, "MongoCryptKMSRequestNetworkTimeoutError", { enumerable: true, get: function() {
      return errors_1.MongoCryptKMSRequestNetworkTimeoutError;
    } });
    var mongo_client_auth_providers_1 = require_mongo_client_auth_providers();
    Object.defineProperty(exports2, "MongoClientAuthProviders", { enumerable: true, get: function() {
      return mongo_client_auth_providers_1.MongoClientAuthProviders;
    } });
  }
});

// node_modules/mongodb-memory-server-core/lib/util/MongoInstance.js
var require_MongoInstance = __commonJS({
  "node_modules/mongodb-memory-server-core/lib/util/MongoInstance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoInstance = exports2.MongoInstanceEvents = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var child_process_1 = require("child_process");
    var path = tslib_1.__importStar(require("path"));
    var MongoBinary_1 = require_MongoBinary();
    var debug_1 = tslib_1.__importDefault(require_src2());
    var utils_1 = require_utils4();
    var semver_1 = require_semver2();
    var events_1 = require("events");
    var mongodb_1 = require_lib6();
    var errors_1 = require_errors();
    if ((0, semver_1.lt)(process.version, "16.20.1")) {
      console.warn("Using NodeJS below 16.20.1");
    }
    var log = (0, debug_1.default)("MongoMS:MongoInstance");
    var MongoInstanceEvents;
    (function(MongoInstanceEvents2) {
      MongoInstanceEvents2["instanceReplState"] = "instanceReplState";
      MongoInstanceEvents2["instancePrimary"] = "instancePrimary";
      MongoInstanceEvents2["instanceReady"] = "instanceReady";
      MongoInstanceEvents2["instanceSTDOUT"] = "instanceSTDOUT";
      MongoInstanceEvents2["instanceSTDERR"] = "instanceSTDERR";
      MongoInstanceEvents2["instanceClosed"] = "instanceClosed";
      MongoInstanceEvents2["instanceRawError"] = "instanceRawError";
      MongoInstanceEvents2["instanceError"] = "instanceError";
      MongoInstanceEvents2["killerLaunched"] = "killerLaunched";
      MongoInstanceEvents2["instanceLaunched"] = "instanceLaunched";
      MongoInstanceEvents2["instanceStarted"] = "instanceStarted";
    })(MongoInstanceEvents || (exports2.MongoInstanceEvents = MongoInstanceEvents = {}));
    var MongoInstance = class extends events_1.EventEmitter {
      constructor(opts) {
        super();
        this.isInstancePrimary = false;
        this.isInstanceReady = false;
        this.isReplSet = false;
        this.instanceOpts = { ...opts.instance };
        this.binaryOpts = { ...opts.binary };
        this.spawnOpts = { ...opts.spawn };
        this.on(MongoInstanceEvents.instanceReady, () => {
          this.isInstanceReady = true;
          this.debug("constructor: Instance is ready!");
        });
        this.on(MongoInstanceEvents.instanceError, async (err) => {
          this.debug(`constructor: Instance has thrown an Error: ${err.toString()}`);
          this.isInstanceReady = false;
          this.isInstancePrimary = false;
          await this.stop();
        });
      }
      /**
       * Debug-log with template applied
       * @param msg The Message to log
       */
      debug(msg, ...extra) {
        const port = this.instanceOpts.port ?? "unknown";
        log(`Mongo[${port}]: ${msg}`, ...extra);
      }
      /**
       * Create an new instance an call method "start"
       * @param opts Options passed to the new instance
       */
      static async create(opts) {
        log("create: Called .create() method");
        const instance = new this(opts);
        await instance.start();
        return instance;
      }
      /**
       * Create an array of arguments for the mongod instance
       */
      prepareCommandArgs() {
        this.debug("prepareCommandArgs");
        (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(this.instanceOpts.port), new Error('"instanceOpts.port" is required to be set!'));
        (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(this.instanceOpts.dbPath), new Error('"instanceOpts.dbPath" is required to be set!'));
        const result = [];
        result.push("--port", this.instanceOpts.port.toString());
        result.push("--dbpath", this.instanceOpts.dbPath);
        if (!!this.instanceOpts.replSet) {
          this.isReplSet = true;
          result.push("--replSet", this.instanceOpts.replSet);
        }
        if (!!this.instanceOpts.storageEngine) {
          result.push("--storageEngine", this.instanceOpts.storageEngine);
        }
        if (!!this.instanceOpts.ip) {
          result.push("--bind_ip", this.instanceOpts.ip);
        }
        if (this.instanceOpts.auth) {
          result.push("--auth");
          if (this.isReplSet) {
            (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(this.instanceOpts.keyfileLocation), new errors_1.KeyFileMissingError());
            result.push("--keyFile", this.instanceOpts.keyfileLocation);
          }
        } else {
          result.push("--noauth");
        }
        const final = result.concat(this.instanceOpts.args ?? []);
        this.debug("prepareCommandArgs: final argument array:" + JSON.stringify(final));
        return final;
      }
      /**
       * Create the mongod process
       * @fires MongoInstance#instanceStarted
       */
      async start() {
        this.debug("start");
        if (!(0, utils_1.isNullOrUndefined)(this.mongodProcess?.pid)) {
          throw new errors_1.GenericMMSError(`Cannot run "MongoInstance.start" because "mongodProcess.pid" is still defined (pid: ${this.mongodProcess?.pid})`);
        }
        this.isInstancePrimary = false;
        this.isInstanceReady = false;
        this.isReplSet = false;
        let timeout;
        const mongoBin = await MongoBinary_1.MongoBinary.getPath(this.binaryOpts);
        await (0, utils_1.checkBinaryPermissions)(mongoBin);
        const launch = new Promise((res, rej) => {
          this.once(MongoInstanceEvents.instanceReady, res);
          this.once(MongoInstanceEvents.instanceError, rej);
          this.once(MongoInstanceEvents.instanceClosed, function launchInstanceClosed() {
            rej(new Error("Instance Exited before being ready and without throwing an error!"));
          });
          const timeoutTime = !!this.instanceOpts.launchTimeout && this.instanceOpts.launchTimeout >= 1e3 ? this.instanceOpts.launchTimeout : 1e3 * 10;
          timeout = setTimeout(() => {
            const err = new errors_1.GenericMMSError(`Instance failed to start within ${timeoutTime}ms`);
            this.emit(MongoInstanceEvents.instanceError, err);
            rej(err);
          }, timeoutTime);
        }).finally(() => {
          clearTimeout(timeout);
        });
        this.debug("start: Starting Processes");
        this.mongodProcess = this._launchMongod(mongoBin);
        (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(this.mongodProcess.pid), new Error("MongoD Process failed to spawn"));
        this.killerProcess = this._launchKiller(process.pid, this.mongodProcess.pid);
        await launch;
        this.emit(MongoInstanceEvents.instanceStarted);
        this.debug("start: Processes Started");
      }
      /**
       * Shutdown all related processes (Mongod Instance & Killer Process)
       */
      async stop() {
        this.debug("stop");
        if (!this.mongodProcess && !this.killerProcess) {
          this.debug("stop: nothing to shutdown, returning");
          return false;
        }
        if (!(0, utils_1.isNullOrUndefined)(this.stopPromise)) {
          this.debug("stop: stopPromise is already set, using that");
          return this.stopPromise;
        }
        this.stopPromise = (async () => {
          if (!(0, utils_1.isNullOrUndefined)(this.mongodProcess) && (0, utils_1.isAlive)(this.mongodProcess.pid)) {
            if (this.isReplSet) {
              let con;
              try {
                this.debug("stop: trying shutdownServer");
                const port = this.instanceOpts.port;
                const ip = this.instanceOpts.ip;
                (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(port), new Error('Cannot shutdown replset gracefully, no "port" is provided'));
                (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(ip), new Error('Cannot shutdown replset gracefully, no "ip" is provided'));
                con = await mongodb_1.MongoClient.connect((0, utils_1.uriTemplate)(ip, port, "admin"), {
                  // stopping a instance should not take long to connect to, default would be 30 seconds
                  serverSelectionTimeoutMS: 5e3,
                  // 5 seconds
                  ...this.extraConnectionOptions,
                  directConnection: true
                });
                const admin = con.db("admin");
                await admin.command({ shutdown: 1, force: true, timeoutSecs: 1 });
                this.debug("stop: after admin shutdown command");
              } catch (err) {
                if (!(err instanceof mongodb_1.MongoNetworkError && /^connection \d+ to [\d.]+:\d+ closed$/i.test(err.message))) {
                  console.warn(err);
                }
              } finally {
                if (!(0, utils_1.isNullOrUndefined)(con)) {
                  await con.close();
                }
              }
            }
            await (0, utils_1.killProcess)(this.mongodProcess, "mongodProcess", this.instanceOpts.port);
            this.mongodProcess = void 0;
          } else {
            this.debug("stop: mongodProcess: nothing to shutdown, skipping");
          }
          if (!(0, utils_1.isNullOrUndefined)(this.killerProcess)) {
            await (0, utils_1.killProcess)(this.killerProcess, "killerProcess", this.instanceOpts.port);
            this.killerProcess = void 0;
          } else {
            this.debug("stop: killerProcess: nothing to shutdown, skipping");
          }
          this.debug("stop: Instance Finished Shutdown");
          return true;
        })().finally(() => this.stopPromise = void 0);
        return this.stopPromise;
      }
      /**
       * Actually launch mongod
       * @param mongoBin The binary to run
       * @fires MongoInstance#instanceLaunched
       */
      _launchMongod(mongoBin) {
        this.debug("_launchMongod: Launching Mongod Process");
        const childProcess = (0, child_process_1.spawn)(path.resolve(mongoBin), this.prepareCommandArgs(), {
          ...this.spawnOpts,
          stdio: "pipe"
          // ensure that stdio is always an pipe, regardless of user input
        });
        childProcess.stderr?.on("data", this.stderrHandler.bind(this));
        childProcess.stdout?.on("data", this.stdoutHandler.bind(this));
        childProcess.on("close", this.closeHandler.bind(this));
        childProcess.on("error", this.errorHandler.bind(this));
        if ((0, utils_1.isNullOrUndefined)(childProcess.pid)) {
          throw new errors_1.StartBinaryFailedError(path.resolve(mongoBin));
        }
        childProcess.unref();
        this.emit(MongoInstanceEvents.instanceLaunched);
        return childProcess;
      }
      /**
       * Spawn an seperate process to kill the parent and the mongod instance to ensure "mongod" gets stopped in any case
       * @param parentPid Parent nodejs process
       * @param childPid Mongod process to kill
       * @fires MongoInstance#killerLaunched
       */
      _launchKiller(parentPid, childPid) {
        this.debug(`_launchKiller: Launching Killer Process (parent: ${parentPid}, child: ${childPid})`);
        const killer = (0, child_process_1.fork)(path.resolve(__dirname, "../../scripts/mongo_killer.js"), [parentPid.toString(), childPid.toString()], {
          execArgv: [],
          detached: true,
          stdio: "ignore"
          // stdio cannot be done with an detached process cross-systems and without killing the fork on parent termination
        });
        killer.unref();
        this.emit(MongoInstanceEvents.killerLaunched);
        return killer;
      }
      /**
       * Event "error" handler
       * @param err The Error to handle
       * @fires MongoInstance#instanceRawError
       * @fires MongoInstance#instanceError
       */
      errorHandler(err) {
        this.emit(MongoInstanceEvents.instanceRawError, err);
        this.emit(MongoInstanceEvents.instanceError, err);
      }
      /**
       * Write the CLOSE event to the debug function
       * @param code The Exit code to handle
       * @param signal The Signal to handle
       * @fires MongoInstance#instanceClosed
       */
      closeHandler(code, signal) {
        if (process.platform === "win32" && code != 12 && code != 0 || process.platform !== "win32" && code != 0) {
          this.debug("closeHandler: Mongod instance closed with an non-0 (or non 12 on windows) code!");
          this.emit(MongoInstanceEvents.instanceError, new errors_1.UnexpectedCloseError(code, signal));
        }
        this.debug(`closeHandler: code: "${code}", signal: "${signal}"`);
        this.emit(MongoInstanceEvents.instanceClosed, code, signal);
      }
      /**
       * Write STDERR to debug function
       * @param message The STDERR line to write
       * @fires MongoInstance#instanceSTDERR
       */
      stderrHandler(message) {
        const line = message.toString().trim();
        this.debug(`stderrHandler: ""${line}""`);
        this.emit(MongoInstanceEvents.instanceSTDERR, line);
        this.checkErrorInLine(line);
      }
      /**
       * Write STDOUT to debug function and process some special messages
       * @param message The STDOUT line to write/parse
       * @fires MongoInstance#instanceSTDOUT
       * @fires MongoInstance#instanceReady
       * @fires MongoInstance#instanceError
       * @fires MongoInstance#instancePrimary
       * @fires MongoInstance#instanceReplState
       */
      stdoutHandler(message) {
        const line = message.toString().trim();
        this.debug(`stdoutHandler: ""${line}""`);
        this.emit(MongoInstanceEvents.instanceSTDOUT, line);
        if (/waiting for connections/i.test(line)) {
          this.emit(MongoInstanceEvents.instanceReady);
        }
        this.checkErrorInLine(line);
        if (/transition to \w+ from \w+/i.test(line)) {
          const state = /transition to (\w+) from \w+/i.exec(line)?.[1] ?? "UNKNOWN";
          this.emit(MongoInstanceEvents.instanceReplState, state);
          if (state !== "PRIMARY") {
            this.isInstancePrimary = false;
          }
        }
        if (/transition to primary complete; database writes are now permitted/i.test(line)) {
          this.isInstancePrimary = true;
          this.debug('stdoutHandler: emitting "instancePrimary"');
          this.emit(MongoInstanceEvents.instancePrimary);
        }
      }
      /**
       * Run Checks on the line if the lines contain any thrown errors
       * @param line The Line to check
       */
      checkErrorInLine(line) {
        if (/address already in use/i.test(line)) {
          this.emit(MongoInstanceEvents.instanceError, new errors_1.StdoutInstanceError(`Port "${this.instanceOpts.port}" already in use`));
        }
        {
          const execptionMatch = /\bexception in initAndListen: (\w+): /i.exec(line);
          if (!(0, utils_1.isNullOrUndefined)(execptionMatch)) {
            this.emit(MongoInstanceEvents.instanceError, new errors_1.StdoutInstanceError(`Instance Failed to start with "${execptionMatch[1] ?? "unknown"}". Original Error:
` + line.substring(execptionMatch.index + execptionMatch[0].length)));
          }
          const execptionMatchJson = /\bDBException in initAndListen,/i.test(line);
          if (execptionMatchJson) {
            const loadedJSON = JSON.parse(line) ?? {};
            this.emit(MongoInstanceEvents.instanceError, new errors_1.StdoutInstanceError(
              `Instance Failed to start with "DBException in initAndListen". Original Error:
` + loadedJSON?.attr?.error
              // try to use the parsed json, but as fallback use the entire line
            ));
          }
        }
        if (/CURL_OPENSSL_3['\s]+not found/i.test(line)) {
          this.emit(MongoInstanceEvents.instanceError, new errors_1.StdoutInstanceError("libcurl3 is not available on your system. Mongod requires it and cannot be started without it.\nYou should manually install libcurl3 or try to use an newer version of MongoDB"));
        }
        if (/CURL_OPENSSL_4['\s]+not found/i.test(line)) {
          this.emit(MongoInstanceEvents.instanceError, new errors_1.StdoutInstanceError("libcurl4 is not available on your system. Mongod requires it and cannot be started without it.\nYou need to manually install libcurl4"));
        }
        {
          const liberrormatch = line.match(/\b(?=(lib[^:]+))\1: cannot open shared object/i);
          if (!(0, utils_1.isNullOrUndefined)(liberrormatch)) {
            const lib = liberrormatch[1].toLocaleLowerCase() ?? "unknown";
            this.emit(MongoInstanceEvents.instanceError, new errors_1.StdoutInstanceError(`Instance failed to start because a library is missing or cannot be opened: "${lib}"`));
          }
        }
        if (/\*\*\*aborting after/i.test(line)) {
          const match = line.match(/\*\*\*aborting after ([^\n]+)/i);
          const extra = match?.[1] ? ` (${match[1]})` : "";
          this.emit(MongoInstanceEvents.instanceError, new errors_1.StdoutInstanceError("Mongod internal error" + extra));
        }
      }
      /// Symbol for "Explicit Resource Management"
      async [Symbol.asyncDispose]() {
        await this.stop();
      }
    };
    exports2.MongoInstance = MongoInstance;
    exports2.default = MongoInstance;
  }
});

// node_modules/mongodb-memory-server-core/lib/MongoMemoryServer.js
var require_MongoMemoryServer = __commonJS({
  "node_modules/mongodb-memory-server-core/lib/MongoMemoryServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoMemoryServer = exports2.MongoMemoryServerStates = exports2.MongoMemoryServerEvents = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var getport_1 = require_getport();
    var utils_1 = require_utils4();
    var MongoInstance_1 = require_MongoInstance();
    var debug_1 = tslib_1.__importDefault(require_src2());
    var events_1 = require("events");
    var fs_1 = require("fs");
    var mongodb_1 = require_lib6();
    var errors_1 = require_errors();
    var os = tslib_1.__importStar(require("os"));
    var DryMongoBinary_1 = require_DryMongoBinary();
    var semver = tslib_1.__importStar(require_semver2());
    var log = (0, debug_1.default)("MongoMS:MongoMemoryServer");
    var MongoMemoryServerEvents;
    (function(MongoMemoryServerEvents2) {
      MongoMemoryServerEvents2["stateChange"] = "stateChange";
    })(MongoMemoryServerEvents || (exports2.MongoMemoryServerEvents = MongoMemoryServerEvents = {}));
    var MongoMemoryServerStates;
    (function(MongoMemoryServerStates2) {
      MongoMemoryServerStates2["new"] = "new";
      MongoMemoryServerStates2["starting"] = "starting";
      MongoMemoryServerStates2["running"] = "running";
      MongoMemoryServerStates2["stopped"] = "stopped";
    })(MongoMemoryServerStates || (exports2.MongoMemoryServerStates = MongoMemoryServerStates = {}));
    var MongoMemoryServer2 = class _MongoMemoryServer extends events_1.EventEmitter {
      /**
       * Create a Mongo-Memory-Sever Instance
       * @param opts Mongo-Memory-Sever Options
       */
      constructor(opts) {
        super();
        this._state = MongoMemoryServerStates.new;
        this.opts = { ...opts };
        if ("auth" in (this.opts.instance ?? {})) {
          log("opts.instance.auth was defined, but will be set automatically, ignoring");
          delete this.opts.instance?.auth;
        }
        if (this.opts.auth?.enable === true) {
          this.auth = (0, utils_1.authDefault)(this.opts.auth);
        }
      }
      /**
       * Create a Mongo-Memory-Sever Instance that can be awaited
       * @param opts Mongo-Memory-Sever Options
       */
      static async create(opts) {
        log("create: Called .create() method");
        const instance = new _MongoMemoryServer({ ...opts });
        await instance.start();
        return instance;
      }
      /**
       * Start the Mongod Instance
       * @param forceSamePort Force to use the port defined in `options.instance` (disabled port generation)
       * @throws if state is not "new" or "stopped"
       */
      async start(forceSamePort) {
        this.debug("start: Called .start() method");
        switch (this._state) {
          case MongoMemoryServerStates.new:
          case MongoMemoryServerStates.stopped:
            break;
          case MongoMemoryServerStates.running:
          case MongoMemoryServerStates.starting:
          default:
            throw new errors_1.StateError([MongoMemoryServerStates.new, MongoMemoryServerStates.stopped], this.state);
        }
        (0, utils_1.assertion)((0, utils_1.isNullOrUndefined)(this._instanceInfo?.instance.mongodProcess), new Error('Cannot start because "instance.mongodProcess" is already defined!'));
        this.stateChange(MongoMemoryServerStates.starting);
        await this._startUpInstance(forceSamePort).catch(async (err) => {
          if (err instanceof Error && err.message?.includes("spawn Unknown system error -86")) {
            if (os.platform() === "darwin" && os.arch() === "arm64") {
              err.message += err.message += ", Is Rosetta Installed and Setup correctly?";
            }
          }
          if (!debug_1.default.enabled("MongoMS:MongoMemoryServer")) {
            console.warn("Starting the MongoMemoryServer Instance failed, enable debug log for more information. Error:\n", err);
          }
          this.debug("_startUpInstance threw a Error: ", err);
          await this.stop({ doCleanup: false, force: false });
          this.stateChange(MongoMemoryServerStates.stopped);
          throw err;
        });
        this.stateChange(MongoMemoryServerStates.running);
        this.debug("start: Instance fully Started");
      }
      /**
       * Change "this._state" to "newState" and emit "stateChange" with "newState"
       * @param newState The new State to set & emit
       */
      stateChange(newState) {
        this._state = newState;
        this.emit(MongoMemoryServerEvents.stateChange, newState);
      }
      /**
       * Debug-log with template applied
       * @param msg The Message to log
       */
      debug(msg, ...extra) {
        const port = this._instanceInfo?.port ?? "unknown";
        log(`Mongo[${port}]: ${msg}`, ...extra);
      }
      /**
       * Find a new unlocked port
       * @param port A User defined default port
       */
      async getNewPort(port) {
        const newPort = await (0, getport_1.getFreePort)(port);
        if (port != newPort && typeof port === "number") {
          this.debug(`getNewPort: starting with port "${newPort}", since "${port}" was locked`);
        }
        return newPort;
      }
      /**
       * Construct Instance Starting Options
       * @param forceSamePort Force to use the port defined in `options.instance` (disabled port generation)
       */
      async getStartOptions(forceSamePort = false) {
        this.debug(`getStartOptions: forceSamePort: ${forceSamePort}`);
        const instOpts = this.opts.instance ?? {};
        let isNew = true;
        const opts = await DryMongoBinary_1.DryMongoBinary.generateOptions(this.opts.binary);
        let storageEngine = instOpts.storageEngine;
        const coercedVersion = semver.coerce(opts.version) ?? new semver.SemVer("0.0.0");
        if (semver.eq(coercedVersion, "0.0.0")) {
          console.warn(new errors_1.UnknownVersionError(opts.version));
        }
        storageEngine = (0, utils_1.getStorageEngine)(storageEngine, coercedVersion);
        let port = typeof instOpts.port === "number" ? instOpts.port : void 0;
        if (!forceSamePort || (0, utils_1.isNullOrUndefined)(port)) {
          port = await this.getNewPort(port);
        }
        const data = {
          port,
          dbName: (0, utils_1.generateDbName)(instOpts.dbName),
          ip: instOpts.ip ?? "127.0.0.1",
          storageEngine,
          replSet: instOpts.replSet,
          dbPath: instOpts.dbPath,
          tmpDir: void 0,
          keyfileLocation: instOpts.keyfileLocation,
          launchTimeout: instOpts.launchTimeout
        };
        if ((0, utils_1.isNullOrUndefined)(this._instanceInfo)) {
          if (!data.dbPath) {
            data.tmpDir = await (0, utils_1.createTmpDir)("mongo-mem-");
            data.dbPath = data.tmpDir;
            isNew = true;
          } else {
            this.debug(`getStartOptions: Checking if "${data.dbPath}}" (no new tmpDir) already has data`);
            const files = await fs_1.promises.readdir(data.dbPath);
            isNew = files.length === 0;
          }
        } else {
          isNew = false;
        }
        const enableAuth = this.authObjectEnable();
        const createAuth = enableAuth && // re-use all the checks from "enableAuth"
        !(0, utils_1.isNullOrUndefined)(this.auth) && // needs to be re-checked because typescript complains
        (this.auth.force || isNew) && // check that either "isNew" or "this.auth.force" is "true"
        !instOpts.replSet;
        return {
          data,
          createAuth,
          mongodOptions: {
            instance: {
              ...data,
              args: instOpts.args,
              auth: enableAuth
            },
            binary: this.opts.binary,
            spawn: this.opts.spawn
          }
        };
      }
      /**
       * Internal Function to start an instance
       * @param forceSamePort Force to use the port defined in `options.instance` (disabled port generation)
       * @private
       */
      async _startUpInstance(forceSamePort) {
        this.debug("_startUpInstance: Called MongoMemoryServer._startUpInstance() method");
        const useSamePort = forceSamePort ?? !(this.opts.instance?.portGeneration ?? true);
        if (!(0, utils_1.isNullOrUndefined)(this._instanceInfo)) {
          this.debug('_startUpInstance: "instanceInfo" already defined, reusing instance');
          if (!useSamePort) {
            const newPort = await this.getNewPort(this._instanceInfo.port);
            this._instanceInfo.instance.instanceOpts.port = newPort;
            this._instanceInfo.port = newPort;
          }
          await this._instanceInfo.instance.start();
          return;
        }
        const { mongodOptions, createAuth, data } = await this.getStartOptions(useSamePort);
        this.debug(`_startUpInstance: Creating new MongoDB instance with options:`, mongodOptions);
        const instance = await MongoInstance_1.MongoInstance.create(mongodOptions);
        this._instanceInfo = {
          ...data,
          dbPath: data.dbPath,
          // because otherwise the types would be incompatible
          instance
        };
        this.debug(`_startUpInstance: Instance Started, createAuth: "${createAuth}"`);
        if (this.authObjectEnable() && mongodOptions.instance?.auth === true && !(0, utils_1.isNullOrUndefined)(this.auth)) {
          instance.extraConnectionOptions = {
            authSource: "admin",
            authMechanism: "SCRAM-SHA-256",
            auth: {
              username: this.auth.customRootName,
              password: this.auth.customRootPwd
            }
          };
        }
        if (!(0, utils_1.isNullOrUndefined)(this.auth) && createAuth) {
          this.debug(`_startUpInstance: Running "createAuth" (force: "${this.auth.force}")`);
          await this.createAuth(data);
        }
      }
      /**
       * Stop the current In-Memory Instance
       * @param cleanupOptions Set how to run ".cleanup", by default only `{ doCleanup: true }` is used
       */
      async stop(cleanupOptions) {
        this.debug("stop: Called .stop() method");
        let cleanup = { doCleanup: true, force: false };
        if (typeof cleanupOptions === "object") {
          cleanup = cleanupOptions;
        }
        if ((0, utils_1.isNullOrUndefined)(this._instanceInfo)) {
          this.debug('stop: "instanceInfo" is not defined (never ran?)');
          return false;
        }
        if (this._state === MongoMemoryServerStates.stopped) {
          this.debug('stop: state is "stopped", trying to stop / kill anyway');
        }
        this.debug(
          `stop: Stopping MongoDB server on port ${this._instanceInfo.port} with pid ${this._instanceInfo.instance?.mongodProcess?.pid}`
          // "undefined" would say more than ""
        );
        await this._instanceInfo.instance.stop();
        this.stateChange(MongoMemoryServerStates.stopped);
        if (cleanup.doCleanup) {
          await this.cleanup(cleanup);
        }
        return true;
      }
      /**
       * Remove the defined dbPath
       * @param options Set how to run a cleanup, by default `{ doCleanup: true }` is used
       * @throws If "state" is not "stopped"
       * @throws If "instanceInfo" is not defined
       * @throws If an fs error occured
       */
      async cleanup(options2) {
        assertionIsMMSState(MongoMemoryServerStates.stopped, this.state);
        let cleanup = { doCleanup: true, force: false };
        if (typeof options2 === "object") {
          cleanup = options2;
        }
        this.debug(`cleanup:`, cleanup);
        if (!cleanup.doCleanup) {
          this.debug('cleanup: "doCleanup" is set to false');
          return;
        }
        if ((0, utils_1.isNullOrUndefined)(this._instanceInfo)) {
          this.debug('cleanup: "instanceInfo" is undefined');
          return;
        }
        (0, utils_1.assertion)((0, utils_1.isNullOrUndefined)(this._instanceInfo.instance.mongodProcess), new Error('Cannot cleanup because "instance.mongodProcess" is still defined'));
        const tmpDir = this._instanceInfo.tmpDir;
        if (!(0, utils_1.isNullOrUndefined)(tmpDir)) {
          this.debug(`cleanup: removing tmpDir at ${tmpDir}`);
          await (0, utils_1.removeDir)(tmpDir);
        }
        if (cleanup.force) {
          const dbPath = this._instanceInfo.dbPath;
          const res = await (0, utils_1.statPath)(dbPath);
          if ((0, utils_1.isNullOrUndefined)(res)) {
            this.debug(`cleanup: force is true, but path "${dbPath}" dosnt exist anymore`);
          } else {
            (0, utils_1.assertion)(res.isDirectory(), new Error("Defined dbPath is not a directory"));
            await (0, utils_1.removeDir)(dbPath);
          }
        }
        this.stateChange(MongoMemoryServerStates.new);
        this._instanceInfo = void 0;
      }
      /**
       * Get Information about the currently running instance, if it is not running it returns "undefined"
       */
      get instanceInfo() {
        return this._instanceInfo;
      }
      /**
       * Get Current state of this class
       */
      get state() {
        return this._state;
      }
      /**
       * Ensure that the instance is running
       * -> throws if instance cannot be started
       */
      async ensureInstance() {
        this.debug("ensureInstance: Called .ensureInstance() method");
        switch (this._state) {
          case MongoMemoryServerStates.running:
            if (this._instanceInfo) {
              return this._instanceInfo;
            }
            throw new errors_1.InstanceInfoError("MongoMemoryServer.ensureInstance (state: running)");
          case MongoMemoryServerStates.new:
          case MongoMemoryServerStates.stopped:
            break;
          case MongoMemoryServerStates.starting:
            return new Promise((res, rej) => this.once(MongoMemoryServerEvents.stateChange, (state) => {
              if (state != MongoMemoryServerStates.running) {
                rej(new Error(`"ensureInstance" waited for "running" but got a different state: "${state}"`));
                return;
              }
              (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(this._instanceInfo), new Error("InstanceInfo is undefined!"));
              res(this._instanceInfo);
            }));
          default:
            throw new errors_1.StateError([
              MongoMemoryServerStates.running,
              MongoMemoryServerStates.new,
              MongoMemoryServerStates.stopped,
              MongoMemoryServerStates.starting
            ], this.state);
        }
        this.debug('ensureInstance: no running instance, calling "start()" command');
        await this.start();
        this.debug('ensureInstance: "start()" command was succesfully resolved');
        (0, utils_1.assertion)(!!this._instanceInfo, new errors_1.InstanceInfoError("MongoMemoryServer.ensureInstance (after starting)"));
        return this._instanceInfo;
      }
      /**
       * Generate the Connection string used by mongodb
       * @param otherDb add a database into the uri (in mongodb its the auth database, in mongoose its the default database for models)
       * @param otherIp change the ip in the generated uri, default will otherwise always be "127.0.0.1"
       * @throws if state is not "running" (or "starting")
       * @throws if a server doesnt have "instanceInfo.port" defined
       * @returns a valid mongo URI, by the definition of https://docs.mongodb.com/manual/reference/connection-string/
       */
      getUri(otherDb, otherIp) {
        this.debug("getUri:", this.state, otherDb, otherIp);
        switch (this.state) {
          case MongoMemoryServerStates.running:
          case MongoMemoryServerStates.starting:
            break;
          case MongoMemoryServerStates.stopped:
          default:
            throw new errors_1.StateError([MongoMemoryServerStates.running, MongoMemoryServerStates.starting], this.state);
        }
        assertionInstanceInfo(this._instanceInfo);
        return (0, utils_1.uriTemplate)(otherIp || "127.0.0.1", this._instanceInfo.port, (0, utils_1.generateDbName)(otherDb));
      }
      /**
       * Create the Root user and additional users using the [localhost exception](https://www.mongodb.com/docs/manual/core/localhost-exception/#std-label-localhost-exception)
       * This Function assumes "this.opts.auth" is already processed into "this.auth"
       * @param data Used to get "ip" and "port"
       * @internal
       */
      async createAuth(data) {
        (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(this.auth), new Error('"createAuth" got called, but "this.auth" is undefined!'));
        assertionInstanceInfo(this._instanceInfo);
        this.debug("createAuth: options:", this.auth);
        let con = await mongodb_1.MongoClient.connect((0, utils_1.uriTemplate)(data.ip, data.port, "admin"));
        try {
          let db = con.db("admin");
          this.debug(`createAuth: Creating Root user, name: "${this.auth.customRootName}"`);
          await db.command({
            createUser: this.auth.customRootName,
            pwd: this.auth.customRootPwd,
            mechanisms: ["SCRAM-SHA-256"],
            customData: {
              createdBy: "mongodb-memory-server",
              as: "ROOTUSER"
            },
            roles: ["root"],
            // "writeConcern" is needced, otherwise replset servers might fail with "auth failed: such user does not exist"
            writeConcern: {
              w: "majority"
            }
          });
          if (this.auth.extraUsers.length > 0) {
            this.debug(`createAuth: Creating "${this.auth.extraUsers.length}" Custom Users`);
            this.auth.extraUsers.sort((a, b) => {
              if (a.database === "admin") {
                return -1;
              }
              return a.database === b.database ? 0 : 1;
            });
            await con.close();
            con = await mongodb_1.MongoClient.connect(this.getUri("admin"), this._instanceInfo.instance.extraConnectionOptions ?? {});
            db = con.db("admin");
            for (const user of this.auth.extraUsers) {
              user.database = (0, utils_1.isNullOrUndefined)(user.database) ? "admin" : user.database;
              if (user.database !== db.databaseName) {
                db = con.db(user.database);
              }
              this.debug("createAuth: Creating User: ", user);
              await db.command({
                createUser: user.createUser,
                pwd: user.pwd,
                customData: {
                  ...user.customData,
                  createdBy: "mongodb-memory-server",
                  as: "EXTRAUSER"
                },
                roles: user.roles,
                authenticationRestrictions: user.authenticationRestrictions ?? [],
                mechanisms: user.mechanisms ?? ["SCRAM-SHA-256"],
                digestPassword: user.digestPassword ?? true,
                // "writeConcern" is needced, otherwise replset servers might fail with "auth failed: such user does not exist"
                writeConcern: {
                  w: "majority"
                }
              });
            }
          }
        } finally {
          await con.close();
        }
      }
      /**
       * Helper function to determine if the "auth" object is set and not to be disabled
       * This function expectes to be run after the auth object has been transformed to a object
       * @returns "true" when "auth" should be enabled
       */
      authObjectEnable() {
        if ((0, utils_1.isNullOrUndefined)(this.auth)) {
          return false;
        }
        return typeof this.auth.enable === "boolean" ? this.auth.enable : false;
      }
      // Symbol for "Explicit Resource Management"
      async [Symbol.asyncDispose]() {
        if (this.opts.dispose?.enabled ?? true) {
          await this.stop(this.opts.dispose?.cleanup);
        }
      }
    };
    exports2.MongoMemoryServer = MongoMemoryServer2;
    exports2.default = MongoMemoryServer2;
    function assertionInstanceInfo(val) {
      (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(val), new Error('"instanceInfo" is undefined'));
    }
    function assertionIsMMSState(wantedState, currentState) {
      (0, utils_1.assertion)(currentState === wantedState, new errors_1.StateError([wantedState], currentState));
    }
  }
});

// node_modules/mongodb-memory-server-core/lib/MongoMemoryReplSet.js
var require_MongoMemoryReplSet = __commonJS({
  "node_modules/mongodb-memory-server-core/lib/MongoMemoryReplSet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoMemoryReplSet = exports2.MongoMemoryReplSetEvents = exports2.MongoMemoryReplSetStates = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var events_1 = require("events");
    var MongoMemoryServer_1 = require_MongoMemoryServer();
    var utils_1 = require_utils4();
    var debug_1 = tslib_1.__importDefault(require_src2());
    var mongodb_1 = require_lib6();
    var MongoInstance_1 = require_MongoInstance();
    var errors_1 = require_errors();
    var fs_1 = require("fs");
    var path_1 = require("path");
    var semver = tslib_1.__importStar(require_semver2());
    var DryMongoBinary_1 = require_DryMongoBinary();
    var log = (0, debug_1.default)("MongoMS:MongoMemoryReplSet");
    var MongoMemoryReplSetStates;
    (function(MongoMemoryReplSetStates2) {
      MongoMemoryReplSetStates2["init"] = "init";
      MongoMemoryReplSetStates2["running"] = "running";
      MongoMemoryReplSetStates2["stopped"] = "stopped";
    })(MongoMemoryReplSetStates || (exports2.MongoMemoryReplSetStates = MongoMemoryReplSetStates = {}));
    var MongoMemoryReplSetEvents;
    (function(MongoMemoryReplSetEvents2) {
      MongoMemoryReplSetEvents2["stateChange"] = "stateChange";
    })(MongoMemoryReplSetEvents || (exports2.MongoMemoryReplSetEvents = MongoMemoryReplSetEvents = {}));
    var MongoMemoryReplSet = class extends events_1.EventEmitter {
      constructor(opts = {}) {
        super();
        this.servers = [];
        this._state = MongoMemoryReplSetStates.stopped;
        this._ranCreateAuth = false;
        this.binaryOpts = { ...opts.binary };
        this.instanceOpts = opts.instanceOpts ?? [];
        this.replSetOpts = { ...opts.replSet };
      }
      /**
       * Change "this._state" to "newState" and emit "newState"
       * @param newState The new State to set & emit
       */
      stateChange(newState, ...args) {
        this._state = newState;
        this.emit(MongoMemoryReplSetEvents.stateChange, newState, ...args);
      }
      /**
       * Create an instance of "MongoMemoryReplSet" and call start
       * @param opts Options for the ReplSet
       */
      static async create(opts) {
        log("create: Called .create() method");
        const replSet = new this({ ...opts });
        await replSet.start();
        return replSet;
      }
      /**
       * Get Current state of this class
       */
      get state() {
        return this._state;
      }
      /**
       * Get & Set "instanceOpts"
       * @throws if "state" is not "stopped"
       */
      get instanceOpts() {
        return this._instanceOpts;
      }
      set instanceOpts(val) {
        assertionIsMMSRSState(MongoMemoryReplSetStates.stopped, this._state);
        this._instanceOpts = val;
      }
      /**
       * Get & Set "binaryOpts"
       * @throws if "state" is not "stopped"
       */
      get binaryOpts() {
        return this._binaryOpts;
      }
      set binaryOpts(val) {
        assertionIsMMSRSState(MongoMemoryReplSetStates.stopped, this._state);
        this._binaryOpts = val;
      }
      /**
       * Get & Set "replSetOpts"
       * (Applies defaults)
       * @throws if "state" is not "stopped"
       */
      get replSetOpts() {
        return this._replSetOpts;
      }
      set replSetOpts(val) {
        assertionIsMMSRSState(MongoMemoryReplSetStates.stopped, this._state);
        const opts = DryMongoBinary_1.DryMongoBinary.getEnsuredOptions(this.binaryOpts);
        const coercedVersion = semver.coerce(opts.version) ?? new semver.SemVer("0.0.0");
        const storageEngine = (0, utils_1.getStorageEngine)(val.storageEngine, coercedVersion);
        const defaults = {
          auth: { enable: false },
          args: [],
          name: "testset",
          count: 1,
          dbName: (0, utils_1.generateDbName)(),
          ip: "127.0.0.1",
          spawn: {},
          storageEngine,
          configSettings: {},
          dispose: {}
        };
        this._replSetOpts = { ...defaults, ...val, storageEngine };
        (0, utils_1.assertion)(this._replSetOpts.count > 0, new errors_1.ReplsetCountLowError(this._replSetOpts.count));
        if (this._replSetOpts.auth.enable) {
          this._replSetOpts.auth = (0, utils_1.authDefault)(this._replSetOpts.auth);
        }
      }
      /**
       * Helper function to determine if "auth" should be enabled
       * This function expectes to be run after the auth object has been transformed to a object
       * @returns "true" when "auth" should be enabled
       */
      enableAuth() {
        if ((0, utils_1.isNullOrUndefined)(this._replSetOpts.auth)) {
          return false;
        }
        (0, utils_1.assertion)(typeof this._replSetOpts.auth === "object", new errors_1.AuthNotObjectError());
        return typeof this._replSetOpts.auth.enable === "boolean" ? this._replSetOpts.auth.enable : false;
      }
      /**
       * Returns instance options suitable for a MongoMemoryServer.
       * @param baseOpts Options to merge with
       * @param keyfileLocation The Keyfile location if "auth" is used
       */
      getInstanceOpts(baseOpts = {}, keyfileLocation) {
        const enableAuth = this.enableAuth();
        const opts = {
          auth: enableAuth,
          args: this._replSetOpts.args,
          dbName: this._replSetOpts.dbName,
          ip: this._replSetOpts.ip,
          replSet: this._replSetOpts.name,
          storageEngine: this._replSetOpts.storageEngine
        };
        if (!(0, utils_1.isNullOrUndefined)(keyfileLocation)) {
          opts.keyfileLocation = keyfileLocation;
        }
        if (baseOpts.args) {
          opts.args = this._replSetOpts.args.concat(baseOpts.args);
        }
        if (baseOpts.port) {
          opts.port = baseOpts.port;
        }
        if (baseOpts.dbPath) {
          opts.dbPath = baseOpts.dbPath;
        }
        if (baseOpts.storageEngine) {
          opts.storageEngine = baseOpts.storageEngine;
        }
        if (baseOpts.replicaMemberConfig) {
          opts.replicaMemberConfig = baseOpts.replicaMemberConfig;
        }
        if (baseOpts.launchTimeout) {
          opts.launchTimeout = baseOpts.launchTimeout;
        }
        log("getInstanceOpts: instance opts:", opts);
        return opts;
      }
      /**
       * Returns an mongodb URI that is setup with all replSet servers
       * @param otherDb add an database into the uri (in mongodb its the auth database, in mongoose its the default database for models)
       * @param otherIp change the ip in the generated uri, default will otherwise always be "127.0.0.1"
       * @throws if state is not "running"
       * @throws if an server doesnt have "instanceInfo.port" defined
       * @returns an valid mongo URI, by the definition of https://docs.mongodb.com/manual/reference/connection-string/
       */
      getUri(otherDb, otherIp) {
        log("getUri:", this.state);
        switch (this.state) {
          case MongoMemoryReplSetStates.running:
          case MongoMemoryReplSetStates.init:
            break;
          case MongoMemoryReplSetStates.stopped:
          default:
            throw new errors_1.StateError([MongoMemoryReplSetStates.running, MongoMemoryReplSetStates.init], this.state);
        }
        const hosts = this.servers.map((s) => {
          const port = s.instanceInfo?.port;
          (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(port), new Error("Instance Port is undefined!"));
          const ip = otherIp || "127.0.0.1";
          return `${ip}:${port}`;
        }).join(",");
        return (0, utils_1.uriTemplate)(hosts, void 0, (0, utils_1.generateDbName)(otherDb), [
          `replicaSet=${this._replSetOpts.name}`
        ]);
      }
      /**
       * Start underlying `mongod` instances.
       * @throws if state is already "running"
       */
      async start() {
        log("start:", this.state);
        switch (this.state) {
          case MongoMemoryReplSetStates.stopped:
            break;
          case MongoMemoryReplSetStates.running:
          default:
            throw new errors_1.StateError([MongoMemoryReplSetStates.stopped], this.state);
        }
        this.stateChange(MongoMemoryReplSetStates.init);
        await (0, utils_1.ensureAsync)().then(() => this.initAllServers()).then(() => this._initReplSet()).catch(async (err) => {
          if (!debug_1.default.enabled("MongoMS:MongoMemoryReplSet")) {
            console.warn("Starting the MongoMemoryReplSet Instance failed, enable debug log for more information. Error:\n", err);
          }
          log("ensureAsync chain threw a Error: ", err);
          await this.stop({ doCleanup: false, force: false });
          this.stateChange(MongoMemoryReplSetStates.stopped);
          throw err;
        });
      }
      /**
       * Initialize & start all servers in the replSet
       */
      async initAllServers() {
        log("initAllServers");
        this.stateChange(MongoMemoryReplSetStates.init);
        if (this.servers.length > 0) {
          log('initAllServers: lenght of "servers" is higher than 0, starting existing servers');
          if (this._ranCreateAuth) {
            log('initAllServers: "_ranCreateAuth" is true, re-using auth');
            const keyfilepath = (0, path_1.resolve)(await this.ensureKeyFile(), "keyfile");
            for (const server of this.servers) {
              (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(server.instanceInfo), new errors_1.InstanceInfoError("MongoMemoryReplSet.initAllServers"));
              (0, utils_1.assertion)(typeof this._replSetOpts.auth === "object", new errors_1.AuthNotObjectError());
              server.instanceInfo.instance.instanceOpts.auth = true;
              server.instanceInfo.instance.instanceOpts.keyfileLocation = keyfilepath;
              server.instanceInfo.instance.extraConnectionOptions = {
                authSource: "admin",
                authMechanism: "SCRAM-SHA-256",
                auth: {
                  username: this._replSetOpts.auth.customRootName,
                  // cast because these are existing
                  password: this._replSetOpts.auth.customRootPwd
                }
              };
            }
          }
          await Promise.all(this.servers.map((s) => s.start(true)));
          log("initAllServers: finished starting existing instances again");
          return;
        }
        let keyfilePath = void 0;
        if (this.enableAuth()) {
          keyfilePath = (0, path_1.resolve)(await this.ensureKeyFile(), "keyfile");
        }
        this._instanceOpts.forEach((opts, index) => {
          log(`initAllServers: starting special server "${index + 1}" of "${this._instanceOpts.length}" from instanceOpts (count: ${this.servers.length + 1}):`, opts);
          this.servers.push(this._initServer(this.getInstanceOpts(opts, keyfilePath)));
        });
        while (this.servers.length < this._replSetOpts.count) {
          log(`initAllServers: starting extra server "${this.servers.length + 1}" of "${this._replSetOpts.count}" (count: ${this.servers.length + 1})`);
          this.servers.push(this._initServer(this.getInstanceOpts(void 0, keyfilePath)));
        }
        log("initAllServers: waiting for all servers to finish starting");
        await Promise.all(this.servers.map((s) => s.start()));
        log("initAllServers: finished starting all servers initially");
      }
      /**
       * Ensure "_keyfiletmp" is defined
       * @returns the ensured "_keyfiletmp" value
       */
      async ensureKeyFile() {
        log("ensureKeyFile");
        if ((0, utils_1.isNullOrUndefined)(this._keyfiletmp)) {
          this._keyfiletmp = await (0, utils_1.createTmpDir)("mongo-mem-keyfile-");
        }
        const keyfilepath = (0, path_1.resolve)(this._keyfiletmp, "keyfile");
        if (!await (0, utils_1.statPath)(keyfilepath)) {
          log("ensureKeyFile: creating Keyfile");
          (0, utils_1.assertion)(typeof this._replSetOpts.auth === "object", new errors_1.AuthNotObjectError());
          await fs_1.promises.writeFile(
            (0, path_1.resolve)(this._keyfiletmp, "keyfile"),
            this._replSetOpts.auth.keyfileContent ?? "0123456789",
            { mode: 448 }
            // this is because otherwise mongodb errors with "permissions are too open" on unix systems
          );
        }
        return this._keyfiletmp;
      }
      /**
       * Stop the underlying `mongod` instance(s).
       * @param cleanupOptions Set how to run ".cleanup", by default only `{ doCleanup: true }` is used
       */
      async stop(cleanupOptions) {
        log(`stop: called by ${(0, utils_1.isNullOrUndefined)(process.exitCode) ? "manual" : "process exit"}`);
        let cleanup = { doCleanup: true, force: false };
        if (typeof cleanupOptions === "object") {
          cleanup = cleanupOptions;
        }
        if (this._state === MongoMemoryReplSetStates.stopped) {
          log('stop: state is "stopped", trying to stop / kill anyway');
        }
        const successfullyStopped = await Promise.all(this.servers.map((s) => s.stop({ doCleanup: false, force: false }))).then(() => {
          this.stateChange(MongoMemoryReplSetStates.stopped);
          return true;
        }).catch((err) => {
          log("stop:", err);
          this.stateChange(MongoMemoryReplSetStates.stopped, err);
          return false;
        });
        if (!successfullyStopped) {
          return false;
        }
        if (cleanup.doCleanup) {
          await this.cleanup(cleanup);
        }
        return true;
      }
      /**
       * Remove the defined dbPath's
       * @param options Set how to run a cleanup, by default `{ doCleanup: true }` is used
       * @throws If "state" is not "stopped"
       * @throws If "instanceInfo" is not defined
       * @throws If an fs error occured
       */
      async cleanup(options2) {
        assertionIsMMSRSState(MongoMemoryReplSetStates.stopped, this._state);
        log(`cleanup for "${this.servers.length}" servers`);
        let cleanup = { doCleanup: true, force: false };
        if (typeof options2 === "object") {
          cleanup = options2;
        }
        log(`cleanup:`, cleanup);
        if (!cleanup.doCleanup) {
          log('cleanup: "doCleanup" is set to false');
          return;
        }
        await Promise.all(this.servers.map((s) => s.cleanup(cleanup)));
        if (!(0, utils_1.isNullOrUndefined)(this._keyfiletmp)) {
          await (0, utils_1.removeDir)(this._keyfiletmp);
          this._keyfiletmp = void 0;
        }
        this.servers = [];
        this._ranCreateAuth = false;
        return;
      }
      /**
       * Wait until all instances are running
       * @throws if state is "stopped" (cannot wait on something that dosnt start)
       */
      async waitUntilRunning() {
        await (0, utils_1.ensureAsync)();
        log("waitUntilRunning:", this._state);
        switch (this._state) {
          case MongoMemoryReplSetStates.running:
            return;
          case MongoMemoryReplSetStates.init:
            await new Promise((res) => {
              function waitRunning(state) {
                if (state === MongoMemoryReplSetStates.running) {
                  this.removeListener(MongoMemoryReplSetEvents.stateChange, waitRunning);
                  res();
                }
              }
              this.on(MongoMemoryReplSetEvents.stateChange, waitRunning);
            });
            return;
          case MongoMemoryReplSetStates.stopped:
          default:
            throw new errors_1.StateError([MongoMemoryReplSetStates.running, MongoMemoryReplSetStates.init], this.state);
        }
      }
      /**
       * Connects to the first server from the list of servers and issues the `replSetInitiate`
       * command passing in a new replica set configuration object.
       * @throws if state is not "init"
       * @throws if "servers.length" is not 1 or above
       * @throws if package "mongodb" is not installed
       */
      async _initReplSet() {
        log("_initReplSet");
        assertionIsMMSRSState(MongoMemoryReplSetStates.init, this._state);
        (0, utils_1.assertion)(this.servers.length > 0, new Error("One or more servers are required."));
        const uris = this.servers.map((server) => server.getUri());
        const isInMemory = this.servers[0].instanceInfo?.storageEngine === "ephemeralForTest";
        const extraOptions = this._ranCreateAuth ? this.servers[0].instanceInfo?.instance.extraConnectionOptions ?? {} : {};
        const con = await mongodb_1.MongoClient.connect(uris[0], {
          // somehow since mongodb-nodejs 4.0, this option is needed when the server is set to be in a replset
          directConnection: true,
          ...extraOptions
        });
        log("_initReplSet: connected");
        try {
          const adminDb = con.db("admin");
          const members = uris.map((uri, index) => ({
            _id: index,
            host: (0, utils_1.getHost)(uri),
            ...this.servers[index].opts.instance?.replicaMemberConfig || {}
            // Overwrite replica member config
          }));
          const rsConfig = {
            _id: this._replSetOpts.name,
            members,
            writeConcernMajorityJournalDefault: !isInMemory,
            // if storage engine is "ephemeralForTest" deactivate this option, otherwise enable it
            settings: {
              electionTimeoutMillis: 500,
              ...this._replSetOpts.configSettings
            }
          };
          try {
            log('_initReplSet: trying "replSetInitiate"');
            await adminDb.command({ replSetInitiate: rsConfig });
            if (this.enableAuth()) {
              log('_initReplSet: "enableAuth" returned "true"');
              await this._waitForPrimary(void 0, "_initReplSet authIsObject");
              const primary = this.servers.find((server) => server.instanceInfo?.instance.isInstancePrimary);
              (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(primary), new Error("No Primary found"));
              (0, utils_1.assertion)(!(0, utils_1.isNullOrUndefined)(primary.instanceInfo), new errors_1.InstanceInfoError("_initReplSet authIsObject primary"));
              await con.close();
              await primary.createAuth(primary.instanceInfo);
              this._ranCreateAuth = true;
            }
          } catch (err) {
            if (err instanceof mongodb_1.MongoError && err.errmsg == "already initialized") {
              log(`_initReplSet: "${err.errmsg}": trying to set old config`);
              const { config: oldConfig } = await adminDb.command({ replSetGetConfig: 1 });
              log("_initReplSet: got old config:\n", oldConfig);
              await adminDb.command({
                replSetReconfig: oldConfig,
                force: true
              });
            } else {
              throw err;
            }
          }
          log("_initReplSet: ReplSet-reconfig finished");
          await this._waitForPrimary(void 0, "_initReplSet beforeRunning");
          this.stateChange(MongoMemoryReplSetStates.running);
          log("_initReplSet: running");
        } finally {
          log("_initReplSet: finally closing connection");
          await con.close();
        }
      }
      /**
       * Create the one Instance (without starting them)
       * @param instanceOpts Instance Options to use for this instance
       */
      _initServer(instanceOpts) {
        const serverOpts = {
          binary: this._binaryOpts,
          instance: instanceOpts,
          spawn: this._replSetOpts.spawn,
          auth: typeof this.replSetOpts.auth === "object" ? this.replSetOpts.auth : void 0
        };
        const server = new MongoMemoryServer_1.MongoMemoryServer(serverOpts);
        return server;
      }
      /**
       * Wait until the replSet has elected a Primary
       * @param timeout Timeout to not run infinitly, default: 30s
       * @param where Extra Parameter for logging to know where this function was called
       * @throws if timeout is reached
       */
      async _waitForPrimary(timeout = 1e3 * 30, where) {
        log("_waitForPrimary: Waiting for a Primary");
        let timeoutId;
        await Promise.race([
          ...this.servers.map((server) => new Promise((res, rej) => {
            const instanceInfo = server.instanceInfo;
            if ((0, utils_1.isNullOrUndefined)(instanceInfo)) {
              return rej(new errors_1.InstanceInfoError("_waitForPrimary Primary race"));
            }
            instanceInfo.instance.once(MongoInstance_1.MongoInstanceEvents.instancePrimary, res);
            if (instanceInfo.instance.isInstancePrimary) {
              log("_waitForPrimary: found instance being already primary");
              res();
            }
          })),
          new Promise((_res, rej) => {
            timeoutId = setTimeout(() => {
              Promise.all([...this.servers.map((v) => v.stop())]);
              rej(new errors_1.WaitForPrimaryTimeoutError(timeout, where));
            }, timeout);
          })
        ]);
        if (!(0, utils_1.isNullOrUndefined)(timeoutId)) {
          clearTimeout(timeoutId);
        }
        log("_waitForPrimary: detected one primary instance ");
      }
      // Symbol for "Explicit Resource Management"
      async [Symbol.asyncDispose]() {
        if (this.replSetOpts.dispose?.enabled ?? true) {
          await this.stop(this.replSetOpts.dispose?.cleanup);
        }
      }
    };
    exports2.MongoMemoryReplSet = MongoMemoryReplSet;
    exports2.default = MongoMemoryReplSet;
    function assertionIsMMSRSState(wantedState, currentState) {
      (0, utils_1.assertion)(currentState === wantedState, new errors_1.StateError([wantedState], currentState));
    }
  }
});

// node_modules/mongodb-memory-server-core/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/mongodb-memory-server-core/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MongoMemoryServer = exports2.errors = exports2.MongoMemoryReplSet = exports2.MongoInstance = exports2.MongoBinary = exports2.DryMongoBinary = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    require_resolveConfig();
    var MongoMemoryServer_1 = require_MongoMemoryServer();
    Object.defineProperty(exports2, "MongoMemoryServer", { enumerable: true, get: function() {
      return MongoMemoryServer_1.MongoMemoryServer;
    } });
    var DryMongoBinary_1 = require_DryMongoBinary();
    Object.defineProperty(exports2, "DryMongoBinary", { enumerable: true, get: function() {
      return DryMongoBinary_1.DryMongoBinary;
    } });
    var MongoBinary_1 = require_MongoBinary();
    Object.defineProperty(exports2, "MongoBinary", { enumerable: true, get: function() {
      return MongoBinary_1.MongoBinary;
    } });
    var MongoInstance_1 = require_MongoInstance();
    Object.defineProperty(exports2, "MongoInstance", { enumerable: true, get: function() {
      return MongoInstance_1.MongoInstance;
    } });
    var MongoMemoryReplSet_1 = require_MongoMemoryReplSet();
    Object.defineProperty(exports2, "MongoMemoryReplSet", { enumerable: true, get: function() {
      return MongoMemoryReplSet_1.MongoMemoryReplSet;
    } });
    exports2.errors = tslib_1.__importStar(require_errors());
    exports2.default = MongoMemoryServer_1.MongoMemoryServer;
  }
});

// node_modules/mongodb-memory-server/index.js
var require_mongodb_memory_server = __commonJS({
  "node_modules/mongodb-memory-server/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib.__exportStar(require_lib7(), exports2);
  }
});

// src/tests/integration/postsRoutes.test.ts
var import_supertest = __toESM(require_supertest());
var import_mongoose3 = __toESM(require("mongoose"));
var import_mongodb_memory_server = __toESM(require_mongodb_memory_server());

// src/app.ts
var import_express2 = __toESM(require("express"));

// src/routes/index.ts
var import_express = require("express");

// src/models/postModel.ts
var import_mongoose = __toESM(require("mongoose"));
var PostSchema = new import_mongoose.default.Schema(
  {
    id: { type: import_mongoose.default.Schema.Types.ObjectId },
    title: { type: String, required: true },
    content: { type: String, required: true },
    author: { type: String, required: true },
    subject: { type: String, default: Date.now }
  },
  { versionKey: false }
);
var PostModel = import_mongoose.default.model("posts", PostSchema);

// src/repositories/postsRepository.ts
var import_mongoose2 = require("mongoose");
var findAllPosts = async (filters = {}, pagination) => {
  const { page, limit } = pagination;
  const skip = (page - 1) * limit;
  const posts = await PostModel.find(filters).skip(skip).limit(limit).lean();
  return posts;
};
var findPostById = async (id) => {
  if (!import_mongoose2.Types.ObjectId.isValid(id)) return null;
  return await PostModel.findById(id).lean();
};
var createPost = async (data) => {
  const post = await PostModel.create(data);
  return post.toObject();
};
var deleteOnePost = async (id) => {
  if (!import_mongoose2.Types.ObjectId.isValid(id)) return false;
  const result = await PostModel.findByIdAndDelete(id);
  return result != null;
};
var updatePost = async (id, data) => {
  if (!import_mongoose2.Types.ObjectId.isValid(id)) return null;
  return await PostModel.findByIdAndUpdate(id, data, { new: true }).lean();
};

// src/utils/http-helper.ts
var ok = async (data) => {
  return {
    statusCode: 200,
    body: data
  };
};
var noContent = async () => {
  return {
    statusCode: 204,
    body: null
  };
};
var badRequest = async (error2) => {
  return {
    statusCode: 400,
    body: error2
  };
};
var created = async (createdPost) => {
  return {
    statusCode: 201,
    body: createdPost ?? "Successfully created"
  };
};

// src/services/postsService.ts
var getPostService = async (filters, pagination) => {
  const posts = await findAllPosts(filters, pagination);
  if (posts.length > 0) {
    return ok(posts);
  }
  return noContent();
};
var getPostByIdService = async (id) => {
  const post = await findPostById(id);
  if (post) {
    return ok(post);
  }
  return noContent();
};
var createPostService = async (postData) => {
  if (!postData || Object.keys(postData).length === 0) {
    return badRequest({ message: "Dados obrigat\xF3rios ausentes" });
  }
  const createdPost = await createPost(postData);
  return created(createdPost);
};
var deletePostService = async (id) => {
  const deleted = await deleteOnePost(id);
  if (deleted) {
    return ok({ message: "Deletado com sucesso" });
  }
  return badRequest({
    message: "Post n\xE3o encontrado ou ID inv\xE1lido"
  });
};
var updatePostService = async (id, content) => {
  if (!content || Object.keys(content).length === 0) {
    return badRequest({
      message: "Nenhum dado enviado para atualiza\xE7\xE3o"
    });
  }
  const updatedPost = await updatePost(id, content);
  if (!updatedPost) {
    return badRequest({
      message: "Post n\xE3o encontrado ou ID inv\xE1lido"
    });
  }
  return ok(updatedPost);
};

// src/validations/postValidation.ts
var import_zod = require("zod");
var postInputSchema = import_zod.z.object({
  title: import_zod.z.string().min(1, "T\xEDtulo \xE9 obrigat\xF3rio"),
  content: import_zod.z.string().min(1, "Conte\xFAdo \xE9 obrigat\xF3rio"),
  author: import_zod.z.string().min(1, "Autor \xE9 obrigat\xF3rio"),
  subject: import_zod.z.string().min(1, "Assunto \xE9 obrigat\xF3rio")
});

// src/controllers/postController.ts
var getPosts = async (req, res) => {
  const { page = "1", limit = "10", author, subject } = req.query;
  const filters = {
    ...author && { author },
    ...subject && { subject }
  };
  const pagination = {
    page: parseInt(page, 10),
    limit: parseInt(limit, 10)
  };
  const httpResponse = await getPostService(filters, pagination);
  if (httpResponse.statusCode === 204) {
    return res.sendStatus(204);
  }
  return res.status(httpResponse.statusCode).json(httpResponse.body);
};
var getPostById = async (req, res) => {
  const id = req.params.id;
  const httpResponse = await getPostByIdService(id);
  if (httpResponse.statusCode === 204) {
    return res.sendStatus(204);
  }
  return res.status(httpResponse.statusCode).json(httpResponse.body);
};
var createPost2 = async (req, res) => {
  const parseResult = postInputSchema.safeParse(req.body);
  if (!parseResult.success) {
    return res.status(400).json({
      message: "Dados inv\xE1lidos",
      errors: parseResult.error.flatten().fieldErrors
    });
  }
  const postData = parseResult.data;
  const createdResponse = await createPostService(postData);
  return res.status(createdResponse.statusCode).json(createdResponse.body);
};
var deletePost = async (req, res) => {
  const id = req.params.id;
  const httpResponse = await deletePostService(id);
  return res.status(httpResponse.statusCode).json(httpResponse.body);
};
var updatePost2 = async (req, res) => {
  const id = req.params.id;
  const bodyData = req.body;
  const httpResponse = await updatePostService(id, bodyData);
  return res.status(httpResponse.statusCode).json(httpResponse.body);
};

// src/routes/index.ts
var router = (0, import_express.Router)();
router.get("/posts", getPosts);
router.get("/posts/:id", getPostById);
router.post("/posts", createPost2);
router.delete("/posts/:id", deletePost);
router.patch("/posts/:id", updatePost2);
var routes_default = router;

// src/app.ts
var import_swagger_ui_express = __toESM(require("swagger-ui-express"));

// src/config/swagger.ts
var import_swagger_jsdoc = __toESM(require("swagger-jsdoc"));

// src/config/env.ts
var import_config = require("dotenv/config");
var import_zod2 = __toESM(require("zod"));
var envSchema = import_zod2.default.object({
  PORT: import_zod2.default.coerce.number().default(3e3),
  MONGO_USER: import_zod2.default.string(),
  MONGO_PASSWORD: import_zod2.default.string(),
  MONGO_PORT: import_zod2.default.coerce.number().default(27017),
  DATABASE: import_zod2.default.string().default("mongodb"),
  MONGO_HOST: import_zod2.default.string().default("localhost")
});
var _env = envSchema.safeParse(process.env);
if (!_env.success) {
  console.error("Invalid environment variables:", _env.error.format());
  throw new Error("Invalid environment variables");
}
var env = _env.data;

// src/config/swagger.ts
var swaggerOptions = {
  definition: {
    openapi: "3.0.0",
    info: {
      title: "API de Posts",
      version: "1.0.0",
      description: "Documenta\xE7\xE3o gerada automaticamente com Swagger JSDoc"
    },
    servers: [
      {
        url: `http://localhost:${env.PORT}`
      }
    ]
  },
  apis: ["./src/routes/*.ts"]
  // arquivos onde estão os JSDoc das rotas
};
var swaggerSpec = (0, import_swagger_jsdoc.default)(swaggerOptions);

// src/app.ts
var import_cors = __toESM(require("cors"));
function createApp() {
  const app = (0, import_express2.default)();
  app.use(import_express2.default.json());
  app.use("/api", routes_default);
  app.use("/api-docs", import_swagger_ui_express.default.serve, import_swagger_ui_express.default.setup(swaggerSpec));
  app.use((0, import_cors.default)());
  return app;
}
var app_default = createApp;

// src/tests/integration/postsRoutes.test.ts
describe("Posts API Integration", () => {
  let mongod;
  let app;
  beforeAll(async () => {
    mongod = await import_mongodb_memory_server.MongoMemoryServer.create();
    const uri = mongod.getUri();
    await import_mongoose3.default.connect(uri);
    app = app_default();
  });
  afterAll(async () => {
    await import_mongoose3.default.disconnect();
    await mongod.stop();
  });
  beforeEach(async () => {
    await PostModel.deleteMany({});
  });
  describe("GET /api/posts", () => {
    it("deve retornar 204 quando n\xE3o houver posts", async () => {
      const res = await (0, import_supertest.default)(app).get("/api/posts");
      expect(res.status).toBe(204);
      expect(res.body).toEqual({});
    });
  });
  describe("POST /api/posts", () => {
    const validPayload = {
      title: "T\xEDtulo Teste",
      content: "Conte\xFAdo Teste",
      author: "Autor Teste",
      subject: "Assunto Teste"
    };
    it("deve retornar 400 para payload inv\xE1lido", async () => {
      const res = await (0, import_supertest.default)(app).post("/api/posts").send({ title: "S\xF3 t\xEDtulo" });
      expect(res.status).toBe(400);
      expect(res.body).toHaveProperty("message", "Dados inv\xE1lidos");
      expect(res.body).toHaveProperty("errors");
    });
    it("deve criar um post e retornar 201 + objeto criado", async () => {
      const res = await (0, import_supertest.default)(app).post("/api/posts").send(validPayload);
      expect(res.status).toBe(201);
      expect(res.body).toMatchObject(validPayload);
      expect(res.body).toHaveProperty("_id");
    });
  });
  describe("GET /api/posts (ap\xF3s criar)", () => {
    it("deve retornar 200 e lista de posts", async () => {
      await PostModel.create({
        title: "A",
        content: "C",
        author: "X",
        subject: "S"
      });
      const res = await (0, import_supertest.default)(app).get("/api/posts");
      expect(res.status).toBe(200);
      expect(Array.isArray(res.body)).toBe(true);
      expect(res.body).toHaveLength(1);
    });
  });
  describe("GET /api/posts/:id", () => {
    it("deve retornar 200 e o post correto", async () => {
      const doc = await PostModel.create({
        title: "Doc",
        content: "C",
        author: "Y",
        subject: "Z"
      });
      const res = await (0, import_supertest.default)(app).get(`/api/posts/${doc._id}`);
      expect(res.status).toBe(200);
      expect(res.body).toMatchObject({
        _id: doc._id.toString(),
        title: "Doc",
        content: "C",
        author: "Y",
        subject: "Z"
      });
    });
    it("deve retornar 204 para id v\xE1lido mas n\xE3o existente", async () => {
      const fakeId = new import_mongoose3.default.Types.ObjectId().toString();
      const res = await (0, import_supertest.default)(app).get(`/api/posts/${fakeId}`);
      expect(res.status).toBe(204);
      expect(res.body).toEqual({});
    });
    it("deve retornar 204 para id inv\xE1lido", async () => {
      const res = await (0, import_supertest.default)(app).get("/api/posts/123-invalido");
      expect(res.status).toBe(204);
      expect(res.body).toEqual({});
    });
  });
  describe("PATCH /api/posts/:id", () => {
    it("deve retornar 400 se body vazio", async () => {
      const doc = await PostModel.create({
        title: "T",
        content: "C",
        author: "A",
        subject: "S"
      });
      const res = await (0, import_supertest.default)(app).patch(`/api/posts/${doc._id}`).send({});
      expect(res.status).toBe(400);
      expect(res.body).toHaveProperty(
        "message",
        "Nenhum dado enviado para atualiza\xE7\xE3o"
      );
    });
    it("deve retornar 400 para id inv\xE1lido", async () => {
      const res = await (0, import_supertest.default)(app).patch("/api/posts/invalid-id").send({ title: "Novo" });
      expect(res.status).toBe(400);
      expect(res.body).toHaveProperty(
        "message",
        "Post n\xE3o encontrado ou ID inv\xE1lido"
      );
    });
    it("deve atualizar e retornar 200 + objeto atualizado", async () => {
      const doc = await PostModel.create({
        title: "Antes",
        content: "C",
        author: "A",
        subject: "S"
      });
      const res = await (0, import_supertest.default)(app).patch(`/api/posts/${doc._id}`).send({ title: "Depois" });
      expect(res.status).toBe(200);
      expect(res.body).toMatchObject({
        _id: doc._id.toString(),
        title: "Depois"
      });
    });
  });
  describe("DELETE /api/posts/:id", () => {
    it("deve retornar 400 para id inv\xE1lido", async () => {
      const res = await (0, import_supertest.default)(app).delete("/api/posts/invalid-id");
      expect(res.status).toBe(400);
      expect(res.body).toHaveProperty(
        "message",
        "Post n\xE3o encontrado ou ID inv\xE1lido"
      );
    });
    it("deve deletar e retornar 200 + mensagem", async () => {
      const doc = await PostModel.create({
        title: "Para deletar",
        content: "C",
        author: "A",
        subject: "S"
      });
      const res = await (0, import_supertest.default)(app).delete(`/api/posts/${doc._id}`);
      expect(res.status).toBe(200);
      expect(res.body).toEqual({ message: "Deletado com sucesso" });
      const still = await PostModel.findById(doc._id);
      expect(still).toBeNull();
    });
  });
});
/*! Bundled license information:

methods/index.js:
  (*!
   * methods
   * Copyright(c) 2013-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
